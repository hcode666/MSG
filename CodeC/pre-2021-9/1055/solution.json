["(n, m) = map(int, input().split())\nL = []\nfor i in range(n):\n    s = input()\n    L.append(s)\ncost = []\nh2 = [0] * (m + 1)\ncost.append(h2)\nfor i in range(n):\n    h = [0]\n    for j in range(m):\n        if L[i][j] == '0' and (i + j) % 2 != 0:\n            h.append(1)\n        elif L[i][j] == '1' and (i + j) % 2 == 0:\n            h.append(1)\n        else:\n            h.append(0)\n    cost.append(h)\npre = []\nh2 = [0] * (m + 1)\npre.append(h2)\nfor i in range(1, n + 1):\n    h = [0]\n    c = 0\n    for j in range(1, m + 1):\n        c += cost[i][j]\n        c2 = c\n        if i > 0:\n            c2 += pre[i - 1][j]\n        h.append(c2)\n    pre.append(h)\nbs = [0] * (m * n + 10)\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        for k in range(1, min(m, n) + 1):\n            if i - k >= 0 and j - k >= 0:\n                c = pre[i][j] - pre[i - k][j] - pre[i][j - k] + pre[i - k][j - k]\n                c = min(c, k * k - c)\n                bs[c] = max(bs[c], k)\nmx = bs[0]\nfor i in range(1, len(bs)):\n    mx = max(mx, bs[i])\n    bs[i] = mx\nQ = int(input())\nq = [int(x) for x in input().split()]\nfor i in range(0, len(q)):\n    qr = min(m * n, q[i])\n    print(bs[qr])", "(n, m) = map(int, input().split())\nL = []\nfor i in range(n):\n    s = input()\n    L.append(s)\ncost = []\nh2 = [0] * (m + 1)\ncost.append(h2)\nfor i in range(n):\n    h = [0]\n    for j in range(m):\n        if L[i][j] == '0' and (i + j) % 2 != 0:\n            h.append(1)\n        elif L[i][j] == '1' and (i + j) % 2 == 0:\n            h.append(1)\n        else:\n            h.append(0)\n    cost.append(h)\npre = []\nh2 = [0] * (m + 1)\npre.append(h2)\nfor i in range(1, n + 1):\n    h = [0]\n    c = 0\n    for j in range(1, m + 1):\n        c += cost[i][j]\n        c2 = c\n        if i > 0:\n            c2 += pre[i - 1][j]\n        h.append(c2)\n    pre.append(h)\nbs = [0] * (m * n + 10)\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        for k in range(1, min(m, n) + 1):\n            if i - k >= 0 and j - k >= 0:\n                c = pre[i][j] - pre[i - k][j] - pre[i][j - k] + pre[i - k][j - k]\n                c = min(c, k * k - c)\n                bs[c] = max(bs[c], k)\nmx = bs[0]\nfor i in range(1, len(bs)):\n    mx = max(mx, bs[i])\n    bs[i] = mx\nQ = int(input())\nq = [int(x) for x in input().split()]\nfor i in range(0, len(q)):\n    qr = min(m * n, q[i])\n    print(bs[qr])", "(n, m) = map(int, input().split())\nL = []\nfor i in range(n):\n    s = input()\n    L.append(s)\ncost = []\nh2 = [0] * (m + 1)\ncost.append(h2)\nfor i in range(n):\n    h = [0]\n    for j in range(m):\n        if L[i][j] == '0' and (i + j) % 2 != 0:\n            h.append(1)\n        elif L[i][j] == '1' and (i + j) % 2 == 0:\n            h.append(1)\n        else:\n            h.append(0)\n    cost.append(h)\npre = []\nh2 = [0] * (m + 1)\npre.append(h2)\nfor i in range(1, n + 1):\n    h = [0]\n    c = 0\n    for j in range(1, m + 1):\n        c += cost[i][j]\n        c2 = c\n        if i > 0:\n            c2 += pre[i - 1][j]\n        h.append(c2)\n    pre.append(h)\nbs = [0] * (m * n + 10)\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        for k in range(1, min(m, n) + 1):\n            if i - k >= 0 and j - k >= 0:\n                c = pre[i][j] - pre[i - k][j] - pre[i][j - k] + pre[i - k][j - k]\n                c = min(c, k * k - c)\n                bs[c] = max(bs[c], k)\nmx = bs[0]\nfor i in range(1, len(bs)):\n    mx = max(mx, bs[i])\n    bs[i] = mx\nQ = int(input())\nq = [int(x) for x in input().split()]\nfor i in range(0, len(q)):\n    qr = min(m * n, q[i])\n    print(bs[qr])", "(n, m) = [int(i) for i in input().split()]\nsqsets = list(range(2, min(n, m) + 1))\nci = []\nfor i in range(n):\n    ci.append(list(input()))\ncc = [[0 for i in range(m + 1)] for j in range(n + 1)]\n\ndef cache_creation_part(x, y):\n    cc[y][x] = cc[y][x - 1] + cc[y - 1][x] - cc[y - 1][x - 1]\n    if (y + x) % 2 == 0:\n        cc[y][x] += int(ci[y - 1][x - 1] != '1')\n    else:\n        cc[y][x] += int(ci[y - 1][x - 1] != '0')\n\ndef cache_creation(m, n):\n    for y in range(1, n + 1):\n        for x in range(1, m + 1):\n            cache_creation_part(x, y)\n\ndef operation(x, y, k):\n    return cc[y + k][x + k] + cc[y][x] - cc[y + k][x] - cc[y][x + k]\nc = 0\nkd = {k: c for k in sqsets}\n\ndef kd_creation(m, n, sqsets):\n    cache_creation(m, n)\n    for k in sqsets:\n        kd[k] = 10 ** 9 + 1\n        for y in range(n - k + 1):\n            for x in range(m - k + 1):\n                cu = operation(x, y, k)\n                kd[k] = min(kd[k], cu, k * k - cu)\nkd_creation(m, n, sqsets)\ndel cc\ndel ci\ndel sqsets\ntc = int(input())\ntc = [int(x) for x in input().split()]\nfor u in tc:\n    p = 0\n    for i in kd:\n        if kd[i] <= u:\n            p = max(i, p)\n    print(p)", "(n, m) = map(int, input().split())\nR = n\nC = m\na = [None] * n\nz = [0] * n\no = [1] * n\nfor i in range(m):\n    if i % 2 != 0:\n        z[i] = 1\n        o[i] = 0\nzi = [None] * n\noi = [None] * n\nfor i in range(n):\n    a[i] = input()\n    a[i] = list(a[i])\n    for j in range(m):\n        a[i][j] = int(a[i][j])\n    if i % 2 == 0:\n        zi[i] = z[:]\n        oi[i] = o[:]\n    else:\n        zi[i] = o[:]\n        oi[i] = z[:]\nforzi = 0\nforoi = 0\npsao = [[0 for x in range(C)] for y in range(R)]\npsaz = [[0 for x in range(C)] for y in range(R)]\nnoioo = 0\nnoizz = 0\nnoio = 0\nnoiz = 0\nfor i in range(n):\n    noiz = 0\n    noio = 0\n    for j in range(m):\n        if i == 0:\n            if a[i][j] != oi[i][j]:\n                noio += 1\n            else:\n                noiz += 1\n            psao[i][j] = noio\n            psaz[i][j] = noiz\n        else:\n            if a[i][j] != oi[i][j]:\n                noio += 1\n            else:\n                noiz += 1\n            psaz[i][j] = noiz + psaz[i - 1][j]\n            psao[i][j] = noio + psao[i - 1][j]\nmmm = []\nfor i in range(2, min(m, n) + 1):\n    c = 0\n    ap = []\n    for j in range(n - i + 1):\n        for k in range(m - i + 1):\n            czz = 0\n            czz1 = 0\n            czz2 = 0\n            coo = 0\n            cor = 0\n            czz += psaz[j + i - 1][k + i - 1]\n            coo += psao[j + i - 1][k + i - 1]\n            if k - 1 >= 0:\n                czz -= psaz[j + i - 1][k - 1]\n                coo -= psao[j + i - 1][k - 1]\n            else:\n                czz += 0\n            if j - 1 >= 0:\n                czz -= psaz[j - 1][k + i - 1]\n                coo -= psao[j - 1][k + i - 1]\n            else:\n                czz += 0\n            if j - 1 >= 0 and k - 1 >= 0:\n                czz += psaz[j - 1][k - 1]\n                coo += psao[j - 1][k - 1]\n            else:\n                czz += 0\n            ap.append(min(abs(coo), abs(czz)))\n    mmm.append(min(ap))\nq = int(input())\nlo = [int(pp) for pp in input().split()]\nmaxq = max(mmm)\nfor i in range(q):\n    if lo[i] > maxq:\n        print(min(n, m))\n    else:\n        j = len(mmm) - 1\n        ind = 0\n        while j >= 0:\n            if lo[i] >= mmm[j]:\n                ind = j + 2\n                break\n            j -= 1\n        print(ind)", "(n, m) = map(int, input().split())\ndp = [[0 for x in range(m + 1)] for y in range(n + 1)]\nl1 = [[0 for x in range(m)] for y in range(n)]\nl2 = [[0 for x in range(m)] for y in range(n)]\nfor ii in range(n):\n    for jj in range(m):\n        if (ii + jj) % 2 == 0:\n            l2[ii][jj] = 1\n        else:\n            l2[ii][jj] = 0\nfor i in range(n):\n    s = input()\n    for j in range(m):\n        l1[i][j] = int(s[j])\nl = [0] * min(n, m)\nsq = min(n, m)\nl3 = [0] * sq\nfor i in range(n):\n    s = 0\n    for j in range(m):\n        if l1[i][j] != l2[i][j]:\n            s += 1\n            dp[i + 1][j + 1] = s\n        else:\n            dp[i + 1][j + 1] = s\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        dp[i][j] = dp[i - 1][j] + dp[i][j]\nfor no in range(sq, 1, -1):\n    mymin = 1000000\n    for i in range(n):\n        for j in range(m):\n            if i + no <= n and j + no <= m:\n                ans = dp[i + no][j + no] - dp[i][j + no] - dp[i + no][j] + dp[i][j]\n                ans = min(ans, no * no - ans)\n                if ans < mymin:\n                    mymin = ans\n    l3[no - 1] = mymin\n    if mymin == 0:\n        break\nq = int(input())\nlq = list(map(int, input().split()))\nfor i in lq:\n    if i > sq * sq // 2:\n        print(sq)\n    else:\n        for j in range(len(l3) - 1, -1, -1):\n            if l3[j] <= i:\n                print(j + 1)\n                break", "(n, m) = map(int, input().split())\ndp = [[0 for x in range(m + 1)] for y in range(n + 1)]\nl1 = [[0 for x in range(m)] for y in range(n)]\nl2 = [[0 for x in range(m)] for y in range(n)]\nfor ii in range(n):\n    for jj in range(m):\n        if (ii + jj) % 2 == 0:\n            l2[ii][jj] = 1\n        else:\n            l2[ii][jj] = 0\nfor i in range(n):\n    s = input()\n    for j in range(m):\n        l1[i][j] = int(s[j])\nl = [0] * min(n, m)\nsq = min(n, m)\nl3 = [0] * sq\nfor i in range(n):\n    s = 0\n    for j in range(m):\n        if l1[i][j] != l2[i][j]:\n            s += 1\n            dp[i + 1][j + 1] = s\n        else:\n            dp[i + 1][j + 1] = s\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        dp[i][j] = dp[i - 1][j] + dp[i][j]\nfor no in range(sq, 1, -1):\n    mymin = 1000000\n    for i in range(n):\n        for j in range(m):\n            if i + no <= n and j + no <= m:\n                ans = dp[i + no][j + no] - dp[i][j + no] - dp[i + no][j] + dp[i][j]\n                ans = min(ans, no * no - ans)\n                if ans < mymin:\n                    mymin = ans\n    l3[no - 1] = mymin\nq = int(input())\nlq = list(map(int, input().split()))\nfor i in lq:\n    if i > sq * sq // 2:\n        print(sq)\n    else:\n        for j in range(len(l3) - 1, -1, -1):\n            if l3[j] <= i:\n                print(j + 1)\n                break", "from functools import reduce as rd\nimport operator as optr\nimport math\nimport itertools\ninp = lambda : map(int, input().split())\n(n, m) = inp()\nmatrix1 = [] * n\nmatrix2 = [] * n\nmaximum = [1000000] * 600\nfor row in range(n):\n    st = input()\n    l = []\n    for abc in st:\n        l.append(int(abc))\n    matrix1.append(l)\nfor row in range(n):\n    l = []\n    for col in range(m):\n        if (row + col) % 2 == 0 and matrix1[row][col] == 0:\n            l.append(1)\n        elif (row + col) % 2 == 0 and matrix1[row][col] == 1:\n            l.append(0)\n        elif (row + col) % 2 != 0 and matrix1[row][col] == 1:\n            l.append(1)\n        elif (row + col) % 2 != 0 and matrix1[row][col] == 0:\n            l.append(0)\n    matrix2.append(l)\nfor row in range(1, n):\n    for col in range(m):\n        matrix2[row][col] += matrix2[row - 1][col]\nfor row in range(1, n):\n    for col in range(m):\n        matrix2[col][row] += matrix2[col][row - 1]\nfault = 0\nfor row in range(n):\n    for col in range(m):\n        fault = 0\n        val = min(m - col, n - row)\n        for k in range(1, val + 1):\n            fault = matrix2[row + k - 1][col + k - 1]\n            if row > 0:\n                fault -= matrix2[row - 1][col + k - 1]\n            if col > 0:\n                fault -= matrix2[row + k - 1][col - 1]\n            if row > 0 and col > 0:\n                fault += matrix2[row - 1][col - 1]\n            if fault > k ** 2 // 2:\n                fault = k ** 2 - fault\n            maximum[k] = min(maximum[k], fault)\na = min(n, m)\nindex = maximum[a]\nquery = int(input())\nq = list(inp())\nfor c in q:\n    if c > index:\n        print(a)\n    else:\n        for dd in range(1, a + 1):\n            if maximum[dd] == c:\n                if maximum[dd + 1] == c:\n                    continue\n                print(dd)\n                break\n            elif maximum[dd] > c:\n                print(dd - 1)\n                break", "(n, m) = map(int, input().split(' '))\nCZM = 0\nCOM = 0\nIVM0 = [[0] * m for i in range(n)]\nIVM1 = [[0] * m for i in range(n)]\nPSA0 = [[0] * m for i in range(n)]\nPSA1 = [[0] * m for i in range(n)]\n\ndef findsum(PSA, i, j, k):\n    (x, y) = (i - k, j - k)\n    if x < 0 and y < 0:\n        return PSA[i][j]\n    if x < 0 and y >= 0:\n        return PSA[i][j] - PSA[i][j - k]\n    if x >= 0 and y < 0:\n        return PSA[i][j] - PSA[i - k][j]\n    if x >= 0 and y >= 0:\n        return PSA[i][j] - PSA[i][j - k] - PSA[i - k][j] + PSA[i - k][j - k]\n\ndef calPAS(PSA, IVM, n, m):\n    PSA[0][0] = IVM[0][0]\n    for i in range(1, m):\n        PSA[0][i] = PSA[0][i - 1] + IVM[0][i]\n    for i in range(0, n):\n        PSA[i][0] = PSA[i - 1][0] + IVM[i][0]\n    for i in range(1, n):\n        for j in range(1, m):\n            PSA[i][j] = PSA[i - 1][j] + PSA[i][j - 1] - PSA[i - 1][j - 1] + IVM[i][j]\nans = 1\nfor i in range(n):\n    x = input()\n    for j in range(m):\n        b = int(x[j])\n        if (i + j) % 2 == 0:\n            p = ans\n            q = 1 - ans\n        else:\n            p = 1 - ans\n            q = ans\n        if b != p:\n            IVM1[i][j] = 1\n        if b != q:\n            IVM0[i][j] = 1\ncalPAS(PSA0, IVM0, n, m)\ncalPAS(PSA1, IVM1, n, m)\nans0 = [-1] * (n * m + 1)\nans1 = [-1] * (n * m + 1)\n(p, q) = (0, 0)\nv = min(m, n)\nfor k in range(2, v + 1):\n    p = q = k - 1\n    for i in range(p, n):\n        for j in range(q, m):\n            x0 = findsum(PSA0, i, j, k)\n            x1 = findsum(PSA1, i, j, k)\n            ans0[x0] = max(k, ans0[x0])\n            ans1[x1] = max(k, ans1[x1])\nif ans0[0] == -1:\n    ans0[0] = 1\nif ans1[0] == -1:\n    ans1[0] = 1\nfor i in range(1, n * m + 1):\n    if ans0[i] == -1:\n        ans0[i] = ans0[i - 1]\n    elif ans0[i] < ans0[i - 1]:\n        ans0[i] = ans0[i - 1]\n    if ans1[i] == -1:\n        ans1[i] = ans1[i - 1]\n    elif ans1[i] < ans1[i - 1]:\n        ans1[i] = ans1[i - 1]\nq = int(input())\nfor q in input().split(' '):\n    p = int(q)\n    if p > n * m:\n        print(max(ans0[n * m], ans1[n * m]))\n    else:\n        print(max(ans1[p], ans0[p]))", "(n, m) = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input())))\ninf = int(1000000000.0)\nauxArr = [[0 for k in range(m + 1)] for i in range(n + 1)]\nminInvArr = [inf for i in range(min(n, m) + 1)]\n\ndef invGrid(nflips=0):\n    for i in range(n):\n        for j in range(m):\n            auxArr[i + 1][j + 1] = 0\n            if i + j & 1:\n                if grid[i][j] == nflips:\n                    auxArr[i + 1][j + 1] += 1\n            elif grid[i][j] == (not nflips):\n                auxArr[i + 1][j + 1] += 1\n            auxArr[i + 1][j + 1] += auxArr[i + 1][j]\n        for j in range(m):\n            auxArr[i + 1][j + 1] += auxArr[i][j + 1]\n\ndef get_inv_sq(x, y, p, q):\n    return auxArr[p + 1][q + 1] - auxArr[x][q + 1] - auxArr[p + 1][y] + auxArr[x][y]\n\ndef minInv():\n    for curSize in range(0, min(n, m)):\n        for i in range(0, n - curSize):\n            for j in range(0, m - curSize):\n                minInvArr[curSize + 1] = min(minInvArr[curSize + 1], get_inv_sq(i, j, i + curSize, j + curSize))\ninvGrid()\nminInv()\ninvGrid(nflips=1)\nminInv()\nq = int(input())\nqArr = map(int, input().split(' '))\nfor c in qArr:\n    for j in range(len(minInvArr) - 1, 0, -1):\n        if minInvArr[j] <= c:\n            print(j)\n            break", "(n, m) = [int(i) for i in input().strip().split(' ')]\narr = [0] * n\nfor i in range(n):\n    inp = list(input())\n    arr[i] = [int(k) for k in inp]\nreq = min(m, n)\ndp_0 = [[[0 for k in range(m)] for j in range(n)] for i in range(req + 1)]\nfor i in range(n):\n    for j in range(m):\n        dp_0[1][i][j] = arr[i][j]\nans_arr = [0] * 20001\nfor i in range(2, req + 1):\n    cl = 100000\n    i2 = (i - 1) ** 2\n    for j in range(0, n + 1 - i):\n        for k in range(0, m + 1 - i):\n            dp_0[i][j][k] = i2 - dp_0[i - 1][j + 1][k] + (i2 - dp_0[i - 1][j][k + 1]) - dp_0[i - 2][j + 1][k + 1] + dp_0[1][j][k] + dp_0[1][j + i - 1][k + i - 1]\n            cl = min(min(dp_0[i][j][k], i ** 2 - dp_0[i][j][k]), cl)\n    ans_arr[int(cl)] = i\nprev = ans_arr[0]\nfor i in range(20001):\n    curr = ans_arr[i]\n    if curr == 0:\n        ans_arr[i] = prev\n    else:\n        prev = ans_arr[i]\nq = int(input())\nque = [int(i) for i in input().strip().split(' ')]\nfor i in que:\n    if i > 20000:\n        print(int(ans_arr[-1]))\n    else:\n        print(int(ans_arr[i]))", "def hz_arr(arr, N, M):\n    ans = []\n    for g in range(N):\n        pref = [0]\n        for h in range(M):\n            if g % 2 == 0:\n                if h % 2 == 0 and int(arr[g][h]) == 1:\n                    pref.append(pref[h] + 1)\n                elif h % 2 == 1 and int(arr[g][h]) == 0:\n                    pref.append(pref[h] + 1)\n                else:\n                    pref.append(pref[h])\n            elif h % 2 == 0 and int(arr[g][h]) == 0:\n                pref.append(pref[h] + 1)\n            elif h % 2 == 1 and int(arr[g][h]) == 1:\n                pref.append(pref[h] + 1)\n            else:\n                pref.append(pref[h])\n        ans.append(pref)\n    return ans\n\ndef ho_arr(arr, N, M):\n    ans = []\n    for g in range(N):\n        pref = [0]\n        for h in range(M):\n            if g % 2 == 0:\n                if h % 2 == 0 and int(arr[g][h]) == 0:\n                    pref.append(pref[h] + 1)\n                elif h % 2 == 1 and int(arr[g][h]) == 1:\n                    pref.append(pref[h] + 1)\n                else:\n                    pref.append(pref[h])\n            elif h % 2 == 0 and int(arr[g][h]) == 1:\n                pref.append(pref[h] + 1)\n            elif h % 2 == 1 and int(arr[g][h]) == 0:\n                pref.append(pref[h] + 1)\n            else:\n                pref.append(pref[h])\n        ans.append(pref)\n    return ans\n\ndef vz_arr(hz_arr, N, M):\n    ans = []\n    for y in range(M + 1):\n        pref = [0]\n        for x in range(N):\n            pref.append(hz_arr[x][y] + pref[x])\n        ans.append(pref)\n    return ans\n\ndef vo_arr(ho_arr, N, M):\n    ans = []\n    for y in range(M + 1):\n        pref = [0]\n        for x in range(N):\n            pref.append(ho_arr[x][y] + pref[x])\n        ans.append(pref)\n    return ans\n\ndef ret_max(arr, c):\n    for d in range(len(arr) - 1, -1, -1):\n        if arr[d] <= c:\n            return d + 1\n\ndef zero(vz, p, q, l):\n    return vz[p + l][q + l] - vz[p][q + l] - vz[p + l][q] + vz[p][q]\n\ndef one(vo, p, q, l):\n    return vo[p + l][q + l] - vo[p][q + l] - vo[p + l][q] + vo[p][q]\n[N, M] = [int(i) for i in input().split()]\narr = []\ns = ''\nfor x in range(N):\n    s = input()\n    arr.append(s)\nQ = int(input())\nqry = [int(i) for i in input().split()]\nlookup = []\nhz = hz_arr(arr, N, M)\nho = ho_arr(arr, N, M)\nvz = vz_arr(hz, N, M)\nvo = vo_arr(ho, N, M)\nfor w in range(1, min(N, M) + 1):\n    done = 0\n    ans = pow(10, 9) + 1\n    for p in range(N - w + 1):\n        for q in range(M - w + 1):\n            temp = min(zero(vz, p, q, w), one(vo, p, q, w))\n            ans = min(ans, temp)\n    lookup.append(ans)\nfor e in range(len(qry)):\n    print(ret_max(lookup, qry[e]))", "(n, m) = [int(i) for i in input().split()]\nsqsets = list(range(2, min(n, m) + 1))\nci = []\nfor i in range(n):\n    ci.append(list(input()))\ncc = [[0 for i in range(m + 1)] for j in range(n + 1)]\n\ndef cache_creation_part(x, y):\n    cc[y][x] = cc[y][x - 1] + cc[y - 1][x] - cc[y - 1][x - 1]\n    if (y + x) % 2 == 0:\n        cc[y][x] += int(ci[y - 1][x - 1] != '1')\n    else:\n        cc[y][x] += int(ci[y - 1][x - 1] != '0')\n\ndef cache_creation(m, n):\n    for y in range(1, n + 1):\n        for x in range(1, m + 1):\n            cache_creation_part(x, y)\n\ndef operation(x, y, k):\n    return cc[y + k][x + k] + cc[y][x] - cc[y + k][x] - cc[y][x + k]\nc = 0\nkd = {k: c for k in sqsets}\n\ndef kd_creation(m, n, sqsets):\n    cache_creation(m, n)\n    for k in sqsets:\n        kd[k] = 10 ** 9 + 1\n        for y in range(n - k + 1):\n            for x in range(m - k + 1):\n                cu = operation(x, y, k)\n                kd[k] = min(kd[k], cu, k * k - cu)\nkd_creation(m, n, sqsets)\ndel cc\ndel ci\ndel sqsets\ntc = int(input())\ntc = [int(x) for x in input().split()]\nfor u in tc:\n    p = 0\n    for i in kd:\n        if kd[i] <= u:\n            p = max(i, p)\n    print(p)", "import sys\nfrom collections import defaultdict\ndp = defaultdict(int)\nsys.setrecursionlimit(10 ** 9)\n(a, b) = [int(j) for j in input().split()]\nboard = []\nfor i in range(a):\n    l = [int(j) for j in input()]\n    board.append(l)\nb2 = [[0 for i in range(b)] for j in range(a)]\nfor i in range(a):\n    for j in range(b):\n        if (i + j) % 2:\n            if board[i][j] == 0:\n                b2[i][j] = 1\n        elif board[i][j] == 1:\n            b2[i][j] = 1\n\ndef fun(b2, x, y):\n    if x < 0 or y < 0:\n        return 0\n    elif x == 0 and y == 0:\n        if b2[0][0] == 0:\n            dp[x, y] = 0\n            return 0\n        if b2[0][0] == 1:\n            dp[x, y] = 1\n            return 1\n    elif (x, y) in dp:\n        return dp[x, y]\n    else:\n        if b2[x][y] == 1:\n            k = fun(b2, x, y - 1) + fun(b2, x - 1, y) - fun(b2, x - 1, y - 1) + 1\n        else:\n            k = fun(b2, x, y - 1) + fun(b2, x - 1, y) - fun(b2, x - 1, y - 1)\n        dp[x, y] = k\n        return k\nfun(b2, a - 1, b - 1)\nl = [1000000000000000000000 for i in range(201)]\nfor i in range(2, min(a, b) + 1):\n    le = i ** 2\n    mi = 10 ** 9\n    for j in range(a - i + 1):\n        for k in range(b - i + 1):\n            k1 = dp[j + i - 1, k + i - 1] - dp[j - 1, k + i - 1] - dp[j + i - 1, k - 1] + dp[j - 1, k - 1]\n            k2 = le - k1\n            mi = min(k1, k2, mi)\n    l[i - 1] = mi\nl[0] = 0\nlei = len(l)\nq = int(input())\nql = [int(j) for j in input().split()]\nfor i in ql:\n    high = i\n    for i in range(lei):\n        if l[i] > high:\n            print(i)\n            break", "from collections import defaultdict\n(n, m) = (int(s) for s in input().split())\nc = [input() for j in range(n)]\nl = [[int(s) for s in c[i]] for i in range(n)]\nc1 = [[0 for i in range(m)] for k in range(n)]\nfor i in range(n):\n    for j in range(m):\n        w = 0\n        if (i + j) % 2 == 1:\n            w = 1\n        if l[i][j] != w:\n            c1[i][j] = 1\nd1 = defaultdict(int)\nfor i in range(n):\n    for j in range(m):\n        if i == 0:\n            d1[i, j] = c1[i][j] + d1[i, j - 1]\n        else:\n            d1[i, j] = c1[i][j] + d1[i - 1, j] + d1[i, j - 1] - d1[i - 1, j - 1]\nd2 = defaultdict(int)\nd2[0] = 0\nd2[1] = 0\nfor i in range(2, min(n, m) + 1):\n    mini = 10 ** 9 + 7\n    for j in range(n - i + 1):\n        for k in range(m - i + 1):\n            ans1 = d1[j + i - 1, k + i - 1] - d1[j + i - 1, k - 1] - d1[j - 1, k + i - 1] + d1[j - 1, k - 1]\n            ans2 = min(ans1, i ** 2 - ans1)\n            if mini > ans2:\n                mini = ans2\n    d2[i] = mini\nq = int(input())\nl1 = [int(s) for s in input().split()]\nfor j in l1:\n    low = 0\n    high = min(n, m)\n    ans = (low + high) // 2\n    while low < high:\n        if d2[ans] <= j:\n            low = ans + 1\n        else:\n            high = ans\n        ans = (low + high) // 2\n    if ans == 0:\n        print(0)\n    elif ans == min(n, m):\n        if d2[ans] <= j:\n            print(ans)\n        else:\n            print(ans - 1)\n    else:\n        print(ans - 1)", "(n, m) = map(int, input().split())\nchs = []\nfor i in range(n):\n    chs.append(list(input()))\ntest = []\nfor i in range(n):\n    if i % 2 == 0:\n        test.append(list('01' * (m // 2 + 1)))\n    else:\n        test.append(list('10' * (m // 2 + 1)))\ninv = [[0] * (m + 1) for i in range(n + 1)]\nfor i in range(n):\n    for j in range(m):\n        if chs[i][j] != test[i][j]:\n            inv[i + 1][j + 1] = inv[i + 1][j] + 1\n        else:\n            inv[i + 1][j + 1] = inv[i + 1][j]\ncol_sum = [[0] * (m + 1) for i in range(n + 1)]\nfor i in range(n):\n    for j in range(m):\n        if chs[i][j] != test[i][j]:\n            col_sum[i + 1][j + 1] = col_sum[i][j + 1] + 1\n        else:\n            col_sum[i + 1][j + 1] = col_sum[i][j + 1]\nmin_req = [1000000000] * min(n + 1, m + 1)\nmin_req[1] = min_req[0] = 0\nfor i in range(2, n + 1):\n    for j in range(2, m + 1):\n        dim = min(i, j)\n        s = inv[i][j] - inv[i][j - 1]\n        for k in range(2, dim + 1):\n            s += inv[i - k + 1][j] - inv[i - k + 1][j - k] + col_sum[i][j - k + 1] - col_sum[i - k + 1][j - k + 1]\n            min_req[k] = min(s, k * k - s, min_req[k])\nQ = int(input())\nq = list(map(int, input().split()))\nfor i in q:\n    ans = 0\n    for j in range(len(min_req)):\n        if i >= min_req[j]:\n            ans = j\n    print(ans)", "import numpy as np\n(n, m) = [int(i) for i in input().strip().split(' ')]\narr = [0] * n\nfor i in range(n):\n    inp = list(input())\n    arr[i] = [int(k) for k in inp]\nreq = min(m, n)\ndp_0 = [[[0 for k in range(m)] for j in range(n)] for i in range(req + 1)]\nfor i in range(n):\n    for j in range(m):\n        dp_0[1][i][j] = arr[i][j]\nans_arr = [0] * 20001\nfor i in range(2, req + 1):\n    cl = 100000\n    i2 = (i - 1) ** 2\n    for j in range(0, n + 1 - i):\n        for k in range(0, m + 1 - i):\n            dp_0[i][j][k] = i2 - dp_0[i - 1][j + 1][k] + (i2 - dp_0[i - 1][j][k + 1]) - dp_0[i - 2][j + 1][k + 1] + dp_0[1][j][k] + dp_0[1][j + i - 1][k + i - 1]\n            cl = min(min(dp_0[i][j][k], i ** 2 - dp_0[i][j][k]), cl)\n    ans_arr[int(cl)] = i\nprev = ans_arr[0]\nfor i in range(20001):\n    curr = ans_arr[i]\n    if curr == 0:\n        ans_arr[i] = prev\n    else:\n        prev = ans_arr[i]\nq = int(input())\nque = [int(i) for i in input().strip().split(' ')]\nfor i in que:\n    if i > 20000:\n        print(int(ans_arr[-1]))\n    else:\n        print(int(ans_arr[i]))", "def sum_up(row1, col1, row2, col2):\n    return sums[row2 + 1][col2 + 1] - sums[row2 + 1][col1] - sums[row1][col2 + 1] + sums[row1][col1]\n(n, m) = map(int, input().strip().split())\nc = []\narr1 = [[0 for i in range(205)] for j in range(205)]\narr2 = [[0 for i in range(205)] for j in range(205)]\nfor _ in range(n):\n    c.append(list(input()))\n(s1, s2) = ({}, {})\nfor i in range(n):\n    for j in range(m):\n        if (i + j) % 2 == 0:\n            if c[i][j] == '1':\n                arr1[i][j] = 0\n            else:\n                arr1[i][j] = 1\n                s1[i] = j\n        elif c[i][j] == '0':\n            arr1[i][j] = 0\n        else:\n            arr1[i][j] = 1\n            s1[i] = j\n        if (i + j) % 2 != 0:\n            if c[i][j] == '1':\n                arr2[i][j] == 0\n            else:\n                arr2[i][j] = 1\n                s2[i] = j\n        elif c[i][j] == '0':\n            arr2[i][j] = 0\n        else:\n            arr2[i][j] = 1\n            s2[i] = j\nmax_poss = min(n, m)\ndp1 = [-1] * 1000005\ndp2 = [-1] * 1000005\n(last1, last2) = (0, 0)\n(row, col) = (n, m)\nsums = [[0 for i in range(m + 1)] for j in range(n + 1)]\nfor i in range(1, row + 1):\n    for j in range(1, col + 1):\n        sums[i][j] = arr1[i - 1][j - 1] + sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1]\nfor l in range(2, max_poss + 1):\n    mini = 1000005\n    for i in range(n - l + 1):\n        for j in range(m - l + 1):\n            inversions = sum_up(i, j, i + l - 1, j + l - 1)\n            if inversions < mini:\n                mini = inversions\n    dp1[mini] = l\n    last1 = max(last1, mini)\nsums = [[0 for i in range(m + 1)] for j in range(n + 1)]\nfor i in range(1, row + 1):\n    for j in range(1, col + 1):\n        sums[i][j] = arr2[i - 1][j - 1] + sums[i - 1][j] + sums[i][j - 1] - sums[i - 1][j - 1]\nfor l in range(2, max_poss + 1):\n    mini = 1000005\n    for i in range(n - l + 1):\n        for j in range(m - l + 1):\n            inversions = sum_up(i, j, i + l - 1, j + l - 1)\n            if inversions < mini:\n                mini = inversions\n    dp2[mini] = l\n    last2 = max(last2, mini)\npre = 0\nfor i in range(last1 + 1):\n    if dp1[i] == -1 and i == 0:\n        while dp[i] == -1:\n            dp1[i] = 1\n            i += 1\n    elif dp1[i] == -1:\n        while i <= last1 and dp1[i] == -1:\n            dp1[i] = pre\n            i += 1\n    else:\n        pre = dp1[i]\n        i += 1\nfor i in range(last2 + 1):\n    if dp2[i] == -1 and i == 0:\n        while dp2[i] == -1:\n            dp2[i] = 1\n            i += 1\n    elif dp2[i] == -1:\n        while i <= last2 and dp2[i] == -1:\n            dp2[i] = pre\n            i += 1\n    else:\n        pre = dp2[i]\n        i += 1\nq = int(input())\nquery = list(map(int, input().strip().split()))\nfor i in query:\n    if n == 1 or m == 1:\n        print(1)\n    elif i <= min(last1, last2):\n        if dp1[i] == 0 and dp2[i] == 0:\n            print(1)\n        else:\n            print(max(dp1[i], dp2[i]))\n    else:\n        print(max_poss)", "from collections import defaultdict\npre = defaultdict(int)\n\ndef M1(gr, x, y):\n    if x == 0 or y == 0:\n        return 0\n    elif (x, y) in pre:\n        return pre[x, y]\n    else:\n        ans = M1(gr, x - 1, y) + M1(gr, x, y - 1) - M1(gr, x - 1, y - 1) + gr[x][y]\n        pre[x, y] = ans\n        return ans\n(N, M) = (int(i) for i in input().split())\ngr = [[int(i) for i in input()] for j in range(N)]\ngr1 = [[0 for i in range(M + 1)] for j in range(N + 1)]\nfor i in range(1, N + 1):\n    for j in range(1, M + 1):\n        gr1[i][j] = 0 if gr[i - 1][j - 1] == (i + j) % 2 else 1\nq = int(input())\nqls = (int(i) for i in input().split())\nM1(gr1, N, M)\nmaxlen = min(N, M)\nsidelenarr = [200000000000 for i in range(202)]\nfor lenght in range(1, maxlen + 1):\n    area = lenght * lenght\n    for u in range(1, N - lenght + 2):\n        x = u + lenght - 1\n        for v in range(1, M - lenght + 2):\n            y = v + lenght - 1\n            pencelose = pre[x, y] - pre[u - 1, y] - pre[x, v - 1] + pre[u - 1, v - 1]\n            sidelenarr[lenght] = min(pencelose, area - pencelose, sidelenarr[lenght])\nsidelenarr[0] = 0\nfor i in range(1, 201):\n    sidelenarr[i] = max(sidelenarr[i], sidelenarr[i - 1])\n\ndef bsearch(left, right, val):\n    mid = (left + right) // 2\n    if left == right:\n        if sidelenarr[left] > val:\n            return -1\n        else:\n            return left\n    elif sidelenarr[mid] > val:\n        return bsearch(left, mid, val)\n    else:\n        return max(bsearch(mid + 1, right, val), mid)\nfor i in qls:\n    print(bsearch(0, maxlen + 1, i))", "from bisect import bisect\n(n, m) = map(int, input().split())\ngrid = []\nfor i in range(n):\n    string = input()\n    row = []\n    for (j, ch) in enumerate(string):\n        if int(ch) == (i + j) % 2:\n            row.append(0)\n        else:\n            row.append(1)\n    grid.append(row)\nfor i in range(1, n):\n    grid[i][0] += grid[i - 1][0]\nfor j in range(1, m):\n    grid[0][j] += grid[0][j - 1]\nfor i in range(1, n):\n    for j in range(1, m):\n        grid[i][j] += grid[i - 1][j] + grid[i][j - 1] - grid[i - 1][j - 1]\nflips = []\nfor l in range(min(n, m), 0, -1):\n    f = l * l\n    for i in range(n - l + 1):\n        for j in range(m - l + 1):\n            total = grid[i + l - 1][j + l - 1]\n            if i > 0:\n                total -= grid[i - 1][j + l - 1]\n            if j > 0:\n                total -= grid[i + l - 1][j - 1]\n            if i > 0 and j > 0:\n                total += grid[i - 1][j - 1]\n            f = min(f, l * l - total, total)\n    flips.append(f)\nflips.reverse()\nq = int(input())\nqs = list(map(int, input().split()))\nfor i in qs:\n    print(bisect(flips, i))", "(n, m) = input().split(' ')\nn = int(n)\nm = int(m)\nlst = [None] * n\nfor i in range(0, n):\n    lst[i] = input()\nc1 = [[0 for x in range(m + 2)] for y in range(n + 2)]\nc2 = [[0 for x in range(m + 2)] for y in range(n + 2)]\nc3 = [[0 for x in range(m + 2)] for y in range(n + 2)]\nc4 = [[0 for x in range(m + 2)] for y in range(n + 2)]\na = 1\nb = 0\ncn1 = 0\ncn2 = 0\ncn3 = 0\nfor i in range(n):\n    if i % 2 == 0:\n        a = 1\n    else:\n        a = 0\n    if i % 2 == 0:\n        b = 0\n    else:\n        b = 1\n    for j in range(m):\n        x = int(lst[i][j])\n        if x != a:\n            if j == 0:\n                c1[i][j] = 1\n            else:\n                c1[i][j] = c1[i][j - 1] + 1\n        elif j != 0:\n            c1[i][j] = c1[i][j - 1]\n        if x != b:\n            if j == 0:\n                c2[i][j] = 1\n            else:\n                c2[i][j] = c2[i][j - 1] + 1\n        elif j != 0:\n            c2[i][j] = c2[i][j - 1]\n        if a == 0:\n            a = 1\n        else:\n            a = 0\n        if b == 0:\n            b = 1\n        else:\n            b = 0\nfor i in range(m):\n    c3[0][i] = c1[0][i]\n    c4[0][i] = c2[0][i]\nfor i in range(1, n):\n    for j in range(m):\n        c3[i][j] = c3[i - 1][j] + c1[i][j]\n        c4[i][j] = c4[i - 1][j] + c2[i][j]\nquery = [99999999] * 2000\nquery[0] = 0\nfor x in range(1, min(m, n)):\n    for i in range(x, n):\n        for j in range(x, m):\n            query[x] = min(query[x], c3[i][j] - c3[i - x - 1][j] - (c3[i][j - x - 1] - c3[i - x - 1][j - x - 1]), c4[i][j] - c4[i - x - 1][j] - (c4[i][j - x - 1] - c4[i - x - 1][j - x - 1]))\nq = input()\nq = int(q)\narr = [int(x) for x in input().split(' ')]\nfor i in range(0, q):\n    if arr[i] >= query[min(m, n) - 1]:\n        print(min(m, n))\n    else:\n        for j in range(min(m, n) - 1, -1, -1):\n            if arr[i] >= query[j]:\n                break\n        print(j + 1)", "def preProcess(mat, aux):\n    for i in range(M):\n        aux[0][i] = mat[0][i]\n    for i in range(1, N):\n        for j in range(M):\n            aux[i][j] = mat[i][j] + aux[i - 1][j]\n    for i in range(N):\n        for j in range(1, M):\n            aux[i][j] += aux[i][j - 1]\n\ndef sumQuery(aux, li, lj, ri, rj):\n    res = aux[ri][rj]\n    if li > 0:\n        res = res - aux[li - 1][rj]\n    if lj > 0:\n        res = res - aux[ri][lj - 1]\n    if li > 0 and lj > 0:\n        res = res + aux[li - 1][lj - 1]\n    return res\n\ndef solve():\n    min_size = min(M, N)\n    board = [[0 for _ in range(M)] for _ in range(N)]\n    aux = [[0 for _ in range(M)] for _ in range(N)]\n    cell = 1\n    for i in range(N):\n        col = [int(k) for k in input().strip()]\n        if M % 2 == 0:\n            cell = not cell\n        for j in range(M):\n            board[i][j] = 1 if col[j] == cell else 0\n            cell = not cell\n    preProcess(board, aux)\n    prev = sumQuery(aux, 0, 0, N - 1, M - 1)\n    prev = min(prev, min_size ** 2 - prev)\n    flips = [0] * (N * M + 1)\n    flips[prev:] = [min_size for _ in range(len(flips[prev:]))]\n    cont = True\n    for size in range(min(N, M) - 1, 1, -1):\n        flips_needed = 10 ** 10\n        for i in range(N - size + 1):\n            for j in range(M - size + 1):\n                val = sumQuery(aux, i, j, i + size - 1, j + size - 1)\n                flips_needed = min(flips_needed, val, size * size - val)\n                if val == 0:\n                    flips[0:prev] = [size for _ in range(len(flips[0:prev]))]\n                    cont = False\n                    break\n            if not cont:\n                break\n        if not cont:\n            break\n        flips[flips_needed:prev] = [size for _ in range(len(flips[flips_needed:prev]))]\n        prev = flips_needed\n    Q = int(input())\n    buff = []\n    for q in input().split():\n        q = int(q)\n        if q >= N * M - flips[0]:\n            buff.append(min_size)\n            continue\n        buff.append(flips[q])\n    print('\\n'.join((str(q) for q in buff)))\n(N, M) = map(int, input().split())\nsolve()", "from bisect import bisect_right as br\nfor _ in range(1):\n    (n, m) = [int(i) for i in input().split(' ')]\n    l = []\n    for i in range(n):\n        l.append([int(i) for i in input()])\n    dp1 = [[0] * (m + 1) for i in range(n + 1)]\n    dp2 = [[0] * (m + 1) for i in range(n + 1)]\n    k1 = [[0] * (m + 1) for i in range(n + 1)]\n    k2 = [[0] * (m + 1) for i in range(n + 1)]\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if (i + j) % 2 == 0:\n                k1[i][j] = 1\n            else:\n                k2[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if k1[i][j] == 1:\n                if l[i][j] == 0:\n                    dp1[i + 1][j + 1] = 1\n                else:\n                    dp2[i + 1][j + 1] = 1\n            elif l[i][j] == 1:\n                dp1[i + 1][j + 1] = 1\n            else:\n                dp2[i + 1][j + 1] = 1\n    for i in range(n + 1):\n        for j in range(1, m + 1):\n            dp1[i][j] += dp1[i][j - 1]\n            dp2[i][j] += dp2[i][j - 1]\n    for i in range(m + 1):\n        for j in range(1, n + 1):\n            dp1[j][i] += dp1[j - 1][i]\n            dp2[j][i] += dp2[j - 1][i]\n    nk = min(n, m)\n    ans = [40000 for i in range(nk)]\n    for k in range(nk):\n        for i in range(1, n - k + 1):\n            for j in range(1, m - k + 1):\n                chng1 = dp1[i + k][j + k] + dp1[i - 1][j - 1] - dp1[i + k][j - 1] - dp1[i - 1][j + k]\n                chng2 = dp2[i + k][j + k] + dp2[i - 1][j - 1] - dp2[i + k][j - 1] - dp2[i - 1][j + k]\n                ans[k] = min(ans[k], chng1, chng2)\n    q = int(input())\n    for i in [int(i) for i in input().split(' ')]:\n        print(br(ans, i))", "(n, m) = [int(i) for i in input().split(' ')]\na = []\nfor _ in range(n):\n    a.append([int(i) for i in input()])\nb1 = [[0 for i in range(m + 1)] for j in range(n + 1)]\nb2 = [[0 for i in range(m + 1)] for j in range(n + 1)]\nfor i in range(n):\n    for j in range(m):\n        if i % 2 == 0 and j % 2 == 0 or (i % 2 == 1 and j % 2 == 1):\n            if a[i][j] == 0:\n                b1[i + 1][j + 1] = 0\n                b2[i + 1][j + 1] = 1\n            else:\n                b1[i + 1][j + 1] = 1\n                b2[i + 1][j + 1] = 0\n        elif a[i][j] == 1:\n            b1[i + 1][j + 1] = 0\n            b2[i + 1][j + 1] = 1\n        else:\n            b1[i + 1][j + 1] = 1\n            b2[i + 1][j + 1] = 0\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        b1[i][j] += b1[i - 1][j] + b1[i][j - 1] - b1[i - 1][j - 1]\n        b2[i][j] += b2[i - 1][j] + b2[i][j - 1] - b2[i - 1][j - 1]\nfrom collections import defaultdict as dd\nd = []\nfor k in range(0, min(m, n)):\n    r = 9999999999999999\n    for i in range(1, n - k + 1):\n        for j in range(1, m - k + 1):\n            (x1, y1) = (i, j)\n            (x2, y2) = (i + k, j + k)\n            f1 = b1[x2][y2]\n            f2 = b2[x2][y2]\n            f1 -= b1[x1 - 1][y1 + k] + b1[x1 + k][y1 - 1] - b1[x1 - 1][y1 - 1]\n            f2 -= b2[x1 - 1][y1 + k] + b2[x1 + k][y1 - 1] - b2[x1 - 1][y1 - 1]\n            if r > min(f1, f2):\n                r = min(f1, f2)\n    d.append(r)\nimport bisect\nnq = int(input())\nq = [int(I) for I in input().split(' ')]\nfor i in q:\n    t = bisect.bisect_right(d, i)\n    print(t)", "(a, b) = map(int, input().split())\narr2d = []\nfor i in range(a):\n    arr2d.append(list(map(int, input())))\ngi = int(1000000000.0)\nacc = [[0] * (b + 1) for i in range(a + 1)]\nszm = [gi] * (min(a, b) + 1)\n\ndef citr(shift=0):\n    for i in range(a):\n        for j in range(b):\n            acc[i + 1][j + 1] = 0\n            if i + j & 1:\n                if arr2d[i][j] == shift:\n                    acc[i + 1][j + 1] += 1\n            elif arr2d[i][j] == (not shift):\n                acc[i + 1][j + 1] += 1\n            acc[i + 1][j + 1] += acc[i + 1][j]\n        for j in range(b):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\ndef szopp(x, y, p, q):\n    return acc[p + 1][q + 1] - acc[x][q + 1] - acc[p + 1][y] + acc[x][y]\n\ndef citr2():\n    for sz in range(0, min(a, b)):\n        for i in range(0, a - sz):\n            for j in range(0, b - sz):\n                szm[sz + 1] = min(szm[sz + 1], szopp(i, j, i + sz, j + sz))\ncitr()\ncitr2()\ncitr(shift=1)\ncitr2()\nq = int(input())\narr5 = map(int, input().split(' '))\nfor c in arr5:\n    for j in range(len(szm) - 1, 0, -1):\n        if szm[j] <= c:\n            print(j)\n            break", "import bisect\n(n, m) = [int(x) for x in input().split()]\nBoard = [(m + 1) * [0]]\nWrong = [(m + 1) * [0]]\nfor i in range(n):\n    row = [0] + [int(x) for x in input()]\n    comRow = [0]\n    for j in range(m):\n        comRow.append(comRow[j] + Wrong[i][j + 1] - Wrong[i][j] + (i + j + row[j + 1]) % 2)\n    Board.append(row)\n    Wrong.append(comRow)\nboardSize = [0] + min(n, m) * [n * n]\nfor k in range(len(boardSize)):\n    for i in range(1, n + 1 - k):\n        for j in range(1, m + 1 - k):\n            changes = Wrong[i + k][j + k] - Wrong[i - 1][j + k] - Wrong[i + k][j - 1] + Wrong[i - 1][j - 1]\n            boardSize[k] = min(boardSize[k], changes, (k + 1) * (k + 1) - changes)\nq = int(input())\nqu = [int(x) for x in input().split()]\nfor c in qu:\n    print(min(bisect.bisect_right(boardSize, c), min(m, n)))", "import sys, time, bisect\ntry:\n    sys.stdin = open('inp', 'r')\nexcept:\n    pass\n\nclass prefix_sum:\n\n    def __init__(self, a):\n        (R, C) = (len(a), len(a[0]))\n        td = [[0 for x in range(C)] for y in range(R)]\n        td[0][0] = a[0][0]\n        for i in range(1, C):\n            td[0][i] = td[0][i - 1] + a[0][i]\n        for i in range(1, R):\n            td[i][0] = td[i - 1][0] + a[i][0]\n        for i in range(1, R):\n            for j in range(1, C):\n                td[i][j] = td[i - 1][j] + td[i][j - 1] - td[i - 1][j - 1] + a[i][j]\n        self.td = td\n\n    def query(self, x1, y1, x2, y2):\n        (x1, y1) = (x1 - 1, y1 - 1)\n        left = self.td[x2][y1] if y1 >= 0 else 0\n        top = self.td[x1][y2] if x1 >= 0 else 0\n        incl = self.td[x1][y1] if x1 >= 0 and y1 >= 0 else 0\n        return self.td[x2][y2] - left - top + incl\n\n    def __str__(self):\n        return '\\n'.join((' '.join(map(str, i)) for i in self.td))\n(n, m) = map(int, input().split())\nboard = []\nfor _ in range(n):\n    board.append([int(x) for x in input()])\n(r, c) = (n, m)\n(bw, wb) = ([[0 for i in range(c)] for j in range(r)], [[0 for i in range(c)] for j in range(r)])\nfor i in range(r):\n    for j in range(c):\n        loc = i + j\n        if loc & 1 == 0:\n            wb[i][j] = 0 if board[i][j] == 0 else 1\n            bw[i][j] = 1 ^ wb[i][j]\n        else:\n            wb[i][j] = 0 if board[i][j] == 1 else 1\n            bw[i][j] = 1 ^ wb[i][j]\npwb = prefix_sum(wb)\npbw = prefix_sum(bw)\nres = {}\nmx = min(r, c)\nfor i in range(r):\n    for j in range(c):\n        for k in range(mx):\n            if i + k >= r or j + k >= c:\n                break\n            res[k] = min(res.get(k, 50000), pwb.query(i, j, i + k, j + k), pbw.query(i, j, i + k, j + k))\nans = {}\nfor (k, v) in res.items():\n    ans[v] = max(ans.get(v, 0), k + 1)\nmoves = [k for k in ans.keys()]\nmoves.sort()\ninput()\nfor q in map(int, input().split()):\n    try:\n        ind = bisect.bisect_left(moves, q)\n        if ind >= len(moves) or moves[ind] > q:\n            ind -= 1\n        print(ans[moves[ind]])\n    except:\n        print('1')", "(n, m) = map(int, input().split())\nC = []\nfor i in range(n):\n    R_ = list(map(int, list(input().strip())))\n    C.append(R_)\nvo = [[0 for _ in range(m)] for _ in range(n)]\nve = [[0 for _ in range(m)] for _ in range(n)]\nvo[0][0] = C[0][0]\nve[0][0] = (C[0][0] + 1) % 2\nfor i in range(1, m):\n    if C[0][i] == i % 2:\n        vo[0][i] = vo[0][i - 1]\n        ve[0][i] = ve[0][i - 1] + 1\n    else:\n        vo[0][i] = vo[0][i - 1] + 1\n        ve[0][i] = ve[0][i - 1]\nfor i in range(1, n):\n    if C[i][0] == i % 2:\n        vo[i][0] = vo[i - 1][0]\n        ve[i][0] = ve[i - 1][0] + 1\n    else:\n        vo[i][0] = vo[i - 1][0] + 1\n        ve[i][0] = ve[i - 1][0]\nfor i in range(1, n):\n    for j in range(1, m):\n        if C[i][j] == (i + j) % 2:\n            vo[i][j] = vo[i - 1][j] + vo[i][j - 1] - vo[i - 1][j - 1]\n            ve[i][j] = ve[i - 1][j] + ve[i][j - 1] - ve[i - 1][j - 1] + 1\n        else:\n            vo[i][j] = vo[i - 1][j] + vo[i][j - 1] - vo[i - 1][j - 1] + 1\n            ve[i][j] = ve[i - 1][j] + ve[i][j - 1] - ve[i - 1][j - 1]\nvv = [100000 for _ in range(min(n, m) + 1)]\nvv[1] = 0\nfor i in range(2, min(n, m) + 1):\n    for j in range(n - i + 1):\n        for k in range(m - i + 1):\n            oo = vo[j + i - 1][k + i - 1]\n            ee = ve[j + i - 1][k + i - 1]\n            if j - 1 >= 0:\n                oo = oo - vo[j - 1][k + i - 1]\n                ee = ee - ve[j - 1][k + i - 1]\n            if k - 1 >= 0:\n                oo = oo - vo[j + i - 1][k - 1]\n                ee = ee - ve[j + i - 1][k - 1]\n            if k - 1 >= 0 and j - 1 >= 0:\n                oo = oo + vo[j - 1][k - 1]\n                ee = ee + ve[j - 1][k - 1]\n            vv[i] = min(vv[i], oo, ee)\nq = int(input())\nquer = list(map(int, list(input().split())))\nfor j in quer:\n    for i in range(min(n, m), 0, -1):\n        if vv[i] <= j:\n            print(i)\n            break", "import math\n\ndef compute_horizontal_diff(chessboard, N, M):\n    horizontal_diff = [[0 for j in range(M)] for i in range(N)]\n    compare_str = '10' * math.floor(M / 2) + '1' * (M % 2)\n    compare_str = list((int(bit) for bit in compare_str))\n    for i in range(N):\n        if chessboard[i][M - 1] != compare_str[M - 1]:\n            horizontal_diff[i][M - 1] = 1\n        for j in reversed(range(M - 1)):\n            if chessboard[i][j] != compare_str[j]:\n                horizontal_diff[i][j] = horizontal_diff[i][j + 1] + 1\n            else:\n                horizontal_diff[i][j] = horizontal_diff[i][j + 1]\n    return horizontal_diff\n\ndef compute_vertical_diff(chessboard, N, M):\n    vertical_diff = [[0 for j in range(M)] for i in range(N)]\n    compare_str = '10' * math.floor(N / 2) + '1' * (N % 2)\n    compare_str = list((int(bit) for bit in compare_str))\n    for j in range(M):\n        if chessboard[N - 1][j] != compare_str[N - 1]:\n            vertical_diff[N - 1][j] = 1\n        for i in reversed(range(N - 1)):\n            if chessboard[i][j] != compare_str[i]:\n                vertical_diff[i][j] = vertical_diff[i + 1][j] + 1\n            else:\n                vertical_diff[i][j] = vertical_diff[i + 1][j]\n    return vertical_diff\n\ndef get_horizontal_bit_string_diff(horizontal_diff, N, M, i, j, length):\n    if j + length == M:\n        return horizontal_diff[i][j]\n    else:\n        return horizontal_diff[i][j] - horizontal_diff[i][j + length]\n\ndef get_vertical_bit_string_diff(vertical_diff, N, M, i, j, length):\n    if i + length == N:\n        return vertical_diff[i][j]\n    else:\n        return vertical_diff[i][j] - vertical_diff[i + length][j]\n\ndef get_num_of_diff(chessboard, horizontal_diff, vertical_diff, N, M, i, j, length, flag):\n    diff = 0\n    if flag == True and chessboard[i][j] == 0 or (flag == False and chessboard[i][j] == 1):\n        diff += 1\n    expected_bit = 1 if j % 2 == 0 else 0\n    if flag == True and expected_bit == 1 or (flag == False and expected_bit == 0):\n        diff += get_horizontal_bit_string_diff(horizontal_diff, N, M, i, j + 1, length - 1)\n    else:\n        diff += length - 1 - get_horizontal_bit_string_diff(horizontal_diff, N, M, i, j + 1, length - 1)\n    expected_bit = 1 if i % 2 == 0 else 0\n    if flag == True and expected_bit == 1 or (flag == False and expected_bit == 0):\n        diff += get_vertical_bit_string_diff(vertical_diff, N, M, i + 1, j, length - 1)\n    else:\n        diff += length - 1 - get_vertical_bit_string_diff(vertical_diff, N, M, i + 1, j, length - 1)\n    return diff\n(N, M) = list(map(int, input().split()))\ni = 0\nchessboard = []\nwhile i < N:\n    row = list(map(int, input()))\n    chessboard.append(row)\n    i += 1\nhorizontal_diff = compute_horizontal_diff(chessboard, N, M)\nvertical_diff = compute_vertical_diff(chessboard, N, M)\nmin_inverts = [(k + 1) ** 2 for k in range(min(N, M))]\nmin_inverts[0] = 0\nfor i in range(N):\n    for j in range(M):\n        prev_1 = 0\n        prev_2 = 1\n        if chessboard[i][j] == 1:\n            flag = True\n        else:\n            flag = False\n        for k in range(1, min(i, j) + 1):\n            diff = get_num_of_diff(chessboard, horizontal_diff, vertical_diff, N, M, i - k, j - k, k + 1, flag)\n            curr_1 = prev_1 + diff\n            curr_2 = prev_2 + (2 * k + 1 - diff)\n            min_inverts[k] = min(min_inverts[k], min(curr_1, curr_2))\n            (prev_1, prev_2) = (curr_1, curr_2)\nmax_correct_chessboard = []\ni = 0\nj = 0\nwhile i < len(min_inverts):\n    while i < len(min_inverts) and min_inverts[i] == j:\n        i += 1\n    max_correct_chessboard.append(i)\n    j += 1\nQ = int(input())\nc = list(map(int, input().split()))\ni = 0\nmax_required_inverts = len(max_correct_chessboard) - 1\nwhile i < Q:\n    if c[i] >= max_required_inverts:\n        print(max_correct_chessboard[max_required_inverts])\n    else:\n        print(max_correct_chessboard[c[i]])\n    i += 1", "def pre():\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == '1':\n                b[i][j].append((1, 0))\n            else:\n                b[i][j].append((0, 1))\n            hr = 1\n            vr = 1\n            co = 0\n            if b[i][j][0][1]:\n                co = 1\n            for k in range(min(i, j)):\n                hr = int(not hr)\n                vr = int(not vr)\n                if a[i - k - 1][j] != str(vr):\n                    co += 1\n                if a[i][j - k - 1] != str(hr):\n                    co += 1\n                wb = b[i - 1][j - 1][k][1] + co\n                b[i][j].append(((k + 2) ** 2 - wb, wb))\n(n, m) = [int(x) for x in input().split()]\na = []\nfor i in range(n):\n    a.append(input())\nb = [[[] for i in range(m)] for j in range(n)]\npre()\nans = [0] * 40000\nfor i in range(n):\n    for j in range(m):\n        for k in range(min(i, j) + 1):\n            ans[b[i][j][k][0]] = max(ans[b[i][j][k][0]], k + 1)\n            ans[b[i][j][k][1]] = max(ans[b[i][j][k][1]], k + 1)\nfor i in range(1, len(ans)):\n    ans[i] = max(ans[i], ans[i - 1])\nq = int(input())\nqu = [int(x) for x in input().split()]\nfor el in qu:\n    if el > 20000:\n        print(min(n, m))\n    else:\n        print(ans[el])", "import sys\nfrom collections import defaultdict as dd\nfrom itertools import permutations as pp\nfrom itertools import combinations as cc\nfrom collections import Counter as ccd\nfrom random import randint as rd\nfrom bisect import bisect_left as bl\nfrom bisect import bisect_right as br\nimport heapq\nmod = 10 ** 9 + 7\n\ndef ri(flag=0):\n    if flag == 0:\n        return [int(i) for i in sys.stdin.readline().split()]\n    else:\n        return int(sys.stdin.readline())\n(n, m) = ri()\nmat = []\nfor i in range(n):\n    mat.append(input())\ndp1 = [[0 for i in range(m + 1)] for j in range(n + 1)]\ndp2 = [[0 for i in range(m + 1)] for j in range(n + 1)]\nfor i in range(n):\n    for j in range(m):\n        if (i + j) % 2 == 0:\n            if mat[i][j] == '0':\n                dp1[i + 1][j + 1] = 1\n        elif mat[i][j] == '1':\n            dp1[i + 1][j + 1] = 1\nfor i in range(n):\n    for j in range(m):\n        if (i + j) % 2 == 1:\n            if mat[i][j] == '0':\n                dp2[i + 1][j + 1] = 1\n        elif mat[i][j] == '1':\n            dp2[i + 1][j + 1] = 1\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        dp1[i][j] += dp1[i - 1][j] + dp1[i][j - 1] - dp1[i - 1][j - 1]\n        dp2[i][j] += dp2[i - 1][j] + dp2[i][j - 1] - dp2[i - 1][j - 1]\nres = dd(set)\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        try:\n            k = 0\n            while 1:\n                get1 = dp1[i + k][j + k] + dp1[i - 1][j - 1] - dp1[i + k][j - 1] - dp1[i - 1][j + k]\n                get2 = dp2[i + k][j + k] + dp2[i - 1][j - 1] - dp2[i + k][j - 1] - dp2[i - 1][j + k]\n                res[k + 1].add(min(get1, get2))\n                k += 1\n        except:\n            just = 1\nans = []\nfor i in res:\n    ans.append((i, min(res[i])))\nans.sort()\nfinal = []\nfor i in ans:\n    final.append(i[1])\nfor i in range(ri(1)):\n    qu = ri()\n    for j in qu:\n        print(br(final, j))", "def get_aux_matrix(C, n, m):\n    mat = [[0 for j in range(0, m)] for i in range(0, N)]\n    for i in range(0, m):\n        mat[0][i] = C[0][i]\n    for i in range(1, n):\n        for j in range(0, m):\n            mat[i][j] = C[i][j] + mat[i - 1][j]\n    for i in range(0, n):\n        for j in range(1, m):\n            mat[i][j] += mat[i][j - 1]\n    return mat\n\ndef sum_sub_matrix(mat, i1, j1, i2, j2):\n    ret = mat[i2][j2]\n    if i1 > 0:\n        ret -= mat[i1 - 1][j2]\n    if j1 > 0:\n        ret -= mat[i2][j1 - 1]\n    if i1 > 0 and j1 > 0:\n        ret += mat[i1 - 1][j1 - 1]\n    return ret\n\ndef get_nb_intersects(aux_C, side):\n    ret = 2 ** 64\n    for i in range(0, len(aux_C) - side + 1):\n        for j in range(0, len(aux_C) - side + 1):\n            ret = min(ret, sum_sub_matrix(aux_C, i, j, i + side - 1, j + side - 1))\n    return ret\n(N, M) = [int(s) for s in input().split(' ')]\nboard = []\nfor i in range(0, N):\n    board.append([int(s) for s in input()])\nC1 = [[0 for j in range(0, M)] for i in range(0, N)]\nC2 = [[0 for j in range(0, M)] for i in range(0, N)]\nfor i in range(0, N):\n    for j in range(0, M):\n        if board[i][j] != (j % 2 + i % 2) % 2:\n            C1[i][j] = 1\n        if board[i][j] != (j % 2 + (i + 1) % 2) % 2:\n            C2[i][j] = 1\naux_C1 = get_aux_matrix(C1, N, M)\naux_C2 = get_aux_matrix(C2, N, M)\ncTab = [0] * (min(N, M) + 1)\ncTab[1] = 0\nfor i in range(2, len(cTab)):\n    c1 = get_nb_intersects(aux_C1, i)\n    c2 = get_nb_intersects(aux_C2, i)\n    cTab[i] = min(c1, c2)\nQ = int(input())\nfor c in [int(s) for s in input().split(' ')]:\n    side = len(cTab) - 1\n    while cTab[side] > c:\n        side = side - 1\n    print(side)", "(n, m) = map(int, input().split())\ngrid = []\nfor i in range(n):\n    grid.append(list(map(int, input())))\ninf = int(1000000000.0)\nacc = [[0] * (m + 1) for i in range(n + 1)]\nmin_inv = [inf] * (min(n, m) + 1)\n\ndef comp_inv(flip=0):\n    for i in range(n):\n        for j in range(m):\n            acc[i + 1][j + 1] = 0\n            if i + j & 1:\n                if grid[i][j] == flip:\n                    acc[i + 1][j + 1] += 1\n            elif grid[i][j] == (not flip):\n                acc[i + 1][j + 1] += 1\n            acc[i + 1][j + 1] += acc[i + 1][j]\n        for j in range(m):\n            acc[i + 1][j + 1] += acc[i][j + 1]\n\ndef get_inv_sq(x, y, p, q):\n    return acc[p + 1][q + 1] - acc[x][q + 1] - acc[p + 1][y] + acc[x][y]\n\ndef comp_min_inv():\n    for sq_sz in range(0, min(n, m)):\n        for i in range(0, n - sq_sz):\n            for j in range(0, m - sq_sz):\n                min_inv[sq_sz + 1] = min(min_inv[sq_sz + 1], get_inv_sq(i, j, i + sq_sz, j + sq_sz))\ncomp_inv()\ncomp_min_inv()\ncomp_inv(flip=1)\ncomp_min_inv()\nq = int(input())\nc_arr = map(int, input().split(' '))\nfor c in c_arr:\n    for j in range(len(min_inv) - 1, 0, -1):\n        if min_inv[j] <= c:\n            print(j)\n            break", "def toggle_elem(elem):\n    if elem == '0':\n        return '1'\n    else:\n        return '0'\n\ndef printGrid(grid, n, m):\n    for i in range(n):\n        for j in range(m):\n            print(grid[i][j], end=' ')\n        print()\n_input = input().split()\nN = int(_input[0])\nM = int(_input[1])\ndp_data = [[0] * M for i in range(N)]\ngrid = []\nfor i in range(N):\n    _input = input()\n    grid.append(_input)\nelem = '1'\nfor i in range(N):\n    elem2 = elem\n    prev = 0\n    for j in range(M):\n        if elem2 != grid[i][j]:\n            dp_data[i][j] = prev + 1\n        else:\n            dp_data[i][j] = prev\n        prev = dp_data[i][j]\n        elem2 = toggle_elem(elem2)\n    elem = toggle_elem(elem)\nfor i in range(1, N):\n    for j in range(M):\n        dp_data[i][j] += dp_data[i - 1][j]\nmax_size = min(N, M)\nmin_for_size_list = [0] * (max_size + 1)\nfor size in range(1, max_size + 1):\n    min_for_size = -1\n    for i in range(N + 1 - size):\n        for j in range(M + 1 - size):\n            l_corner = (i, j)\n            r_corner = (i + size - 1, j + size - 1)\n            ABCD = dp_data[r_corner[0]][r_corner[1]]\n            if l_corner[0] - 1 >= 0 and l_corner[1] - 1 >= 0:\n                A = dp_data[l_corner[0] - 1][l_corner[1] - 1]\n            else:\n                A = 0\n            if l_corner[0] - 1 >= 0:\n                AB = dp_data[l_corner[0] - 1][r_corner[1]]\n            else:\n                AB = 0\n            if l_corner[1] - 1 >= 0:\n                AC = dp_data[r_corner[0]][l_corner[1] - 1]\n            else:\n                AC = 0\n            D = ABCD - (AB - A) - (AC - A) - A\n            min_shuffle = min(D, size * size - D)\n            if min_shuffle < min_for_size or min_for_size == -1:\n                min_for_size = min_shuffle\n                min_for_size_list[size] = min_for_size\nQ = int(input())\n_input = input().split()\nfor i in range(Q):\n    query = int(_input[i])\n    for j in range(len(min_for_size_list) - 1, 0, -1):\n        if min_for_size_list[j] <= query:\n            print(j)\n            break"]