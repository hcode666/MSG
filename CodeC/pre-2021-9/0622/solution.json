["try:\n    (n, m, h) = map(int, input().split())\n    T = n * m\n    D = dict()\n    Sk = 0\n    for _ in range(h):\n        (tk, ck) = map(int, input().split())\n        D[ck] = D.get(ck, 0) + tk\n        Sk += tk\n    if Sk < T:\n        print('Impossible')\n    else:\n        res = 0\n        cl = list(D.keys())\n        cl.sort()\n        for ck in cl:\n            if D[ck] <= T:\n                res += ck * D[ck]\n                T -= D[ck]\n            else:\n                res += ck * T\n                break\n        print(res)\nexcept Exception as err:\n    print('error occured!!', err)\n    pass", "try:\n    (n, m, h) = map(int, input().split())\n    T = n * m\n    D = dict()\n    Sk = 0\n    for _ in range(h):\n        (tk, ck) = map(int, input().split())\n        D[ck] = D.get(ck, 0) + tk\n        Sk += tk\n    if Sk < T:\n        print('Impossible')\n    else:\n        res = 0\n        cl = list(D.keys())\n        cl.sort()\n        for ck in cl:\n            if D[ck] <= T:\n                res += ck * D[ck]\n                T -= D[ck]\n            else:\n                res += ck * T\n                break\n        print(res)\nexcept Exception as err:\n    print('error occured!!', err)\n    pass", "def solve():\n    (n, m, h) = map(int, input().split())\n    Tcells = 0\n    d = []\n    for _ in range(h):\n        (t, c) = map(int, input().split())\n        d.append([t, c])\n        Tcells += t\n    d_sorted = sorted(d, key=lambda x: x[1])\n    Pcells = 0\n    cost = 0\n    k = m * n\n    if k <= Tcells:\n        for i in d_sorted:\n            Pcells += i[0]\n            if Pcells < k:\n                cost += i[0] * i[1]\n            else:\n                cost += (k - Pcells + i[0]) * i[1]\n                print(cost)\n                break\n    else:\n        print('Impossible')\nsolve()", "def solve():\n    (n, m, h) = map(int, input().split())\n    Tcells = 0\n    d = []\n    for _ in range(h):\n        (t, c) = map(int, input().split())\n        d.append([t, c])\n        Tcells += t\n    d_sorted = sorted(d, key=lambda x: x[1])\n    Pcells = 0\n    cost = 0\n    k = m * n\n    if k <= Tcells:\n        for i in d_sorted:\n            Pcells += i[0]\n            if Pcells < k:\n                cost += i[0] * i[1]\n            else:\n                cost += (k - Pcells + i[0]) * i[1]\n                print(cost)\n                break\n    else:\n        print('Impossible')\nsolve()", "def solve():\n    (n, m, h) = map(int, input().split())\n    Tcells = 0\n    d = []\n    for _ in range(h):\n        (t, c) = map(int, input().split())\n        d.append([t, c])\n        Tcells += t\n    d_sorted = sorted(d, key=lambda x: x[1])\n    Pcells = 0\n    cost = 0\n    k = m * n\n    if k <= Tcells:\n        for i in d_sorted:\n            Pcells += i[0]\n            if Pcells < k:\n                cost += i[0] * i[1]\n            else:\n                diff = k - Pcells + i[0]\n                cost += diff * i[1]\n                print(cost)\n                break\n    else:\n        print('Impossible')\nsolve()", "(n, m, h) = map(int, input().split())\nnumCells = n * m\ntk_ck = []\ntot = 0\nfor _ in range(h):\n    (t, c) = map(int, input().split())\n    tk_ck.append((t, c))\n    tot += t\nif tot < numCells:\n    print('Impossible')\nelse:\n    tk_ck = sorted(tk_ck, key=lambda x: x[1])\n    curCost = 0\n    i = 0\n    while numCells > 0:\n        curCost += tk_ck[i][1] * min(tk_ck[i][0], numCells)\n        numCells -= tk_ck[i][0]\n        i += 1\n    print(curCost)", "(n, m, h) = map(int, input().split())\nnumCells = n * m\ntk_ck = []\ntot = 0\nfor _ in range(h):\n    (t, c) = map(int, input().split())\n    tk_ck.append((t, c))\n    tot += t\nif tot < numCells:\n    print('Impossible')\nelse:\n    tk_ck = sorted(tk_ck, key=lambda x: x[1])\n    curCost = 0\n    i = 0\n    while numCells > 0:\n        curCost += tk_ck[i][1] * min(tk_ck[i][0], numCells)\n        numCells -= tk_ck[i][0]\n        i += 1\n    print(curCost)", "s = input().split(' ')\n(n, m, h) = (int(s[0]), int(s[1]), int(s[2]))\nnumCells = n * m\ncost = []\ncellsPainted = []\nfor _ in range(h):\n    s = input().split(' ')\n    (t, c) = (int(s[0]), int(s[1]))\n    cost.append((c, t))\n    cellsPainted.append(t)\nif sum(cellsPainted) < numCells:\n    print('Impossible')\nelse:\n    cost = sorted(cost, key=lambda x: x[0])\n    curCost = 0\n    i = 0\n    while numCells > 0:\n        curCost += cost[i][0] * min(cost[i][1], numCells)\n        numCells -= cost[i][1]\n        i += 1\n    print(curCost)", "s = input().split(' ')\n(n, m, h) = (int(s[0]), int(s[1]), int(s[2]))\nnumCells = n * m\ncost = []\ncellsPainted = []\nfor _ in range(h):\n    s = input().split(' ')\n    (t, c) = (int(s[0]), int(s[1]))\n    cost.append((c, t))\n    cellsPainted.append(t)\nif sum(cellsPainted) < numCells:\n    print('Impossible')\nelse:\n    cost = sorted(cost, key=lambda x: x[0])\n    curCost = 0\n    i = 0\n    while numCells > 0:\n        curCost += cost[i][0] * min(cost[i][1], numCells)\n        numCells -= cost[i][1]\n        i += 1\n    print(curCost)", "s = input().split(' ')\n(n, m, h) = (int(s[0]), int(s[1]), int(s[2]))\nnumCells = n * m\ncost = []\ncellsPainted = []\nfor _ in range(h):\n    s = input().split(' ')\n    (t, c) = (int(s[0]), int(s[1]))\n    cost.append((c, t))\n    cellsPainted.append(t)\nif sum(cellsPainted) < numCells:\n    print('Impossible')\nelse:\n    cost = sorted(cost, key=lambda x: x[0])\n    curCost = 0\n    i = 0\n    while numCells > 0:\n        curCost += cost[i][0] * min(cost[i][1], numCells)\n        numCells -= cost[i][1]\n        i += 1\n    print(curCost)", "s = input().split(' ')\n(n, m, h) = (int(s[0]), int(s[1]), int(s[2]))\nnumCells = n * m\ncost = []\ncellsPainted = []\nfor i in range(h):\n    s = input().split(' ')\n    (t, c) = (int(s[0]), int(s[1]))\n    cost.append((c, t))\n    cellsPainted.append(t)\nif sum(cellsPainted) < numCells:\n    print('Impossible')\nelse:\n    cost = sorted(cost, key=lambda x: x[0])\n    curCost = 0\n    i = 0\n    while numCells > 0:\n        curCost += cost[i][0] * min(cost[i][1], numCells)\n        numCells -= cost[i][1]\n        i += 1\n    print(curCost)", "s = input().split(' ')\n(n, m, h) = (int(s[0]), int(s[1]), int(s[2]))\nnumCells = n * m\ncost = []\ncellsPainted = []\nfor _ in range(h):\n    s = input().split(' ')\n    (t, c) = (int(s[0]), int(s[1]))\n    cost.append((c, t))\n    cellsPainted.append(t)\nif sum(cellsPainted) < numCells:\n    print('Impossible')\nelse:\n    cost = sorted(cost, key=lambda x: x[0])\n    curCost = 0\n    i = 0\n    while numCells > 0:\n        curCost += cost[i][0] * min(cost[i][1], numCells)\n        numCells -= cost[i][1]\n        i += 1\n    print(curCost)", "s = input().split(' ')\n(n, m, h) = (int(s[0]), int(s[1]), int(s[2]))\nnumCells = n * m\ncost = []\ncellsPainted = []\nfor _ in range(h):\n    s = input().split(' ')\n    (t, c) = (int(s[0]), int(s[1]))\n    cost.append((c, t))\n    cellsPainted.append(t)\nif sum(cellsPainted) < numCells:\n    print('Impossible')\nelse:\n    cost = sorted(cost, key=lambda x: x[0])\n    curCost = 0\n    i = 0\n    while numCells > 0:\n        curCost += cost[i][0] * min(cost[i][1], numCells)\n        numCells -= cost[i][1]\n        i += 1\n    print(curCost)", "s = input().split(' ')\n(n, m, h) = (int(s[0]), int(s[1]), int(s[2]))\nnumCells = n * m\ncost = []\ncellsPainted = []\nfor _ in range(h):\n    s = input().split(' ')\n    (t, c) = (int(s[0]), int(s[1]))\n    cost.append((c, t))\n    cellsPainted.append(t)\nif sum(cellsPainted) < numCells:\n    print('Impossible')\nelse:\n    cost = sorted(cost, key=lambda x: x[0])\n    curCost = 0\n    i = 0\n    while numCells > 0:\n        curCost += cost[i][0] * min(cost[i][1], numCells)\n        numCells -= cost[i][1]\n        i += 1\n    print(curCost)", "line = input()\np = line.split()\nn = int(p[0])\nm = int(p[1])\nt = int(p[2])\nar = list()\nfor _ in range(t):\n    line = input()\n    p = line.split()\n    x = int(p[0])\n    y = int(p[1])\n    ar.append((y, x))\nar = sorted(ar)\nc = 0\ncou = 0\narea = m * n\nfor (y, x) in ar:\n    r = area - cou\n    if x < r:\n        cou = cou + x\n        c = c + x * y\n    else:\n        cou = cou + r\n        c = c + y * r\n        break\nif cou != area:\n    print('Impossible')\nelse:\n    print(c)", "line = input()\np = line.split()\nn = int(p[0])\nm = int(p[1])\nt = int(p[2])\nar = list()\nfor i in range(t):\n    line = input()\n    p = line.split()\n    x = int(p[0])\n    y = int(p[1])\n    ar.append((y, x))\nar = sorted(ar)\nc = 0\ncou = 0\narea = m * n\nfor (y, x) in ar:\n    r = area - cou\n    if x < r:\n        cou = cou + x\n        c = c + x * y\n    else:\n        cou = cou + r\n        c = c + y * r\n        break\nif cou != area:\n    print('Impossible')\nelse:\n    print(c)", "(N, M, H) = map(int, input().split())\nleft = N * M\narray = []\nfor i in range(H):\n    (t, c) = map(int, input().split())\n    array.append([c, t])\narray.sort()\ncost = 0\nfor i in range(H):\n    p = array[i]\n    if left <= p[1]:\n        cost += left * p[0]\n        left = 0\n        break\n    else:\n        cost += p[0] * p[1]\n        left -= p[1]\nif left == 0:\n    print(cost)\nelse:\n    print('Impossible')", "(n, m, h) = map(int, input().split())\nTcells = 0\nd = []\nfor _ in range(h):\n    (t, c) = map(int, input().split())\n    d.append([t, c])\n    Tcells += t\nd_sorted = sorted(d, key=lambda x: x[1])\ncotedcells = 0\ncost = 0\nk = m * n\nif k <= Tcells:\n    for i in d_sorted:\n        cotedcells += i[0]\n        if cotedcells < k:\n            cost += i[0] * i[1]\n        else:\n            diff = k - cotedcells + i[0]\n            cost += diff * i[1]\n            print(cost)\n            break\nelse:\n    print('Impossible')", "(n, m, h) = map(int, input().split())\ncells_to_be_painted = 0\na = []\nfor i in range(h):\n    (t, c) = map(int, input().split())\n    cells_to_be_painted += t\n    a.append([c, t])\nif cells_to_be_painted < m * n:\n    print('Impossible')\nelif cells_to_be_painted == m * n:\n    cost = 0\n    for i in range(h):\n        cost += a[i][0] * a[i][1]\n    print(cost)\nelse:\n    a.sort()\n    cost = 0\n    cells_not_painted = m * n\n    k = 0\n    while cells_not_painted != 0:\n        v = min(cells_not_painted, a[k][1])\n        cost += v * a[k][0]\n        k += 1\n        cells_not_painted -= v\n    print(cost)", "(n, m, h) = list(map(int, input().split()))\ntemp = []\ntot = 0\nfor i in range(h):\n    (v1, v2) = list(map(int, input().split()))\n    tot += v1\n    temp.append((v2, v1))\nif tot < m * n:\n    print('Impossible')\nelse:\n    temp.sort(key=lambda x: x[0])\n    ans = 0\n    topaint = n * m\n    for i in range(h):\n        if topaint == 0:\n            break\n        canpaint = min(temp[i][1], topaint)\n        ans += canpaint * temp[i][0]\n        topaint -= canpaint\n    print(ans)", "(n, m, h) = input().strip().split()\nn = int(n)\nm = int(m)\nh = int(h)\np = []\nadd = 0\nfor i in range(0, h):\n    a = list(map(int, input().strip().split()))\n    add += a[0]\n    p.append(a)\nif add < m * n:\n    print('Impossible')\nelse:\n    p = sorted(p, key=lambda x: x[1])\n    total = n * m\n    cost = 0\n    for j in p:\n        if j[0] <= total:\n            cost += j[0] * j[1]\n            total -= j[0]\n        elif j[0] > total:\n            cost += total * j[1]\n            total = 0\n            break\n    print(cost)", "temp = list(map(int, input().split()))\nn = temp[0]\nm = temp[1]\nh = temp[2]\na = []\nfor t in range(h):\n    temp = list(map(int, input().split()))\n    a.append([temp[1], temp[0]])\na.sort()\nrem = n * m\ni = 0\nans = 0\nwhile i < h and rem > 0:\n    if a[i][1] <= rem:\n        rem -= a[i][1]\n        ans += a[i][1] * a[i][0]\n    elif a[i][1] > rem:\n        ans += rem * a[i][0]\n        rem = 0\n    i += 1\nif rem <= 0:\n    print(ans)\nelse:\n    print('Impossible')", "import sys\n[n, m, h] = list(map(int, input().split()))\ncnt = 0\ncost = []\nfor i in range(h):\n    [t, c] = list(map(int, input().split()))\n    cost.append([c, t])\ncost.sort()\nans = 0\nfor i in range(h):\n    cnt += cost[i][1]\n    ans += cost[i][0] * cost[i][1]\n    if cnt == n * m:\n        print(ans)\n        sys.exit(0)\n    elif cnt > n * m:\n        x = cnt - n * m\n        c = cost[i][0]\n        ans = ans - c * x\n        print(ans)\n        sys.exit(0)\nprint('Impossible')", "(n, m, h) = [int(x) for x in input().split()]\nk = []\nfor i in range(h):\n    k += [[int(x) for x in input().split()]]\nk = sorted(k, key=lambda x: x[1])\ntotal = n * m\nc = 0\nfor i in k:\n    if total > 0:\n        d = min(total, i[0])\n        c += d * i[1]\n        total -= d\n    else:\n        break\nif total > 0:\n    print('Impossible')\nelse:\n    print(c)", "(n, m, h) = map(int, input().split())\nbase = n * m\npaint_available = 0\npaint_value = []\nfor z in range(h):\n    (t, c) = map(int, input().split())\n    paint_available += t\n    paint_value.append([c, t])\nif paint_available < base:\n    print('Impossible')\nelse:\n    paint_value.sort(key=lambda x: x[0])\n    cost = 0\n    for i in range(h):\n        if base > paint_value[i][1]:\n            base -= paint_value[i][1]\n            value = paint_value[i][0] * paint_value[i][1]\n            cost += value\n        else:\n            value = base * paint_value[i][0]\n            cost += value\n            base = 0\n            break\n    print(cost)", "(n, m, h) = [int(word) for word in input().split()]\nct_vals = []\nfor k in range(h):\n    (t, c) = [int(word) for word in input().split()]\n    ct_vals.append((c, t))\nct_vals = sorted(ct_vals)\nrem_cells = m * n\ncost = 0\nfor k in range(h):\n    if rem_cells > ct_vals[k][1]:\n        rem_cells -= ct_vals[k][1]\n        cost += ct_vals[k][0] * ct_vals[k][1]\n    else:\n        cost += ct_vals[k][0] * rem_cells\n        rem_cells = 0\n        break\nif rem_cells > 0:\n    print('Impossible')\nelse:\n    print(cost)", "import sys\nimport math\nfrom time import time\nfrom itertools import permutations, combinations\nimport collections\nimport functools\nfrom fractions import gcd, Fraction\nimport string\nimport operator\nimport bisect\n\nclass timed(object):\n\n    def __init__(self, func):\n        self.func = func\n\n    def __call__(self, *args):\n        t1 = time()\n        ret = self.func(*args)\n        dif_time = time() - t1\n        print('%s: returned %s in %f seconds' % (self.func.__name__, ret, dif_time))\n        return ret\n\ndef comp(f1, f2, *args):\n    t1 = time()\n    r1 = f1(*args) if f1 is not None else None\n    t2 = time()\n    r2 = f2(*args) if f2 is not None else None\n    t3 = time()\n    res = '%5s: %s in %f\\n%5s: %s in %f' % (f1.__name__ if f1 is not None else None, r1, t2 - t1, f2.__name__ if f2 is not None else None, r2, t3 - t2)\n    if r1 != r2:\n        dr = '!! DIFFERENT RESULTS !!'\n        res = dr + '\\n' + res + '\\n' + dr\n    print(res)\n\ndef alg(N, M, H, layers):\n    total_to_paint = N * M\n    layers.sort(key=operator.itemgetter(1))\n    cost = 0\n    for l in layers:\n        if total_to_paint <= l[0]:\n            cost += total_to_paint * l[1]\n            total_to_paint = 0\n            break\n        else:\n            cost += l[1] * l[0]\n            total_to_paint -= l[0]\n    return cost if total_to_paint == 0 else 'Impossible'\n\ndef main():\n    data = sys.stdin\n    (N, M, H) = list(map(int, data.readline().split()))\n    layers = []\n    for h in range(H):\n        layers.append(list(map(int, data.readline().split())))\n    res = alg(N, M, H, layers)\n    print(res)\nmain()", "def main():\n    (n, m, h) = map(int, input().split(' '))\n    layers = []\n    for i in range(h):\n        layers.append(list(map(int, input().split(' '))))\n    cellsRem = n * m\n    cost = 0\n    for i in sorted(list(layers), key=lambda x: x[1]):\n        if cellsRem > i[0]:\n            cost += i[0] * i[1]\n            cellsRem -= i[0]\n        else:\n            cost += cellsRem * i[1]\n            cellsRem = 0\n            break\n    if cellsRem > 0:\n        print('Impossible')\n    else:\n        print(cost)\nmain()", "stri = input().split()\n(n, m, h) = (int(stri[0]), int(stri[1]), int(stri[2]))\ntvalues = []\nfor i in range(h):\n    stri = input().split()\n    tvalues.append((int(stri[0]), int(stri[1])))\ntvalues.sort(key=lambda x: x[1])\ncount = 0\nanswer = 0\ntotal = n * m\ni = 0\nwhile count < total and i <= h - 1:\n    if tvalues[i][0] <= total - count:\n        answer += tvalues[i][1] * tvalues[i][0]\n        count += tvalues[i][0]\n        i += 1\n    else:\n        remaining = total - count\n        count += remaining\n        answer += tvalues[i][1] * remaining\nif count < total:\n    print('Impossible')\nelse:\n    print(answer)"]