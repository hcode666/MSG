["t = int(input())\n\ndef maxpawns(x, y, n):\n    if x >= n or x < 0 or y >= n:\n        return 0\n    if values[y][x] != -1:\n        return values[y][x]\n    values[y][x] = board[x][y] + max(maxpawns(x - 1, y + 2, n), maxpawns(x + 1, y + 2, n), maxpawns(x + 2, y + 1, n), maxpawns(x - 2, y + 1, n))\n    return values[y][x]\nfor abcd in range(t):\n    n = int(input())\n    board = [list(input()) for jkl in range(n)]\n    values = [[-1] * n for mno in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'K':\n                (x1, y1) = (i, j)\n                board[i][j] = 0\n            if board[i][j] == 'P':\n                board[i][j] = 1\n            if board[i][j] == '.':\n                board[i][j] = 0\n    print(maxpawns(x1, y1, n))", "t = int(input())\n\ndef maxpawns(x, y, n):\n    if x >= n or x < 0 or y >= n:\n        return 0\n    if values[y][x] != -1:\n        return values[y][x]\n    values[y][x] = board[x][y] + max(maxpawns(x - 1, y + 2, n), maxpawns(x + 1, y + 2, n), maxpawns(x + 2, y + 1, n), maxpawns(x - 2, y + 1, n))\n    return values[y][x]\nfor abcd in range(t):\n    n = int(input())\n    board = [list(input()) for jkl in range(n)]\n    values = [[-1] * n for mno in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'K':\n                (x1, y1) = (i, j)\n                board[i][j] = 0\n            if board[i][j] == 'P':\n                board[i][j] = 1\n            if board[i][j] == '.':\n                board[i][j] = 0\n    print(maxpawns(x1, y1, n))", "def getMax(boardSize, board, i, j, dp):\n    if i < 0:\n        return 0\n    elif i >= boardSize or j >= boardSize:\n        return 0\n    elif dp[i][j] != None:\n        return dp[i][j]\n    else:\n        if board[i][j] == 'P':\n            dp[i][j] = 1 + max(getMax(boardSize, board, i + 1, j + 2, dp), getMax(boardSize, board, i + 2, j + 1, dp), getMax(boardSize, board, i - 1, j + 2, dp), getMax(boardSize, board, i - 2, j + 1, dp))\n        else:\n            dp[i][j] = max(getMax(boardSize, board, i + 1, j + 2, dp), getMax(boardSize, board, i + 2, j + 1, dp), getMax(boardSize, board, i - 1, j + 2, dp), getMax(boardSize, board, i - 2, j + 1, dp))\n        return dp[i][j]\ntestCases = int(input())\nresult = []\nfor case in range(testCases):\n    boardSize = int(input())\n    board = []\n    knightPosition_i = 0\n    knightPosition_j = 0\n    for j in range(boardSize):\n        boardRow = []\n        row = input()\n        for index in range(len(row)):\n            if row[index] == 'K':\n                knightPosition_i = j\n                knightPosition_j = index\n            boardRow.append(row[index])\n        board.append(boardRow)\n    dp = []\n    for i in range(boardSize):\n        dp_row = []\n        for j in range(boardSize):\n            dp_row.append(None)\n        dp.append(dp_row)\n    result.append(getMax(boardSize, board, knightPosition_i, knightPosition_j, dp))\nfor r in result:\n    print(r)", "def getMax(boardSize, board, i, j, dp):\n    if i < 0:\n        return 0\n    elif i >= boardSize or j >= boardSize:\n        return 0\n    elif dp[i][j] != None:\n        return dp[i][j]\n    else:\n        if board[i][j] == 'P':\n            dp[i][j] = 1 + max(getMax(boardSize, board, i + 1, j + 2, dp), getMax(boardSize, board, i + 2, j + 1, dp), getMax(boardSize, board, i - 1, j + 2, dp), getMax(boardSize, board, i - 2, j + 1, dp))\n        else:\n            dp[i][j] = max(getMax(boardSize, board, i + 1, j + 2, dp), getMax(boardSize, board, i + 2, j + 1, dp), getMax(boardSize, board, i - 1, j + 2, dp), getMax(boardSize, board, i - 2, j + 1, dp))\n        return dp[i][j]\ntestCases = int(input())\nresult = []\nfor case in range(testCases):\n    boardSize = int(input())\n    board = []\n    knightPosition_i = 0\n    knightPosition_j = 0\n    for j in range(boardSize):\n        boardRow = []\n        row = input()\n        for index in range(len(row)):\n            if row[index] == 'K':\n                knightPosition_i = j\n                knightPosition_j = index\n            boardRow.append(row[index])\n        board.append(boardRow)\n    dp = []\n    for i in range(boardSize):\n        dp_row = []\n        for j in range(boardSize):\n            dp_row.append(None)\n        dp.append(dp_row)\n    result.append(getMax(boardSize, board, knightPosition_i, knightPosition_j, dp))\nfor r in result:\n    print(r)", "def getMax(boardSize, board, i, j, dp):\n    if i < 0:\n        return 0\n    elif i >= boardSize or j >= boardSize:\n        return 0\n    elif dp[i][j] != None:\n        return dp[i][j]\n    else:\n        if board[i][j] == 'P':\n            dp[i][j] = 1 + max(getMax(boardSize, board, i + 1, j + 2, dp), getMax(boardSize, board, i + 2, j + 1, dp), getMax(boardSize, board, i - 1, j + 2, dp), getMax(boardSize, board, i - 2, j + 1, dp))\n        else:\n            dp[i][j] = max(getMax(boardSize, board, i + 1, j + 2, dp), getMax(boardSize, board, i + 2, j + 1, dp), getMax(boardSize, board, i - 1, j + 2, dp), getMax(boardSize, board, i - 2, j + 1, dp))\n        return dp[i][j]\ntestCases = int(input())\nresult = []\nfor case in range(testCases):\n    boardSize = int(input())\n    board = []\n    knightPosition_i = 0\n    knightPosition_j = 0\n    for j in range(boardSize):\n        boardRow = []\n        row = input()\n        for index in range(len(row)):\n            if row[index] == 'K':\n                knightPosition_i = j\n                knightPosition_j = index\n            boardRow.append(row[index])\n        board.append(boardRow)\n    dp = []\n    for i in range(boardSize):\n        dp_row = []\n        for j in range(boardSize):\n            dp_row.append(None)\n        dp.append(dp_row)\n    result.append(getMax(boardSize, board, knightPosition_i, knightPosition_j, dp))\nfor r in result:\n    print(r)", "from collections import defaultdict\nget_int = lambda : int(input())\nget_mint = lambda : list(map(int, input().split()))\nknight_moves = [[1, 2], [1, -2], [2, 1], [2, -1]]\n\ndef recur(x, y):\n    if x >= N or y >= N or x < 0 or (y < 0):\n        return 0\n    if dp[x][y] != -1:\n        return dp[x][y]\n    cnt = 1 if chessboard[x][y] == 'P' else 0\n    dp[x][y] = max(cnt + recur(x + 1, y + 2), cnt + recur(x + 2, y + 1), cnt + recur(x - 2, y + 1), cnt + recur(x - 1, y + 2))\n    return dp[x][y]\nfor _ in range(get_int()):\n    N = get_int()\n    chessboard = [input() for _ in range(N)]\n    dp = [[-1 for _ in range(N)] for _ in range(N)]\n    for row in range(N):\n        for cell in range(N):\n            if chessboard[row][cell] == 'K':\n                (r, c) = (row, cell)\n                break\n    print(max(recur(r + 1, c + 2), recur(r + 2, c + 1), recur(r - 2, c + 1), recur(r - 1, c + 2)))", "for _ in range(int(input())):\n    n = int(input())\n    chess = [list(input()) for i in range(n)]\n    dp = [[-1] * n for _ in range(n)]\n\n    def helper(r, c):\n        if r < 0 or c < 0 or r >= n or (c >= n):\n            return 0\n        if c == n - 1:\n            if chess[r][c] == 'P':\n                return 1\n            else:\n                return 0\n        if dp[r][c] != -1:\n            return dp[r][c]\n        if chess[r][c] == 'P':\n            ans = 1\n        else:\n            ans = 0\n        dp[r][c] = ans + max(helper(r - 2, c + 1), helper(r - 1, c + 2), helper(r + 1, c + 2), helper(r + 2, c + 1))\n        return dp[r][c]\n    for i in range(n):\n        for j in range(n):\n            if chess[i][j] == 'K':\n                print(helper(i, j))\n                break", "def solve(i, j):\n    if i >= n or j >= n or i < 0 or (j < 0):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    cur_val = 0\n    if mat[i][j] == 'P':\n        cur_val = 1\n    cnt = cur_val + max(solve(i - 1, j + 2), solve(i - 2, j + 1), solve(i + 1, j + 2), solve(i + 2, j + 1))\n    dp[i][j] = cnt\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    mat = list()\n    for i in range(n):\n        mat.append(input())\n    (row, col) = (-1, -1)\n    dp = [[-1] * n for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 'K':\n                (row, col) = (i, j)\n                break\n    (i, j) = (row, col)\n    print(max(solve(i - 2, j + 1), solve(i - 1, j + 2), solve(i + 1, j + 2), solve(i + 2, j + 1)))", "def solve(i, j):\n    if i >= n or j >= n or i < 0 or (j < 0):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    cur_val = 0\n    if mat[i][j] == 'P':\n        cur_val = 1\n    cnt = cur_val + max(solve(i - 1, j + 2), solve(i - 2, j + 1), solve(i + 1, j + 2), solve(i + 2, j + 1))\n    dp[i][j] = cnt\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    mat = list()\n    for i in range(n):\n        mat.append(input())\n    (row, col) = (-1, -1)\n    dp = [[-1] * n for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 'K':\n                (row, col) = (i, j)\n                break\n    (i, j) = (row, col)\n    print(max(solve(i - 2, j + 1), solve(i - 1, j + 2), solve(i + 1, j + 2), solve(i + 2, j + 1)))", "import sys\nsys.setrecursionlimit(5000)\n\ndef fun_dp(x, y):\n    if x >= n or x < 0 or y < 0 or (y >= n):\n        cache[x][y] = 0\n        return 0\n    if cache[x][y] != -1:\n        return cache[x][y]\n    else:\n        c1 = fun_dp(x + 1, y + 2)\n        c2 = fun_dp(x + 2, y + 1)\n        c3 = fun_dp(x - 1, y + 2)\n        c4 = fun_dp(x - 2, y + 1)\n        temp = max(c1, c2, c3, c4, 0)\n        if mat[x][y] == 'P':\n            cache[x][y] = temp + 1\n        else:\n            cache[x][y] = temp\n        return cache[x][y]\n\ndef solve(i, j):\n    if i >= n or j >= n or i < 0 or (j < 0):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    cur_val = 0\n    if mat[i][j] == 'P':\n        cur_val = 1\n    cnt = cur_val + max(solve(i - 1, j + 2), solve(i - 2, j + 1), solve(i + 1, j + 2), solve(i + 2, j + 1))\n    dp[i][j] = cnt\n    return dp[i][j]\ntest = int(input())\nwhile test:\n    n = int(sys.stdin.readline().rstrip('\\n'))\n    mat = []\n    found = False\n    ind = [0, 0]\n    for i in range(n):\n        temp = sys.stdin.readline().rstrip('\\n')\n        if not found:\n            for j in range(n):\n                if temp[j] == 'K':\n                    ind = [j, i]\n                    found = True\n        mat.append(temp)\n    cache = [[-1 for _ in range(n + 6)] for k in range(n + 6)]\n    print(fun_dp(ind[1], ind[0]))\n    test -= 1", "import sys\nsys.setrecursionlimit(5000)\n\ndef fun_dp(x, y):\n    if cache[x][y] != -1:\n        return cache[x][y]\n    elif x >= n or y < 0 or y >= n:\n        cache[x][y] = 0\n        return 0\n    else:\n        c1 = fun_dp(x + 1, y + 2)\n        c2 = fun_dp(x + 2, y + 1)\n        c3 = fun_dp(x + 1, y - 2)\n        c4 = fun_dp(x + 2, y - 1)\n        temp = max(c1, c2, c3, c4, 0)\n        if mat[x][y] == 'P':\n            cache[x][y] = temp + 1\n        else:\n            cache[x][y] = temp\n        return cache[x][y]\n\ndef solve(i, j):\n    if i >= n or j >= n or i < 0 or (j < 0):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    cur_val = 0\n    if mat[i][j] == 'P':\n        cur_val = 1\n    cnt = cur_val + max(solve(i - 1, j + 2), solve(i - 2, j + 1), solve(i + 1, j + 2), solve(i + 2, j + 1))\n    dp[i][j] = cnt\n    return dp[i][j]\ntest = int(input())\nwhile test:\n    n = int(sys.stdin.readline().rstrip('\\n'))\n    mat = []\n    found = False\n    ind = [0, 0]\n    for i in range(n):\n        temp = sys.stdin.readline().rstrip('\\n')\n        if not found:\n            for j in range(n):\n                if temp[j] == 'K':\n                    ind = [j, i]\n                    found = True\n        mat.append(temp)\n    dp = [[-1 for _ in range(n + 6)] for k in range(n + 6)]\n    print(solve(ind[1], ind[0]))\n    test -= 1", "def solve(i, j):\n    if i >= n or j >= n or i < 0 or (j < 0):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    cur_val = 0\n    if mat[i][j] == 'P':\n        cur_val = 1\n    cnt = cur_val + max(solve(i - 1, j + 2), solve(i - 2, j + 1), solve(i + 1, j + 2), solve(i + 2, j + 1))\n    dp[i][j] = cnt\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    mat = list()\n    for i in range(n):\n        mat.append(input())\n    (row, col) = (-1, -1)\n    dp = [[-1] * n for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 'K':\n                (row, col) = (i, j)\n                break\n    (i, j) = (row, col)\n    print(solve(i, j))", "def solve(i, j):\n    if i >= n or j >= n or i < 0 or (j < 0):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    cur_val = 0\n    if mat[i][j] == 'P':\n        cur_val = 1\n    cnt = cur_val + max(solve(i - 1, j + 2), solve(i - 2, j + 1), solve(i + 1, j + 2), solve(i + 2, j + 1))\n    dp[i][j] = cnt\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    mat = list()\n    for i in range(n):\n        mat.append(input())\n    (row, col) = (-1, -1)\n    dp = [[-1] * n for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 'K':\n                (row, col) = (i, j)\n                break\n    (i, j) = (row, col)\n    print(max(solve(i - 2, j + 1), solve(i - 1, j + 2), solve(i + 1, j + 2), solve(i + 2, j + 1)))", "def solve(i, j):\n    if i >= n or j >= n or i < 0 or (j < 0):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    cur_val = 0\n    if mat[i][j] == 'P':\n        cur_val = 1\n    cnt = cur_val + max(solve(i - 1, j + 2), solve(i - 2, j + 1), solve(i + 1, j + 2), solve(i + 2, j + 1))\n    dp[i][j] = cnt\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    mat = list()\n    for i in range(n):\n        mat.append(input())\n    (row, col) = (-1, -1)\n    dp = [[-1] * n for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 'K':\n                (row, col) = (i, j)\n                break\n    (i, j) = (row, col)\n    print(max(solve(i - 2, j + 1), solve(i - 1, j + 2), solve(i + 1, j + 2), solve(i + 2, j + 1)))", "def solve(i, j):\n    if j >= n or i >= n or i < 0:\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if mat[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = p + max(solve(i - 2, j + 1), solve(i - 1, j + 2), solve(i + 1, j + 2), solve(i + 2, j + 1))\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    mat = list()\n    for i in range(n):\n        mat.append(input())\n    dp = [[-1] * n for i in range(n)]\n    (row, col) = (-1, -1)\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 'K':\n                (row, col) = (i, j)\n                break\n    print(max(solve(row - 2, col + 1), solve(row - 1, col + 2), solve(row + 1, col + 2), solve(row + 2, col + 1)))", "def dp(i, j):\n    if j >= n or i >= n or i < 0:\n        return 0\n    if memo[i][j] != -1:\n        return memo[i][j]\n    if c[i][j] == 'P':\n        P = 1\n    else:\n        P = 0\n    memo[i][j] = max(P + dp(i + 1, j + 2), P + dp(i + 2, j + 1), P + dp(i - 2, j + 1), P + dp(i - 1, j + 2))\n    return memo[i][j]\nfor k in range(int(input())):\n    n = int(input())\n    memo = [[-1 for i in range(n)] for j in range(n)]\n    c = [input() for j in range(n)]\n    for j in range(n):\n        pos = c[j].find('K')\n        if pos >= 0:\n            row = j\n            break\n    col = pos\n    print(max(dp(row + 1, col + 2), dp(row + 2, col + 1), dp(row - 2, col + 1), dp(row - 1, col + 2)))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def main():\n    t = int(input())\n    for i in range(t):\n        n = int(input())\n        ploc = []\n        kloc = (0, 0)\n        append = ploc.append\n        for j in range(n):\n            line = input()\n            for (k, c) in enumerate(line):\n                if c == 'K':\n                    kloc = (j, k)\n                if c == 'P':\n                    append((j, k))\n        solve(kloc, ploc, n)\n\ndef solve(kloc, ploc, n):\n    cache = [[0] * n for i in range(n)]\n    (y, x) = kloc\n    for loc in ploc:\n        cache[loc[0]][loc[1]] = 1\n    for j in range(n - 2, x - 1, -1):\n        for i in range(n):\n            (a, b, c, d) = (0, 0, 0, 0)\n            if 0 <= i - 1 < n and j + 2 < n:\n                a = cache[i - 1][j + 2]\n            if 0 <= i + 1 < n and j + 2 < n:\n                b = cache[i + 1][j + 2]\n            if 0 <= i - 2 < n and j + 1 < n:\n                c = cache[i - 2][j + 1]\n            if 0 <= i + 2 < n and j + 1 < n:\n                d = cache[i + 2][j + 1]\n            cache[i][j] += max(a, b, c, d)\n    print(cache[y][x])\nmain()", "def calculate_max_captured(size, knight_position, pawn_positions):\n    cancel = -10 ** 6\n    pre_previous = [cancel] * size\n    previous = [cancel] * size\n    previous[knight_position[1]] = 0\n    current = [cancel] * size\n    for i in range(knight_position[0] + 1, size):\n        for j in range(size):\n            max_captured = cancel\n            if 0 <= j + 2 < size and max_captured < previous[j + 2]:\n                max_captured = previous[j + 2]\n            if 0 <= j - 2 < size and max_captured < previous[j - 2]:\n                max_captured = previous[j - 2]\n            if 0 <= j + 1 < size and max_captured < pre_previous[j + 1]:\n                max_captured = pre_previous[j + 1]\n            if 0 <= j - 1 < size and max_captured < pre_previous[j - 1]:\n                max_captured = pre_previous[j - 1]\n            if (i, j) in pawn_positions:\n                max_captured += 1\n            if max_captured > current[j]:\n                current[j] = max_captured\n        pre_previous = previous\n        previous = current\n        current = [cancel] * size\n    return max(previous)\ntestcases = int(input())\nfor testcase in range(testcases):\n    size = int(input())\n    knight_position = None\n    pawn_positions = set()\n    for i in range(size):\n        for (j, cell) in enumerate(input()):\n            if cell == 'K':\n                knight_position = (j, i)\n            if cell == 'P':\n                pawn_positions.add((j, i))\n    max_captured = calculate_max_captured(size, knight_position, pawn_positions)\n    print(max_captured)", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "def knight(k_r, k_c, n):\n    for j in range(n - 2, k_c - 1, -1):\n        for i in range(n):\n            a = b = c = d = 0\n            if i - 2 >= 0 and j + 1 < n:\n                a = dp[i - 2][j + 1]\n            if i - 1 >= 0 and j + 2 < n:\n                b = dp[i - 1][j + 2]\n            if i + 2 < n and j + 1 < n:\n                c = dp[i + 2][j + 1]\n            if i + 1 < n and j + 2 < n:\n                d = dp[i + 1][j + 2]\n            dp[i][j] += max(a, b, c, d)\n    return dp[k_r][k_c]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    arr = []\n    dp = []\n    for i in range(n):\n        s1 = input()\n        l1 = [0] * n\n        for j in range(n):\n            if s1[j] == 'K':\n                k_r = i\n                k_c = j\n            if s1[j] == 'P':\n                l1[j] = 1\n        arr.append(s1)\n        dp.append(l1)\n    print(knight(k_r, k_c, n))", "sli = []\n\ndef exploreAll(r, c, n):\n    if c >= n or r < 0 or r >= n:\n        return 0\n    if sli[c][r] != -1:\n        return sli[c][r]\n    sli[c][r] = arr[r][c] + max(exploreAll(r + 2, c + 1, n), exploreAll(r + 1, c + 2, n), exploreAll(r - 1, c + 2, n), exploreAll(r - 2, c + 1, n))\n    return sli[c][r]\ntn = int(input())\nfor _ in range(tn):\n    n = int(input())\n    sli = [[-1 for _ in range(n)] for _ in range(n)]\n    arr = [list(input()) for _ in range(n)]\n    (x, y) = (-1, -1)\n    for i in range(n):\n        for j in range(n):\n            if arr[i][j] == 'K':\n                (x, y) = (i, j)\n            if arr[i][j] == 'P':\n                arr[i][j] = 1\n            else:\n                arr[i][j] = 0\n    a = exploreAll(x, y, n)\n    print(a)", "def jump(i, j):\n    if i < 0 or j < 0 or i >= n or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    dp[i][j] = 1 if board[i][j] == 'P' else 0\n    dp[i][j] += max(jump(i - 1, j + 2), jump(i - 2, j + 1), jump(i + 1, j + 2), jump(i + 2, j + 1))\n    return dp[i][j]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        board[i] = list(input())\n        if 'K' in board[i]:\n            loc_k = (i, board[i].index('K'))\n    dp = [[-1 for _ in range(n)] for _ in range(n)]\n    print(jump(loc_k[0], loc_k[1]))", "def jump(i, j):\n    if i < 0 or j < 0 or i >= n or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    dp[i][j] = 1 if board[i][j] == 'P' else 0\n    dp[i][j] += max(jump(i - 1, j + 2), jump(i - 2, j + 1), jump(i + 1, j + 2), jump(i + 2, j + 1))\n    return dp[i][j]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        board[i] = list(input())\n        if 'K' in board[i]:\n            loc_k = (i, board[i].index('K'))\n    dp = [[-1 for _ in range(n)] for _ in range(n)]\n    print(jump(loc_k[0], loc_k[1]))", "def jump(i, j):\n    if i < 0 or j < 0 or i >= n or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    dp[i][j] = 1 if board[i][j] == 'P' else 0\n    dp[i][j] += max(jump(i - 1, j + 2), jump(i - 2, j + 1), jump(i + 1, j + 2), jump(i + 2, j + 1))\n    return dp[i][j]\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        board[i] = list(input())\n        if 'K' in board[i]:\n            loc_k = (i, board[i].index('K'))\n    dp = [[-1 for _ in range(n)] for _ in range(n)]\n    print(jump(loc_k[0], loc_k[1]))", "def calcPawns(i, j):\n    if i < 0 or j < 0 or i >= n or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    dp[i][j] = 1 if board[i][j] == 'P' else 0\n    dp[i][j] += max(calcPawns(i - 1, j + 2), calcPawns(i - 2, j + 1), calcPawns(i + 1, j + 2), calcPawns(i + 2, j + 1))\n    return dp[i][j]\nn = 0\nboard = [[]]\ndp = [[-1 for j in range(n)] for i in range(n)]\nT = int(input())\nfor t in range(T):\n    n = int(input())\n    board = [list(input()) for _ in range(n)]\n    dp = [[-1 for j in range(n)] for i in range(n)]\n    (ki, kj) = (0, 0)\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'K':\n                (ki, kj) = (i, j)\n                break\n    print(calcPawns(ki, kj))", "def recur(dp, matrix, i, j, n, m):\n    if i >= 0 and j >= 0 and (i < n) and (j < m):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if matrix[i][j] == 'P':\n            dp[i][j] = 1 + max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        else:\n            dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        return dp[i][j]\n    else:\n        return 0\nfor _ in range(int(input())):\n    n = int(input())\n    board = []\n    for _ in range(n):\n        board.append(list(input()))\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, board, x, y, n, n))", "def recur(dp, matrix, i, j, n, m):\n    if i >= 0 and j >= 0 and (i < n) and (j < m):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if matrix[i][j] == 'P':\n            dp[i][j] = 1 + max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        else:\n            dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        return dp[i][j]\n    else:\n        return 0\nfor _ in range(int(input())):\n    n = int(input())\n    board = []\n    for _ in range(n):\n        board.append(list(input()))\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, board, x, y, n, n))", "def recur(dp, matrix, i, j, n, m):\n    if i >= 0 and j >= 0 and (i < n) and (j < m):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if matrix[i][j] == 'P':\n            dp[i][j] = 1 + max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        else:\n            dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        return dp[i][j]\n    else:\n        return 0\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * len(matrix[0]) for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))", "def recur(dp, matrix, i, j, n, m):\n    if i >= 0 and j >= 0 and (i < n) and (j < m):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if matrix[i][j] == 'P':\n            dp[i][j] = 1 + max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        else:\n            dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        return dp[i][j]\n    else:\n        return 0\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * len(matrix[0]) for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))", "def computePawns(board, row, column, n, dp):\n    if row < 0 or row > n - 1 or column > n - 1:\n        return 0\n    if dp[row][column] != -1:\n        return dp[row][column]\n    p = max(computePawns(board, row - 2, column + 1, n, dp), computePawns(board, row - 1, column + 2, n, dp), computePawns(board, row + 1, column + 2, n, dp), computePawns(board, row + 2, column + 1, n, dp))\n    if board[row][column] == 'P':\n        p += 1\n    dp[row][column] = p\n    return p\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    b = False\n    board = []\n    dp = [[-1] * n for i in range(n)]\n    for i in range(n):\n        board.append(input())\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'K':\n                row = i\n                column = j\n                b = True\n                break\n        if b == True:\n            break\n    print(computePawns(board, row, column, n, dp))", "def solve(i, j, dp, l, n):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(solve(i + 2, j + 1, dp, l, n), solve(i + 1, j + 2, dp, l, n), solve(i - 1, j + 2, dp, l, n), solve(i - 2, j + 1, dp, l, n)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(solve(x, y, dp, matrix, n))", "def solve(i, j, dp, l, n):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(solve(i + 2, j + 1, dp, l, n), solve(i + 1, j + 2, dp, l, n), solve(i - 1, j + 2, dp, l, n), solve(i - 2, j + 1, dp, l, n)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(solve(x, y, dp, matrix, n))", "def solve(i, j, dp, l, n):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(solve(i + 2, j + 1, dp, l, n), solve(i + 1, j + 2, dp, l, n), solve(i - 1, j + 2, dp, l, n), solve(i - 2, j + 1, dp, l, n)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(solve(x, y, dp, matrix, n))", "def solve(i, j, dp, l, n):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        dp[i][j] = max(solve(i + 2, j + 1, dp, l, n), solve(i + 1, j + 2, dp, l, n), solve(i - 1, j + 2, dp, l, n), solve(i - 2, j + 1, dp, l, n)) + 1\n    else:\n        dp[i][j] = max(solve(i + 2, j + 1, dp, l, n), solve(i + 1, j + 2, dp, l, n), solve(i - 1, j + 2, dp, l, n), solve(i - 2, j + 1, dp, l, n)) + 0\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(solve(x, y, dp, matrix, n))", "def solve(i, j, dp, l, n):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(solve(i + 2, j + 1, dp, l, n), solve(i + 1, j + 2, dp, l, n), solve(i - 1, j + 2, dp, l, n), solve(i - 2, j + 1, dp, l, n)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(solve(x, y, dp, matrix, n))", "def solve(i, j, dp, l, n):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(solve(i + 2, j + 1, dp, l, n), solve(i + 1, j + 2, dp, l, n), solve(i - 1, j + 2, dp, l, n), solve(i - 2, j + 1, dp, l, n)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(solve(x, y, dp, matrix, n))", "def solve(i, j, dp, l, n):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(solve(i - 2, j + 1, dp, l, n), solve(i + 1, j + 2, dp, l, n), solve(i - 1, j + 2, dp, l, n), solve(i + 2, j + 1, dp, l, n)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(solve(x, y, dp, matrix, n))", "def solve(i, j, dp, l, n):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(solve(i - 1, j + 2, dp, l, n), solve(i + 1, j + 2, dp, l, n), solve(i - 2, j + 1, dp, l, n), solve(i + 2, j + 1, dp, l, n)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(solve(x, y, dp, matrix, n))", "def recur(dp, matrix, i, j, n, m):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))", "def recur(dp, matrix, i, j, n, m):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * len(matrix[0]) for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))", "def recur(dp, matrix, i, j, n, m):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * len(matrix[0]) for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))", "def recur(dp, matrix, i, j, n, m):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * len(matrix[0]) for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))", "def recur(dp, matrix, i, j, n, m):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * len(matrix[0]) for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))", "def recur(dp, matrix, i, j, n, m):\n    if i < 0 or i >= n or j < 0 or (j >= n):\n        return 0\n    if dp[i][j] != -1:\n        return dp[i][j]\n    if matrix[i][j] == 'P':\n        p = 1\n    else:\n        p = 0\n    dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m)) + p\n    return dp[i][j]\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * len(matrix[0]) for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))", "def recur(dp, matrix, i, j, n, m):\n    if i >= 0 and j >= 0 and (i < n) and (j < m):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if matrix[i][j] == 'P':\n            dp[i][j] = 1 + max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        else:\n            dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        return dp[i][j]\n    else:\n        return 0\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * len(matrix[0]) for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))", "def recur(dp, matrix, i, j, n, m):\n    if i >= 0 and j >= 0 and (i < n) and (j < m):\n        if dp[i][j] != -1:\n            return dp[i][j]\n        if matrix[i][j] == 'P':\n            dp[i][j] = 1 + max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        else:\n            dp[i][j] = max(recur(dp, matrix, i - 1, j + 2, n, m), recur(dp, matrix, i + 1, j + 2, n, m), recur(dp, matrix, i - 2, j + 1, n, m), recur(dp, matrix, i + 2, j + 1, n, m))\n        return dp[i][j]\n    else:\n        return 0\nfor _ in range(int(input())):\n    n = int(input())\n    matrix = []\n    for i in range(n):\n        matrix.append(input())\n    dp = [[-1] * len(matrix[0]) for _ in range(n)]\n    for i in range(n):\n        for j in range(len(matrix[0])):\n            if matrix[i][j] == 'K':\n                x = i\n                y = j\n                break\n    print(recur(dp, matrix, x, y, n, len(matrix[0])))"]