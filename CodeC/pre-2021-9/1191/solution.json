["def change(u):\n    i = 0\n    N = len(u)\n    v = u[::-1]\n    new = ''\n    for i in range(N):\n        new += u[i] + v[i]\n    return new\nT = int(input())\nfor nnn in range(T):\n    k = []\n    N = int(input())\n    for i in range(N):\n        u = input()\n        u = change(u)\n        k.append(u)\n    k.sort()\n    tt = []\n    ttt = 0\n    i = 0\n    newarr = []\n    if len(tt) < 0:\n        a = 'abcdefghijklmnopqrstuvwxyz'\n        b = 0\n        for i in a:\n            m = []\n            for j in range(b, len(k)):\n                if i == k[j][0]:\n                    m.append(k[j])\n                else:\n                    b = j\n                    break\n            newarr.append(m)\n        ttt = 0\n        for d in newarr:\n            if len(d) <= 1:\n                continue\n            while len(d) >= 1:\n                i = 0\n                arr_indexes = 0\n                max1 = 0\n                while i < len(d) - 1:\n                    u = 0\n                    for j in range(min(len(d[i]), len(d[i + 1]))):\n                        if d[i][j] == d[i + 1][j]:\n                            u += 1\n                        else:\n                            break\n                    if u > 0:\n                        if max1 < u:\n                            max1 = u\n                            arr_indexes = i\n                        i += 1\n                    else:\n                        i += 1\n                try:\n                    d.pop(arr_indexes)\n                    d.pop(arr_indexes)\n                except:\n                    break\n                ttt += max1 * max1\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    mmm = k[:]\n    a = my(k, mmm)\n    print(a[2])", "def change(u):\n    i = 0\n    N = len(u)\n    v = u[::-1]\n    new = ''\n    for i in range(N):\n        new += u[i] + v[i]\n    return new\nT = int(input())\nfor nnn in range(T):\n    k = []\n    N = int(input())\n    for i in range(N):\n        u = input()\n        u = change(u)\n        k.append(u)\n    k.sort()\n    tt = []\n    ttt = 0\n    i = 0\n    newarr = []\n    if len(tt) < 0:\n        a = 'abcdefghijklmnopqrstuvwxyz'\n        b = 0\n        for i in a:\n            m = []\n            for j in range(b, len(k)):\n                if i == k[j][0]:\n                    m.append(k[j])\n                else:\n                    b = j\n                    break\n            newarr.append(m)\n        ttt = 0\n        for d in newarr:\n            if len(d) <= 1:\n                continue\n            while len(d) >= 1:\n                i = 0\n                arr_indexes = 0\n                max1 = 0\n                while i < len(d) - 1:\n                    u = 0\n                    for j in range(min(len(d[i]), len(d[i + 1]))):\n                        if d[i][j] == d[i + 1][j]:\n                            u += 1\n                        else:\n                            break\n                    if u > 0:\n                        if max1 < u:\n                            max1 = u\n                            arr_indexes = i\n                        i += 1\n                    else:\n                        i += 1\n                try:\n                    d.pop(arr_indexes)\n                    d.pop(arr_indexes)\n                except:\n                    break\n                ttt += max1 * max1\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    mmm = k[:]\n    a = my(k, mmm)\n    print(a[2])", "def calbeauty(word1, word2):\n    p = 0\n    i = 0\n    a = len(word1)\n    b = len(word2)\n    k = min(a, b)\n    while i < k:\n        if word1[i] == word2[i]:\n            i = i + 1\n            p = p + 1\n        else:\n            break\n    return i // 2\nfor _ in range(int(input())):\n    N = int(input())\n    Word = []\n    from collections import defaultdict\n    d = defaultdict(int)\n    for j in range(N):\n        w = input()\n        d[w] += 1\n    beauty = 0\n    for item in d:\n        f = d[item]\n        if f % 2 == 1:\n            Word.append(item)\n            data = len(item) ** 2\n            q = f // 2\n            beauty = beauty + q * data\n        else:\n            data = len(item) ** 2\n            q = f // 2\n            beauty = beauty + q * data\n    W = []\n    for w in Word:\n        i = 0\n        itsL = []\n        for i in range(len(w)):\n            itsL.append(w[i])\n            itsL.append(w[-i - 1])\n        W.append(tuple(itsL))\n    Lists = defaultdict(list)\n    for item in W:\n        Lists[item[0] + item[1]].append(item)\n    for c in Lists:\n        W = sorted(Lists[c])\n        count = len(W)\n        while count > 0:\n            count = count - 1\n            Remain = []\n            while len(W) > 2:\n                data1 = calbeauty(W[-1], W[-2])\n                data2 = calbeauty(W[-2], W[-3])\n                if data2 <= data1:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                else:\n                    d = W.pop()\n                    Remain.append(d)\n            if len(Remain) == 0:\n                break\n            else:\n                W.extend(Remain)\n                W.sort()\n        while len(W) > 2:\n            if len(W) >= 4:\n                data1 = calbeauty(W[-1], W[-2])\n                data2 = calbeauty(W[-2], W[-3])\n                data3 = calbeauty(W[-3], W[-4])\n                beauty = beauty + max(data1, data2, data3) ** 2\n                if data1 >= data2 and data1 >= data3:\n                    W.pop()\n                    W.pop()\n                elif data2 >= data1 and data2 >= data3:\n                    W.pop(-2)\n                    W.pop(-2)\n                elif data3 >= data2 and data3 >= data1:\n                    W.pop(-3)\n                    W.pop(-3)\n            else:\n                data1 = calbeauty(W[0], W[1])\n                data2 = calbeauty(W[1], W[2])\n                if data2 <= data1:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                else:\n                    beauty = beauty + data2 ** 2\n                    W.pop(-2)\n                    W.pop(-2)\n        if len(W) == 1 or len(W) == 0:\n            continue\n        else:\n            beauty = beauty + calbeauty(W[0], W[1]) ** 2\n    print(beauty)", "import string\nimport math\nimport time\nimport sys\nfrom typing import List, Dict, Tuple\n\nclass Solution:\n\n    def __init__(self):\n        self.TIMEDIFF = 6.0\n        self.DELTA = 0.5\n\n    def __len__(self):\n        return 0\n\n    def maxVersePalindrome(self, A: List[str], op: bool, d: dict) -> int:\n        if not op:\n            m = dict()\n            for a in A:\n                s = ''\n                for char in a:\n                    s += char\n                    if s in m:\n                        m[s] += 1\n                    else:\n                        m[s] = 1\n        else:\n            m = d\n        count = 0\n        for a in A:\n            local_count = 0\n            s = ''\n            if m.get(a) == 0:\n                continue\n            for i in range(len(a)):\n                s += a[i]\n                curr_count = m.get(s)\n                if curr_count == 1:\n                    last_char = s[-1]\n                    s = s[:-1]\n                    break\n                else:\n                    local_count += 1\n            if len(s) == 0:\n                continue\n            elif local_count == len(a):\n                last_char = 'Z'\n            if abs(m.get(s) - self.nChildrenPalindrome(s, m)) >= 2:\n                count += math.pow(local_count, 2)\n                b = ''\n                for char in a:\n                    b += char\n                    m[b] -= 2\n            else:\n                letters = string.ascii_lowercase\n                matched = False\n                while s != '' and (not matched):\n                    for l in letters:\n                        f = s + l\n                        if l != last_char and f in m and (m.get(f) > 0) and (m.get(f) % 2 != 0):\n                            s += l\n                            matched = not False\n                            break\n                    if not matched:\n                        local_count -= 1\n                        last_char = s[-1]\n                        s = s[:-1]\n                    else:\n                        while self.nChildrenPalindrome(s, m) % 2 == 1:\n                            for l in letters:\n                                f = s + l\n                                if f in m and m.get(f) > 0 and (m.get(f) % 2 != 0):\n                                    s += l\n                                    break\n                if len(s) != 0 or s != '':\n                    b = ''\n                    count += math.pow(local_count, 2)\n                    for char in a:\n                        b += char\n                        m[b] -= 1\n                    b = ''\n                    for char in s:\n                        b += char\n                        m[b] -= 1\n        return int(count)\n\n    def maxVerseNormal(self, A: list, time_init: float) -> int:\n        letters = string.ascii_lowercase\n        count = 0\n        (fs, m, u) = (dict(), dict(), dict())\n        for a in A:\n            (f, b) = ('', '')\n            for i in range(len(a)):\n                f += a[i]\n                b += a[len(a) - i - 1]\n                if f in fs:\n                    fs[f] += 1\n                else:\n                    fs[f] = 1\n                result = self.concatStr(f, '|', b)\n                if result in m:\n                    m[result] += 1\n                else:\n                    m[result] = 1\n            if a in u:\n                u[a] += 1\n            else:\n                u[a] = 1\n        t_final = time.time()\n        diff = abs(t_final - time_init)\n        if diff >= self.TIMEDIFF:\n            if abs(diff - self.TIMEDIFF) <= self.DELTA:\n                return self.maxVersePalindrome(A, True, fs)\n        for a in A:\n            if u[a] == 0:\n                continue\n            (f, b) = ('', '')\n            local_count = 0\n            for i in range(len(a)):\n                f += a[i]\n                b += a[len(a) - i - 1]\n                concat = self.concatStr(f, '|', b)\n                currCount = m.get(concat)\n                if currCount == 1:\n                    lastChar = f[-1] + '|' + b[-1]\n                    f = f[:-1]\n                    b = b[:-1]\n                    break\n                else:\n                    local_count += 1\n            if f == '' or b == '':\n                continue\n            elif local_count == len(a):\n                lastChar = 'Z'\n            if abs(m.get(self.concatStr(f, '|', b)) - self.nChildrenNormal(f, b, m, fs, letters)) >= 2:\n                (p, q) = ('', '')\n                for i in range(len(a)):\n                    p += a[i]\n                    q += a[len(a) - i - 1]\n                    m[self.concatStr(p, '|', q)] -= 2\n                u[a] -= 2\n                count += math.pow(local_count, 2)\n            else:\n                matched = not True\n                while not matched and (f != '' and b != ''):\n                    for l1 in letters:\n                        fw = f + l1\n                        if fw not in fs:\n                            continue\n                        for l2 in letters:\n                            s = self.concatStr(fw, '|', b, l2)\n                            if self.concatStr(l1, '|', l2) != lastChar and s in m and (m.get(s) % 2 != 0) and (m.get(s) > 0):\n                                (f, b) = (f + l1, b + l2)\n                                matched = True\n                                break\n                        if matched:\n                            break\n                    if not matched:\n                        lastChar = self.concatStr(f[-1], '|', b[-1])\n                        (f, b) = (f[:-1], b[:-1])\n                        local_count -= 1\n                    else:\n                        while self.nChildrenNormal(f, b, m, fs, letters) % 2 == 1:\n                            for l1 in letters:\n                                flag = False\n                                fw = f + l1\n                                if fw not in fs:\n                                    continue\n                                for l2 in letters:\n                                    bw = b + l2\n                                    s = self.concatStr(fw, '|', bw)\n                                    if s in m and m.get(s) % 2 != 0 and (m.get(s) > 0):\n                                        flag = True\n                                        (f, b) = (f + l1, b + l2)\n                                        break\n                                if flag:\n                                    break\n                if f != '' and b != '':\n                    u[a] -= 1\n                    u[f] -= 1\n                    count += math.pow(local_count, 2)\n                    (p, q) = ('', '')\n                    for i in range(len(a)):\n                        p += a[i]\n                        q += a[len(a) - i - 1]\n                        m[self.concatStr(p, '|', q)] -= 1\n                    (p, q) = ('', '')\n                    for i in range(len(f)):\n                        p += f[i]\n                        q += b[i]\n                        m[self.concatStr(p, '|', q)] -= 1\n        return int(count)\n\n    def nChildrenNormal(self, f: str, b: str, m: dict, fs: list, letters: str) -> int:\n        count = 0\n        for l1 in letters:\n            forward = f + l1\n            if forward not in fs:\n                continue\n            for l2 in letters:\n                lookfor = self.concatStr(forward, '|', b, l2)\n                if lookfor in m:\n                    count += m.get(lookfor)\n        return count\n\n    def isPal(self, s: str) -> bool:\n        return s == s[::-1]\n\n    def concatStr(self, *args) -> str:\n        s = ''\n        for arg in args:\n            s += arg\n        return s\n\n    def nChildrenPalindrome(self, s: str, m: dict) -> int:\n        letters = string.ascii_lowercase\n        count = 0\n        for l in letters:\n            search = s + l\n            if search in m:\n                count += m[search]\n        return count\n\n    def solve(self) -> None:\n        t = int(sys.stdin.readline())\n        t_init = time.time()\n        buffer_out = ''\n        for test_case in range(t):\n            pal = False\n            n_strings = int(sys.stdin.readline())\n            A = []\n            for _ in range(n_strings):\n                x = sys.stdin.readline().split()[0]\n                if not pal and (not self.isPal(x)):\n                    pal = True\n                A.append(x)\n            A = sorted(A)\n            if pal:\n                buffer_out += str(self.maxVerseNormal(A, t_init))\n                buffer_out += '\\n'\n            else:\n                buffer_out += str(self.maxVersePalindrome(A, False, {}))\n                buffer_out += '\\n'\n        sys.stdout.write(buffer_out)\ns = Solution()\ns.solve()", "def rhyme(word1, word2):\n    c = 0\n    while c < len(word1) and c < len(word2) and (word1[c] == word2[c]) and (word1[-1 - c] == word2[-1 - c]):\n        c += 1\n    return c ** 2\n\ndef solve(words):\n    (count, beauty, beauties) = ({}, 0, [])\n    for word in words:\n        if word not in count:\n            count[word] = 0\n        count[word] += 1\n    for word in count:\n        if count[word] >= 2:\n            beauty += rhyme(word, word) * (count[word] // 2)\n            count[word] = count[word] % 2\n    for word1 in count:\n        for word2 in count:\n            if word1 != word2:\n                if rhyme(word1, word2) > 0:\n                    beauties.append((rhyme(word1, word2), word1, word2))\n    beauties.sort(key=lambda x: x[0], reverse=True)\n    for (b, word1, word2) in beauties:\n        if count[word1] > 0 and count[word2] > 0:\n            (count[word1], count[word2], beauty) = (count[word1] - 1, count[word2] - 1, beauty + b)\n    return beauty\nfor _ in range(int(input())):\n    (n, words) = (int(input()), [])\n    for i in range(n):\n        words.append(input())\n    print(solve(words))", "def rhyme(word1, word2):\n    c = 0\n    while c < len(word1) and c < len(word2) and (word1[c] == word2[c]) and (word1[-1 - c] == word2[-1 - c]):\n        c += 1\n    return c ** 2\n\ndef solve(words):\n    count = {}\n    for word in words:\n        if word not in count:\n            count[word] = 0\n        count[word] += 1\n    beauty = 0\n    for word in count:\n        if count[word] >= 2:\n            beauty += rhyme(word, word) * (count[word] // 2)\n            count[word] = count[word] % 2\n    beauties = []\n    for word1 in count:\n        for word2 in count:\n            if word1 != word2:\n                b = rhyme(word1, word2)\n                if b > 0:\n                    beauties.append((b, word1, word2))\n    beauties.sort(key=lambda x: x[0], reverse=True)\n    for (b, word1, word2) in beauties:\n        if count[word1] > 0 and count[word2] > 0:\n            count[word1] -= 1\n            count[word2] -= 1\n            beauty += b\n    return beauty\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    b = solve(words)\n    print(b)", "def rhyme(word1, word2):\n    c = 0\n    while c < len(word1) and c < len(word2) and (word1[c] == word2[c]) and (word1[-1 - c] == word2[-1 - c]):\n        c += 1\n    return c ** 2\n\ndef solve(words):\n    count = {}\n    for word in words:\n        if word not in count:\n            count[word] = 0\n        count[word] += 1\n    beauty = 0\n    for word in count:\n        if count[word] >= 2:\n            beauty += rhyme(word, word) * (count[word] // 2)\n            count[word] = count[word] % 2\n    beauties = []\n    for word1 in count:\n        for word2 in count:\n            if word1 != word2:\n                b = rhyme(word1, word2)\n                if b > 0:\n                    beauties.append((b, word1, word2))\n    beauties.sort(key=lambda x: x[0], reverse=True)\n    for (b, word1, word2) in beauties:\n        if count[word1] > 0 and count[word2] > 0:\n            count[word1] -= 1\n            count[word2] -= 1\n            beauty += b\n    return beauty\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    b = solve(words)\n    print(b)", "def rhyme(word1, word2):\n    c = 0\n    while c < len(word1) and c < len(word2) and (word1[c] == word2[c]) and (word1[-1 - c] == word2[-1 - c]):\n        c += 1\n    return c ** 2\n\ndef solve(words):\n    count = {}\n    for word in words:\n        if word not in count:\n            count[word] = 0\n        count[word] += 1\n    beauty = 0\n    for word in count:\n        if count[word] >= 2:\n            beauty += rhyme(word, word) * (count[word] // 2)\n            count[word] = count[word] % 2\n    beauties = []\n    for word1 in count:\n        for word2 in count:\n            if word1 != word2:\n                b = rhyme(word1, word2)\n                if b > 0:\n                    beauties.append((b, word1, word2))\n    beauties.sort(key=lambda x: x[0], reverse=True)\n    for (b, word1, word2) in beauties:\n        if count[word1] > 0 and count[word2] > 0:\n            count[word1] -= 1\n            count[word2] -= 1\n            beauty += b\n    return beauty\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    b = solve(words)\n    print(b)", "def rhyme(word1, word2):\n    c = 0\n    while c < len(word1) and c < len(word2) and (word1[c] == word2[c]) and (word1[-1 - c] == word2[-1 - c]):\n        c += 1\n    return c ** 2\n\ndef solve(words):\n    count = {}\n    for word in words:\n        if word not in count:\n            count[word] = 0\n        count[word] += 1\n    beauty = 0\n    for word in count:\n        if count[word] >= 2:\n            beauty += rhyme(word, word) * (count[word] // 2)\n            count[word] = count[word] % 2\n    beauties = []\n    for word1 in count:\n        for word2 in count:\n            if word1 != word2:\n                b = rhyme(word1, word2)\n                if b > 0:\n                    beauties.append((b, word1, word2))\n    beauties.sort(key=lambda x: x[0], reverse=True)\n    for (b, word1, word2) in beauties:\n        if count[word1] > 0 and count[word2] > 0:\n            count[word1] -= 1\n            count[word2] -= 1\n            beauty += b\n    return beauty\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    b = solve(words)\n    print(b)", "def change(u):\n    i = 0\n    N = len(u)\n    v = u[::-1]\n    new = ''\n    for i in range(N):\n        new += u[i] + v[i]\n    return new\nT = int(input())\nfor nnn in range(T):\n    k = []\n    N = int(input())\n    for i in range(N):\n        u = input()\n        u = change(u)\n        k.append(u)\n    k.sort()\n    tt = []\n    ttt = 0\n    i = 0\n    newarr = []\n    if len(tt) < 0:\n        a = 'abcdefghijklmnopqrstuvwxyz'\n        b = 0\n        for i in a:\n            m = []\n            for j in range(b, len(k)):\n                if i == k[j][0]:\n                    m.append(k[j])\n                else:\n                    b = j\n                    break\n            newarr.append(m)\n        ttt = 0\n        for d in newarr:\n            if len(d) <= 1:\n                continue\n            while len(d) >= 1:\n                i = 0\n                arr_indexes = 0\n                max1 = 0\n                while i < len(d) - 1:\n                    u = 0\n                    for j in range(min(len(d[i]), len(d[i + 1]))):\n                        if d[i][j] == d[i + 1][j]:\n                            u += 1\n                        else:\n                            break\n                    if u > 0:\n                        if max1 < u:\n                            max1 = u\n                            arr_indexes = i\n                        i += 1\n                    else:\n                        i += 1\n                try:\n                    d.pop(arr_indexes)\n                    d.pop(arr_indexes)\n                except:\n                    break\n                ttt += max1 * max1\n\n    def my(k, mmm):\n        mini = 1000000000000\n        index = 0\n        for i in range(0, len(k) - 1):\n            u = 0\n            for j in range(min(len(k[i]), len(k[i + 1]))):\n                if k[i][j] == k[i + 1][j]:\n                    u += 1\n                else:\n                    break\n            if mini > u:\n                mini = u\n                index = i\n        if k[0] == k[-1]:\n            c = len(k) // 2 * len(k[0]) * len(k[0]) // 4\n            if len(k) % 2 == 0:\n                return (0, 0, c)\n            else:\n                return (1, mmm.index(k[0]), c)\n        if len(k) == 1:\n            return (1, mmm.index(k[0]), 0)\n        if len(k) == 2:\n            mini = mini // 2\n            return (0, 0, mini * mini)\n        a1 = my(k[:index + 1], mmm)\n        a2 = my(k[index + 1:], mmm)\n        if a1[0] == 1 and a2[0] == 1:\n            u = 0\n            for j in range(min(len(mmm[a1[1]]), len(mmm[a2[1]]))):\n                if mmm[a1[1]][j] == mmm[a2[1]][j]:\n                    u += 1\n                else:\n                    break\n            u = u // 2\n            return (0, 0, a1[2] + a2[2] + u * u)\n        elif a1[0] == 1 and a2[0] == 0:\n            return (1, a1[1], a1[2] + a2[2])\n        elif a1[0] == 0 and a2[0] == 1:\n            return (1, a2[1], a1[2] + a2[2])\n        else:\n            return (0, 0, a1[2] + a2[2])\n    mmm = k[:]\n    a = my(k, mmm)\n    print(a[2])", "class Node:\n\n    def __init__(self, value, L):\n        self.value = value\n        self.count = 1\n        self.L = L\n        self.R = dict()\n\n    def increment(self):\n        self.count += 1\n\n    @staticmethod\n    def encode(c_1, c_0):\n        return (c_1 - 97) * 26 + (c_0 - 97)\n\n    def add_node(self, value):\n        if value in self.R:\n            self.R[value].increment()\n        else:\n            self.R[value] = Node(value, self)\n        return self.R[value]\n\n    def get_pair_length(self):\n        length = 0\n        node = self\n        while node != None and node.count > 1:\n            length += 1\n            node.count -= 2\n            node = node.find_most_frequent()\n        return length\n\n    def find_most_frequent(self):\n        max_count = 1\n        max_count_node = None\n        for node in self.R.values():\n            if node.count > max_count:\n                max_count = node.count\n                max_count_node = node\n        return max_count_node\n\n    def solve(self):\n        total_beauty = 0\n        stanza_beauty = 0\n        node = self.find_most_frequent()\n        while node != None:\n            stanza_beauty = int(node.get_pair_length())\n            stanza_beauty *= stanza_beauty\n            total_beauty += stanza_beauty\n            node = self.find_most_frequent()\n        return total_beauty\n\n    def load(self, line):\n        node = self\n        for i in range(0, len(line)):\n            j = len(line) - 1 - i\n            value = line[i] + line[j]\n            node = node.add_node(value)\n\n    def print(self, depth):\n        str = ''\n        for i in range(0, depth):\n            str += '-'\n        print(f'{str} {self.value} {self.count}')\n        depth += 1\n        for node in self.R.values():\n            node.print(depth)\n\ndef main():\n    T = int(input())\n    for t in range(0, T):\n        root = Node(1000, 'None')\n        N = int(input())\n        for n in range(0, N):\n            line = input()\n            root.load(line)\n        beauty = root.solve()\n        print(beauty)\nmain()", "global ans\nans = 0\n\ndef lmatch(a, b):\n    match = 0\n    for i in range(min(len(a), len(b))):\n        if a[i] == b[i]:\n            match += 1\n        else:\n            break\n    return int(match / 2) ** 2\ntc = int(input())\nfor tc_i in range(tc):\n    arr = []\n    n = int(input())\n    for n_i in range(n):\n        x = input()\n        nx = ''\n        for i in range(len(x)):\n            nx = nx + x[i] + x[len(x) - i - 1]\n        arr.append(nx)\n    arr.sort()\n\n    def recursive(st, fin):\n        ans = 0\n        if st == fin:\n            return [1, st, ans]\n        elif st + 1 == fin:\n            x = lmatch(arr[st], arr[fin])\n            ans = ans + x\n            return [0, 0, ans]\n        elif arr[st] == arr[fin]:\n            total = fin - st + 1\n            x = total // 2 * lmatch(arr[st], arr[fin])\n            if 1 & total:\n                return [1, st, x]\n            return [0, 0, x]\n        index = st\n        minsc = 100000000\n        for i in range(st, fin):\n            tsc = lmatch(arr[i], arr[i + 1])\n            if tsc < minsc:\n                index = i\n                minsc = tsc\n        f1 = recursive(st, index)\n        f2 = recursive(index + 1, fin)\n        if f1[0] == 1 and f2[0] == 1:\n            x = lmatch(arr[f1[1]], arr[f2[1]])\n            return [0, 0, f1[2] + f2[2] + x]\n        elif f1[0] == 1 and f2[0] == 0:\n            return [1, f1[1], f1[2] + f2[2]]\n        elif f1[0] == 0 and f2[0] == 1:\n            return [1, f2[1], f1[2] + f2[2]]\n        else:\n            return [0, 0, f1[2] + f2[2]]\n    q = recursive(0, n - 1)[-1]\n    print(q)", "import heapq\n\ndef beauty(word1, word2):\n    try:\n        for (i, w) in enumerate(word1):\n            if w != word2[i] or word1[-1 - i] != word2[-1 - i]:\n                return i\n        else:\n            return i + 1\n    except:\n        return i\n\ndef findBeauty():\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            b = beauty(unique_words[i], unique_words[j])\n            if b:\n                heapq.heappush(beauties, (-b, (i, j)))\n\ndef removeDuplicate():\n    dic = {}\n    unique_words = []\n    for word in Words:\n        if word not in dic.keys():\n            dic[word] = 1\n        else:\n            dic[word] += 1\n    total_beauty = 0\n    for (word, count) in dic.items():\n        if count == 1:\n            unique_words.append(word)\n        else:\n            total_beauty += count // 2 * len(word) ** 2\n            if count % 2:\n                unique_words.append(word)\n    return (total_beauty, unique_words)\n\ndef solve(total_beauty):\n    used = set()\n    while len(beauties) > 0:\n        (b, (i, j)) = heapq.heappop(beauties)\n        if i in used or j in used:\n            continue\n        total_beauty += b ** 2\n        used.add(i)\n        used.add(j)\n    return total_beauty\nT = int(input())\nfor _ in range(T):\n    Words = []\n    N = int(input())\n    for n in range(N):\n        Words.append(input())\n    (total_beauty, unique_words) = removeDuplicate()\n    N = len(unique_words)\n    beauties = []\n    heapq.heapify(beauties)\n    findBeauty()\n    print(solve(total_beauty))", "t = int(input())\n\nclass TrieNode:\n\n    def __init__(self):\n        self.children = [None] * 26 * 26\n        self.count = 0\n        self.length = 0\n\nclass Trie:\n\n    def __init__(self):\n        self.root = self.getNode()\n\n    def getNode(self):\n        return TrieNode()\n\n    def char_to_index(self, char1, char2):\n        index1 = ord(char1) - ord('a')\n        return index1 * 26 + (ord(char2) - ord('a'))\n\n    def insert(self, key):\n        pcrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self.char_to_index(key[level], key[length - 1 - level])\n            if not pcrawl.children[index]:\n                pcrawl.children[index] = self.getNode()\n            pcrawl = pcrawl.children[index]\n            pcrawl.count += 1\n            pcrawl.length = level + 1\n\n    def DFS(self):\n        stack = []\n        beauty = 0\n        pcrawl = self.root\n        for i in range(26 * 26):\n            if pcrawl.children[i] != None and pcrawl.children[i].count > 1:\n                stack.append((pcrawl.children[i], pcrawl.children[i].length))\n        while len(stack) != 0:\n            node = stack.pop()\n            beauty += int(node[0].count / 2) * (pow(node[1], 2) - pow(node[1] - 1, 2))\n            for i in range(26 * 26):\n                if node[0].children[i] != None and node[0].children[i].count > 1:\n                    stack.append((node[0].children[i], node[0].children[i].length))\n        print(beauty)\nfor i in range(t):\n    n = int(input())\n    word_list = []\n    for j in range(n):\n        word_list.append(input())\n    T = Trie()\n    for key in word_list:\n        T.insert(key)\n    T.DFS()", "from collections import defaultdict\n\ndef check(aa, bb):\n    l = 0\n    r = -1\n    counter = 0\n    for _ in range(min(len(aa), len(bb))):\n        if aa[l] == bb[l] and aa[r] == bb[r]:\n            counter += 1\n        else:\n            return counter\n        l += 1\n        r -= 1\n    return counter\nfor _ in range(int(input())):\n    N = int(input())\n    word = []\n    dic = defaultdict(int)\n    for __ in range(N):\n        x = input()\n        dic[x] += 1\n    ans = 0\n    for (w, n) in dic.items():\n        if n % 2 == 0:\n            ans += len(w) ** 2 * (n // 2)\n        else:\n            ans += len(w) ** 2 * (n // 2)\n            word.append(w)\n    wordTup = []\n    for i in range(len(word)):\n        for j in range(len(word)):\n            if i != j:\n                key = check(word[i], word[j])\n                if key > 0:\n                    wordTup.append((key, word[i], word[j]))\n    ss = set()\n    wordTup.sort(key=lambda x: x[0], reverse=True)\n    for i in wordTup:\n        if i[1] not in ss and i[2] not in ss:\n            ans += i[0] ** 2\n            ss.add(i[1])\n            ss.add(i[2])\n    print(ans)", "def check(s1, s2):\n    m = min(len(s1), len(s2))\n    r = -1\n    i = 0\n    count = 0\n    while i < m and r >= -m and (s1[i] == s2[i]) and (s1[r] == s2[r]):\n        count += 1\n        i += 1\n        r -= 1\n    return count\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    d = {}\n    for i in words:\n        if d.get(i) == None:\n            d[i] = 1\n        else:\n            d[i] += 1\n    ans = 0\n    words = []\n    for (i, j) in d.items():\n        if j % 2 == 0:\n            ans += len(i) ** 2 * (j // 2)\n        else:\n            ans += len(i) ** 2 * (j // 2)\n            words.append(i)\n    arr = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j:\n                ret = check(words[i], words[j])\n                if ret > 0:\n                    arr.append((ret, words[i], words[j]))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    s = set()\n    for item in arr:\n        if item[1] not in s and item[2] not in s:\n            ans += item[0] ** 2\n            s.add(item[1])\n            s.add(item[2])\n    print(ans)", "def check(s1, s2):\n    m = min(len(s1), len(s2))\n    r = -1\n    i = 0\n    count = 0\n    while i < m and r >= -m and (s1[i] == s2[i]) and (s1[r] == s2[r]):\n        count += 1\n        i += 1\n        r -= 1\n    return count\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    d = {}\n    for i in words:\n        if d.get(i) == None:\n            d[i] = 1\n        else:\n            d[i] += 1\n    ans = 0\n    words = []\n    for (i, j) in d.items():\n        if j % 2 == 0:\n            ans += len(i) ** 2 * (j // 2)\n        else:\n            ans += len(i) ** 2 * (j // 2)\n            words.append(i)\n    arr = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j:\n                ret = check(words[i], words[j])\n                if ret > 0:\n                    arr.append((ret, words[i], words[j]))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    s = set()\n    for item in arr:\n        if item[1] not in s and item[2] not in s:\n            ans += item[0] ** 2\n            s.add(item[1])\n            s.add(item[2])\n    print(ans)", "def common(a, b):\n    m = min(len(a), len(b))\n    i = 0\n    r = -1\n    count = 0\n    while i < m and r >= -m and (a[i] == b[i]) and (a[r] == b[r]):\n        count += 1\n        i += 1\n        r -= 1\n    return count\n\ndef main():\n    t = int(input())\n    while t > 0:\n        n = int(input())\n        arr = []\n        for i in range(n):\n            arr.append(input())\n        d = {}\n        ans = 0\n        for i in arr:\n            if d.get(i) == None:\n                d[i] = 1\n            else:\n                d[i] += 1\n        words = []\n        for (i, j) in d.items():\n            if j % 2 == 0:\n                ans += len(i) ** 2 * (j // 2)\n            else:\n                ans += len(i) ** 2 * (j // 2)\n                words.append(i)\n        s = set()\n        arr1 = []\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if i != j:\n                    r = common(words[i], words[j])\n                    if r > 0:\n                        arr1.append((r, words[i], words[j]))\n        arr1.sort(key=lambda x: x[0], reverse=True)\n        s = set()\n        for i in arr1:\n            if i[1] not in s and i[2] not in s:\n                ans += i[0] ** 2\n                s.add(i[1])\n                s.add(i[2])\n        print(ans)\n        t -= 1\nmain()", "def rhyme(word1, word2):\n    c = 0\n    while c < len(word1) and c < len(word2) and (word1[c] == word2[c]) and (word1[-1 - c] == word2[-1 - c]):\n        c += 1\n    return c ** 2\n\ndef solve(words, n):\n    count = {}\n    for word in words:\n        if word not in count:\n            count[word] = 0\n        count[word] += 1\n    beauty = 0\n    for word in count:\n        if count[word] >= 2:\n            beauty += rhyme(word, word) * (count[word] // 2)\n            count[word] = count[word] % 2\n    beauties = []\n    for word1 in count:\n        for word2 in count:\n            if word1 != word2:\n                if count[word1] > 0 and count[word2] > 0:\n                    b = rhyme(word1, word2)\n                    if b > 0:\n                        beauties.append((b, word1, word2))\n    beauties = sorted(beauties, key=lambda x: x[0], reverse=True)\n    for (b, word1, word2) in beauties:\n        if count[word1] > 0 and count[word2] > 0:\n            count[word1] -= 1\n            count[word2] -= 1\n            beauty += b\n    return beauty\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    n = int(input().strip())\n    words = []\n    for word in range(n):\n        words.append(input().strip())\n    print(solve(words, n))", "def rhyme(word1, word2):\n    c = 0\n    while c < len(word1) and c < len(word2) and (word1[c] == word2[c]) and (word1[-1 - c] == word2[-1 - c]):\n        c += 1\n    return c ** 2\n\ndef solve(words, n):\n    count = {}\n    for word in words:\n        if word not in count:\n            count[word] = 0\n        count[word] += 1\n    beauty = 0\n    for word in count:\n        if count[word] >= 2:\n            beauty += rhyme(word, word) * (count[word] // 2)\n            count[word] = count[word] % 2\n    beauties = []\n    for (i, word1) in enumerate(count):\n        for (j, word2) in enumerate(count):\n            if i != j:\n                if count[word1] > 0 and count[word2] > 0:\n                    b = rhyme(word1, word2)\n                    if b > 0:\n                        beauties.append((b, word1, word2))\n    beauties = sorted(beauties, key=lambda x: x[0], reverse=True)\n    while beauties:\n        (b, word1, word2) = beauties.pop(0)\n        if count[word1] > 0 and count[word2] > 0:\n            count[word1] -= 1\n            count[word2] -= 1\n            beauty += b\n    return beauty\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    n = int(input().strip())\n    words = []\n    for word in range(n):\n        words.append(input().strip())\n    print(solve(words, n))", "def rhyme(word1, word2):\n    c = 0\n    while c < len(word1) and c < len(word2) and (word1[c] == word2[c]) and (word1[-1 - c] == word2[-1 - c]):\n        c += 1\n    return c ** 2\n\ndef solve(words, n):\n    count = {}\n    for word in words:\n        if word not in count:\n            count[word] = 0\n        count[word] += 1\n    beauty = 0\n    for word in count:\n        if count[word] >= 2:\n            beauty += rhyme(word, word) * (count[word] // 2)\n            count[word] = count[word] % 2\n    beauties = []\n    for word1 in count:\n        for word2 in count:\n            if word1 != word2 and count[word1] > 0 and (count[word2] > 0):\n                b = rhyme(word1, word2)\n                if b > 0:\n                    beauties.append((b, word1, word2))\n    beauties = sorted(beauties, key=lambda x: x[0], reverse=True)\n    while beauties:\n        (b, word1, word2) = beauties.pop(0)\n        if count[word1] > 0 and count[word2] > 0:\n            count[word1] -= 1\n            count[word2] -= 1\n            beauty += b\n    return beauty\nT = int(input().strip())\nfor problem in range(1, T + 1):\n    n = int(input().strip())\n    words = []\n    for word in range(n):\n        words.append(input().strip())\n    print(solve(words, n))", "def check(x, y):\n    ans = 0\n    left = 0\n    right = -1\n    z = min(len(x), len(y))\n    while left < z and right >= -z and (x[left] == y[left]) and (x[right] == y[right]):\n        ans += 1\n        left += 1\n        right -= 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = []\n    for x in range(n):\n        l.append(input())\n    d = {}\n    for x in list(l):\n        if x in d:\n            d[x] += 1\n        else:\n            d[x] = 1\n    ans = 0\n    l = []\n    for x in dict(d):\n        if d[x] % 2 == 0:\n            ans += len(x) ** 2 * (d[x] // 2)\n        else:\n            ans += len(x) ** 2 * (d[x] // 2)\n            l.append(x)\n    arr = []\n    for x in list(l):\n        for y in list(l):\n            if x == y:\n                continue\n            else:\n                val = check(x, y)\n                if val > 0:\n                    arr.append((val * val, x, y))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    s = set()\n    for x in arr:\n        if x[1] not in s and x[2] not in s:\n            ans += x[0]\n            s.add(x[1])\n            s.add(x[2])\n    print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    ref = dict()\n    mai = dict()\n    for i in range(n):\n        a = input().rstrip()\n        if a not in mai:\n            mai[a] = 1\n        else:\n            mai[a] += 1\n        ref[a] = 0\n    b = []\n    res = 0\n    for i in mai.keys():\n        if mai[i] >= 2:\n            res += pow(len(i), 2) * (mai[i] // 2)\n            if mai[i] % 2:\n                b.append(i)\n            continue\n        b.append(i)\n    l1 = len(b)\n    fi = []\n    for i in range(l1):\n        for j in range(l1):\n            if i == j:\n                continue\n            l = 0\n            r = min(len(b[i]), len(b[j]))\n            r1 = r\n            r -= 1\n            p = len(b[i]) - 1\n            p1 = len(b[j]) - 1\n            c = 0\n            while l <= r1 - 1 and r >= 0 and (b[i][l] == b[j][l]) and (b[i][p] == b[j][p1]):\n                c += 1\n                l += 1\n                r -= 1\n                p -= 1\n                p1 -= 1\n            if c > 0:\n                fi.append([c, b[i], b[j]])\n    fi.sort(reverse=True)\n    for i in fi:\n        if ref[i[1]] == 0 and ref[i[2]] == 0:\n            res += pow(i[0], 2)\n            ref[i[1]] = 1\n            ref[i[2]] = 1\n    print(res)", "def check(s1, s2):\n    m = min(len(s1), len(s2))\n    r = -1\n    i = 0\n    count = 0\n    while i < m and r >= -m and (s1[i] == s2[i]) and (s1[r] == s2[r]):\n        count += 1\n        i += 1\n        r -= 1\n    return count\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    d = {}\n    for i in words:\n        if d.get(i) == None:\n            d[i] = 1\n        else:\n            d[i] += 1\n    ans = 0\n    words = []\n    for (i, j) in d.items():\n        if j % 2 == 0:\n            ans += len(i) ** 2 * (j // 2)\n        else:\n            ans += len(i) ** 2 * (j // 2)\n            words.append(i)\n    arr = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j:\n                ret = check(words[i], words[j])\n                if ret > 0:\n                    arr.append((ret, words[i], words[j]))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    s = set()\n    for item in arr:\n        if item[1] not in s and item[2] not in s:\n            ans += item[0] ** 2\n            s.add(item[1])\n            s.add(item[2])\n    print(ans)", "def check(s1, s2):\n    m = min(len(s1), len(s2))\n    r = -1\n    i = 0\n    count = 0\n    while i < m and r >= -m and (s1[i] == s2[i]) and (s1[r] == s2[r]):\n        count += 1\n        i += 1\n        r -= 1\n    return count\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    d = {}\n    for i in words:\n        if d.get(i) == None:\n            d[i] = 1\n        else:\n            d[i] += 1\n    ans = 0\n    words = []\n    for (i, j) in d.items():\n        if j % 2 == 0:\n            ans += len(i) ** 2 * (j // 2)\n        else:\n            ans += len(i) ** 2 * (j // 2)\n            words.append(i)\n    arr = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j:\n                ret = check(words[i], words[j])\n                if ret > 0:\n                    arr.append((ret, words[i], words[j]))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    s = set()\n    for item in arr:\n        if item[1] not in s and item[2] not in s:\n            ans += item[0] ** 2\n            s.add(item[1])\n            s.add(item[2])\n    print(ans)", "def check(s1, s2):\n    i = -1\n    for i in range(min(len(s1), len(s2))):\n        if s1[i] != s2[i]:\n            i = i - 1\n            break\n    mi = i + 1\n    i = len(s1) - 1\n    j = len(s2) - 1\n    n = 0\n    while i >= 0 and j >= 0:\n        if s1[i] != s2[j]:\n            break\n        n += 1\n        i = i - 1\n        j = j - 1\n    if n < mi:\n        mi = n\n    return mi\n\ndef func(l):\n    d = {}\n    d2 = {}\n    for i in l:\n        d[i] = 0\n    n = len(l)\n    for i in range(n):\n        if d[l[i]] == 0:\n            for j in range(i + 1, n):\n                m = check(l[i], l[j])\n                if m in d2:\n                    d2[m].append((l[i], l[j]))\n                else:\n                    d2[m] = [(l[i], l[j])]\n        d[l[i]] += 1\n    list = []\n    val = 0\n    for j in d2.keys():\n        list.append(j)\n    list.sort(reverse=True)\n    for i in list:\n        for j in d2[i]:\n            if d[j[0]] > 0:\n                d[j[0]] -= 1\n                if d[j[1]] > 0:\n                    d[j[1]] -= 1\n                    val += i ** 2\n                else:\n                    d[j[0]] += 1\n    return val\nt = int(input())\nfor fber in range(t):\n    n = int(input())\n    l = []\n    for gi5t in range(n):\n        l.append(input())\n    ns = func(l)\n    print(ns)", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\nrr = lambda : input().strip()\nrri = lambda : int(rr())\nrrm = lambda : [int(x) for x in rr().split()]\n\nclass node(object):\n\n    def __init__(self, d=0):\n        self.nodes = [None] * 676\n        self.c = 0\n        self.d = d\n\n    def ce(self, con):\n        if con:\n            self.c += 1\n\n    def sc(self, c):\n        self.c = c\n\n    def gd(self):\n        return self.d\n\n    def gc(self):\n        return self.c\n\nclass trie(object):\n\n    def __init__(self):\n        self.root = node()\n\n    def addn(self, s):\n        nd = self.root\n        for i in s:\n            if nd.nodes[i] == None:\n                nd.nodes[i] = node(nd.gd() + 1)\n            nd = nd.nodes[i]\n        nd.ce(True)\n\ndef getint(ch1, ch2):\n    return (ord(ch1) - ord('a')) * 26 + ord(ch2) - ord('a')\nres = 0\n\ndef dfs(nd):\n    global res\n    k = 0\n    for i in range(676):\n        if nd.nodes[i] != None:\n            k += dfs(nd.nodes[i])\n    k += nd.gc()\n    res += nd.gd() ** 2 * (k // 2)\n    return k % 2\n\ndef sol():\n    n = rri()\n    if n == 1:\n        rr()\n        return 0\n    lis = []\n    tr = trie()\n    for i in range(n):\n        s = rr()\n        t = s[::-1]\n        k = []\n        for j in range(len(s)):\n            k.append(getint(s[j], t[j]))\n        tr.addn(k)\n    global res\n    res = 0\n    dfs(tr.root)\n    return res\nT = rri()\nfor _ in range(T):\n    ans = sol()\n    print(ans)", "t = int(input())\nwhile t:\n    inp = []\n    n = int(input())\n    for i in range(n):\n        inp.append(input())\n    d = {}\n    for i in inp:\n        if d.get(i) is None:\n            d[i] = 1\n        else:\n            d[i] += 1\n    ans = 0\n    words = []\n    for (i, j) in d.items():\n        if j % 2 == 0:\n            ans += len(i) ** 2 * (j // 2)\n        else:\n            ans += len(i) ** 2 * (j // 2)\n            words.append(i)\n    arr = []\n    for i in words:\n        for j in words:\n            count = 0\n            if i != j:\n                p1 = 0\n                p2 = -1\n                m = min(len(i), len(j))\n                while p1 < m and p2 >= -m and (i[p1] == j[p1]) and (i[p2] == j[p2]):\n                    p1 += 1\n                    p2 -= 1\n                    count += 1\n                if count > 0:\n                    arr.append((count, i, j))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    s = set()\n    for i in arr:\n        if i[1] not in s and i[2] not in s:\n            ans += i[0] ** 2\n            s.add(i[1])\n            s.add(i[2])\n    print(ans)\n    t = t - 1", "def beauty(s1, s2):\n    l = min(len(s1), len(s2))\n    i = 0\n    j = -1\n    c = 0\n    while i < l and s1[i] == s2[i] and (s1[j] == s2[j]):\n        i += 1\n        j -= 1\n        c += 1\n    return c * c\nfor _ in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        l.append(input())\n    d = {}\n    for i in l:\n        if i not in d:\n            d[i] = 1\n        else:\n            d[i] += 1\n    ans = 0\n    l = []\n    for (i, j) in d.items():\n        if j % 2 == 1:\n            l.append(i)\n        ans += d[i] // 2 * len(i) ** 2\n    res = []\n    for i in range(0, len(l)):\n        for j in range(i + 1, len(l)):\n            ret = beauty(l[i], l[j])\n            if ret > 0:\n                res.append((ret, l[i], l[j]))\n    res = sorted(res, key=lambda x: x[0], reverse=True)\n    s = set()\n    for ele in res:\n        if ele[1] not in s and ele[2] not in s:\n            s.add(ele[1])\n            s.add(ele[2])\n            ans += ele[0]\n    print(ans)", "def beauty(w1, w2):\n    m = min(len(w1), len(w2))\n    l = 0\n    r = -1\n    num = 0\n    while l < m and r >= -m and (w1[l] == w2[l]) and (w1[r] == w2[r]):\n        num += 1\n        l += 1\n        r -= 1\n    return num ** 2\nT = int(input())\nwhile T:\n    N = int(input())\n    List = []\n    from collections import defaultdict\n    D = defaultdict(int)\n    for i in range(N):\n        word = input()\n        List.append(word)\n        D[word] += 1\n    ans = 0\n    List = []\n    for (i, j) in D.items():\n        ans += len(i) ** 2 * (j // 2)\n        if j % 2 != 0:\n            List.append(i)\n    arr = []\n    for i in range(len(List)):\n        for j in range(len(List)):\n            if i == j:\n                continue\n            else:\n                val = beauty(List[i], List[j])\n                arr.append((val, List[i], List[j]))\n    arr.sort(key=lambda X: X[0], reverse=True)\n    set1 = set()\n    for i in arr:\n        if i[1] not in set1 and i[2] not in set1:\n            ans += i[0]\n            set1.add(i[1])\n            set1.add(i[2])\n    print(ans)\n    T -= 1", "def findPairsVal(s1, s2):\n    n = min(len(s1), len(s2))\n    s = 0\n    e = -1\n    cnt = 0\n    while s < n and e >= -n and (s1[s] == s2[s]) and (s1[e] == s2[e]):\n        cnt += 1\n        s += 1\n        e -= 1\n    return cnt ** 2\nfor t in range(int(input())):\n    words = []\n    for n in range(int(input())):\n        words.append(input())\n    d = {}\n    for w in words:\n        if d.get(w) == None:\n            d[w] = 1\n        else:\n            d[w] += 1\n    words = []\n    ans = 0\n    for (i, j) in d.items():\n        ans += len(i) ** 2 * (j // 2)\n        if j & 1:\n            words.append(i)\n    arr = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j:\n                temp = findPairsVal(words[i], words[j])\n                if temp > 0:\n                    arr.append((temp, words[i], words[j]))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    s = set()\n    for ele in arr:\n        if ele[1] not in s and ele[2] not in s:\n            s.add(ele[1])\n            s.add(ele[2])\n            ans += ele[0]\n    print(ans)", "def fun(s1, s2):\n    start = 0\n    end = -1\n    min_length = min(len(s1), len(s2))\n    c = 0\n    while start < min_length and end >= -min_length and (s1[start] == s2[start]) and (s1[end] == s2[end]):\n        c += 1\n        start += 1\n        end -= 1\n    return c\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    h = dict()\n    for i in words:\n        if i not in h:\n            h[i] = 1\n        else:\n            h[i] += 1\n    words = []\n    ans = 0\n    for (i, j) in h.items():\n        if j % 2 == 0:\n            ans += len(i) ** 2 * (j // 2)\n        else:\n            ans += len(i) ** 2 * (j // 2)\n            words.append(i)\n    my_array = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j:\n                res = fun(words[i], words[j])\n                if res > 0:\n                    my_array.append((res, words[i], words[j]))\n    my_array.sort(key=lambda x: x[0], reverse=True)\n    final_ans = set()\n    for word in my_array:\n        if word[1] not in final_ans and word[2] not in final_ans:\n            ans += word[0] ** 2\n            final_ans.add(word[1])\n            final_ans.add(word[2])\n    print(ans, end='\\n')", "def reverse(s):\n    str = ''\n    for i in s:\n        str = i + str\n    return str\n\ndef solve():\n    n = int(input())\n    arr = list()\n    num = list()\n    num.append(0)\n    for i in range(n):\n        temp = ''\n        temp1 = input()\n        temp2 = reverse(temp1)\n        for i in range(len(temp1)):\n            temp = temp + temp1[i]\n            temp = temp + temp2[i]\n        arr.append(temp)\n    arr.sort()\n    for i in range(0, n - 1):\n        counter = 0\n        a = len(arr[i])\n        b = len(arr[i + 1])\n        for j in range(min(a, b)):\n            if arr[i][j] == arr[i + 1][j]:\n                counter += 1\n            else:\n                break\n        counter = int(counter / 2)\n        num.append(counter * counter)\n    num.append(0)\n    answer = 0\n    while len(num) > 2:\n        if len(num) == 3:\n            answer += num[1]\n            num.clear()\n            break\n        else:\n            i = 1\n            while i < len(num) - 1:\n                if num[i] >= num[i - 1] and num[i] >= num[i + 1]:\n                    answer += num[i]\n                    num[i - 1] = min(num[i - 1], num[i + 1])\n                    del num[i:i + 2]\n                    i -= 1\n                i += 1\n    print(answer)\nt = int(input())\nfor i in range(t):\n    solve()", "t = int(input())\nL_final = []\n\ndef final_string(string):\n    b = ''\n    for i in range(len(string)):\n        b += string[i] + string[-i - 1]\n    return b\nfor i in range(t):\n    n = int(input())\n    values = []\n    for j in range(n):\n        values += [final_string(input())]\n    values.sort()\n    if n > 10 ** 3:\n        k = 0\n        count = 0\n        while k < n - 1:\n            t = k\n            while t < n - 1 and values[t][0] == values[t + 1][0]:\n                t += 1\n            L = values[k:t + 1]\n            w = t - k + 1\n            if w == 1:\n                k += 1\n                continue\n            elif w == 2:\n                x = 1\n                while x < min(len(L[0]), len(L[1])) and L[0][x] == L[1][x]:\n                    x += 1\n                x = x // 2\n                count += x ** 2\n                k += 2\n                continue\n            elif w == 3:\n                (x, y) = (1, 1)\n                while x < min(len(L[0]), len(L[1])) and L[0][x] == L[1][x]:\n                    x += 1\n                while y < min(len(L[1]), len(L[2])) and L[1][y] == L[2][y]:\n                    y += 1\n                count += max(x // 2, y // 2) ** 2\n                k += 3\n                continue\n            else:\n                while len(L) >= 4:\n                    (x, y, z) = (1, 1, 1)\n                    while x < min(len(L[0]), len(L[1])) and L[0][x] == L[1][x]:\n                        x += 1\n                    while y < min(len(L[1]), len(L[2])) and L[1][y] == L[2][y]:\n                        y += 1\n                    (x, y) = (x // 2, y // 2)\n                    if x > y:\n                        count += x ** 2\n                        del L[0]\n                        del L[0]\n                        continue\n                    else:\n                        while z < min(len(L[2]), len(L[3])) and L[2][z] == L[3][z]:\n                            z += 1\n                        z = z // 2\n                        if y >= z:\n                            count += y ** 2\n                            del L[1]\n                            del L[1]\n                        else:\n                            count += x ** 2\n                            del L[0]\n                            del L[0]\n                if len(L) == 2:\n                    x = 1\n                    while x < min(len(L[0]), len(L[1])) and L[0][x] == L[1][x]:\n                        x += 1\n                    x = x // 2\n                    count += x ** 2\n                    k += w\n                    continue\n                else:\n                    (x, y) = (1, 1)\n                    while x < min(len(L[0]), len(L[1])) and L[0][x] == L[1][x]:\n                        x += 1\n                    while y < min(len(L[1]), len(L[2])) and L[1][y] == L[2][y]:\n                        y += 1\n                    (x, y) = (x // 2, y // 2)\n                    count += max(x, y) ** 2\n                    k += w\n                    continue\n            k = t + 1\n        L_final += [count]\n    else:\n        k = 0\n        count = 0\n        while k < n - 1:\n            t = k\n            while t < n - 1 and values[t][0] == values[t + 1][0]:\n                t += 1\n            L = values[k:t + 1]\n            while len(L) > 1:\n                L1 = []\n                for z in range(len(L) - 1):\n                    x = 1\n                    while x < min(len(L[z]), len(L[z + 1])) and L[z][x] == L[z + 1][x]:\n                        x += 1\n                    L1 += [x]\n                L1 = list(map(lambda x: x // 2, L1))\n                index_ = L1.index(max(L1))\n                count += max(L1) ** 2\n                del L[index_]\n                del L[index_]\n            k = t + 1\n        L_final += [count]\nfor ele in L_final:\n    print(ele)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 9)\n\nclass Trie:\n\n    def __init__(self, n):\n        self.nodes = 1\n        self.child = [[0] * 676 for _ in range(n + 1)]\n        self.count = [0] * (n + 1)\n\n    def insert(self, word):\n        u = 0\n        for i in word:\n            if not self.child[u][i]:\n                self.child[u][i] = self.nodes\n                self.nodes += 1\n            u = self.child[u][i]\n        self.count[u] += 1\n\n    def dfs(self, root, depth=0):\n        ans = 0\n        for v in range(676):\n            if self.child[root][v]:\n                ans += self.dfs(self.child[root][v], depth + 1)\n                self.count[root] += self.count[self.child[root][v]]\n        while self.count[root] >= 2:\n            self.count[root] -= 2\n            ans += depth ** 2\n        return ans\nt = int(input())\nqueries = []\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input().strip())\n    queries.append(s)\nans = []\n\ndef convert_string_to_int(s, r):\n    res = []\n    for i in range(len(s)):\n        res.append((ord(s[i]) - ord('a')) * 26 + (ord(r[i]) - ord('a')))\n    return res\nfor i in queries:\n    trie = Trie(sum((len(j) for j in i)))\n    for j in i:\n        res = convert_string_to_int(j, j[::-1])\n        trie.insert(res)\n    print(trie.dfs(0))", "def clean(a):\n    required = 0\n    length = len(a)\n    temp = []\n    for i in range(length - 1):\n        if a[i][0] == a[i + 1][0]:\n            temp.append(a[i])\n        else:\n            temp.append(a[i])\n            if len(temp) > 1:\n                required += solve(temp)\n            temp = []\n    i += 1\n    temp.append(a[i])\n    if len(temp) > 1:\n        required += solve(temp)\n    return required\n\ndef calculate(a, b):\n    index = 0\n    la = len(a)\n    lb = len(b)\n    while index < len(a) and index < len(b):\n        c1 = a[index]\n        c2 = b[index]\n        if c1 == c2:\n            index += 1\n        else:\n            break\n    index = index // 2\n    return index * index\n\ndef solve(arr):\n    i = 0\n    answer = 0\n    length = len(arr)\n    used = [0] * length\n    que = [i for i in range(length)]\n    count = length\n    if length == 2:\n        return calculate(arr[0], arr[1])\n    else:\n        head = que[0]\n        while True:\n            while used[i] != 0:\n                i += 1\n                i = i % length\n            first = i\n            i = (i + 1) % length\n            while used[i] != 0:\n                i += 1\n                i = i % length\n            second = i\n            i = (i + 1) % length\n            while used[i] != 0:\n                i += 1\n                i = i % length\n            third = i\n            one = calculate(arr[first], arr[second])\n            two = calculate(arr[second], arr[third])\n            if one >= two:\n                answer += one\n                used[first] = 1\n                used[second] = 1\n                que.remove(first)\n                que.remove(second)\n                count -= 2\n                head = que[0]\n                i = head\n            else:\n                i = first + 1\n                i = i % length\n            if count <= 2:\n                break\n        if count == 2:\n            while used[i] != 0:\n                i += 1\n                i = i % length\n            first = i\n            i = (i + 1) % length\n            while used[i] != 0:\n                i += 1\n            second = i\n            answer += calculate(arr[first], arr[second])\n        return answer\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        s = input()\n        print(0)\n        continue\n    verse = []\n    answer = 0\n    q = 0\n    for _ in range(n):\n        s = input()\n        rev = s[::-1]\n        news = ''\n        for i in range(len(s)):\n            news += s[i] + rev[i]\n        if news in verse:\n            verse.remove(news)\n            answer += pow(len(news) // 2, 2)\n            continue\n        verse.append(news)\n    verse.sort()\n    if len(verse) > 1:\n        q = clean(verse)\n    print(answer + q)", "def clean(a):\n    required = 0\n    length = len(a)\n    temp = []\n    for i in range(length - 1):\n        if a[i][0] == a[i + 1][0]:\n            temp.append(a[i])\n        else:\n            temp.append(a[i])\n            if len(temp) > 1:\n                temp = temp[::-1]\n                required += solve(temp)\n            temp = []\n    i += 1\n    temp.append(a[i])\n    if len(temp) > 1:\n        temp = temp[::-1]\n        required += solve(temp)\n    return required\n\ndef calculate(a, b):\n    index = 0\n    la = len(a)\n    lb = len(b)\n    while index < len(a) and index < len(b):\n        c1 = a[index]\n        c2 = b[index]\n        e1 = a[la - 1 - index]\n        e2 = b[lb - 1 - index]\n        if c1 == c2 and e1 == e2:\n            index += 1\n        else:\n            break\n    index = index // 2\n    return index * index\n\ndef solve(arr):\n    i = 0\n    answer = 0\n    length = len(arr)\n    used = [0] * length\n    que = [i for i in range(length)]\n    count = length\n    if length == 2:\n        return calculate(arr[0], arr[1])\n    else:\n        head = que[0]\n        while True:\n            while used[i] != 0:\n                i += 1\n                i = i % length\n            first = i\n            i = (i + 1) % length\n            while used[i] != 0:\n                i += 1\n                i = i % length\n            second = i\n            i = (i + 1) % length\n            while used[i] != 0:\n                i += 1\n                i = i % length\n            third = i\n            one = calculate(arr[first], arr[second])\n            two = calculate(arr[second], arr[third])\n            if one >= two:\n                answer += one\n                used[first] = 1\n                used[second] = 1\n                que.remove(first)\n                que.remove(second)\n                count -= 2\n                head = que[0]\n                i = head\n            else:\n                i = first + 1\n                i = i % length\n            if count <= 2:\n                break\n        if count == 2:\n            while used[i] != 0:\n                i += 1\n                i = i % length\n            first = i\n            i = (i + 1) % length\n            while used[i] != 0:\n                i += 1\n            second = i\n            answer += calculate(arr[first], arr[second])\n        return answer\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        s = input()\n        print(0)\n        continue\n    verse = []\n    answer = 0\n    q = 0\n    for _ in range(n):\n        s = input()\n        rev = s[::-1]\n        news = ''\n        for i in range(len(s)):\n            news += s[i] + rev[i]\n        if news in verse:\n            verse.remove(news)\n            answer += pow(len(news) // 2, 2)\n            continue\n        verse.append(news)\n    verse.sort()\n    if len(verse) > 1:\n        q = clean(verse)\n    print(answer + q)", "t = int(input())\nfor _ in range(t):\n    ls = []\n    n = int(input())\n    for _ in range(n):\n        s = input()\n        ls.append(s)\n    sum = 0\n    i = 0\n    ans = []\n    ls.sort()\n    new_ls = []\n    count = 0\n    for i in range(n):\n        if i == 0:\n            count += 1\n            if i == n - 1:\n                sum += len(ls[i]) ** 2 * (count // 2)\n                if count % 2 != 0:\n                    new_ls.append(ls[i])\n        elif ls[i] == ls[i - 1]:\n            count += 1\n            if i == n - 1:\n                sum += len(ls[i]) ** 2 * (count // 2)\n                if count % 2 != 0:\n                    new_ls.append(ls[i])\n        else:\n            sum += len(ls[i - 1]) ** 2 * (count // 2)\n            if count % 2 != 0:\n                new_ls.append(ls[i - 1])\n            count = 1\n            if i == n - 1:\n                sum += len(ls[i]) ** 2 * (count // 2)\n                if count % 2 != 0:\n                    new_ls.append(ls[i])\n    xx = len(new_ls)\n    for i in range(xx - 1):\n        for j in range(i + 1, xx):\n            s1 = new_ls[i]\n            s2 = new_ls[j]\n            len1 = len(s1)\n            len2 = len(s2)\n            pre = 0\n            l1 = 0\n            l2 = 0\n            while l1 < len1 and l2 < len2 and (s1[l1] == s2[l2]):\n                l2 += 1\n                l1 += 1\n                pre += 1\n            l1 = len1 - 1\n            l2 = len2 - 1\n            suff = 0\n            if pre > 0:\n                while l1 >= 0 and l2 >= 0 and (s1[l1] == s2[l2]):\n                    l1 -= 1\n                    l2 -= 1\n                    suff += 1\n                maa = min(pre, suff) ** 2\n                ans.append([maa, s1, s2])\n    x1 = set()\n    ans.sort(reverse=True)\n    rr = len(ans)\n    i = 0\n    while i < rr and ans[i][0] > 0:\n        if ans[i][1] not in x1 and ans[i][2] not in x1:\n            sum += ans[i][0]\n            x1.add(ans[i][1])\n            x1.add(ans[i][2])\n        i += 1\n    print(sum)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 9)\n\nclass Trie:\n\n    def __init__(self, n):\n        self.nodes = 1\n        self.child = [[0] * 676 for _ in range(n + 1)]\n        self.count = [0] * (n + 1)\n\n    def insert(self, word):\n        u = 0\n        for i in word:\n            if not self.child[u][i]:\n                self.child[u][i] = self.nodes\n                self.nodes += 1\n            u = self.child[u][i]\n        self.count[u] += 1\n\n    def dfs(self, root, depth=0):\n        ans = 0\n        for v in range(676):\n            if self.child[root][v]:\n                ans += self.dfs(self.child[root][v], depth + 1)\n                self.count[root] += self.count[self.child[root][v]]\n        while self.count[root] >= 2:\n            self.count[root] -= 2\n            ans += depth ** 2\n        return ans\nt = int(input())\nqueries = []\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input().strip())\n    queries.append(s)\nans = []\n\ndef convert_string_to_int(s, r):\n    res = []\n    for i in range(len(s)):\n        res.append((ord(s[i]) - ord('a')) * 26 + (ord(r[i]) - ord('a')))\n    return res\nfor i in queries:\n    trie = Trie(sum((len(j) for j in i)))\n    for j in i:\n        res = convert_string_to_int(j, j[::-1])\n        trie.insert(res)\n    print(trie.dfs(0))", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 9)\n\nclass Trie:\n\n    def __init__(self, n):\n        self.nodes = 1\n        self.child = [[0] * 676 for _ in range(n + 1)]\n        self.count = [0] * (n + 1)\n\n    def insert(self, word):\n        u = 0\n        for i in word:\n            if not self.child[u][i]:\n                self.child[u][i] = self.nodes\n                self.nodes += 1\n            u = self.child[u][i]\n        self.count[u] += 1\n\n    def dfs(self, root, depth=0):\n        ans = 0\n        for v in range(676):\n            if self.child[root][v]:\n                ans += self.dfs(self.child[root][v], depth + 1)\n                self.count[root] += self.count[self.child[root][v]]\n        while self.count[root] >= 2:\n            self.count[root] -= 2\n            ans += depth ** 2\n        return ans\nt = int(input())\nqueries = []\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input().strip())\n    queries.append(s)\nans = []\n\ndef convert_string_to_int(s, r):\n    res = []\n    for i in range(len(s)):\n        res.append((ord(s[i]) - ord('a')) * 26 + (ord(r[i]) - ord('a')))\n    return res\nfor i in queries:\n    trie = Trie(sum((len(j) for j in i)))\n    for j in i:\n        res = convert_string_to_int(j, j[::-1])\n        trie.insert(res)\n    print(trie.dfs(0))", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 9)\n\nclass Trie:\n\n    def __init__(self, n):\n        self.nodes = 1\n        self.child = [[0] * 676 for _ in range(n + 1)]\n        self.count = [0] * (n + 1)\n\n    def insert(self, word):\n        u = 0\n        for i in word:\n            if not self.child[u][i]:\n                self.child[u][i] = self.nodes\n                self.nodes += 1\n            u = self.child[u][i]\n        self.count[u] += 1\n\n    def dfs(self, root, depth=0):\n        ans = 0\n        for v in range(676):\n            if self.child[root][v]:\n                ans += self.dfs(self.child[root][v], depth + 1)\n                self.count[root] += self.count[self.child[root][v]]\n        while self.count[root] >= 2:\n            self.count[root] -= 2\n            ans += depth ** 2\n        return ans\nt = int(input())\nqueries = []\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input().strip())\n    queries.append(s)\nans = []\n\ndef convert_string_to_int(s, r):\n    res = []\n    for i in range(len(s)):\n        res.append((ord(s[i]) - ord('a')) * 26 + (ord(r[i]) - ord('a')))\n    return res\nfor i in queries:\n    trie = Trie(sum((len(j) for j in i)))\n    for j in i:\n        res = convert_string_to_int(j, j[::-1])\n        trie.insert(res)\n    print(trie.dfs(0))", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 9)\n\nclass Trie:\n\n    def __init__(self, n):\n        self.nodes = 1\n        self.child = [[0] * 676 for _ in range(n + 1)]\n        self.count = [0] * (n + 1)\n\n    def insert(self, word):\n        u = 0\n        for i in word:\n            if not self.child[u][i]:\n                self.child[u][i] = self.nodes\n                self.nodes += 1\n            u = self.child[u][i]\n        self.count[u] += 1\n\n    def dfs(self, root, depth=0):\n        ans = 0\n        for v in range(676):\n            if self.child[root][v]:\n                ans += self.dfs(self.child[root][v], depth + 1)\n                self.count[root] += self.count[self.child[root][v]]\n        while self.count[root] >= 2:\n            self.count[root] -= 2\n            ans += depth ** 2\n        return ans\nt = int(input())\nqueries = []\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    s = []\n    for i in range(n):\n        s.append(input().strip())\n    queries.append(s)\nans = []\n\ndef convert_string_to_int(s, r):\n    res = []\n    for i in range(len(s)):\n        res.append((ord(s[i]) - ord('a')) * 26 + (ord(r[i]) - ord('a')))\n    return res\nfor i in queries:\n    trie = Trie(sum((len(j) for j in i)))\n    for j in i:\n        res = convert_string_to_int(j, j[::-1])\n        trie.insert(res)\n    print(trie.dfs(0))", "t = int(input())\nfor _ in range(t):\n    ls = []\n    n = int(input())\n    for _ in range(n):\n        s = input()\n        ls.append(s)\n    sum = 0\n    i = 0\n    ans = []\n    ls.sort()\n    new_ls = []\n    count = 0\n    for i in range(n):\n        if i == 0:\n            count += 1\n            if i == n - 1:\n                sum += len(ls[i]) ** 2 * (count // 2)\n                if count % 2 != 0:\n                    new_ls.append(ls[i])\n        elif ls[i] == ls[i - 1]:\n            count += 1\n            if i == n - 1:\n                sum += len(ls[i]) ** 2 * (count // 2)\n                if count % 2 != 0:\n                    new_ls.append(ls[i])\n        else:\n            sum += len(ls[i - 1]) ** 2 * (count // 2)\n            if count % 2 != 0:\n                new_ls.append(ls[i - 1])\n            count = 1\n            if i == n - 1:\n                sum += len(ls[i]) ** 2 * (count // 2)\n                if count % 2 != 0:\n                    new_ls.append(ls[i])\n    xx = len(new_ls)\n    for i in range(xx - 1):\n        for j in range(i + 1, xx):\n            s1 = new_ls[i]\n            s2 = new_ls[j]\n            len1 = len(s1)\n            len2 = len(s2)\n            pre = 0\n            l1 = 0\n            l2 = 0\n            while l1 < len1 and l2 < len2 and (s1[l1] == s2[l2]):\n                l2 += 1\n                l1 += 1\n                pre += 1\n            l1 = len1 - 1\n            l2 = len2 - 1\n            suff = 0\n            if pre > 0:\n                while l1 >= 0 and l2 >= 0 and (s1[l1] == s2[l2]):\n                    l1 -= 1\n                    l2 -= 1\n                    suff += 1\n                maa = min(pre, suff) ** 2\n                ans.append([maa, s1, s2])\n    x1 = set()\n    ans.sort(reverse=True)\n    rr = len(ans)\n    i = 0\n    while i < rr and ans[i][0] > 0:\n        if ans[i][1] not in x1 and ans[i][2] not in x1:\n            sum += ans[i][0]\n            x1.add(ans[i][1])\n            x1.add(ans[i][2])\n        i += 1\n    print(sum)", "from sys import stdin\n\nclass Box:\n\n    def __init__(self, humt):\n        self.humeighumt = humt\n        self.link = {}\n        self.branchum = 0\n\ndef solution(N, W):\n    root = Box(0)\n    temporary = root\n    (hum, p, rem) = (None, None, None)\n    countt = 0\n    prefix = {}\n    for i in range(N):\n        w = W[i]\n        idn = i + 1\n        temporary = root\n        for j in range(len(w)):\n            s = w[j]\n            if s not in temporary.link:\n                hum = Box(temporary.humeighumt + 1)\n                temporary.link[s] = hum\n                temporary = hum\n                countt += 1\n                temporary.branchum = countt\n            else:\n                temporary = temporary.link[s]\n            if temporary.humeighumt not in prefix:\n                prefix[temporary.humeighumt] = {}\n            p = prefix[temporary.humeighumt]\n            s = s + str(temporary.branchum)\n            if s in p:\n                p[s].add(idn)\n            else:\n                p[s] = {idn}\n    suffix = {}\n    roots = Box(0)\n    temporary = roots\n    for i in range(N):\n        w = W[i]\n        idn = i + 1\n        temporary = roots\n        for j in range(len(w) - 1, -1, -1):\n            s = w[j]\n            if s not in temporary.link:\n                hum = Box(temporary.humeighumt + 1)\n                temporary.link[s] = hum\n                temporary = hum\n                countt += 1\n                temporary.branchum = countt\n            else:\n                temporary = temporary.link[s]\n            if temporary.humeighumt not in suffix:\n                suffix[temporary.humeighumt] = {}\n            p = suffix[temporary.humeighumt]\n            s = s + str(temporary.branchum)\n            if s in p:\n                p[s].add(idn)\n            else:\n                p[s] = {idn}\n    suffix_m = {}\n    for num in suffix.keys():\n        mp = suffix_m[num] = {}\n        for ky in suffix[num].keys():\n            for p in suffix[num][ky]:\n                mp[p] = ky\n    hum = list(prefix.keys())\n    hum.sort(reverse=True)\n    done = set()\n    ans = 0\n    for num in hum:\n        for ky in prefix[num].keys():\n            g = {}\n            for p in prefix[num][ky]:\n                if p in done:\n                    continue\n                if suffix_m[num][p] in g:\n                    ans += num ** 2\n                    done.add(p)\n                    done.add(g[suffix_m[num][p]])\n                    del g[suffix_m[num][p]]\n                else:\n                    g[suffix_m[num][p]] = p\n    print(ans)\n\ndef rajiv():\n    read = stdin.readline\n    for _ in range(int(read())):\n        num = int(read())\n        work = [read().strip() for i in range(num)]\n        solution(num, work)\nrajiv()", "import string\nimport math\nimport time\nimport sys\nfrom typing import List, Dict, Tuple\n\nclass Solution:\n\n    def __init__(self):\n        self.TIMEDIFF = 6.0\n        self.DELTA = 0.5\n\n    def __len__(self):\n        return 0\n\n    def maxVersePalindrome(self, A: List[str], op: bool, d: dict) -> int:\n        if not op:\n            m = dict()\n            for a in A:\n                s = ''\n                for char in a:\n                    s += char\n                    if s in m:\n                        m[s] += 1\n                    else:\n                        m[s] = 1\n        else:\n            m = d\n        count = 0\n        for a in A:\n            local_count = 0\n            s = ''\n            if m.get(a) == 0:\n                continue\n            for i in range(len(a)):\n                s += a[i]\n                curr_count = m.get(s)\n                if curr_count == 1:\n                    last_char = s[-1]\n                    s = s[:-1]\n                    break\n                else:\n                    local_count += 1\n            if len(s) == 0:\n                continue\n            elif local_count == len(a):\n                last_char = 'Z'\n            if abs(m.get(s) - self.nChildrenPalindrome(s, m)) >= 2:\n                count += math.pow(local_count, 2)\n                b = ''\n                for char in a:\n                    b += char\n                    m[b] -= 2\n            else:\n                letters = string.ascii_lowercase\n                matched = False\n                while s != '' and (not matched):\n                    for l in letters:\n                        f = s + l\n                        if l != last_char and f in m and (m.get(f) > 0) and (m.get(f) % 2 != 0):\n                            s += l\n                            matched = not False\n                            break\n                    if not matched:\n                        local_count -= 1\n                        last_char = s[-1]\n                        s = s[:-1]\n                    else:\n                        while self.nChildrenPalindrome(s, m) % 2 == 1:\n                            for l in letters:\n                                f = s + l\n                                if f in m and m.get(f) > 0 and (m.get(f) % 2 != 0):\n                                    s += l\n                                    break\n                if len(s) != 0 or s != '':\n                    b = ''\n                    count += math.pow(local_count, 2)\n                    for char in a:\n                        b += char\n                        m[b] -= 1\n                    b = ''\n                    for char in s:\n                        b += char\n                        m[b] -= 1\n        return int(count)\n\n    def maxVerseNormal(self, A: list, time_init: float) -> int:\n        letters = string.ascii_lowercase\n        count = 0\n        (fs, m, u) = (dict(), dict(), dict())\n        for a in A:\n            (f, b) = ('', '')\n            for i in range(len(a)):\n                f += a[i]\n                b += a[len(a) - i - 1]\n                if f in fs:\n                    fs[f] += 1\n                else:\n                    fs[f] = 1\n                result = self.concatStr(f, '|', b)\n                if result in m:\n                    m[result] += 1\n                else:\n                    m[result] = 1\n            if a in u:\n                u[a] += 1\n            else:\n                u[a] = 1\n        t_final = time.time()\n        diff = abs(t_final - time_init)\n        if diff >= self.TIMEDIFF:\n            if abs(diff - self.TIMEDIFF) <= self.DELTA:\n                return self.maxVersePalindrome(A, True, fs)\n        for a in A:\n            if u[a] == 0:\n                continue\n            (f, b) = ('', '')\n            local_count = 0\n            for i in range(len(a)):\n                f += a[i]\n                b += a[len(a) - i - 1]\n                concat = self.concatStr(f, '|', b)\n                currCount = m.get(concat)\n                if currCount == 1:\n                    lastChar = f[-1] + '|' + b[-1]\n                    f = f[:-1]\n                    b = b[:-1]\n                    break\n                else:\n                    local_count += 1\n            if f == '' or b == '':\n                continue\n            elif local_count == len(a):\n                lastChar = 'Z'\n            if abs(m.get(self.concatStr(f, '|', b)) - self.nChildrenNormal(f, b, m, fs, letters)) >= 2:\n                (p, q) = ('', '')\n                for i in range(len(a)):\n                    p += a[i]\n                    q += a[len(a) - i - 1]\n                    m[self.concatStr(p, '|', q)] -= 2\n                u[a] -= 2\n                count += math.pow(local_count, 2)\n            else:\n                matched = not True\n                while not matched and (f != '' and b != ''):\n                    for l1 in letters:\n                        fw = f + l1\n                        if fw not in fs:\n                            continue\n                        for l2 in letters:\n                            s = self.concatStr(fw, '|', b, l2)\n                            if self.concatStr(l1, '|', l2) != lastChar and s in m and (m.get(s) % 2 != 0) and (m.get(s) > 0):\n                                (f, b) = (f + l1, b + l2)\n                                matched = True\n                                break\n                        if matched:\n                            break\n                    if not matched:\n                        lastChar = self.concatStr(f[-1], '|', b[-1])\n                        (f, b) = (f[:-1], b[:-1])\n                        local_count -= 1\n                    else:\n                        while self.nChildrenNormal(f, b, m, fs, letters) % 2 == 1:\n                            for l1 in letters:\n                                flag = False\n                                fw = f + l1\n                                if fw not in fs:\n                                    continue\n                                for l2 in letters:\n                                    bw = b + l2\n                                    s = self.concatStr(fw, '|', bw)\n                                    if s in m and m.get(s) % 2 != 0 and (m.get(s) > 0):\n                                        flag = True\n                                        (f, b) = (f + l1, b + l2)\n                                        break\n                                if flag:\n                                    break\n                if f != '' and b != '':\n                    u[a] -= 1\n                    u[f] -= 1\n                    count += math.pow(local_count, 2)\n                    (p, q) = ('', '')\n                    for i in range(len(a)):\n                        p += a[i]\n                        q += a[len(a) - i - 1]\n                        m[self.concatStr(p, '|', q)] -= 1\n                    (p, q) = ('', '')\n                    for i in range(len(f)):\n                        p += f[i]\n                        q += b[i]\n                        m[self.concatStr(p, '|', q)] -= 1\n        return int(count)\n\n    def nChildrenNormal(self, f: str, b: str, m: dict, fs: list, letters: str) -> int:\n        count = 0\n        for l1 in letters:\n            forward = f + l1\n            if forward not in fs:\n                continue\n            for l2 in letters:\n                lookfor = self.concatStr(forward, '|', b, l2)\n                if lookfor in m:\n                    count += m.get(lookfor)\n        return count\n\n    def isPal(self, s: str) -> bool:\n        return s == s[::-1]\n\n    def concatStr(self, *args) -> str:\n        s = ''\n        for arg in args:\n            s += arg\n        return s\n\n    def nChildrenPalindrome(self, s: str, m: dict) -> int:\n        letters = string.ascii_lowercase\n        count = 0\n        for l in letters:\n            search = s + l\n            if search in m:\n                count += m[search]\n        return count\n\n    def solve(self) -> None:\n        t = int(sys.stdin.readline())\n        t_init = time.time()\n        buffer_out = ''\n        for test_case in range(t):\n            pal = False\n            n_strings = int(sys.stdin.readline())\n            A = []\n            for _ in range(n_strings):\n                x = sys.stdin.readline().split()[0]\n                if not pal and (not self.isPal(x)):\n                    pal = True\n                A.append(x)\n            A = sorted(A)\n            if pal:\n                buffer_out += str(self.maxVerseNormal(A, t_init))\n                buffer_out += '\\n'\n            else:\n                buffer_out += str(self.maxVersePalindrome(A, False, {}))\n                buffer_out += '\\n'\n        sys.stdout.write(buffer_out)\ns = Solution()\ns.solve()", "class Node(object):\n\n    def __init__(self, cho: str):\n        self.cho = cho\n        self.childr = []\n        self.lev = 0\n        self.counter = set()\n\ndef addition(root, verb, i):\n    node = root\n    l = 0\n    for cho in verb:\n        l += 1\n        found = False\n        for child in node.childr:\n            if child.cho == cho:\n                child.counter.add(i)\n                node = child\n                found = True\n                break\n        if found == False:\n            ne = Node(cho)\n            node.childr.append(ne)\n            node.childr[-1].counter.add(i)\n            ne.lev = l\n            node = ne\n\ndef final(ilish, l, lor, mim):\n    sc = 0\n    ta = 0\n    i = ilish\n    while i > 0:\n        for j in l[i]:\n            for z in lor[i]:\n                op = j & z\n                cize = 0\n                for k in op:\n                    if mim[k] == 0:\n                        cize += 1\n                        ta = k\n                        mim[k] = 1\n                if cize % 2 == 0:\n                    sc = sc + cize / 2 * i ** 2\n                else:\n                    sc = sc + int(cize / 2) * i ** 2\n                    mim[ta] = 0\n        i = i - 1\n    return int(sc)\nfor i in range(int(input())):\n    st = []\n    n = int(input())\n    r1 = Node('$')\n    r2 = Node('$')\n    for j in range(n):\n        dws = input()\n        st.append(dws)\n        rev = st[-1]\n        addition(r2, rev[::-1], j)\n        addition(r1, rev, j)\n    lor = []\n    lor.append([])\n    q2 = []\n    q2 = [r2]\n    while len(q2) != 0:\n        node = q2[0]\n        q2.pop(0)\n        for i in node.childr:\n            cn = i.counter\n            if len(cn) >= 9 - 7:\n                if i.lev + 1 > len(lor):\n                    lor.append([])\n                lor[i.lev].append(cn)\n                q2.append(i)\n    q = [r1]\n    l = []\n    l.append([])\n    while len(q) > 0:\n        node = q[0]\n        q.pop(0)\n        for iny in node.childr:\n            cn2 = iny.counter\n            if len(cn2) >= 8 - 6:\n                if iny.lev + 1 > len(l):\n                    l.append([])\n                l[iny.lev].append(cn2)\n                q.append(iny)\n    ilish = min(len(l), len(lor)) - 1\n    mim = []\n    w = len(st)\n    for j in range(w):\n        mim.append(0)\n    answer = final(ilish, l, lor, mim)\n    print(answer)", "total = input()\ntotal = int(total)\nfor test in range(total):\n    wrd_ = []\n    my_dic = {}\n    hgt = 0\n    wrd_len = []\n    numb = input()\n    grp = {}\n    numb = int(numb)\n    for ind in range(numb):\n        wrd_.append(input())\n        wrd_len.append(len(wrd_[ind]))\n    mlen = max(wrd_len)\n    for index in range(len(wrd_)):\n        wrd_[index] = wrd_[index] + '`' * (mlen - len(wrd_[index]))\n    for ind in range(len(wrd_)):\n        grp[wrd_[ind], hgt] = 0\n    for p in range(mlen):\n        gp = 1\n        for it in range(len(wrd_)):\n            cnt = p\n            if my_dic.get((wrd_[it][p], wrd_[it][wrd_len[it] - p - 1], cnt, grp[wrd_[it], hgt])) != None:\n                my_dic[wrd_[it][p], wrd_[it][wrd_len[it] - p - 1], cnt, grp[wrd_[it], hgt]].append(wrd_[it])\n                grp[wrd_[it], hgt + 1] = grp[my_dic[wrd_[it][p], wrd_[it][wrd_len[it] - p - 1], cnt, grp[wrd_[it], hgt]][0], hgt + 1]\n            else:\n                my_dic[wrd_[it][p], wrd_[it][wrd_len[it] - p - 1], cnt, grp[wrd_[it], hgt]] = [wrd_[it]]\n                grp[wrd_[it], hgt + 1] = gp\n                gp += 1\n        hgt += 1\n    fin = {}\n    plus = []\n    for h in range(hgt, -1, -1):\n        new_d = {}\n        for idn in range(numb):\n            if fin.get((wrd_[idn], idn)) != None:\n                pass\n            elif new_d.get(grp[wrd_[idn], h]) != None:\n                plus.append(wrd_[idn])\n                fin[wrd_[idn], idn] = 1\n                plus.append(new_d[grp[wrd_[idn], h]][0][0])\n                fin[new_d[grp[wrd_[idn], h]][0]] = 1\n                del new_d[grp[wrd_[idn], h]]\n            else:\n                new_d[grp[wrd_[idn], h]] = [(wrd_[idn], idn)]\n    result = 0\n    for item in range(0, len(plus), 2):\n        str1 = plus[item].strip('`')\n        str2 = plus[item + 1].strip('`')\n        count = 0\n        mini = min(len(str1), len(str2))\n        for c in range(mini):\n            if str1[c] != str2[c] or str1[-(c + 1)] != str2[-(c + 1)]:\n                break\n            else:\n                count += 1\n        result = result + count ** 2\n    print(result)", "import sys\nfrom random import choice, randint\ninp = sys.stdin.readline\nout = sys.stdout.write\nflsh = sys.stdout.flush\nsys.setrecursionlimit(10 ** 9)\ninf = 10 ** 20\neps = 1.0 / 10 ** 10\nmod = 10 ** 9 + 7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\ndef MI():\n    return map(int, inp().strip().split())\n\ndef LI():\n    return list(map(int, inp().strip().split()))\n\ndef LLI():\n    return [list(map(int, l.split())) for l in sys.stdin.readlines().strip()]\n\ndef LI_():\n    return [int(x) - 1 for x in inp().strip().split()]\n\ndef LF():\n    return [float(x) for x in inp().strip().split()]\n\ndef LS():\n    return inp().strip().split()\n\ndef I():\n    return int(inp().strip())\n\ndef F():\n    return float(inp().strip())\n\ndef S():\n    return inp().strip()\n\ndef pf(s):\n    return out(s + '\\n')\n\ndef JA(a, sep):\n    return sep.join(map(str, a))\n\ndef JAA(a, s, t):\n    return s.join((t.join(map(str, b)) for b in a))\n\ndef main():\n    alphasize = 26\n\n    class TNode:\n\n        def __init__(self):\n            self.children = [None] * alphasize\n            self.l = []\n            self.isendofword = False\n\n    def chartoidx(ch):\n        return ord(ch) - ord('a')\n\n    def Pinsert(root, s, sidx):\n        ptemp = root\n        ln = len(s)\n        for i in range(ln):\n            idx = chartoidx(s[i])\n            if not ptemp.children[idx]:\n                ptemp.children[idx] = TNode()\n            ptemp = ptemp.children[idx]\n            ptemp.l.append(sidx)\n        ptemp.isendofword = True\n\n    def Sinsert(root, s, sidx):\n        stemp = root\n        ln = len(s)\n        for i in range(ln - 1, -1, -1):\n            idx = chartoidx(s[i])\n            if not stemp.children[idx]:\n                stemp.children[idx] = TNode()\n            stemp = stemp.children[idx]\n            stemp.l.append(sidx)\n        stemp.isendofword = True\n\n    def comb(d, ptr, deep, wordlist, ans, f):\n        n = len(ptr.l)\n        c = 0\n        for i in range(alphasize):\n            if ptr.children[i]:\n                c += 1\n        if c > 1 or (ptr.isendofword and len(ptr.l) > 1):\n            if n > 1000:\n                d = dict()\n                a = []\n                for j in range(len(wordlist)):\n                    w = wordlist[j]\n                    while len(w) > 0:\n                        if w not in d:\n                            d[w] = 1\n                        else:\n                            d[w] += 1\n                        if d[w] == 1:\n                            a.append(w)\n                        w = w[:-1]\n                        if len(w) < 1:\n                            break\n                a.sort()\n                res = 0\n                for j in range(len(a) - 1, -1, -1):\n                    if d[a[j]] > 1:\n                        res += len(a[j]) * len(a[j]) * (d[a[j]] // 2)\n                    red = d[a[j]] - d[a[j]] % 2\n                    nw = a[j]\n                    while len(nw) > 0:\n                        d[nw] -= red\n                        nw = nw[:-1]\n                        if len(nw) < 1:\n                            break\n                ans[0] = res\n                f[0] = 1\n                return\n            else:\n                for i in range(n):\n                    for j in range(i + 1, n):\n                        d[ptr.l[i], ptr.l[j]] = deep\n        for i in range(alphasize):\n            if ptr.children[i]:\n                comb(d, ptr.children[i], deep + 1, wordlist, ans, f)\n\n    def cmp(x, y):\n        return (x > y) - (x < y)\n\n    def compare(a, b):\n        if a[1][1] == b[1][1]:\n            if a[1][0] == b[1][0]:\n                return cmp(a[0], b[0])\n            else:\n                return cmp(a[1][0], b[1][0])\n        else:\n            return cmp(a[1][1], b[1][1])\n    from functools import cmp_to_key\n    import string\n    t = I()\n    l = []\n    for _ in range(t):\n        n = I()\n        (wordlist, ans, f) = ([], [0], [0])\n        for i in range(n):\n            w = S()\n            wordlist.append(w)\n        proot = TNode()\n        sroot = TNode()\n        for i in range(n):\n            Pinsert(proot, wordlist[i], i)\n        for i in range(n):\n            Sinsert(sroot, wordlist[i], i)\n        pred = dict()\n        sufd = dict()\n        for i in range(alphasize):\n            if proot.children[i]:\n                comb(pred, proot.children[i], 1, wordlist, ans, f)\n        if f[0] == 1:\n            l.append(ans[0])\n        else:\n            for i in range(alphasize):\n                if sroot.children[i]:\n                    comb(sufd, sroot.children[i], 1, wordlist, ans, f)\n            pairs = []\n            for i in pred:\n                if (i[0], i[1]) in sufd:\n                    d1 = min(pred[i], sufd[i[0], i[1]])\n                else:\n                    d1 = min(pred[i], 0)\n                pairs.append([i[0], [i[1], d1]])\n            pairs = sorted(pairs, key=cmp_to_key(compare))\n            vis = [0 for i in range(n)]\n            res = 0\n            for i in range(len(pairs) - 1, -1, -1):\n                if vis[pairs[i][0]] == False and vis[pairs[i][1][0]] == False:\n                    res += pairs[i][1][1] * pairs[i][1][1]\n                    vis[pairs[i][0]] = 1\n                    vis[pairs[i][1][0]] = 1\n            l.append(res)\n    for i in range(t):\n        pf(str(l[i]))\nmain()", "def ii():\n    return int(input())\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(mi())\n\ndef si():\n    return input()\nt1 = ii()\nwhile t1:\n    t1 -= 1\n    n = ii()\n    m = {}\n    ans = 0\n    m1 = {}\n    for i in range(n):\n        s = si()\n        if s not in m:\n            m[s] = 1\n        else:\n            m[s] += 1\n        m1[s] = 0\n    b = []\n    for i in m.keys():\n        if m[i] >= 2:\n            x = len(i)\n            ans += pow(x, 2) * (m[i] // 2)\n            if m[i] % 2:\n                b.append(i)\n        else:\n            b.append(i)\n    n1 = len(b)\n    x = []\n    for i in range(n1):\n        for j in range(n1):\n            if i != j:\n                c = 0\n                a1 = len(b[i]) - 1\n                a2 = len(b[j]) - 1\n                l = 0\n                t = min(a1, a2)\n                r = t\n                while l <= t and r >= 0 and (b[i][l] == b[j][l]) and (b[i][a1] == b[j][a2]):\n                    c += 1\n                    l += 1\n                    a1 -= 1\n                    a2 -= 1\n                    r -= 1\n                if c > 0:\n                    y = []\n                    y.append(c)\n                    y.append(b[i])\n                    y.append(b[j])\n                    x.append(y)\n    x.sort(reverse=True)\n    for i in range(len(x)):\n        c = x[i][0]\n        s1 = x[i][1]\n        s2 = x[i][2]\n        if m1[s1] == 0 and m1[s2] == 0:\n            ans += pow(c, 2)\n            m1[s1] = 1\n            m1[s2] = 1\n    print(ans)", "import math\nfrom itertools import *\nfrom collections import *\nfrom random import shuffle\n\ndef prefix(s1, s2):\n    c = 0\n    while True:\n        try:\n            if s1[c] != s2[c]:\n                break\n        except:\n            break\n        c += 1\n    return c\n\ndef idea(lis):\n    mylis = []\n    it = 0\n    comb = 0\n    for i in lis:\n        mylis.append([i, it])\n        it += 1\n    ready = []\n    for i in combinations(mylis, 2):\n        ready.append([min(prefix(i[0][0], i[1][0]), prefix(i[0][0][::-1], i[1][0][::-1])), [i[0][1], i[1][1]]])\n    ready.sort(key=lambda x: x[0])\n    ready = ready[::-1]\n    pure = set()\n    for i in ready:\n        if i[1][0] not in pure and i[1][1] not in pure:\n            pure.add(i[1][0])\n            pure.add(i[1][1])\n            comb += i[0] ** 2\n    return comb\nfor _ in range(int(input())):\n    checker = set()\n    n = int(input())\n    mlis = []\n    tot = 0\n    lis = []\n    for i in range(n):\n        s = input()\n        mlis.append(s)\n    for (i, j) in Counter(mlis).items():\n        if j == 1:\n            lis.append(i)\n        elif j % 2:\n            lis.append(i)\n            tot += len(i) ** 2 * (j // 2)\n        else:\n            tot += len(i) ** 2 * (j // 2)\n    alpha = defaultdict(list)\n    for i in lis:\n        alpha[i[0]].append(i)\n    for (i, j) in alpha.items():\n        sample = [k for k in j]\n        shuf = idea(sample)\n        tot += shuf\n    tot1 = tot\n    alpha = defaultdict(list)\n    tot = 0\n    for i in lis:\n        alpha[i[-1]].append(i)\n    for (i, j) in alpha.items():\n        sample = [k for k in j]\n        shuf = idea(sample)\n        tot += shuf\n    print(max(tot1, tot))", "def comp(s1, s2):\n    n1 = len(s1)\n    n2 = len(s2)\n    st = 0\n    count = 0\n    while st < n1 and st < n2 and (s1[st] == s2[st]) and (s1[n1 - st - 1] == s2[n2 - st - 1]):\n        count += 1\n        st += 1\n    return count\n\ndef count(arr):\n    n = len(arr)\n    d = {arr[i]: 0 for i in range(n)}\n    d_str = {}\n    for i in range(n):\n        if not d[arr[i]]:\n            d[arr[i]] += 1\n            for j in range(i + 1, n):\n                if d_str.get((arr[i], arr[j])) == None and d_str.get((arr[j], arr[i])) == None:\n                    val = comp(arr[i], arr[j]) ** 2\n                    d_str[arr[i], arr[j]] = val\n        else:\n            d[arr[i]] += 1\n    final = sorted(d_str.items(), key=lambda x: x[1], reverse=True)\n    val = 0\n    for pair in final:\n        if pair[1] == 0:\n            return val\n        a = pair[0][0]\n        b = pair[0][1]\n        if d[a] > 0 and d[b] > 0:\n            while d[a] > 0 and d[b] > 0:\n                d[a] -= 1\n                d[b] -= 1\n                found = 0\n                if d[a] >= 0 and d[b] >= 0:\n                    found = 1\n                    val += pair[1]\n                if not found:\n                    d[a] += 1\n                    d[b] += 1\n                    break\n    return val\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    lis = []\n    for i in range(n):\n        lis.append(input())\n    print(count(lis))", "for t in range(int(input())):\n    n = int(input())\n    li2 = []\n    for i in range(n):\n        li2 += [input()]\n    li3 = list(set(li2))\n    (ans, li) = (0, [])\n    for x in li3:\n        ct = li2.count(x)\n        if ct % 2 != 0:\n            li += [x]\n            ct -= 1\n        ans += ct // 2 * len(x) ** 2\n    li.sort()\n    (i, j) = (0, 1)\n    n = len(li)\n    while j < n:\n        while j < n and li[i][0] == li[j][0]:\n            j += 1\n        temp = li[i:j]\n        i = j\n        j += 1\n        nx = len(temp)\n        if nx > 2:\n            marr = []\n            for ii in range(1, nx):\n                x = temp[ii]\n                for jj in range(ii):\n                    y = temp[jj]\n                    l = min(len(y), len(x))\n                    ctr = 0\n                    while ctr < l and x[ctr] == y[ctr] and (x[-1 - ctr] == y[-1 - ctr]):\n                        ctr += 1\n                    if ctr != 0:\n                        marr += [[ctr, ii, jj]]\n            marr.sort(reverse=True)\n            done = [1 for ii in range(nx)]\n            val = 0\n            for itm in marr:\n                (x, ii, jj) = itm\n                if x == 0:\n                    break\n                if done[ii] and done[jj]:\n                    val += x ** 2\n                    done[ii] = 0\n                    done[jj] = 0\n            ans += val\n        elif nx == 2:\n            (x, y) = (temp[0], temp[1])\n            l = min(len(y), len(x))\n            ctr = 0\n            while ctr < l and x[ctr] == y[ctr] and (x[-1 - ctr] == y[-1 - ctr]):\n                ctr += 1\n            ans += ctr ** 2\n    print(ans)", "import string\nimport math\nimport time\nimport sys\nTIMEDIFF = 6.0\nDELTA = 0.5\n\ndef maxVersePalindrome(A: list, op: bool, d) -> int:\n    if not op:\n        m = dict()\n        for a in A:\n            s = ''\n            for char in a:\n                s += char\n                if s in m:\n                    m[s] += 1\n                else:\n                    m[s] = 1\n    else:\n        m = d\n    count = 0\n    for a in A:\n        local_count = 0\n        s = ''\n        if m.get(a) == 0:\n            continue\n        for i in range(len(a)):\n            s += a[i]\n            curr_count = m.get(s)\n            if curr_count == 1:\n                last_char = s[-1]\n                s = s[:-1]\n                break\n            else:\n                local_count += 1\n        if len(s) == 0:\n            continue\n        elif local_count == len(a):\n            last_char = 'Z'\n        if abs(m.get(s) - nChildrenPalindrome(s, m)) >= 2:\n            count += math.pow(local_count, 2)\n            b = ''\n            for char in a:\n                b += char\n                m[b] -= 2\n        else:\n            letters = string.ascii_lowercase\n            matched = False\n            while s != '' and (not matched):\n                for l in letters:\n                    f = s + l\n                    if l != last_char and f in m and (m.get(f) > 0) and (m.get(f) % 2 != 0):\n                        s += l\n                        matched = not False\n                        break\n                if not matched:\n                    local_count -= 1\n                    last_char = s[-1]\n                    s = s[:-1]\n                else:\n                    while nChildrenPalindrome(s, m) % 2 == 1:\n                        for l in letters:\n                            f = s + l\n                            if f in m and m.get(f) > 0 and (m.get(f) % 2 != 0):\n                                s += l\n                                break\n            if len(s) != 0 or s != '':\n                b = ''\n                count += math.pow(local_count, 2)\n                for char in a:\n                    b += char\n                    m[b] -= 1\n                b = ''\n                for char in s:\n                    b += char\n                    m[b] -= 1\n    return int(count)\n\ndef maxVerseNormal(A: list, time_init: float) -> int:\n    letters = string.ascii_lowercase\n    count = 0\n    (fs, m, u) = (dict(), dict(), dict())\n    for a in A:\n        (f, b) = ('', '')\n        for i in range(len(a)):\n            f += a[i]\n            b += a[len(a) - i - 1]\n            if f in fs:\n                fs[f] += 1\n            else:\n                fs[f] = 1\n            result = concatStr(f, '|', b)\n            if result in m:\n                m[result] += 1\n            else:\n                m[result] = 1\n        if a in u:\n            u[a] += 1\n        else:\n            u[a] = 1\n    t_final = time.time()\n    diff = abs(t_final - time_init)\n    if diff >= TIMEDIFF:\n        if abs(diff - TIMEDIFF) <= DELTA:\n            return maxVersePalindrome(A, True, fs)\n    for a in A:\n        if u[a] == 0:\n            continue\n        (f, b) = ('', '')\n        local_count = 0\n        for i in range(len(a)):\n            f += a[i]\n            b += a[len(a) - i - 1]\n            concat = concatStr(f, '|', b)\n            currCount = m.get(concat)\n            if currCount == 1:\n                lastChar = f[-1] + '|' + b[-1]\n                f = f[:-1]\n                b = b[:-1]\n                break\n            else:\n                local_count += 1\n        if f == '' or b == '':\n            continue\n        elif local_count == len(a):\n            lastChar = 'Z'\n        if abs(m.get(concatStr(f, '|', b)) - nChildrenNormal(f, b, m, fs, letters)) >= 2:\n            (p, q) = ('', '')\n            for i in range(len(a)):\n                p += a[i]\n                q += a[len(a) - i - 1]\n                m[concatStr(p, '|', q)] -= 2\n            u[a] -= 2\n            count += math.pow(local_count, 2)\n        else:\n            matched = not True\n            while not matched and (f != '' and b != ''):\n                for l1 in letters:\n                    fw = f + l1\n                    if fw not in fs:\n                        continue\n                    for l2 in letters:\n                        s = concatStr(fw, '|', b, l2)\n                        if concatStr(l1, '|', l2) != lastChar and s in m and (m.get(s) % 2 != 0) and (m.get(s) > 0):\n                            (f, b) = (f + l1, b + l2)\n                            matched = True\n                            break\n                    if matched:\n                        break\n                if not matched:\n                    lastChar = concatStr(f[-1], '|', b[-1])\n                    (f, b) = (f[:-1], b[:-1])\n                    local_count -= 1\n                else:\n                    while nChildrenNormal(f, b, m, fs, letters) % 2 == 1:\n                        for l1 in letters:\n                            flag = False\n                            fw = f + l1\n                            if fw not in fs:\n                                continue\n                            for l2 in letters:\n                                bw = b + l2\n                                s = concatStr(fw, '|', bw)\n                                if s in m and m.get(s) % 2 != 0 and (m.get(s) > 0):\n                                    flag = True\n                                    (f, b) = (f + l1, b + l2)\n                                    break\n                            if flag:\n                                break\n            if f != '' and b != '':\n                u[a] -= 1\n                u[f] -= 1\n                count += math.pow(local_count, 2)\n                (p, q) = ('', '')\n                for i in range(len(a)):\n                    p += a[i]\n                    q += a[len(a) - i - 1]\n                    m[concatStr(p, '|', q)] -= 1\n                (p, q) = ('', '')\n                for i in range(len(f)):\n                    p += f[i]\n                    q += b[i]\n                    m[concatStr(p, '|', q)] -= 1\n    return int(count)\n\ndef nChildrenNormal(f: str, b: str, m: dict, fs: list, letters: str) -> int:\n    count = 0\n    for l1 in letters:\n        forward = f + l1\n        if forward not in fs:\n            continue\n        for l2 in letters:\n            lookfor = concatStr(forward, '|', b, l2)\n            if lookfor in m:\n                count += m.get(lookfor)\n    return count\n\ndef isPal(s: str) -> bool:\n    return s == s[::-1]\n\ndef concatStr(*args) -> str:\n    s = ''\n    for arg in args:\n        s += arg\n    return s\n\ndef nChildrenPalindrome(s: str, m: dict) -> int:\n    letters = string.ascii_lowercase\n    count = 0\n    for l in letters:\n        search = s + l\n        if search in m:\n            count += m[search]\n    return count\nt = int(sys.stdin.readline())\nt_init = time.time()\nbuffer_out = ''\nfor test_case in range(t):\n    pal = False\n    n_strings = int(sys.stdin.readline())\n    A = []\n    for _ in range(n_strings):\n        x = sys.stdin.readline().split()[0]\n        if not pal and (not isPal(x)):\n            pal = True\n        A.append(x)\n    A = sorted(A)\n    if pal:\n        buffer_out += str(maxVerseNormal(A, t_init))\n        buffer_out += '\\n'\n    else:\n        buffer_out += str(maxVersePalindrome(A, False, {}))\n        buffer_out += '\\n'\nsys.stdout.write(buffer_out)", "import operator\nt = input()\nt = int(t)\nfor test_cases in [i for i in list(range(t))]:\n    n = int(input())\n    the_given_strings = []\n    for i in range(n):\n        the_given_strings.append(input())\n    to_remove_common_elements = {}\n    for i in the_given_strings:\n        if to_remove_common_elements.get(i) != None:\n            to_remove_common_elements[i] += 1\n        else:\n            to_remove_common_elements[i] = 1\n    final_result = 0\n    the_given_strings = []\n    for (i, j) in to_remove_common_elements.items():\n        if j >= 2:\n            temp = i\n            temp2 = j // 2\n            if j - 2 * temp2 != 0:\n                the_given_strings.append(i)\n            final_result += pow(len(temp), 2) * temp2\n        else:\n            the_given_strings.append(i)\n    number = len(the_given_strings)\n    temporary_array = []\n    for i in range(number):\n        for j in range(number):\n            if i != j:\n                string1 = the_given_strings[i]\n                string2 = the_given_strings[j]\n                len_string1 = len(the_given_strings[i])\n                len_string2 = len(the_given_strings[j])\n                upto = min(len_string1, len_string2)\n                end = -1\n                start = 0\n                inner_cnt = 0\n                while start < upto and end >= -upto and (string1[start] == string2[start]) and (string1[end] == string2[end]):\n                    inner_cnt += 1\n                    start += 1\n                    end -= 1\n                if inner_cnt == 0:\n                    pass\n                else:\n                    temporary_array.append((inner_cnt, the_given_strings[i], the_given_strings[j]))\n    temporary_array = sorted(temporary_array, key=operator.itemgetter(0), reverse=True)\n    final_dictionary = dict()\n    for item in temporary_array:\n        if final_dictionary.get(item[1]) == None:\n            if final_dictionary.get(item[2]) == None:\n                final_result += pow(item[0], 2)\n                final_dictionary[item[1]] = 1\n                final_dictionary[item[2]] = 1\n    print(final_result)", "t = int(input())\nfor t in range(t):\n    for i in range(1000):\n        continue\n    times = int(input())\n    p = []\n    for i in range(times):\n        p.append(input().strip())\n    vect = [False] * times\n    p.sort()\n    rt = 0\n    left = 0\n    while left < times - 1:\n        if p[left] == p[left + 1]:\n            lq = len(p[left])\n            rt += lq ** 2\n            vect[left] = True\n            left += 1\n            vect[left] = True\n        left += 1\n    tm = {}\n    for it in range(times):\n        if vect[it]:\n            continue\n        pehle = ''\n        baad = ''\n        wt = p[it]\n        por = len(wt)\n        trr = por - 1\n        ytl = 0\n        while ytl < por and trr >= 0:\n            pehle += wt[ytl]\n            baad = wt[trr] + baad\n            te = (pehle, baad, len(pehle))\n            if te in tm:\n                tm[te].append([len(pehle), it])\n            else:\n                tm[te] = [[len(pehle), it]]\n            ytl += 1\n            trr -= 1\n    cess = [rq for (nw, rq) in sorted(tm.items(), key=lambda item: item[1][0], reverse=True)]\n    for y in cess:\n        if len(y) <= 1:\n            continue\n        else:\n            nt = 0\n            rta = []\n            for i in y:\n                if vect[i[1]]:\n                    continue\n                else:\n                    nt += 1\n                    rta.append(i[1])\n            if nt > 1:\n                rt += y[0][0] ** 2 * (nt // 2)\n                if nt % 2 == 1:\n                    for i in range(len(rta) - 1):\n                        vect[rta[i]] = True\n                else:\n                    for i in rta:\n                        vect[i] = True\n    print(rt)", "import sys\nimport time\nALPHA = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n\ndef n_after2(string, d):\n    n = 0\n    for i in ALPHA:\n        search = string + i\n        if search in d:\n            n += d[search]\n    return n\n\ndef give_result2(arr):\n    res = 0\n    d = {}\n    for ele in arr:\n        string = ''\n        for char in ele:\n            string += char\n            if string in d:\n                d[string] += 1\n            else:\n                d[string] = 1\n    for ele in arr:\n        if d[ele] == 0:\n            continue\n        string = ''\n        c = 0\n        for x in range(len(ele)):\n            string += ele[x]\n            cnt = d[string]\n            if cnt == 1:\n                prev = string[-1]\n                string = string[:-1]\n                break\n            c += 1\n        if c == len(ele):\n            prev = '$'\n        if string == '':\n            res += 0\n            continue\n        if d[string] - n_after2(string, d) >= 2:\n            res += c ** 2\n            s = ''\n            for char in ele:\n                s += char\n                d[s] -= 2\n        else:\n            f = False\n            while string != '' and (not f):\n                for i in ALPHA:\n                    char = i\n                    s = string + char\n                    if char != prev and s in d and (d[s] > 0) and (d[s] % 2 != 0):\n                        string += char\n                        f = True\n                        break\n                if not f:\n                    c -= 1\n                    prev = string[-1]\n                    string = string[:-1]\n                else:\n                    while n_after2(string, d) % 2 == 1:\n                        for i in ALPHA:\n                            char = i\n                            s = string + char\n                            if s in d and d[s] > 0 and (d[s] % 2 != 0):\n                                string += char\n                                break\n            if string != '':\n                s = ''\n                for char in ele:\n                    s += char\n                    d[s] -= 1\n                s = ''\n                for char in string:\n                    s += char\n                    d[s] -= 1\n                res += c ** 2\n            else:\n                res += 0\n    return res\n\ndef give_result3(arr, f_strings):\n    res = 0\n    d = f_strings\n    for ele in arr:\n        if d[ele] == 0:\n            continue\n        string = ''\n        c = 0\n        for x in range(len(ele)):\n            string += ele[x]\n            cnt = d[string]\n            if cnt == 1:\n                prev = string[-1]\n                string = string[:-1]\n                break\n            c += 1\n        if c == len(ele):\n            prev = '$'\n        if string == '':\n            res += 0\n            continue\n        if d[string] - n_after2(string, d) >= 2:\n            res += c ** 2\n            s = ''\n            for char in ele:\n                s += char\n                d[s] -= 2\n        else:\n            f = False\n            while string != '' and (not f):\n                for i in ALPHA:\n                    char = i\n                    s = string + char\n                    if char != prev and s in d and (d[s] > 0) and (d[s] % 2 != 0):\n                        string += char\n                        f = True\n                        break\n                if not f:\n                    c -= 1\n                    prev = string[-1]\n                    string = string[:-1]\n                else:\n                    while n_after2(string, d) % 2 == 1:\n                        for i in ALPHA:\n                            char = i\n                            s = string + char\n                            if s in d and d[s] > 0 and (d[s] % 2 != 0):\n                                string += char\n                                break\n            if string != '':\n                s = ''\n                for char in ele:\n                    s += char\n                    d[s] -= 1\n                s = ''\n                for char in string:\n                    s += char\n                    d[s] -= 1\n                res += c ** 2\n            else:\n                res += 0\n    return res\n\ndef n_after(fw_string, bw_string, d, f_strings):\n    n = 0\n    for i in ALPHA:\n        s1 = fw_string + i\n        if s1 not in f_strings:\n            continue\n        for j in ALPHA:\n            search = ''.join([s1, ':', bw_string, j])\n            if search in d:\n                n += d[search]\n    return n\n\ndef give_result(arr, t0):\n    res = 0\n    d = {}\n    d2 = {}\n    f_strings = {}\n    used = {}\n    for ele in arr:\n        if ele in used:\n            used[ele] += 1\n        else:\n            used[ele] = 1\n        fw_string = ''\n        bw_string = ''\n        for x in range(len(ele)):\n            fw_string += ele[x]\n            bw_string += ele[len(ele) - x - 1]\n            if fw_string in f_strings:\n                f_strings[fw_string] += 1\n            else:\n                f_strings[fw_string] = 1\n            rez = ':'.join([fw_string, bw_string])\n            if rez in d:\n                d[rez] += 1\n            else:\n                d[rez] = 1\n    t1 = time.time()\n    if t1 - t0 >= 6.0 and t1 - t0 <= 6.5:\n        return give_result3(arr, f_strings)\n    for ele in arr:\n        if used[ele] == 0:\n            continue\n        fw_string = ''\n        bw_string = ''\n        c = 0\n        for x in range(len(ele)):\n            fw_string += ele[x]\n            bw_string += ele[len(ele) - x - 1]\n            cnt = d[fw_string + ':' + bw_string]\n            if cnt == 1:\n                prev = fw_string[-1] + ':' + bw_string[-1]\n                fw_string = fw_string[:-1]\n                bw_string = bw_string[:-1]\n                break\n            c += 1\n        if c == len(ele):\n            prev = '$'\n        if len(fw_string) == 0 or len(bw_string) == 0:\n            res += 0\n            continue\n        if d[fw_string + ':' + bw_string] - n_after(fw_string, bw_string, d, f_strings) >= 2:\n            res += c ** 2\n            s = ''\n            r = ''\n            for x in range(len(ele)):\n                s += ele[x]\n                r += ele[len(ele) - x - 1]\n                d[s + ':' + r] -= 2\n            used[ele] -= 2\n        else:\n            f = False\n            while (len(fw_string) != 0 and len(bw_string) != 0) and (not f):\n                for i in ALPHA:\n                    fw_char = i\n                    s1 = fw_string + fw_char\n                    if s1 not in f_strings:\n                        continue\n                    for j in ALPHA:\n                        bw_char = j\n                        s = ''.join([s1, ':', bw_string, bw_char])\n                        if fw_char + ':' + bw_char != prev and s in d and (d[s] > 0) and (d[s] % 2 != 0):\n                            fw_string += fw_char\n                            bw_string += bw_char\n                            f = True\n                            break\n                    if f:\n                        break\n                if not f:\n                    c -= 1\n                    prev = ''.join([fw_string[-1], ':', bw_string[-1]])\n                    fw_string = fw_string[:-1]\n                    bw_string = bw_string[:-1]\n                else:\n                    while n_after(fw_string, bw_string, d, f_strings) % 2 == 1:\n                        for i in ALPHA:\n                            fw_char = i\n                            s1 = fw_string + fw_char\n                            if s1 not in f_strings:\n                                continue\n                            for j in ALPHA:\n                                flg = False\n                                bw_char = j\n                                s = ''.join([s1, ':', bw_string, bw_char])\n                                if s in d and d[s] > 0 and (d[s] % 2 != 0):\n                                    fw_string += fw_char\n                                    bw_string += bw_char\n                                    flg = True\n                                    break\n                            if flg:\n                                break\n            if fw_string + ':' + bw_string != ':':\n                s = ''\n                r = ''\n                for x in range(len(ele)):\n                    s += ele[x]\n                    r += ele[len(ele) - x - 1]\n                    d[s + ':' + r] -= 1\n                s = ''\n                r = ''\n                for x in range(len(fw_string)):\n                    s += fw_string[x]\n                    r += bw_string[x]\n                    d[s + ':' + r] -= 1\n                res += c ** 2\n                used[ele] -= 1\n                used[fw_string] -= 1\n            else:\n                res += 0\n    return res\nt0 = time.time()\nt = int(sys.stdin.readline())\nres = ''\nfor _ in range(t):\n    n = int(sys.stdin.readline())\n    flag = False\n    strings = []\n    lens = 0\n    npal = 0\n    for i in range(n):\n        s = sys.stdin.readline()[:-1]\n        lens += len(s)\n        if s != s[::-1]:\n            flag = True\n        else:\n            npal += 1\n        strings.append(s)\n    strings.sort()\n    if flag:\n        res += str(give_result(strings, t0)) + '\\n'\n    else:\n        res += str(give_result2(strings)) + '\\n'\nsys.stdout.write(res)", "def commonpref(a, k):\n    c = 0\n    for i in range(k):\n        if a[0][i] != a[1][i]:\n            break\n        c += 1\n    return c\nT = int(input())\nwhile T > 0:\n    N = int(input())\n    c = 0\n    ai = []\n    a = []\n    for i in range(N):\n        h = input()\n        ai.append(h)\n    ex = []\n    di = {}\n    for i in range(N):\n        if ai[i] not in di.keys():\n            di[ai[i]] = 1\n        else:\n            di[ai[i]] += 1\n    for i in range(N):\n        cn = di[ai[i]]\n        if cn > 1 and cn % 2 == 0:\n            if ai[i] not in ex:\n                num = len(ai[i]) * len(ai[i])\n                c += num * int(cn / 2)\n                ex.append(ai[i])\n        elif ai[i] in a and (cn > 1 and cn % 2 != 0):\n            bn = int(cn / 2)\n            if ai[i] not in ex:\n                num = len(ai[i]) * len(ai[i])\n                c += num * bn\n                ex.append(ai[i])\n        else:\n            a.append(ai[i])\n    keep = []\n    ni = len(a)\n    if ni > 1:\n        for i in range(ni):\n            for j in range(i, ni):\n                k = min(len(a[i]), len(a[j]))\n                if j != i and a[i] == a[j]:\n                    num = len(a[i]) * len(a[j])\n                    keep.append([[i, j], num])\n                elif j != i and (a[i][0] == a[j][0] and a[i][-1] != a[j][-1]):\n                    keep.append([[i, j], 0])\n                elif j != i and (a[i][0] != a[j][0] and a[i][-1] == a[j][-1]):\n                    keep.append([[i, j], 0])\n                elif j != i and (a[i][0] == a[j][0] and a[i][-1] == a[j][-1]):\n                    ri = a[i][::-1]\n                    rj = a[j][::-1]\n                    if a[i] == ri and a[j] == rj:\n                        f = commonpref([a[i], a[j]], k)\n                        num = f * f\n                        keep.append([[i, j], num])\n                    else:\n                        f = commonpref([a[i], a[j]], k)\n                        g = commonpref([ri, rj], f)\n                        num = g * g\n                        keep.append([[i, j], num])\n    k1 = sorted(keep, key=lambda x: x[1], reverse=True)\n    k3 = []\n    for i in range(len(k1)):\n        if k1[i][0][0] not in k3 and k1[i][0][1] not in k3:\n            c += k1[i][1]\n            k3.append(k1[i][0][0])\n            k3.append(k1[i][0][1])\n    print(c)\n    T -= 1", "def match(s1, s2):\n    (c1, c2) = (0, 0)\n    for i in range(min(len(s1), len(s2))):\n        if s1[i] != s2[i]:\n            break\n        else:\n            c1 += 1\n    s1 = s1[::-1]\n    s2 = s2[::-1]\n    for i in range(min(len(s1), len(s2))):\n        if s1[i] != s2[i]:\n            break\n        else:\n            c2 += 1\n    return min(c1, c2) ** 2\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    counter = 0\n    d = dict()\n    for j in range(n):\n        string = input()\n        m = len(string)\n        (pre, suf) = ('', '')\n        for i in range(0, m):\n            pre = pre + string[i]\n            suf = string[m - 1 - i] + suf\n            x = (pre, suf, i + 1)\n            if x in d:\n                d[x].append([i + 1, j])\n            else:\n                d[x] = [[i + 1, j]]\n    l = [i for (key, i) in sorted(d.items(), key=lambda x: x[1][0], reverse=True)]\n    c = [False for i in range(n)]\n    for i in l:\n        if len(i) <= 1:\n            continue\n        leng = i[0][0]\n        ind = 0\n        inc = 0\n        flag = 0\n        incl = []\n        for j in i:\n            if c[j[1]] == False:\n                inc += 1\n                incl.append(j[1])\n        if inc % 2 != 0:\n            del incl[-1]\n            inc -= 1\n        for j in incl:\n            c[j] = True\n        inc = int(inc / 2)\n        counter += inc * leng ** 2\n    print(counter)", "from sys import stdin\nfrom collections import defaultdict, OrderedDict\nt = int(stdin.readline())\nfor i in range(t):\n    w = int(stdin.readline())\n    arr = defaultdict(int)\n    for j in range(w):\n        word = str(stdin.readline()).rstrip()\n        arr[word] = arr[word] + 1\n    result = 0\n    word_list = []\n    for (word, count) in arr.items():\n        if count > 1:\n            pair_count = int(count / 2)\n            result = result + len(word) ** 2 * pair_count\n            if pair_count * 2 == count:\n                continue\n        word_list.append(word)\n    n_word = len(word_list)\n    distinct_pair = {}\n    for x in range(n_word):\n        for y in range(x + 1, n_word):\n            max_l = min(len(word_list[x]), len(word_list[y]))\n            common = 0\n            for z in range(max_l):\n                neg_z = z * -1 - 1\n                if word_list[x][z] != word_list[y][z] or word_list[x][neg_z] != word_list[y][neg_z]:\n                    break\n                common = common + 1\n            if common:\n                distinct_pair[x, y] = common ** 2\n    sorted_dict = OrderedDict(sorted(distinct_pair.items(), key=lambda item: item[1], reverse=True))\n    include_list = []\n    for (k, v) in sorted_dict.items():\n        if k[0] in include_list or k[1] in include_list:\n            continue\n        result += v\n        include_list.append(k[0])\n        include_list.append(k[1])\n    print(result)", "from sys import stdin\n\nclass Node:\n\n    def __init__(self, height, chr):\n        self.height = height\n        self.chr = chr\n        self.link = {}\n        self.branch = 0\n\ndef solve(N, W):\n    root = Node(0, '#')\n    temp = root\n    (h, p, rem) = (None, None, None)\n    cnz = 0\n    prefix = {}\n    for i in range(N):\n        w = W[i]\n        idn = i + 1\n        temp = root\n        for j in range(len(w)):\n            s = w[j]\n            if s not in temp.link:\n                h = Node(temp.height + 1, s)\n                temp.link[s] = h\n                temp = h\n                cnz += 1\n                temp.branch = cnz\n            else:\n                temp = temp.link[s]\n            if temp.height not in prefix:\n                prefix[temp.height] = {}\n            p = prefix[temp.height]\n            s = s + str(temp.branch)\n            if s in p:\n                p[s].add(idn)\n            else:\n                p[s] = {idn}\n    suffix = {}\n    roots = Node(0, '#s')\n    temp = roots\n    for i in range(N):\n        w = W[i]\n        idn = i + 1\n        temp = roots\n        for j in range(len(w) - 1, -1, -1):\n            s = w[j]\n            if s not in temp.link:\n                h = Node(temp.height + 1, s)\n                temp.link[s] = h\n                temp = h\n                cnz += 1\n                temp.branch = cnz\n            else:\n                temp = temp.link[s]\n            if temp.height not in suffix:\n                suffix[temp.height] = {}\n            p = suffix[temp.height]\n            s = s + str(temp.branch)\n            if s in p:\n                p[s].add(idn)\n            else:\n                p[s] = {idn}\n    suffix_m = {}\n    for num in suffix.keys():\n        mp = suffix_m[num] = {}\n        for ky in suffix[num].keys():\n            for p in suffix[num][ky]:\n                mp[p] = ky\n    h = list(prefix.keys())\n    h.sort(reverse=True)\n    done = set()\n    ans = 0\n    for num in h:\n        for ky in prefix[num].keys():\n            g = {}\n            for p in prefix[num][ky]:\n                if p in done:\n                    continue\n                if suffix_m[num][p] in g:\n                    ans += num ** 2\n                    done.add(p)\n                    done.add(g[suffix_m[num][p]])\n                    del g[suffix_m[num][p]]\n                else:\n                    g[suffix_m[num][p]] = p\n    print(ans)\n\ndef main():\n    inp = stdin.readline\n    for _ in range(int(inp())):\n        N = int(inp())\n        W = [inp().strip() for i in range(N)]\n        solve(N, W)\nmain()", "from collections import Counter\nfrom collections import defaultdict\nimport math\nimport random\nimport heapq as hq\nfrom math import sqrt\nimport sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef iinput():\n    return int(input())\n\ndef tinput():\n    return input().split()\n\ndef rinput():\n    return map(int, tinput())\n\ndef rlinput():\n    return list(rinput())\nmod = int(1000000000.0) + 7\n\ndef match_prefix(s1, s2):\n    prefix = 0\n    (i, j) = (0, 0)\n    while i < len(s1) and j < len(s2):\n        if s1[i] == s2[j]:\n            i += 1\n            j += 1\n            prefix += 1\n        else:\n            break\n    return prefix * prefix\n\ndef match_suffix(s1, s2):\n    suffix = 0\n    (i, j) = (len(s1) - 1, len(s2) - 1)\n    while i >= 0 and j >= 0:\n        if s1[i] == s2[j]:\n            i -= 1\n            j -= 1\n            suffix += 1\n        else:\n            break\n    return suffix * suffix\nfor _ in range(iinput()):\n    n = iinput()\n    a = []\n    d = defaultdict(int)\n    for i in range(n):\n        a.append(input())\n        d[a[i]] += 1\n    result = 0\n    for i in d:\n        result += len(i) * len(i) * (d[i] // 2)\n        d[i] = d[i] % 2\n    a = []\n    for i in d:\n        if d[i] != 0:\n            a.append(i)\n    a.sort()\n    while len(a) > 1:\n        (best_s1, best_s2) = ('', '')\n        mx = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                s1 = a[i]\n                s2 = a[j]\n                prefix = match_prefix(s1, s2)\n                suffix = match_suffix(s1, s2)\n                if prefix == 0 and suffix == 0:\n                    break\n                ans = min(prefix, suffix)\n                if mx <= ans:\n                    mx = ans\n                    best_s1 = s1\n                    best_s2 = s2\n        result += mx\n        if mx == 0:\n            break\n        if best_s1 in d:\n            d.pop(best_s1)\n            a.remove(best_s1)\n        if best_s2 in d:\n            d.pop(best_s2)\n            a.remove(best_s2)\n    print(result)", "for _ in range(int(input())):\n    n = int(input())\n    jode = []\n    for i in range(n):\n        jode.append(input().strip())\n    check = [False] * n\n    jode.sort()\n    ans = 0\n    lii = 0\n    while lii < n - 1:\n        if jode[lii] == jode[lii + 1]:\n            ans += len(jode[lii]) ** 2\n            check[lii] = True\n            check[lii + 1] = True\n            lii += 1\n        lii += 1\n    mt = {}\n    for i in range(100):\n        continue\n    for t in range(n):\n        if check[t]:\n            continue\n        wt = jode[t]\n        wor = len(wt)\n        l = 0\n        r = wor - 1\n        prefix = ''\n        sufix = ''\n        while l < wor and r >= 0:\n            prefix += wt[l]\n            sufix = wt[r] + sufix\n            temp = (prefix, sufix, len(prefix))\n            if temp in mt:\n                mt[temp].append([len(prefix), t])\n            else:\n                mt[temp] = [[len(prefix), t]]\n            l += 1\n            r -= 1\n    process = [zen for (ken, zen) in sorted(mt.items(), key=lambda item: item[1][0], reverse=True)]\n    for x in process:\n        if len(x) <= 1:\n            continue\n        else:\n            count = 0\n            a = []\n            for i in x:\n                if check[i[1]]:\n                    continue\n                else:\n                    count += 1\n                    a.append(i[1])\n            if count >= 2:\n                ans += x[0][0] ** 2 * (count // 2)\n                if count % 2 == 0:\n                    for i in a:\n                        check[i] = True\n                else:\n                    for i in range(len(a) - 1):\n                        check[a[i]] = True\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    alc = [0] * n\n    st = []\n    dict = {}\n    for i in range(n):\n        st.append(input().strip())\n    st.sort()\n    ans = 0\n    i = 0\n    lst = []\n    while i < n - 1:\n        if st[i] == st[i + 1]:\n            ans += len(st[i]) ** 2\n            alc[i] = 1\n            alc[i + 1] = 1\n            i += 1\n        i += 1\n    for i in range(n):\n        if alc[i]:\n            alc[i] = 1\n        else:\n            alc[i] = 0\n    for i in range(n):\n        if alc[i]:\n            continue\n        word = st[i]\n        w = len(word)\n        l = 0\n        r = w - 1\n        pre = ''\n        suf = ''\n        while l < w and r >= 0:\n            pre += word[l]\n            suf = word[r] + suf\n            ls = (pre, suf, len(pre))\n            if ls in dict:\n                dict[ls].append([len(pre), i])\n            else:\n                dict[ls] = [[len(pre), i]]\n            l += 1\n            r -= 1\n    a = [v for (j, v) in sorted(dict.items(), reverse=True)]\n    for i in a:\n        if len(i) <= 1:\n            continue\n        else:\n            d = []\n            b = 0\n            for j in i:\n                if alc[j[1]]:\n                    continue\n                else:\n                    b += 1\n                    d.append(j[1])\n            if b >= 2:\n                ans += i[0][0] ** 2 * (b // 2)\n                if b % 2 == 0:\n                    for j in d:\n                        alc[j] = 1\n                else:\n                    for j in range(len(d) - 1):\n                        alc[d[j]] = 1\n    print(ans)", "import heapq\n\ndef stanza_beauty(wd1, wd2):\n    L = min(len(wd1), len(wd2))\n    for i in range(L):\n        if wd1[i] != wd2[i] or wd1[-i - 1] != wd2[-i - 1]:\n            return i * i\n    return L * L\n\ndef transform(wd):\n    return ''.join((''.join((a, b)) for (a, b) in zip(wd, reversed(wd))))\n\ndef solve(N, words):\n    words = sorted(words, key=transform)\n    nxt = [None for _ in range(N)]\n    prv = [None for _ in range(N)]\n    stanzas = []\n    for i in range(N - 1):\n        wd1 = words[i]\n        j = i + 1\n        wd2 = words[j]\n        b = stanza_beauty(wd1, wd2)\n        nxt[i] = j\n        prv[j] = i\n        if b > 0:\n            heapq.heappush(stanzas, (-b, i, j))\n    solution = 0\n    taken = [False for _ in range(N)]\n    while stanzas:\n        (weight, i, j) = heapq.heappop(stanzas)\n        if taken[i] or taken[j]:\n            continue\n        taken[i] = taken[j] = True\n        solution += -weight\n        p = prv[i]\n        n = nxt[j]\n        if p is None or n is None:\n            continue\n        if p == n:\n            continue\n        nxt[p] = n\n        prv[n] = p\n        wd1 = words[p]\n        wd2 = words[n]\n        b = stanza_beauty(wd1, wd2)\n        if b > 0:\n            heapq.heappush(stanzas, (-b, p, n))\n    return solution\n\ndef main():\n    import sys\n    T = int(sys.stdin.readline())\n    for _ in range(T):\n        N = int(sys.stdin.readline())\n        words = []\n        for _ in range(N):\n            words.append(sys.stdin.readline().strip())\n        print(solve(N, words))\nmain()", "for _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input().strip())\n    done = [False] * n\n    words.sort()\n    i = 0\n    res = 0\n    lst = []\n    while i < n - 1:\n        if words[i] == words[i + 1]:\n            res += len(words[i]) ** 2\n            done[i] = True\n            done[i + 1] = True\n            i += 1\n        i += 1\n    mapp = {}\n    for i in range(n):\n        if done[i]:\n            continue\n        word = words[i]\n        w = len(word)\n        l = 0\n        r = w - 1\n        pre = ''\n        suf = ''\n        while l < w and r >= 0:\n            pre += word[l]\n            suf = word[r] + suf\n            ls = (pre, suf, len(pre))\n            if ls in mapp:\n                mapp[ls].append([len(pre), i])\n            else:\n                mapp[ls] = [[len(pre), i]]\n            l += 1\n            r -= 1\n    op = [v for (k, v) in sorted(mapp.items(), key=lambda item: item[1][0], reverse=True)]\n    for i in op:\n        if len(i) <= 1:\n            continue\n        else:\n            cnt = 0\n            ld = []\n            for k in i:\n                if done[k[1]]:\n                    continue\n                else:\n                    cnt += 1\n                    ld.append(k[1])\n            if cnt >= 2:\n                res += i[0][0] ** 2 * (cnt // 2)\n                if cnt % 2 == 0:\n                    for k in ld:\n                        done[k] = True\n                else:\n                    for k in range(len(ld) - 1):\n                        done[ld[k]] = True\n    print(res)", "import copy\nimport sys\nfrom collections import Counter\n\ndef fun(val):\n    return\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input().strip())\n    done = [False] * n\n    words.sort()\n    i = 0\n    res = 0\n    lst = []\n    while i < n - 1:\n        if words[i] == words[i + 1]:\n            res += len(words[i]) ** 2\n            done[i] = True\n            done[i + 1] = True\n            i += 1\n        i += 1\n    mapp = {}\n    for i in range(n):\n        if done[i]:\n            continue\n        word = words[i]\n        w = len(word)\n        l = 0\n        r = w - 1\n        pre = ''\n        suf = ''\n        while l < w and r >= 0:\n            pre += word[l]\n            suf = word[r] + suf\n            ls = (pre, suf, len(pre))\n            if ls in mapp:\n                mapp[ls].append([len(pre), i])\n            else:\n                mapp[ls] = [[len(pre), i]]\n            l += 1\n            r -= 1\n    op = [v for (k, v) in sorted(mapp.items(), key=lambda item: item[1][0], reverse=True)]\n    for i in op:\n        if len(i) <= 1:\n            continue\n        else:\n            cnt = 0\n            ld = []\n            for k in i:\n                if done[k[1]]:\n                    continue\n                else:\n                    cnt += 1\n                    ld.append(k[1])\n            if cnt >= 2:\n                res += i[0][0] ** 2 * (cnt // 2)\n                if cnt % 2 == 0:\n                    for k in ld:\n                        done[k] = True\n                else:\n                    for k in range(len(ld) - 1):\n                        done[ld[k]] = True\n    print(res)", "import heapq\n\ndef prefixSuffix(s1, s2):\n    if s1 == s2:\n        return len(s1)\n    if s1[len(s1) - 1] != s2[len(s2) - 1]:\n        return 0\n    pref = 1\n    for i in range(1, min(len(s1), len(s2))):\n        if s1[i] == s2[i] and s1[len(s1) - 1 - i] == s2[len(s2) - 1 - i]:\n            pref += 1\n        else:\n            break\n    return pref\n\ndef verse(arr):\n    x = []\n    l = 0\n    visited = [False] * len(arr)\n    arr.sort()\n    for i in range(len(arr) - 1):\n        for j in range(i + 1, len(arr)):\n            if arr[i][0] != arr[j][0]:\n                break\n            if arr[i][len(arr[i]) - 1] != arr[j][len(arr[j]) - 1]:\n                continue\n            heapq.heappush(x, (-prefixSuffix(arr[i], arr[j]), i, j))\n    if len(arr) % 2 != 0:\n        l1 = len(arr) - 2\n    else:\n        l1 = len(arr) - 1\n    ans = 0\n    while len(x) > 0:\n        (y, i, j) = heapq.heappop(x)\n        if not (visited[i] or visited[j]):\n            ans += y ** 2\n            l += 2\n            visited[i] = True\n            visited[j] = True\n        if l == l1:\n            break\n    return ans\ntry:\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        arr = set()\n        ans = 0\n        for i in range(n):\n            x = input()\n            if x not in arr:\n                arr.add(x)\n            else:\n                arr.remove(x)\n                ans += len(x) ** 2\n        arr = list(arr)\n        print(ans + verse(arr))\nexcept:\n    pass", "for _ in range(int(input())):\n    n = int(input())\n    completed = [False] * n\n    beauty = 0\n    words = []\n    for i in range(n):\n        words.append(input())\n    words.sort()\n    for i in range(n - 1):\n        if words[i] == words[i + 1] and completed[i] == False and (completed[i + 1] == False):\n            beauty += len(words[i]) ** 2\n            (completed[i], completed[i + 1]) = (True, True)\n    mapping = dict()\n    for i in range(n):\n        if completed[i] == True:\n            continue\n        word = words[i]\n        (prefix, suffix) = ('', '')\n        length = len(word)\n        (left, right) = (0, length - 1)\n        while left < length and right >= 0:\n            prefix = prefix + word[left]\n            suffix = word[right] + suffix\n            tup = (prefix, suffix, len(prefix))\n            if tup in mapping:\n                mapping[tup].append([len(prefix), i])\n            else:\n                mapping[tup] = [[len(prefix), i]]\n            left += 1\n            right -= 1\n    common = [value for (key, value) in sorted(mapping.items(), key=lambda item: item[1][0], reverse=True)]\n    for i in common:\n        if len(i) > 1:\n            count = 0\n            included = []\n            for j in i:\n                if completed[j[1]] == False:\n                    count += 1\n                    included.append(j[1])\n            if count >= 2:\n                beauty += i[0][0] ** 2 * (count // 2)\n                if count % 2 == 0:\n                    for k in included:\n                        completed[k] = True\n                else:\n                    del included[-1]\n                    for k in included:\n                        completed[k] = True\n    print(beauty)", "def compare(s1, s2):\n    pre = 0\n    suf = 0\n    if s1 == s2:\n        return (0, pow(len(s1), 2))\n    else:\n        s1 = list(s1)\n        s2 = list(s2)\n        for i in range(min(len(s1), len(s2))):\n            if s1[i] == s2[i]:\n                pre += 1\n            else:\n                break\n        s1 = s1[::-1]\n        s2 = s2[::-1]\n        for i in range(min(len(s1), len(s2))):\n            if s1[i] == s2[i]:\n                suf += 1\n            else:\n                break\n        return (1, min(pow(pre, 2), pow(suf, 2)))\n\ndef compare_2(arr, z, start, mi):\n    z2 = start\n    mi2 = mi\n    for i in range(len(arr)):\n        if i == start or i == z:\n            continue\n        else:\n            (a2, s2) = compare(arr[z], arr[i])\n            if a2 == 0:\n                z2 = i\n                del arr[z]\n                del arr[i - 1]\n                mi2 = s2\n                return mi2\n                break\n            elif mi2 < s2:\n                z2 = i\n                mi2 = s2\n    if z2 == start:\n        del arr[start]\n        del arr[z - 1]\n        return mi2\n    else:\n        return compare_2(arr, z2, z, mi2)\nfor t in range(int(input())):\n    n = int(input())\n    arr = []\n    total = 0\n    mi = 0\n    for i in range(n):\n        arr.append(input())\n    while len(arr) > 1:\n        z = 1\n        for i in range(1, len(arr)):\n            (a, s) = compare(arr[0], arr[i])\n            if mi < s:\n                z = i\n                mi = s\n            if a == 0:\n                mi = pow(len(arr[0]), 2)\n                del arr[0]\n                del arr[i - 1]\n                i -= 2\n                break\n            if i == len(arr) - 1 and mi == 0:\n                del arr[0]\n                i -= 1\n                recur = 1\n        if a != 0 and mi != 0:\n            mi = compare_2(arr, z, 0, mi)\n        total += mi\n        mi = 0\n    print(total)", "def solve(arr):\n    answer = 0\n    while len(arr) >= 2:\n        maximum = 0\n        word1 = ''\n        word2 = ''\n        first = 0\n        second = 0\n        length = len(arr)\n        for i in range(length):\n            for j in range(i + 1, length):\n                first = i\n                second = j\n                if calculate(arr[first], arr[second]) >= maximum:\n                    word1 = arr[first]\n                    word2 = arr[second]\n                    maximum = calculate(arr[first], arr[second])\n        temp = calculate(word1, word2)\n        answer += temp\n        arr.remove(word1)\n        arr.remove(word2)\n    return answer\n\ndef calculate(a, b):\n    index = 0\n    la = len(a)\n    lb = len(b)\n    while index < len(a) and index < len(b):\n        c1 = a[index]\n        c2 = b[index]\n        e1 = a[la - 1 - index]\n        e2 = b[lb - 1 - index]\n        if c1 == c2 and e1 == e2:\n            index += 1\n        else:\n            break\n    return index * index\n\ndef clean(a):\n    required = 0\n    length = len(a)\n    temp = []\n    for i in range(length - 1):\n        if a[i][0] == a[i + 1][0]:\n            temp.append(a[i])\n        else:\n            temp.append(a[i])\n            if len(temp) > 1:\n                required += solve(temp)\n            temp = []\n    i += 1\n    temp.append(a[i])\n    if len(temp) > 1:\n        required += solve(temp)\n    return required\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        s = input()\n        print(0)\n        continue\n    verse = []\n    answer = 0\n    q = 0\n    for _ in range(n):\n        s = input()\n        if s in verse:\n            verse.remove(s)\n            answer += pow(len(s), 2)\n            continue\n        verse.append(s)\n    verse.sort()\n    if len(verse) > 1:\n        q = clean(verse)\n    print(answer + q)", "def solve(arr):\n    answer = 0\n    while len(arr) >= 2:\n        maximum = 0\n        word1 = ''\n        word2 = ''\n        first = 0\n        second = 0\n        length = len(arr)\n        for i in range(length):\n            for j in range(i + 1, length):\n                first = i\n                second = j\n                if calculate(arr[first], arr[second]) >= maximum:\n                    word1 = arr[first]\n                    word2 = arr[second]\n                    maximum = calculate(arr[first], arr[second])\n        temp = calculate(word1, word2)\n        answer += temp\n        arr.remove(word1)\n        arr.remove(word2)\n    return answer\n\ndef calculate(a, b):\n    index = 0\n    la = len(a)\n    lb = len(b)\n    while index < len(a) and index < len(b):\n        c1 = a[index]\n        c2 = b[index]\n        e1 = a[la - 1 - index]\n        e2 = b[lb - 1 - index]\n        if c1 == c2 and e1 == e2:\n            index += 1\n        else:\n            break\n    return index * index\n\ndef clean(a):\n    required = 0\n    length = len(a)\n    temp = []\n    for i in range(length - 1):\n        if a[i][0] == a[i + 1][0]:\n            temp.append(a[i])\n        else:\n            temp.append(a[i])\n            if len(temp) > 1:\n                temp = temp[::-1]\n                required += solve(temp)\n            temp = []\n    i += 1\n    temp.append(a[i])\n    if len(temp) > 1:\n        temp = temp[::-1]\n        required += solve(temp)\n    return required\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n == 1:\n        s = input()\n        print(0)\n        continue\n    verse = []\n    answer = 0\n    q = 0\n    for _ in range(n):\n        s = input()\n        if s in verse:\n            verse.remove(s)\n            answer += pow(len(s), 2)\n            continue\n        verse.append(s)\n    verse.sort()\n    if len(verse) > 1:\n        q = clean(verse)\n    print(answer + q)", "def change(a):\n    res = ''\n    i = 0\n    j = len(a) - 1\n    n = len(a)\n    for i in range(n):\n        res += a[i] + a[n - i - 1]\n    return res\n\ndef beauty(a, b):\n    na = len(a)\n    nb = len(b)\n    if na <= nb:\n        for i in range(na):\n            if a[i] != b[i]:\n                return i // 2\n        return na // 2\n    else:\n        for i in range(nb):\n            if a[i] != b[i]:\n                return i // 2\n        return nb // 2\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    l = []\n    for i in range(n):\n        l.append(input())\n    if n == 1:\n        print(0)\n        continue\n    for i in range(n):\n        l[i] = change(l[i])\n    l.sort()\n    s = []\n    s.append(l[0])\n    s.append(l[1])\n    top = l[1]\n    st = l[0]\n    res = 0\n    for i in range(2, n):\n        a = -1\n        b = -1\n        while len(s) >= 2:\n            a = s.pop()\n            b = s.pop()\n            if beauty(a, b) >= beauty(a, l[i]):\n                res += pow(beauty(a, b), 2)\n                a = -1\n                b = -1\n            else:\n                break\n        if a != -1 and b != -1:\n            s.append(b)\n            s.append(a)\n        s.append(l[i])\n    while len(s) >= 2:\n        a = s.pop()\n        b = s.pop()\n        res += pow(beauty(a, b), 2)\n    print(res)", "t = int(input())\nfor qwe in range(t):\n    l = []\n    s1 = int(input())\n    for i in range(s1):\n        s = input()\n        for j in range(1, len(s) + 1):\n            l.append([j, s[0:j] + s[len(s) - j:], i])\n    l.sort(reverse=True)\n    a = 0\n    c = 1\n    if len(l) == 1:\n        print(0)\n    else:\n        d = {}\n        ans = 0\n        while a <= c < len(l):\n            if l[a][1] == l[c][1]:\n                ans += l[a][0] ** 2\n                d[l[a][2]] = 1\n                d[l[c][2]] = 1\n            else:\n                a += 1\n                c += 1\n            while a < len(l):\n                if l[a][2] not in d:\n                    break\n                else:\n                    a += 1\n            while c < len(l):\n                if l[c][2] not in d and a != c:\n                    break\n                else:\n                    c += 1\n        print(ans)", "def ispalin(s):\n    a = 0\n    b = len(s) - 1\n    while a < b:\n        if s[a] != s[b]:\n            return False\n        a += 1\n        b -= 1\n    return True\n\ndef f(s1, s2):\n    a = len(s1)\n    b = len(s2)\n    w = count = 0\n    while w < min(a, b):\n        if s1[w] == s2[w]:\n            count += 1\n            w += 1\n        else:\n            break\n    return count ** 2\n\ndef f1(l1, l2):\n    s1 = l1[0]\n    s2 = l2[0]\n    a = len(s1)\n    b = len(s2)\n    w = count = 0\n    v = 0\n    while w < min(a, b):\n        if s1[w] == s2[w]:\n            count += 1\n            w += 1\n        else:\n            v = 1\n            break\n    if count % 2 == 1:\n        if v == 0 and w == min(a, b):\n            p1 = p2 = 0\n            s1 = l1[1]\n            s2 = l2[1]\n            for i in range(min(a, b)):\n                if s1[i] == s2[i]:\n                    p1 += 1\n                else:\n                    break\n            if a < b:\n                for i in range(min(a, b) - 1, -1, -1):\n                    if s1[i] == s2[i + b - a]:\n                        p2 += 1\n                    else:\n                        break\n            else:\n                for i in range(min(a, b) - 1, -1, -1):\n                    if s1[i + a - b] == s2[i]:\n                        p2 += 1\n                    else:\n                        break\n            return min(p1, p2) ** 2\n        return ((count - 1) // 2) ** 2\n    else:\n        return (count // 2) ** 2\n\ndef g(s):\n    p = len(s)\n    if p == 1:\n        return s\n    w = p // 2\n    s1 = ''\n    for i in range(w):\n        s1 += s[i] + s[p - 1 - i]\n    if p % 2 == 1:\n        s1 += s[w]\n    return s1\nfor i in range(int(input())):\n    x = True\n    n = int(input())\n    arr1 = []\n    for i in range(n):\n        arr1.append([input()])\n    if not ispalin(arr1[-1][0]):\n        x = False\n    if x == False:\n        for i in range(n):\n            arr1[i] = [g(arr1[i][0])] + arr1[i]\n        arr1.sort()\n        arr = []\n        ans = 0\n        for i in range(n):\n            if arr == []:\n                arr.append(arr1[i])\n            elif arr[-1][0] == arr1[i][0]:\n                ans += len(arr[-1][0]) ** 2\n                arr.pop()\n            else:\n                arr.append(arr1[i])\n        l = []\n        n = len(arr)\n        if n > 1:\n            for i in range(n - 1):\n                l.append([f1(arr[i], arr[i + 1]), i])\n            l1 = []\n            for i in l:\n                l1.append(i[:])\n            l1.sort()\n            temp = [0 for i in range(n)]\n            neigh = []\n            for i in range(n):\n                neigh.append([i - 1, i + 1])\n            neigh[0][0] = None\n            neigh[-1][-1] = None\n            index = [0 for i in range(n - 1)]\n            for i in range(n - 1):\n                index[l1[i][1]] = i\n            index.append(n - 1)\n            for i in range(n - 2, -1, -1):\n                if temp[i] == 1:\n                    continue\n                else:\n                    ans += l1[i][0]\n                    p = l1[i][1]\n                    p1 = neigh[p][1]\n                    c = index[p1]\n                    temp[i] = 1\n                    temp[c] = 1\n                    q1 = neigh[p][0]\n                    q2 = neigh[p1][1]\n                    if q1 == None and q2 == None:\n                        break\n                    elif q1 == None:\n                        neigh[q2][0] = None\n                        continue\n                    elif q2 == None:\n                        neigh[q1][1] = None\n                        temp[index[q1]] = 1\n                    else:\n                        neigh[q1][1] = q2\n                        neigh[q2][0] = q1\n                        j1 = index[q1]\n                        j2 = index[p1]\n                        if j1 > j2:\n                            temp[j1] = 1\n                            temp[j2] = 0\n                            l1[j2][1] = q1\n                            index[q1] = j2\n        print(ans)\n    else:\n        arr = []\n        for i in arr1:\n            arr.append(i[0])\n        arr.sort()\n        ans = 0\n        l = []\n        for i in range(n - 1):\n            l.append([f(arr[i], arr[i + 1]), i])\n        l1 = []\n        for i in l:\n            l1.append(i[:])\n        l1.sort()\n        temp = [0 for i in range(n)]\n        neigh = []\n        for i in range(n):\n            neigh.append([i - 1, i + 1])\n        neigh[0][0] = None\n        neigh[-1][-1] = None\n        index = [0 for i in range(n - 1)]\n        for i in range(n - 1):\n            index[l1[i][1]] = i\n        index.append(n - 1)\n        ans = 0\n        for i in range(n - 2, -1, -1):\n            if temp[i] == 1:\n                continue\n            else:\n                ans += l1[i][0]\n                p = l1[i][1]\n                p1 = neigh[p][1]\n                c = index[p1]\n                temp[i] = 1\n                temp[c] = 1\n                q1 = neigh[p][0]\n                q2 = neigh[p1][1]\n                if q1 == None and q2 == None:\n                    break\n                elif q1 == None:\n                    neigh[q2][0] = None\n                    continue\n                elif q2 == None:\n                    neigh[q1][1] = None\n                    temp[index[q1]] = 1\n                else:\n                    neigh[q1][1] = q2\n                    neigh[q2][0] = q1\n                    j1 = index[q1]\n                    j2 = index[p1]\n                    if j1 > j2:\n                        temp[j1] = 1\n                        temp[j2] = 0\n                        l1[j2][1] = q1\n                        index[q1] = j2\n        print(ans)", "def calbeauty(word1, word2):\n    p = 0\n    i = 0\n    a = len(word1)\n    b = len(word2)\n    k = min(a, b)\n    while i < k:\n        if word1[i] == word2[i]:\n            i = i + 1\n            p = p + 1\n        else:\n            break\n    return i // 2\nfor _ in range(int(input())):\n    N = int(input())\n    Word = []\n    from collections import defaultdict\n    d = defaultdict(int)\n    for j in range(N):\n        w = input()\n        d[w] += 1\n    beauty = 0\n    for item in d:\n        f = d[item]\n        if f % 2 == 1:\n            Word.append(item)\n            data = len(item) ** 2\n            q = f // 2\n            beauty = beauty + q * data\n        else:\n            data = len(item) ** 2\n            q = f // 2\n            beauty = beauty + q * data\n    W = []\n    for w in Word:\n        i = 0\n        itsL = []\n        for i in range(len(w)):\n            itsL.append(w[i])\n            itsL.append(w[-i - 1])\n        W.append(tuple(itsL))\n    Lists = defaultdict(list)\n    for item in W:\n        Lists[item[0] + item[1]].append(item)\n    for c in Lists:\n        W = sorted(Lists[c])\n        count = len(W)\n        while count > 0:\n            count = count - 1\n            Remain = []\n            while len(W) > 2:\n                data1 = calbeauty(W[-1], W[-2])\n                data2 = calbeauty(W[-2], W[-3])\n                if data2 <= data1:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                else:\n                    d = W.pop()\n                    Remain.append(d)\n            if len(Remain) == 0:\n                break\n            else:\n                W.extend(Remain)\n                W.sort()\n        while len(W) > 2:\n            if len(W) >= 4:\n                data1 = calbeauty(W[-1], W[-2])\n                data2 = calbeauty(W[-2], W[-3])\n                data3 = calbeauty(W[-3], W[-4])\n                beauty = beauty + max(data1, data2, data3) ** 2\n                if data1 >= data2 and data1 >= data3:\n                    W.pop()\n                    W.pop()\n                elif data2 >= data1 and data2 >= data3:\n                    W.pop(-2)\n                    W.pop(-2)\n                elif data3 >= data2 and data3 >= data1:\n                    W.pop(-3)\n                    W.pop(-3)\n            else:\n                data1 = calbeauty(W[0], W[1])\n                data2 = calbeauty(W[1], W[2])\n                if data2 <= data1:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                else:\n                    beauty = beauty + data2 ** 2\n                    W.pop(-2)\n                    W.pop(-2)\n        if len(W) == 1 or len(W) == 0:\n            continue\n        else:\n            beauty = beauty + calbeauty(W[0], W[1]) ** 2\n    print(beauty)", "def calbeauty(word1, word2):\n    p = 0\n    i = 0\n    a = len(word1)\n    b = len(word2)\n    k = min(a, b)\n    while i < k:\n        if word1[i] == word2[i]:\n            i = i + 1\n            p = p + 1\n        else:\n            break\n    return i // 2\nfor _ in range(int(input())):\n    N = int(input())\n    Word = []\n    from collections import defaultdict\n    d = defaultdict(int)\n    for j in range(N):\n        w = input()\n        d[w] += 1\n    beauty = 0\n    for item in d:\n        f = d[item]\n        if f % 2 == 1:\n            Word.append(item)\n            data = len(item) ** 2\n            q = f // 2\n            beauty = beauty + q * data\n        else:\n            data = len(item) ** 2\n            q = f // 2\n            beauty = beauty + q * data\n    W = []\n    for w in Word:\n        i = 0\n        itsL = []\n        for i in range(len(w)):\n            itsL.append(w[i])\n            itsL.append(w[-i - 1])\n        W.append(tuple(itsL))\n    Lists = defaultdict(list)\n    for item in W:\n        Lists[item[0] + item[1]].append(item)\n    for c in Lists:\n        W = sorted(Lists[c])\n        count = len(W)\n        while count > 0:\n            count = count - 1\n            Remain = []\n            while len(W) > 2:\n                data1 = calbeauty(W[-1], W[-2])\n                data2 = calbeauty(W[-2], W[-3])\n                if data2 <= data1:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                else:\n                    d = W.pop()\n                    Remain.append(d)\n            if len(Remain) == 0:\n                break\n            else:\n                W.extend(Remain)\n                W.sort()\n        while len(W) > 2:\n            if len(W) >= 4:\n                data1 = calbeauty(W[-1], W[-2])\n                data2 = calbeauty(W[-2], W[-3])\n                data3 = calbeauty(W[-3], W[-4])\n                if data1 >= data2 and data1 >= data3:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                elif data2 >= data1 and data2 >= data3:\n                    beauty = beauty + data2 ** 2\n                    W.pop(-2)\n                    W.pop(-2)\n                elif data3 >= data2 and data3 >= data1:\n                    beauty = beauty + data3 ** 2\n                    W.pop(-3)\n                    W.pop(-3)\n            else:\n                data1 = calbeauty(W[0], W[1])\n                data2 = calbeauty(W[1], W[2])\n                if data2 <= data1:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                else:\n                    beauty = beauty + data2 ** 2\n                    W.pop(-2)\n                    W.pop(-2)\n        if len(W) == 1 or len(W) == 0:\n            continue\n        else:\n            beauty = beauty + calbeauty(W[0], W[1]) ** 2\n    print(beauty)", "def calbeauty(word1, word2):\n    p = 0\n    i = 0\n    a = len(word1)\n    b = len(word2)\n    k = min(a, b)\n    while i < k:\n        if word1[i] == word2[i]:\n            i = i + 1\n            p = p + 1\n        else:\n            break\n    return i // 2\nfor _ in range(int(input())):\n    N = int(input())\n    Word = []\n    from collections import defaultdict\n    d = defaultdict(int)\n    for j in range(N):\n        w = input()\n        d[w] += 1\n    beauty = 0\n    for item in d:\n        f = d[item]\n        if f % 2 == 1:\n            Word.append(item)\n            data = len(item) ** 2\n            q = f // 2\n            beauty = beauty + q * data\n        else:\n            data = len(item) ** 2\n            q = f // 2\n            beauty = beauty + q * data\n    W = []\n    for w in Word:\n        i = 0\n        itsL = []\n        for i in range(len(w)):\n            itsL.append(w[i])\n            itsL.append(w[-i - 1])\n        W.append(tuple(itsL))\n    Lists = defaultdict(list)\n    for item in W:\n        Lists[item[0] + item[1]].append(item)\n    for c in Lists:\n        W = sorted(Lists[c])\n        count = len(W)\n        while count > 0:\n            count = count - 1\n            Remain = []\n            while len(W) > 2:\n                data1 = calbeauty(W[-1], W[-2])\n                data2 = calbeauty(W[-2], W[-3])\n                if data2 <= data1:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                else:\n                    d = W.pop()\n                    Remain.append(d)\n            if len(Remain) == 0:\n                break\n            else:\n                W.extend(Remain)\n                W.sort()\n        while len(W) > 2:\n            if len(W) >= 4:\n                data1 = calbeauty(W[-1], W[-2])\n                data2 = calbeauty(W[-2], W[-3])\n                data3 = calbeauty(W[-3], W[-4])\n                if data1 >= data2 and data1 >= data3:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                elif data2 >= data1 and data2 >= data3:\n                    beauty = beauty + data2 ** 2\n                    W.pop(-2)\n                    W.pop(-2)\n                elif data3 >= data2 and data3 >= data1:\n                    beauty = beauty + data3 ** 2\n                    W.pop(-3)\n                    W.pop(-3)\n            else:\n                data1 = calbeauty(W[0], W[1])\n                data2 = calbeauty(W[1], W[2])\n                if data2 <= data1:\n                    beauty = beauty + data1 ** 2\n                    W.pop()\n                    W.pop()\n                else:\n                    beauty = beauty + data2 ** 2\n                    W.pop(-2)\n                    W.pop(-2)\n        if len(W) == 1 or len(W) == 0:\n            continue\n        else:\n            beauty = beauty + calbeauty(W[0], W[1]) ** 2\n    print(beauty)", "def findBeauty(s1, s2):\n    n = min(len(s1), len(s2))\n    count = 0\n    for i in range(n):\n        if s1[i] != s2[i]:\n            break\n        else:\n            count += 1\n    b = count\n    s1 = s1[::-1]\n    s2 = s2[::-1]\n    count = 0\n    for i in range(n):\n        if s1[i] != s2[i] or i > b:\n            break\n        else:\n            count += 1\n    b = min(b, count)\n    return b * b\n\ndef calBeauty(L):\n    N = len(L)\n    ans = []\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            left = findBeauty(L[i], L[j])\n            if left != 0:\n                ans.append([left, i, j])\n    ans.sort(reverse=True)\n    sum1 = 0\n    p = len(ans)\n    i = 0\n    ans.append([-99, -99, -99])\n    while True:\n        if ans[i][0] == -99:\n            break\n        sum1 += ans[i][0]\n        j = i + 1\n        while True:\n            if ans[j][0] == -99:\n                break\n            if ans[j][1] == ans[i][1] or ans[j][1] == ans[i][2] or ans[j][2] == ans[i][2] or (ans[j][2] == ans[i][1]):\n                ans.remove(ans[j])\n                j -= 1\n            j += 1\n        i += 1\n    return sum1\nfor _ in range(int(input())):\n    N = int(input())\n    L = []\n    for i in range(N):\n        L.append(input())\n    L.sort()\n    W = []\n    same = []\n    for i in range(1, N):\n        if L[i] != L[i - 1]:\n            W.append(L[i - 1])\n            L[i - 1] = ''\n        else:\n            same.append(L[i])\n            L[i - 1] = ''\n            L[i] = ''\n            i += 1\n    W.append(L[-1])\n    while '' in W:\n        W.remove('')\n    beauty = 0\n    for x in same:\n        r = len(x)\n        beauty += r * r\n    L = W\n    S = []\n    k = 0\n    N = len(L)\n    for i in range(1, N):\n        if L[i][0] != L[i - 1][0]:\n            S.append(L[k:i])\n            k = i\n    S.append(L[k:])\n    Y = []\n    for s in S:\n        r = [x[::-1] for x in s]\n        k = 0\n        r.sort()\n        for i in range(len(r)):\n            if r[i][0] != r[i - 1][0]:\n                Y.append(r[k:i])\n                k = i\n        Y.append(r[k:])\n    for i in range(len(Y)):\n        beauty += calBeauty(Y[i])\n    print(beauty)", "def score(s1, s2):\n    count = 0\n    for i in range(min(len(s1), len(s2))):\n        if s1[i] == s2[i] and s1[-(i + 1)] == s2[-(i + 1)]:\n            count += 1\n        else:\n            break\n    return count\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    leng = []\n    for i in range(n):\n        words.append(input())\n        leng.append(len(words[i]))\n    d = {}\n    maxlen = max(leng)\n    for i in range(len(words)):\n        words[i] = words[i] + '^' * (maxlen - len(words[i]))\n    g = {}\n    level = 0\n    for i in range(len(words)):\n        g[words[i], level] = 0\n    for i in range(maxlen):\n        group = 1\n        for j in range(len(words)):\n            i1 = i\n            if d.get((words[j][i], words[j][leng[j] - i - 1], i1, g[words[j], level])) == None:\n                d[words[j][i], words[j][leng[j] - i - 1], i1, g[words[j], level]] = [words[j]]\n                g[words[j], level + 1] = group\n                group += 1\n            else:\n                d[words[j][i], words[j][leng[j] - i - 1], i1, g[words[j], level]].append(words[j])\n                g[words[j], level + 1] = g[d[words[j][i], words[j][leng[j] - i - 1], i1, g[words[j], level]][0], level + 1]\n        level += 1\n    l = []\n    done = {}\n    lis = []\n    for lev in range(level, -1, -1):\n        dic = {}\n        for i in range(n):\n            if done.get((words[i], i)) == None:\n                if dic.get(g[words[i], lev]) == None:\n                    dic[g[words[i], lev]] = [(words[i], i)]\n                else:\n                    done[words[i], i] = 1\n                    lis.append(words[i])\n                    done[dic[g[words[i], lev]][0]] = 1\n                    lis.append(dic[g[words[i], lev]][0][0])\n                    del dic[g[words[i], lev]]\n    ans = 0\n    for i in range(0, len(lis), 2):\n        ans += pow(score(lis[i].strip('^'), lis[i + 1].strip('^')), 2)\n    print(ans)", "def check(arr1, arr2):\n    j = 0\n    n1 = len(arr1)\n    n2 = len(arr2)\n    count = 0\n    while j < n1 and j < n2:\n        if arr1[j] == arr2[j]:\n            count = count + 1\n            j = j + 1\n        else:\n            break\n    return count\nfor _ in range(int(input())):\n    sume = 0\n    n = int(input())\n    a = []\n    for i in range(n):\n        p = input()\n        a.append(p)\n    mno = []\n    mno = a\n    a = []\n    a = list(set(mno))\n    n = len(a)\n    sume2 = 0\n    i = 0\n    while i < n:\n        x = mno.count(a[i])\n        sume2 = sume2 + len(a[i]) * len(a[i]) * (x // 2)\n        if x % 2 == 0:\n            a.pop(i)\n            n = n - 1\n            continue\n        i = i + 1\n    p = []\n    (rows, cols) = (n, n)\n    arr = [[0 for i in range(cols)] for j in range(rows)]\n    for i in range(n):\n        for j in range(i, n):\n            if i == j:\n                p.append(arr[i][j])\n                continue\n            if a[i] == a[j]:\n                arr[i][j] = len(a[i]) ** 2\n                arr[j][i] = arr[i][j]\n                p.append(arr[i][j])\n            else:\n                arr[i][j] = min(check(a[i], a[j]), check(a[i][::-1], a[j][::-1])) ** 2\n                arr[j][i] = arr[i][j]\n                p.append(arr[i][j])\n    p = set(p)\n    p = list(p)\n    p = sorted(p)\n    p = p[::-1]\n    I = []\n    J = []\n    for num in p:\n        for i in range(n):\n            if i not in I:\n                if arr[i].count(num) > 0:\n                    for j in range(n):\n                        if arr[i][j] == num:\n                            if j not in J:\n                                sume = sume + num\n                                I.append(i)\n                                J.append(j)\n                                break\n    print(sume2 + sume // 2)", "from collections import deque\n\ndef prefixal_len(a, b):\n    count = 0\n    for (a1, b1) in zip(a, b):\n        if a1 != b1:\n            return count\n        count += 1\n    else:\n        return count\n\ndef calc_common_prefixal(w, m, n):\n    w.sort()\n    res = 0\n    x = []\n    d = deque()\n    for c in w:\n        if d:\n            p = d.pop()\n            common_len = prefixal_len(p[1], c)\n            if common_len >= n:\n                res += n ** 2\n            elif common_len >= m:\n                if p[0] > common_len:\n                    res += p[0] ** 2\n                    d.pop()\n                    while d:\n                        q = d.pop()\n                        if q[0] > common_len:\n                            res += q[0] ** 2\n                            q.pop()\n                        else:\n                            d.append((q[0], c))\n                            break\n                else:\n                    d.append(p)\n                    d.append((common_len, c))\n            else:\n                if p[0] == 0:\n                    x.append(p[1])\n                else:\n                    res += p[0] ** 2\n                    d.pop()\n                while d:\n                    q = d.pop()\n                    if q[0] == 0:\n                        x.append(q[1])\n                    else:\n                        res += q[0] ** 2\n                        d.pop()\n                d.append((0, c))\n        else:\n            d.append((0, c))\n    else:\n        while d:\n            q = d.pop()\n            if q[0] > 0:\n                res += q[0] ** 2\n                d.pop()\n            else:\n                x.append(q[1])\n    return (res, x)\n\ndef solve(a):\n    a.sort()\n    res = 0\n    d = deque()\n    for c in a:\n        if d:\n            p = d.pop()\n            common_len = prefixal_len(p[1], c)\n            if common_len >= 1:\n                if p[0] > common_len:\n                    q = d.pop()\n                    (r, x) = calc_common_prefixal(p[2], q[0] + 1, p[0])\n                    res += r\n                    while q[0] > common_len:\n                        q2 = d.pop()\n                        (r, x) = calc_common_prefixal(x + q[2], q2[0] + 1, q[0])\n                        res += r\n                        q = q2\n                    if q[0] == common_len:\n                        d.append((common_len, c, x + q[2] + [c[::-1]]))\n                    else:\n                        d.append(q)\n                        d.append((common_len, c, x + [c[::-1]]))\n                elif p[0] == common_len:\n                    d.append((common_len, c, p[2] + [c[::-1]]))\n                else:\n                    d.append((p[0], p[1], p[2][:-1]))\n                    d.append((common_len, c, [p[2][-1], c[::-1]]))\n            else:\n                if p[0] > 0:\n                    q = d.pop()\n                    (r, x) = calc_common_prefixal(p[2], q[0] + 1, p[0])\n                    res += r\n                    while q[0] > 0:\n                        q2 = d.pop()\n                        (r, x) = calc_common_prefixal(x + q[2], q2[0] + 1, q[0])\n                        res += r\n                        q = q2\n                d.append((0, c, [c[::-1]]))\n        else:\n            d.append((0, c, [c[::-1]]))\n    else:\n        x = []\n        if d:\n            q = d.pop()\n            while q[0] > 0:\n                q2 = d.pop()\n                (r, x) = calc_common_prefixal(x + q[2], q2[0] + 1, q[0])\n                res += r\n                q = q2\n    return res\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        w = [input() for i in range(N)]\n        ans = solve(w)\n        print(ans)\nmain()", "from math import factorial as fac\nimport sys, math\nf = None\ntry:\n    f = open('q1.input', 'r')\nexcept IOError:\n    f = sys.stdin\n\ndef print_case_iterable(case_num, iterable):\n    print('Case #{}: {}'.format(case_num, ' '.join(map(str, iterable))))\n\ndef print_case_number(case_num, iterable):\n    print('Case #{}: {}'.format(case_num, iterable))\n\ndef read_int():\n    return int(f.readline())\n\ndef read_int_array():\n    return [int(x) for x in f.readline().split(' ')]\n\ndef rns():\n    a = [x for x in f.readline().split(' ')]\n    return (int(a[0]), a[1].strip())\n\ndef read_string():\n    return list(f.readline())\nNUMBER = 10 ** 9 + 7\n\ndef factorial(n):\n    M = 1000000007\n    f = 1\n    for i in range(1, n + 1):\n        f = f * i % M\n    return f\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nfrom collections import defaultdict\nimport string\nLETTERS = list(string.ascii_lowercase)\n\ndef transform_string(s):\n    n = len(s)\n    res = ''\n    for i in range(n):\n        res += s[i] + s[n - 1 - i]\n    return res\n\ndef diff_s(s, t):\n    i = 0\n    while i < min(len(s), len(t)) and s[i] == t[i]:\n        i += 1\n    return i // 2\n\ndef solution(A, N):\n    A = [transform_string(x) for x in A]\n    A.sort()\n    n = len(A)\n    diffs = []\n    total_sum = 0\n    for i in range(n - 1):\n        diff = diff_s(A[i], A[i + 1])\n        while True:\n            if len(diffs) == 0 or diff > diffs[-1]:\n                diffs.append(diff)\n                break\n            total_sum += diffs[-1] ** 2\n            if len(diffs) == 1 or diff == diffs[-1]:\n                diffs.pop()\n                break\n            if diff >= diffs[-2]:\n                diffs.pop()\n                break\n            diffs.pop()\n            diffs.pop()\n    for i in range(len(diffs) - 1, -1, -2):\n        total_sum += diffs[i] ** 2\n    return total_sum\n\ndef main():\n    T = read_int()\n    for i in range(T):\n        N = read_int()\n        A = []\n        for i in range(N):\n            A.append(f.readline().strip())\n        print(solution(A, N))\nimport random\n\ndef test():\n    A = [[random.choice(LETTERS) for i in range(6)] for i in range(8)]\n    print([random.choice(LETTERS) for i in range(5)])\nmain()", "def modstr(a):\n    tmp = ''\n    l = len(a)\n    for i in range(l):\n        tmp = tmp + a[i] + a[l - 1 - i]\n    return tmp\n\ndef func(b, a):\n    i = 0\n    while i < min(len(a), len(b)) and a[i] == b[i]:\n        i += 1\n    return (i // 2) ** 2\nfor _ in range(int(input())):\n    n = int(input())\n    l = []\n    for i in range(n):\n        a = input()\n        l.append(modstr(a))\n    l.sort()\n    ans = 0\n    prev = -1\n    stack = []\n    stack.append(l[0])\n    i = 1\n    tmp = 0\n    while i < n:\n        while tmp >= prev and i < n:\n            k = 0\n            stack.append(l[i])\n            i += 1\n            prev = tmp\n            tmp = func(stack[-1], stack[-2])\n        while tmp < prev:\n            ans += prev\n            if prev != 0:\n                t1 = stack[-1]\n                stack.pop()\n                stack.pop()\n                stack.pop()\n                stack.append(t1)\n                if len(stack) > 2:\n                    tmp = func(stack[-1], stack[-2])\n                    prev = func(stack[-2], stack[-3])\n                elif len(stack) == 2:\n                    prev = 0\n                    tmp = func(stack[-1], stack[-2])\n                else:\n                    prev = -1\n                    tmp = 0\n    while len(stack) > 1:\n        tmp = func(stack[-1], stack[-2])\n        ans += tmp\n        stack.pop()\n        stack.pop()\n    print(ans)", "def check(s1, s2):\n    if s1 == s2:\n        y = len(s1)\n        return y\n    n = min(len(s1), len(s2))\n    c1 = 0\n    for i in range(n):\n        if s1[i] == s2[i]:\n            c1 += 1\n        else:\n            break\n    c2 = 0\n    s1 = s1[::-1]\n    s2 = s2[::-1]\n    for i in range(n):\n        if s1[i] == s2[i] or c1 < c2:\n            c2 += 1\n        else:\n            break\n    b = min(c1, c2)\n    return b\nT = int(input())\nfor _ in range(T):\n    N = int(input())\n    w = []\n    for _ in range(N):\n        w.append(input())\n    w.sort()\n    i = 0\n    same = []\n    while i < N - 1:\n        if w[i] == w[i + 1]:\n            same.append(len(w[i]))\n            w[i] = ''\n            w[i + 1] = ''\n            i = i + 2\n        else:\n            i += 1\n    while '' in w:\n        w.remove('')\n    wlen = len(w)\n    i = 0\n    while i < wlen - 2:\n        if w[i - 1] == '' and w[i][0] != w[i + 1][0]:\n            w[i] = ''\n        elif w[i][0] != w[i + 1][0]:\n            if w[i + 1][0] != w[i + 2][0]:\n                w[i + 1] = ''\n                i += 1\n        i += 1\n    while '' in w:\n        w.remove('')\n    wlen = len(w)\n    z = []\n    for i in range(wlen):\n        for j in range(i + 1, wlen):\n            left = check(w[i], w[j])\n            if left != 0:\n                z.append([left, i, j])\n    z.sort(reverse=True)\n    sum1 = 0\n    p = len(z)\n    i = 0\n    z.append([-99, -99, -99])\n    while True:\n        if z[i][0] == -99:\n            break\n        sum1 += z[i][0] * z[i][0]\n        j = i + 1\n        while True:\n            if z[j][0] == -99:\n                break\n            if z[j][1] == z[i][1] or z[j][1] == z[i][2] or z[j][2] == z[i][2] or (z[j][2] == z[i][1]):\n                z.remove(z[j])\n                j -= 1\n            j += 1\n        i += 1\n    for x in same:\n        sum1 += x * x\n    print(sum1)", "from collections import defaultdict\n\ndef best_beauty(words):\n    max_len = 0\n    trie_table = {}\n    num_set = defaultdict(set)\n    counts = defaultdict(int)\n    for (idx, word) in enumerate(words):\n        counts[idx] += 1\n        chars = ''\n        c_idx = 0\n        for c_idx in range(len(word)):\n            chars += word[c_idx]\n            chars += word[~c_idx]\n            ln = len(chars) // 2\n            num_set[ln].add(chars)\n            if chars in trie_table:\n                max_len = max(max_len, ln)\n            else:\n                trie_table[chars] = set()\n            trie_table[chars].add(idx)\n    result = 0\n    for i in range(max_len, 0, -1):\n        for word in num_set[i]:\n            indexes = trie_table[word]\n            if len(indexes) > 1:\n                nums = []\n                for index in indexes:\n                    if counts[index] > 0:\n                        nums.append(index)\n                    if len(nums) == 2:\n                        result += i ** 2\n                        counts[nums[0]] -= 1\n                        counts[nums[1]] -= 1\n                        nums = []\n    return result\nfor _ in range(int(input())):\n    words = [input() for _ in range(int(input()))]\n    print(best_beauty(words))", "import math\n\nclass Node:\n\n    def __init__(self, char='', parent=None):\n        self.char = char\n        self.parent = parent\n        self.children = {}\n        self.count = 0\n        if parent is None:\n            self.rht = 0\n        else:\n            self.rht = parent.rht + 1\n\n    def __repr__(self):\n        return self.char\n\ndef addToTrie(root, s):\n    node = root\n    for c in s:\n        if c in node.children:\n            node = node.children[c]\n            node.count += 1\n        else:\n            childnode = Node(char=c, parent=node)\n            childnode.count = 1\n            node.children[c] = childnode\n            node = childnode\n\ndef addTupleToTrie(root, s):\n    node = root\n    l = len(s)\n    l2 = math.ceil(l / 2)\n    for i in range(l2):\n        i_ = l - i - 1\n        if i == i_:\n            c = s[i]\n        else:\n            c = s[i] + s[i_]\n        if c in node.children:\n            node = node.children[c]\n            node.count += 1\n        else:\n            childnode = Node(char=c, parent=node)\n            childnode.count = 1\n            node.children[c] = childnode\n            node = childnode\n\ndef printTrie(root):\n    printQ = []\n    printQ.append(root)\n    printQ.append('\\n')\n    while printQ:\n        node = printQ.pop(0)\n        if node == '\\n':\n            print(node)\n            if printQ:\n                printQ.append('\\n')\n        else:\n            print(node.char, node.value, node.count, node.rht, end=' ')\n            printQ.extend(node.children.values())\n\ndef getBFS(root):\n    visitQ = []\n    visitQ.append(root)\n    visitPointer = 0\n    while visitPointer < len(visitQ):\n        node = visitQ[visitPointer]\n        visitQ.extend(node.children.values())\n        visitPointer += 1\n    return visitQ\n\ndef getTrieValueBU1(bottomUp):\n    buPointer = 0\n    l = len(bottomUp)\n    while buPointer < l:\n        node = bottomUp[buPointer]\n        node.value = 0\n        node.carry = node.count\n        if node.children:\n            for child in node.children.values():\n                node.value += child.value\n                node.carry += child.carry - child.count\n        node.value += node.rht ** 2 * (node.carry // 2)\n        node.carry = node.carry % 2\n        buPointer += 1\n\ndef getTrieValueBU2(bottomUp):\n    buPointer = 0\n    l = len(bottomUp)\n    while buPointer < l:\n        node = bottomUp[buPointer]\n        node.value = 0\n        node.carry = node.count\n        if node.children:\n            factor = 1\n            minus = 0\n            for child in node.children.values():\n                if len(child.char) == 1:\n                    partner = child.char + child.char\n                    if partner in node.children:\n                        if child.carry and node.children[partner].carry:\n                            node.value += child.rht ** 2\n                            child.carry = 0\n                            node.children[partner].carry = 0\n                elif child.char[0] == child.char[1]:\n                    partner = child.char[0]\n                    if partner in node.children:\n                        if child.carry and node.children[partner].carry:\n                            node.value += child.rht ** 2\n                            child.carry = 0\n                            node.children[partner].carry = 0\n                node.value += child.value\n                node.carry += child.carry - child.count\n        else:\n            factor = 2\n            c = node.char\n            minus = 2 - len(c)\n        node.value += (factor * node.rht - minus) ** 2 * (node.carry // 2)\n        node.carry = node.carry % 2\n        buPointer += 1\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    algoUse = 1\n    root = Node()\n    lws = []\n    for i in range(n):\n        w = input().strip()\n        lws.append(w)\n    w = lws[n // 2]\n    if w != w[::-1]:\n        algoUse = 2\n    if algoUse == 1:\n        for w in lws:\n            addToTrie(root, w)\n    else:\n        for w in lws:\n            addTupleToTrie(root, w)\n    visitQ = getBFS(root)\n    bottomUp = visitQ[::-1]\n    if algoUse == 1:\n        getTrieValueBU1(bottomUp)\n    else:\n        getTrieValueBU2(bottomUp)\n    print(root.value)", "def check(s1, s2):\n    m = min(len(s1), len(s2))\n    r = -1\n    i = 0\n    count = 0\n    while i < m and r >= -m and (s1[i] == s2[i]) and (s1[r] == s2[r]):\n        count += 1\n        i += 1\n        r -= 1\n    return count\nfor _ in range(int(input())):\n    n = int(input())\n    words = []\n    for i in range(n):\n        words.append(input())\n    dic = {}\n    for i in words:\n        if dic.get(i) == None:\n            dic[i] = 1\n        else:\n            dic[i] += 1\n    ans = 0\n    words = []\n    for (i, j) in dic.items():\n        if j % 2 == 0:\n            ans += len(i) ** 2 * (j // 2)\n        else:\n            ans += len(i) ** 2 * (j // 2)\n            words.append(i)\n    arr = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i != j:\n                ret = check(words[i], words[j])\n                if ret:\n                    arr.append((ret, words[i], words[j]))\n    arr.sort(key=lambda x: x[0], reverse=True)\n    s = set()\n    for item in arr:\n        if item[1] not in s and item[2] not in s:\n            ans += item[0] ** 2\n            s.add(item[1])\n            s.add(item[2])\n    print(ans)", "import math\nfrom itertools import *\nfrom collections import *\nfrom random import shuffle\n\ndef prefix(s1, s2):\n    c = 0\n    while True:\n        try:\n            if s1[c] != s2[c]:\n                break\n        except:\n            break\n        c += 1\n    return c\n\ndef idea(lis):\n    mylis = []\n    it = 0\n    comb = 0\n    for i in lis:\n        mylis.append([i, it])\n        it += 1\n    ready = []\n    for i in combinations(mylis, 2):\n        ready.append([min(prefix(i[0][0], i[1][0]), prefix(i[0][0][::-1], i[1][0][::-1])), [i[0][1], i[1][1]]])\n    ready.sort(key=lambda x: x[0])\n    ready = ready[::-1]\n    pure = set()\n    for i in ready:\n        if i[1][0] not in pure and i[1][1] not in pure:\n            pure.add(i[1][0])\n            pure.add(i[1][1])\n            comb += i[0] ** 2\n    return comb\nfor _ in range(int(input())):\n    checker = set()\n    n = int(input())\n    mlis = []\n    tot = 0\n    lis = []\n    for i in range(n):\n        s = input()\n        mlis.append(s)\n    for (i, j) in Counter(mlis).items():\n        if j == 1:\n            lis.append(i)\n        elif j % 2:\n            lis.append(i)\n            tot += len(i) ** 2 * (j // 2)\n        else:\n            tot += len(i) ** 2 * (j // 2)\n    alpha = defaultdict(list)\n    for i in lis:\n        alpha[i[0]].append(i)\n    for (i, j) in alpha.items():\n        sample = [k for k in j]\n        shuf = idea(sample)\n        tot += shuf\n    tot1 = tot\n    alpha = defaultdict(list)\n    tot = 0\n    for i in lis:\n        alpha[i[-1]].append(i)\n    for (i, j) in alpha.items():\n        sample = [k for k in j]\n        shuf = idea(sample)\n        tot += shuf\n    print(max(tot1, tot))", "import math\nfrom itertools import *\nfrom collections import *\nfrom random import shuffle\n\ndef prefix(s1, s2):\n    c = 0\n    while True:\n        try:\n            if s1[c] != s2[c]:\n                break\n        except:\n            break\n        c += 1\n    return c\n\ndef find(lis):\n    c = 0\n    fin = 0\n    for i in range(len(lis) // 2):\n        first = lis[c]\n        c += 1\n        second = lis[c]\n        c += 1\n        ans = min(prefix(first, second), prefix(first[::-1], second[::-1]))\n        fin += ans ** 2\n    return fin\n\ndef idea(lis):\n    mylis = []\n    it = 0\n    comb = 0\n    for i in lis:\n        mylis.append([i, it])\n        it += 1\n    ready = []\n    for i in combinations(mylis, 2):\n        ready.append([min(prefix(i[0][0], i[1][0]), prefix(i[0][0][::-1], i[1][0][::-1])), [i[0][1], i[1][1]]])\n    ready.sort(key=lambda x: x[0])\n    ready = ready[::-1]\n    pure = set()\n    for i in ready:\n        if i[1][0] not in pure and i[1][1] not in pure:\n            pure.add(i[1][0])\n            pure.add(i[1][1])\n            comb += i[0] ** 2\n    return comb\nfor _ in range(int(input())):\n    checker = set()\n    n = int(input())\n    mlis = []\n    tot = 0\n    lis = []\n    for i in range(n):\n        s = input()\n        mlis.append(s)\n    for (i, j) in Counter(mlis).items():\n        if j == 1:\n            lis.append(i)\n        elif j % 2:\n            lis.append(i)\n            tot += len(i) ** 2 * (j // 2)\n        else:\n            tot += len(i) ** 2 * (j // 2)\n    alpha = defaultdict(list)\n    for i in lis:\n        alpha[i[0]].append(i)\n    for (i, j) in alpha.items():\n        sample = [k for k in j]\n        sample.sort()\n        fir = find(sample)\n        sample = sample[::-1]\n        sec = find(sample)\n        shuf = idea(sample)\n        tot += shuf\n    tot1 = tot\n    alpha = defaultdict(list)\n    tot = 0\n    for i in lis:\n        alpha[i[-1]].append(i)\n    for (i, j) in alpha.items():\n        sample = [k for k in j]\n        sample.sort()\n        fir = find(sample)\n        sample = sample[::-1]\n        sec = find(sample)\n        shuf = idea(sample)\n        tot += shuf\n    print(max(tot1, tot))", "class TrieNode(object):\n\n    def __init__(self, char: str):\n        self.char = char\n        self.children = []\n        self.level = 0\n        self.counter = set()\n\ndef add(root, word, i):\n    node = root\n    l = 0\n    for char in word:\n        l += 1\n        found_in_child = False\n        for child in node.children:\n            if child.char == char:\n                child.counter.add(i)\n                node = child\n                found_in_child = True\n                break\n        if not found_in_child:\n            new_node = TrieNode(char)\n            node.children.append(new_node)\n            node.children[-1].counter.add(i)\n            new_node.level = l\n            node = new_node\nfor i in range(int(input())):\n    n = int(input())\n    root = TrieNode('*')\n    root2 = TrieNode('*')\n    st = []\n    for j in range(n):\n        st.append(input())\n        add(root, st[-1], j)\n        add(root2, st[-1][::-1], j)\n    queue = [root]\n    l = []\n    l.append([])\n    while len(queue) != 0:\n        node = queue[0]\n        queue.pop(0)\n        for i in node.children:\n            if len(i.counter) >= 2:\n                if i.level + 1 > len(l):\n                    l.append([])\n                l[i.level].append(i.counter)\n                queue.append(i)\n    lr = []\n    lr.append([])\n    queue = []\n    queue = [root2]\n    while len(queue) != 0:\n        node = queue[0]\n        queue.pop(0)\n        for i in node.children:\n            if len(i.counter) >= 2:\n                if i.level + 1 > len(lr):\n                    lr.append([])\n                lr[i.level].append(i.counter)\n                queue.append(i)\n    il = min(len(l), len(lr)) - 1\n    m = []\n    for j in range(len(st)):\n        m.append(0)\n    score = 0\n    tag = 0\n    while il > 0:\n        for j in l[il]:\n            for z in lr[il]:\n                t = j & z\n                c = 0\n                for k in t:\n                    if m[k] == 0:\n                        c += 1\n                        tag = k\n                        m[k] = 1\n                if c % 2 == 0:\n                    score += c / 2 * il ** 2\n                else:\n                    m[tag] = 0\n                    score += c // 2 * il ** 2\n        il -= 1\n    print(int(score))", "import os.path\nimport sys\nsys.setrecursionlimit(100000000)\n\ndef prefix(a, b):\n    return len(os.path.commonprefix([a, b])) // 2\n\ndef mingle(x):\n    (left, right) = (0, len(x) - 1)\n    out = ''\n    while right >= 0:\n        out += x[left]\n        out += x[right]\n        left += 1\n        right -= 1\n    return out\n\ndef optimal(n, paired, i):\n    if n >= len(buckets[i]) - 1:\n        return (0, [])\n    if memo[n] != -1:\n        return memo[n]\n    (a, b) = (buckets[i][n], buckets[i][n + 1])\n    pre = prefix(a, b)\n    value = pre ** 2\n    (a, pa) = optimal(n + 2, [], i)\n    a += value\n    (b, pb) = optimal(n + 1, [], i)\n    if a > b:\n        ans = a\n        paired += [n, n + 1] + pa\n    else:\n        ans = b\n        paired += pb\n    memo[n] = (ans, paired)\n    return (ans, paired)\n\ndef beauties(l):\n    return [prefix(l[i], l[i + 1]) for i in range(len(l) - 1)]\noriginal = {}\nans = []\nfor t in range(int(input())):\n    buckets = {}\n    n = int(input())\n    for i in range(n):\n        temp = input()\n        out = mingle(temp)\n        iden = temp[0] + temp[-1]\n        if iden in buckets:\n            buckets[iden].append(out)\n        else:\n            buckets[iden] = [out]\n        original[out] = temp\n    value = 0\n    for i in buckets:\n        lenn = len(buckets[i])\n        if lenn == 1:\n            continue\n        buckets[i].sort()\n        if lenn > 1000:\n            while True:\n                memo = [-1 for i in range(n)]\n                choice = optimal(0, [], i)\n                if choice[0] == 0:\n                    break\n                value += choice[0]\n                for (j, idx) in enumerate(choice[1]):\n                    del buckets[i][idx - j]\n        else:\n            l = beauties(buckets[i])\n            possible = []\n            for i in range(len(l)):\n                m = float('inf')\n                for j in range(i, len(l)):\n                    if l[j] < m:\n                        m = l[j]\n                    if m == 0:\n                        break\n                    possible.append((m ** 2, i, j + 1))\n            possible.sort(reverse=True)\n            used = set()\n            for (m, i, j) in possible:\n                if i in used or j in used:\n                    continue\n                used.add(i)\n                used.add(j)\n                value += m\n    ans.append(str(value))\nprint('\\n'.join(ans))", "def maxxx(s, w):\n    maxx = -1\n    bb = 0\n    rhyme = -1\n    for i in w:\n        if i == s:\n            continue\n        count = 0\n        while count < len(i) and count < len(s) and (i[count] == s[count]) and (i[len(i) - count - 1] == s[len(s) - count - 1]):\n            count += 1\n        bb = count ** 2\n        if bb > maxx and bb > 0:\n            maxx = bb\n            rhyme = i\n    return (rhyme, maxx)\ntry:\n    t = int(input())\n    for r in range(t):\n        n = int(input())\n        words = []\n        done = {}\n        to = 0\n        for i in range(n):\n            s = input()\n            if s in done:\n                to += len(s) ** 2\n                del done[s]\n            else:\n                done[s] = 1\n                if s not in words:\n                    words.append(s)\n        w = []\n        for i in words:\n            if i in done:\n                w.append(i)\n        w.sort()\n        while len(w) > 1:\n            a = []\n            i = w[0]\n            tt = i\n            while tt not in a:\n                a.append(tt)\n                m = maxxx(tt, w)\n                if m[0] == -1:\n                    w.pop(w.index(tt))\n                    tt = w[0]\n                    break\n                k = maxxx(m[0], w)\n                if k[0] == tt:\n                    to += k[1]\n                    w.pop(w.index(tt))\n                    w.pop(w.index(m[0]))\n                    break\n                tt = m[0]\n        print(to)\nexcept:\n    pass", "def findmax(x, w):\n    max = -1\n    beauty = 0\n    verse = -1\n    for i in w:\n        if i == x:\n            continue\n        c = 0\n        while c < len(i) and c < len(x) and (i[c] == x[c]) and (i[len(i) - c - 1] == x[len(x) - c - 1]):\n            c += 1\n        beauty = c ** 2\n        if beauty > max and beauty > 0:\n            max = beauty\n            verse = i\n    return (verse, max)\nfor _ in range(int(input())):\n    n = int(input())\n    Words = []\n    d = {}\n    maxlen = 0\n    total = 0\n    for i in range(n):\n        x = input()\n        if x in d:\n            total += len(x) ** 2\n            del d[x]\n        else:\n            d[x] = 1\n            if x not in Words:\n                Words.append(x)\n    W = []\n    for i in Words:\n        if i in d:\n            W.append(i)\n    W.sort()\n    while len(W) > 1:\n        a = []\n        i = W[0]\n        temp = i\n        while temp not in a:\n            a.append(temp)\n            m = findmax(temp, W)\n            if m[0] == -1:\n                W.pop(W.index(temp))\n                temp = W[0]\n                break\n            k = findmax(m[0], W)\n            if k[0] == temp:\n                total += k[1]\n                W.pop(W.index(temp))\n                W.pop(W.index(m[0]))\n                break\n            temp = m[0]\n    print(total)", "T = int(input())\nwhile T:\n    N = int(input())\n    ls = []\n    for i in range(N):\n        W = input()\n        ls.append(W)\n    ls.sort()\n    ans = 0\n    new_ls = []\n    count = 0\n    for i in range(N):\n        if i == 0:\n            count += 1\n            if i == N - 1:\n                ans += len(ls[i]) ** 2 * (count // 2)\n                if count % 2 != 0:\n                    new_ls.append(ls[i])\n        elif ls[i] == ls[i - 1]:\n            count += 1\n            if i == N - 1:\n                ans += len(ls[i]) ** 2 * (count // 2)\n                if count % 2 != 0:\n                    new_ls.append(ls[i])\n        else:\n            ans += len(ls[i - 1]) ** 2 * (count // 2)\n            if count % 2 != 0:\n                new_ls.append(ls[i - 1])\n            count = 1\n            if i == N - 1:\n                ans += len(ls[i]) ** 2 * (count // 2)\n                if count % 2 != 0:\n                    new_ls.append(ls[i])\n    greedy = []\n    for i in range(len(new_ls)):\n        for j in range(i + 1, len(new_ls)):\n            score = 0\n            for k in range(min(len(new_ls[i]), len(new_ls[j]))):\n                if new_ls[i][k] == new_ls[j][k] and new_ls[i][len(new_ls[i]) - k - 1] == new_ls[j][len(new_ls[j]) - k - 1]:\n                    score += 1\n                else:\n                    break\n            greedy.append([score, new_ls[i], new_ls[j]])\n    greedy.sort(reverse=True)\n    a = set()\n    for i in range(len(greedy)):\n        if greedy[i][1] not in a and greedy[i][2] not in a:\n            ans += greedy[i][0] ** 2\n            a.add(greedy[i][1])\n            a.add(greedy[i][2])\n    print(ans)\n    T -= 1"]