["import collections\n\ndef ii():\n    return int(input())\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(map(int, input().split()))\nfor i in range(ii()):\n    n = ii()\n    A = li()\n    B = li()\n    temp = 1\n    for i in range(n):\n        if A[i] < B[i]:\n            temp = 0\n    if temp == 0:\n        print(-1)\n    else:\n        D = collections.deque([])\n        ans = 0\n        for i in range(n):\n            while D and D[-1] < B[i]:\n                D.pop()\n            while D and D[0] > A[i]:\n                D.popleft()\n            if A[i] != B[i]:\n                if len(D) == 0:\n                    ans += 1\n                    D.append(B[i])\n                elif B[i] != D[-1]:\n                    ans += 1\n                    D.append(B[i])\n        print(ans)", "import collections\n\ndef ii():\n    return int(input())\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(map(int, input().split()))\nfor i in range(ii()):\n    n = ii()\n    A = li()\n    B = li()\n    temp = 1\n    for i in range(n):\n        if A[i] < B[i]:\n            temp = 0\n    if temp == 0:\n        print(-1)\n    else:\n        D = collections.deque([])\n        ans = 0\n        for i in range(n):\n            while D and D[-1] < B[i]:\n                D.pop()\n            while D and D[0] > A[i]:\n                D.popleft()\n            if A[i] != B[i]:\n                if len(D) == 0:\n                    ans += 1\n                    D.append(B[i])\n                elif B[i] != D[-1]:\n                    ans += 1\n                    D.append(B[i])\n        print(ans)", "import collections\n\ndef ii():\n    return int(input())\n\ndef mi():\n    return map(int, input().split())\n\ndef li():\n    return list(map(int, input().split()))\nfor i in range(ii()):\n    n = ii()\n    A = li()\n    B = li()\n    temp = 1\n    for i in range(n):\n        if A[i] < B[i]:\n            temp = 0\n    if temp == 0:\n        print(-1)\n    else:\n        D = collections.deque([])\n        ans = 0\n        for i in range(n):\n            while D and D[-1] < B[i]:\n                D.pop()\n            while D and D[0] > A[i]:\n                D.popleft()\n            if A[i] != B[i]:\n                if len(D) == 0:\n                    ans += 1\n                    D.append(B[i])\n                elif B[i] != D[-1]:\n                    ans += 1\n                    D.append(B[i])\n        print(ans)", "import collections\ndebug = False\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    if debug:\n        print('A', A)\n        print('B', B)\n    isPossible = True\n    ans = 0\n    q = collections.deque()\n    for i in range(len(A)):\n        if A[i] < B[i]:\n            isPossible = False\n    if isPossible:\n        for i in range(len(A)):\n            while len(q) > 0 and q[-1] < B[i]:\n                q.pop()\n            while len(q) > 0 and q[0] > A[i]:\n                q.popleft()\n            if A[i] != B[i] and (len(q) == 0 or B[i] != q[-1]):\n                ans += 1\n                q.append(B[i])\n        print(ans)\n    else:\n        print(-1)", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = [int(c) for c in input().strip().split()]\n    B = [int(c) for c in input().strip().split()]\n    H = A[:]\n    diff = sum(A) - sum(B)\n    for i in range(len(A)):\n        if B[i] > A[i]:\n            op = -1\n            break\n    else:\n        op = 0\n    if op == -1:\n        print(-1)\n        continue\n    queue = []\n    i = 0\n    while i < len(H):\n        if H[i] - B[i] > 0:\n            break\n        i += 1\n    while i < len(H):\n        while len(queue) != 0:\n            if A[i] < queue[0]:\n                queue.pop(0)\n            else:\n                break\n        while len(queue) != 0:\n            if B[i] > queue[-1]:\n                queue.pop()\n            else:\n                break\n        if len(queue) == 0 or queue[-1] != B[i]:\n            if H[i] != B[i]:\n                queue.append(B[i])\n                op += 1\n        i += 1\n    print(op)", "from collections import deque\nfor x in range(int(input())):\n    n = int(input())\n    count = 0\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    q = deque()\n    for i in range(n):\n        if a[i] < b[i]:\n            count = -1\n    if count == 0:\n        for i in range(n):\n            while q and b[i] > q[-1]:\n                q.pop()\n            while q and a[i] < q[0]:\n                q.popleft()\n            if a[i] != b[i] and (not q or b[i] != q[-1]):\n                count += 1\n                q.append(b[i])\n    print(count)", "for t in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    impossible = False\n    cutting = []\n    r = 0\n    for i in range(n):\n        if a[i] < b[i]:\n            impossible = True\n            print(-1)\n            break\n        while cutting and cutting[-1] < b[i]:\n            cutting.pop()\n            r += 1\n        while cutting and cutting[0] > a[i]:\n            cutting.pop(0)\n            r += 1\n        if a[i] > b[i] and (not cutting or not cutting[-1] == b[i]):\n            cutting.append(b[i])\n    if not impossible:\n        r += len(cutting)\n        print(r)", "for t in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    impossible = False\n    cutting = []\n    r = 0\n    for i in range(n):\n        if a[i] < b[i]:\n            impossible = True\n            print(-1)\n            break\n        while cutting and cutting[-1] < b[i]:\n            cutting.pop()\n            r += 1\n        while cutting and cutting[0] > a[i]:\n            cutting.pop(0)\n            r += 1\n        if a[i] > b[i] and (not cutting or cutting[-1] != b[i]):\n            cutting.append(b[i])\n    if not impossible:\n        r += len(cutting)\n        print(r)", "for t in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    impossible = False\n    cutting = []\n    r = 0\n    for i in range(n):\n        if a[i] < b[i]:\n            impossible = True\n            print(-1)\n            break\n        while cutting and cutting[-1] < b[i]:\n            cutting.pop()\n            r += 1\n        while cutting and cutting[0] > a[i]:\n            cutting.pop(0)\n            r += 1\n        if a[i] > b[i] and (not cutting or not cutting[-1] == b[i]):\n            cutting.append(b[i])\n    if not impossible:\n        r += len(cutting)\n        print(r)", "for t in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    impossible = False\n    cutting = []\n    r = 0\n    for i in range(n):\n        if a[i] < b[i]:\n            impossible = True\n            print(-1)\n            break\n        while cutting and cutting[-1] < b[i]:\n            cutting.pop()\n            r += 1\n        while cutting and cutting[0] > a[i]:\n            cutting.pop(0)\n            r += 1\n        if a[i] > b[i] and (not cutting or not cutting[-1] == b[i]):\n            cutting.append(b[i])\n    if not impossible:\n        r += len(cutting)\n        print(r)", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    flag = 0\n    for i in range(n):\n        if B[i] > A[i]:\n            print('-1')\n            flag = 1\n            break\n    if flag == 0:\n        count = 0\n        t = deque()\n        for i in range(n):\n            while t and t[0] > A[i]:\n                t.popleft()\n            while t and t[-1] < B[i]:\n                t.pop()\n            if not t and A[i] != B[i]:\n                t.append(B[i])\n                count += 1\n            elif t and t[-1] != B[i] and (A[i] != B[i]):\n                t.append(B[i])\n                count += 1\n        print(count)", "from collections import deque\nT = int(input())\nfor test_case in range(T):\n    n = int(input())\n    init = list(map(int, input().split()))\n    req = list(map(int, input().split()))\n    ans = 0\n    dq = deque()\n    x = 0\n    for i in range(0, n):\n        if init[i] < req[i]:\n            x = -1\n    if x != -1:\n        for i in range(0, n):\n            while dq and dq[0] > init[i]:\n                dq.popleft()\n            while dq and dq[-1] < req[i]:\n                dq.pop()\n            if init[i] != req[i] and (not dq or dq[-1] != req[i]):\n                ans = ans + 1\n                dq.append(req[i])\n        print(ans)\n    else:\n        print('-1')", "for t in range(int(input())):\n    n = int(input())\n    a = [int(i) for i in input().split()]\n    b = [int(i) for i in input().split()]\n    impossible = False\n    cutting = []\n    r = 0\n    for i in range(n):\n        if a[i] < b[i]:\n            impossible = True\n            print(-1)\n            break\n        while cutting and cutting[-1] < b[i]:\n            cutting.pop()\n            r += 1\n        while cutting and cutting[0] > a[i]:\n            cutting.pop(0)\n            r += 1\n        if a[i] > b[i] and (not cutting or not cutting[-1] == b[i]):\n            cutting.append(b[i])\n    if not impossible:\n        r += len(cutting)\n        print(r)", "from collections import deque\n\ndef solve(plant_count, init_heights, target_heights):\n    answer = 0\n    cuts = deque()\n    for i in range(plant_count):\n        if init_heights[i] < target_heights[i]:\n            return -1\n        while cuts and cuts[-1] < target_heights[i]:\n            cuts.pop()\n        while cuts and cuts[0] > init_heights[i]:\n            cuts.popleft()\n        if init_heights[i] > target_heights[i]:\n            if not cuts:\n                answer += 1\n                cuts.append(target_heights[i])\n            elif cuts[-1] != target_heights[i]:\n                answer += 1\n                cuts.append(target_heights[i])\n    return answer\n\ndef solve0(plant_count, init_heights, target_heights):\n    cuts = 0\n    for i in range(plant_count):\n        if init_heights[i] < target_heights[i]:\n            return -1\n        if init_heights[i] <= target_heights[i]:\n            continue\n        cuts += 1\n        cut_height = target_heights[i]\n        for j in range(i, plant_count):\n            if init_heights[j] < cut_height or target_heights[j] > cut_height:\n                break\n            init_heights[j] = cut_height\n    return cuts\n\ndef main():\n    import sys\n    sys.setrecursionlimit(1000000)\n    test_cases = int(sys.stdin.readline())\n    for _ in range(test_cases):\n        plant_count = int(sys.stdin.readline())\n        init_heights = [int(i) for i in sys.stdin.readline().split()]\n        target_heights = [int(i) for i in sys.stdin.readline().split()]\n        print(solve(plant_count, init_heights, target_heights))\nmain()", "from collections import deque\nfor _ in range(int(input())):\n    n = int(input())\n    q = deque()\n    ans = 0\n    init = list(map(int, input().split()))\n    final = list(map(int, input().split()))\n    for i in range(n):\n        if init[i] < final[i]:\n            ans = -1\n            break\n    if ans == -1:\n        print(ans)\n    else:\n        cnt = 0\n        for i in range(n):\n            while q and q[0] > init[i]:\n                q.popleft()\n                cnt += 1\n            while q and q[-1] < final[i]:\n                q.pop()\n                cnt += 1\n            if q:\n                if final[i] != init[i] and final[i] != q[-1]:\n                    q.append(final[i])\n            elif final[i] != init[i]:\n                q.append(final[i])\n        print(len(q) + cnt)", "from collections import defaultdict as dd, deque\nt = int(input())\ninf = 10 ** 15\n\nclass Segment:\n\n    def __init__(S, n):\n        sz = 1\n        while sz < n:\n            sz <<= 1\n        S.data = [0] * (n + sz)\n        S.sz = sz\n\n    def sum(S, l, r):\n        sz = S.sz\n        data = S.data\n        S = 0\n        l += sz\n        r += sz\n        while l < r:\n            if l % 2 == 1:\n                S += data[l]\n                l += 1\n            if r % 2 == 1:\n                r -= 1\n                S += data[r]\n            l >>= 1\n            r >>= 1\n        return S\n\n    def inc(S, pos):\n        pos += S.sz\n        while pos > 0:\n            S.data[pos] += 1\n            pos >>= 1\n\nclass MinSegment:\n\n    def __init__(S, n):\n        sz = 1\n        while sz < n:\n            sz <<= 1\n        S.data = [inf] * (n + sz)\n        S.sz = sz\n\n    def min(S, l, r):\n        sz = S.sz\n        data = S.data\n        mini = inf\n        l += sz\n        r += sz\n        while l < r:\n            if l % 2 == 1:\n                mini = min(mini, data[l])\n                l += 1\n            if r % 2 == 1:\n                r -= 1\n                mini = min(mini, data[r])\n            l >>= 1\n            r >>= 1\n        return mini\n\n    def set(S, pos, value):\n        pos += S.sz\n        data = S.data\n        if data[pos] > value:\n            while pos > 0 and data[pos] > value:\n                data[pos] = value\n                pos >>= 1\n        elif data[pos] < value:\n            data[pos] = value\n            pos >>= 1\n            while pos > 0:\n                data[pos] = min(data[pos * 2], data[pos * 2 + 1])\n                pos >>= 1\n\ndef solve():\n    n = int(input())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    for i in range(n):\n        if B[i] > A[i]:\n            return -1\n    D = dd(list)\n    for i in range(n):\n        D[B[i]].append(i)\n    locked = Segment(n)\n    mini = MinSegment(n)\n    for i in range(n):\n        mini.set(i, A[i])\n    D = sorted(D.items(), reverse=True)\n    cnt = 0\n    for (v, I) in D:\n        i = 0\n        while i < len(I):\n            a = I[i]\n            locked.inc(a)\n            if A[a] > v:\n                A[a] = v\n                cnt += 1\n                while i + 1 < len(I):\n                    b = I[i + 1]\n                    if locked.sum(a + 1, b) == 0 and v <= mini.min(a + 1, b):\n                        locked.inc(b)\n                        i += 1\n                        a = I[i]\n                    else:\n                        break\n            i += 1\n    return cnt\nfor _ in range(t):\n    print(solve())", "for t in range(int(input())):\n    N = int(input())\n    A = [int(x) for x in input().split()]\n    B = [int(x) for x in input().split()]\n    (cut, stack, prevh, maxheight) = (0, [], B[0], A[0])\n    for x in range(N):\n        if A[x] < B[x]:\n            print(-1)\n            break\n        if maxheight > A[x]:\n            cut += len(stack)\n            stack = [y for y in stack if y <= A[x]]\n            cut -= len(stack)\n        if B[x] > prevh:\n            while stack != []:\n                if stack[-1] < B[x]:\n                    stack.pop()\n                    cut += 1\n                else:\n                    break\n        if B[x] < A[x]:\n            if stack == []:\n                stack.append(B[x])\n            elif stack[-1] != B[x]:\n                stack.append(B[x])\n        (maxheight, prevh) = (A[x], B[x])\n    else:\n        cut += len(stack)\n        print(cut)", "def take2(elem):\n    return elem[0]\n\ndef fun(i, n):\n    order = [0] * n\n    for i in range(n):\n        order[i] = [0] * 2\n        order[i][0] = brr[i]\n        order[i][1] = int(i)\n    order = sorted(order, key=take2)\n    status = [0] * n\n    (flag, tot) = (0, 0)\n    for i in range(n - 1, -1, -1):\n        j = order[i][1]\n        if c[j] < brr[j]:\n            flag = 1\n            tot = -1\n            break\n        if status[j] == 0 and c[j] != brr[j]:\n            if c[j] > brr[j]:\n                c[j] = brr[j]\n                tot += 1\n                status[j] = 1\n            for k in range(j - 1, -1, -1):\n                if c[k] >= brr[j] and brr[k] <= brr[j]:\n                    c[k] = brr[j]\n                else:\n                    break\n                if c[k] == brr[k]:\n                    status[k] = 1\n    return tot\n\ndef calculate(i, n):\n    stack = []\n    ref = []\n    cut = 0\n    ht = 0\n    (i, flag, inc, count) = (0, 0, 0, 0)\n    while i < n:\n        if arr[i] < brr[i]:\n            flag = 1\n            break\n        elif arr[i] > brr[i]:\n            stack.append(brr[i])\n            ref.append(arr[i])\n            cut = brr[i]\n            count += 1\n            i += 1\n            while i < n:\n                same = 0\n                if arr[i] == brr[i]:\n                    same = 1\n                if arr[i] < brr[i]:\n                    flag = 1\n                    break\n                if len(stack) == 0:\n                    if arr[i] != brr[i]:\n                        cut = brr[i]\n                        stack.append(brr[i])\n                        ref.append(arr[i])\n                        count += 1\n                elif cut <= brr[i]:\n                    cut = brr[i]\n                    while len(stack) != 0 and stack[len(stack) - 1] <= brr[i]:\n                        if brr[i] > ref[len(stack) - 1]:\n                            stack = []\n                            ref = []\n                            if same == 0:\n                                stack.append(brr[i])\n                                ref.append(arr[i])\n                                count += 1\n                            break\n                        if brr[i] == stack[len(stack) - 1]:\n                            if arr[i] < ref[len(stack) - 1]:\n                                ref[len(stack) - 1] = arr[i]\n                                if len(stack) > 1:\n                                    if stack[len(stack) - 2] > arr[i]:\n                                        stack = []\n                                        ref = []\n                                        stack.append(brr[i])\n                                        ref.append(arr[i])\n                                inc = 1\n                            break\n                        stack.pop()\n                        if arr[i] == brr[i]:\n                            ref.pop()\n                        else:\n                            arr[i] = min(ref.pop(), arr[i])\n                    if len(stack) == 0:\n                        if same == 0:\n                            stack.append(brr[i])\n                            ref.append(arr[i])\n                            if inc == 0:\n                                count += 1\n                    elif brr[i] < stack[len(stack) - 1]:\n                        if arr[i] < stack[len(stack) - 1]:\n                            stack = []\n                            ref = []\n                        if same == 0:\n                            stack.append(brr[i])\n                            ref.append(arr[i])\n                            if inc == 0:\n                                count += 1\n                    inc = 0\n                elif arr[i] < cut:\n                    stack = []\n                    ref = []\n                    if arr[i] != brr[i]:\n                        cut = brr[i]\n                        stack.append(brr[i])\n                        ref.append(arr[i])\n                        count += 1\n                else:\n                    cut = brr[i]\n                    stack.append(brr[i])\n                    ref.append(arr[i])\n                    count += 1\n                i += 1\n        i += 1\n    if flag == 1:\n        return -1\n    else:\n        return count\nt = int(input())\nfor l in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    brr = list(map(int, input().split()))\n    print(calculate(0, n))", "T = int(input())\nfor test_case in range(T):\n    N = int(input())\n    I = list(map(int, input().split()))\n    F = list(map(int, input().split()))\n    ans = N\n    chk = list()\n    for (i, f) in list(zip(I, F)):\n        if f > i:\n            ans = -1\n            break\n        while len(chk) > 0 and f > chk[-1][1]:\n            del chk[-1]\n        if len(chk) == 0:\n            if i == f:\n                ans -= 1\n            chk.append((i, f))\n        elif f < chk[-1][1]:\n            if i == f:\n                ans -= 1\n                chk = [(i, f)]\n            else:\n                while len(chk) > 0 and i < chk[0][1]:\n                    del chk[0]\n                chk.append((i, f))\n        elif f == chk[-1][1]:\n            if i == f or chk[-1][0] != chk[-1][1] or (len(chk) > 1 and chk[-2][1] == f):\n                ans -= 1\n            while len(chk) > 0 and i < chk[0][1]:\n                del chk[0]\n            chk.append((i, f))\n    print(ans)", "class Node:\n\n    def __init__(self, val, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def __str__(self):\n        return '< Node with the value = ' + str(self.val) + ' >'\n\nclass Deque:\n\n    def __init__(self):\n        self.left = None\n        self.right = None\n\n    def is_empty(self):\n        return self.left is None\n\n    def push_left(self, val):\n        node = Node(val, right=self.left)\n        self.left = node\n        if self.right is None:\n            self.right = node\n        else:\n            self.left.right.left = node\n\n    def push_right(self, val):\n        node = Node(val, left=self.right)\n        self.right = node\n        if self.left is None:\n            self.left = node\n        else:\n            self.right.left.right = node\n\n    def pop_left(self):\n        if self.left is None:\n            raise IndexError\n        res = self.left.val\n        self.left = self.left.right\n        if self.left is None:\n            self.right = None\n        else:\n            self.left.left = None\n        return res\n\n    def pop_right(self):\n        if self.right is None:\n            raise IndexError\n        res = self.right.val\n        self.right = self.right.left\n        if self.right is None:\n            self.left = None\n        else:\n            self.right.right = None\n        return res\nT = int(input())\nfor query in range(T):\n    N = int(input())\n    A = [int(v) for v in input().split()]\n    B = [int(v) for v in input().split()]\n    cuts = Deque()\n    count = 0\n    for i in range(N):\n        if A[i] < B[i]:\n            print(-1)\n            break\n        while not cuts.is_empty() and cuts.left.val > A[i]:\n            cuts.pop_left()\n        while not cuts.is_empty() and cuts.right.val < B[i]:\n            cuts.pop_right()\n        if not cuts.is_empty():\n            if cuts.right.val > B[i]:\n                cuts.push_right(B[i])\n                count += 1\n        elif A[i] > B[i]:\n            cuts.push_right(B[i])\n            count += 1\n    else:\n        print(count)"]