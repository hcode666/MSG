["from math import sqrt\nfrom bisect import bisect_left, bisect\n\ndef sieve():\n    n = 10 ** 6 + 1\n    spf[1] = 1\n    for i in range(2, n):\n        spf[i] = i\n    for i in range(4, n, 2):\n        spf[i] = 2\n    for i in range(3, int(sqrt(n - 1)) + 1):\n        if spf[i] == i:\n            for j in range(i * i, n, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef pfactorization(n):\n    factors = []\n    while n != 1:\n        factors.append(spf[n])\n        n = n // spf[n]\n    return factors\n\ndef build():\n    i = n - 1\n    while i > 0:\n        tree[i] = sorted(tree[i << 1] + tree[i << 1 | 1])\n        i -= 1\n\ndef query(l, r, x, y):\n    ans = 0\n    l += n\n    r += n\n    while l < r:\n        if l & 1:\n            forx = bisect_left(tree[l], x)\n            fory = bisect(tree[l], y)\n            ans += fory - forx\n            l += 1\n        if r & 1:\n            r -= 1\n            forx = bisect_left(tree[r], x)\n            fory = bisect(tree[r], y)\n            ans += fory - forx\n        l >>= 1\n        r >>= 1\n    return ans\nspf = [0 for i in range(10 ** 6 + 1)]\nsieve()\nn = int(input())\narray = list(map(int, input().split()))\npf = [pfactorization(array[i]) for i in range(n)]\ntree = [0] * 2 * n\nfor i in range(n):\n    tree[i + n] = pf[i]\nbuild()\nq = int(input())\nfor _ in range(q):\n    (l, r, x, y) = map(int, input().split())\n    print(query(l - 1, r, x, y))", "from math import sqrt\nfrom bisect import bisect_left, bisect\n\ndef sieve():\n    n = 10 ** 6 + 1\n    spf[1] = 1\n    for i in range(2, n):\n        spf[i] = i\n    for i in range(4, n, 2):\n        spf[i] = 2\n    for i in range(3, int(sqrt(n - 1)) + 1):\n        if spf[i] == i:\n            for j in range(i * i, n, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef pfactorization(n):\n    factors = []\n    while n != 1:\n        factors.append(spf[n])\n        n = n // spf[n]\n    return factors\n\ndef build():\n    i = n - 1\n    while i > 0:\n        tree[i] = sorted(tree[i << 1] + tree[i << 1 | 1])\n        i -= 1\n\ndef query(l, r, x, y):\n    ans = 0\n    l += n\n    r += n\n    while l < r:\n        if l & 1:\n            forx = bisect_left(tree[l], x)\n            fory = bisect(tree[l], y)\n            ans += fory - forx\n            l += 1\n        if r & 1:\n            r -= 1\n            forx = bisect_left(tree[r], x)\n            fory = bisect(tree[r], y)\n            ans += fory - forx\n        l >>= 1\n        r >>= 1\n    return ans\nspf = [0 for i in range(10 ** 6 + 1)]\nsieve()\nn = int(input())\narray = list(map(int, input().split()))\npf = [pfactorization(array[i]) for i in range(n)]\ntree = [0] * 2 * n\nfor i in range(n):\n    tree[i + n] = pf[i]\nbuild()\nq = int(input())\nfor _ in range(q):\n    (l, r, x, y) = map(int, input().split())\n    print(query(l - 1, r, x, y))", "from bisect import bisect, bisect_left\nmaxn = 10 ** 6 + 100\n\ndef sieve_with_spf():\n    for i in range(4, maxn, 2):\n        spf[i] = 2\n    i = 3\n    while i * i < maxn:\n        if spf[i] == i:\n            j = i * i\n            while j < maxn:\n                if spf[j] == j:\n                    spf[j] = i\n                j += i\n        i += 1\nN = 10 ** 2 << 1\nt = [0] * (N << 1)\n\ndef build():\n    for i in range(n - 1, 0, -1):\n        t[i] = sorted(t[i << 1] + t[i << 1 | 1])\n\ndef query(l, r, x, y):\n    (res, l, r) = (0, l + n, r + n)\n    while l < r:\n        if l & 1:\n            (res, l) = (res + bisect(t[l], y) - bisect_left(t[l], x), l + 1)\n        if r & 1:\n            r -= 1\n            res += bisect(t[r], y) - bisect_left(t[r], x)\n        (l, r) = (l >> 1, r >> 1)\n    return res\n\ndef getFactorization(n, res):\n    while n != 1:\n        res.append(spf[n])\n        n //= spf[n]\n    return res\nspf = [i for i in range(maxn)]\nsieve_with_spf()\n(n, arr) = (int(input()), list(map(int, input().split())))\npF = [getFactorization(arr[i], []) for i in range(n)]\nt = [0 for _ in range(n)] + pF + t\nbuild()\nfor _ in range(int(input())):\n    (left, right, x, y) = map(int, input().split())\n    print(query(left - 1, right, x, y))", "import bisect\nb = bisect.bisect\nbl = bisect.bisect_left\nfrom sys import stdin, stdout\nmx = 10 ** 6 + 1\n\ndef soe():\n    for i in range(4, mx, 2):\n        ar[i] = 2\n    for i in range(3, 1001):\n        if ar[i] == i:\n            for j in range(i ** 2, mx, i):\n                if ar[j] == j:\n                    ar[j] = i\nar = [x for x in range(mx)]\nsoe()\nar1 = [0] * 400\nn = int(stdin.readline())\nlz = list(map(int, stdin.readline().split()))\nq = int(stdin.readline())\n(l1, l3) = ([], [0] * n)\nfor i in range(n):\n    l2 = []\n    k = lz[i]\n    while k != 1:\n        l2.append(ar[k])\n        k //= ar[k]\n    l1.append(l2)\nar1 = l3 + l1 + ar1\nfor i in range(n - 1, 0, -1):\n    ar1[i] = sorted(ar1[i << 1] + ar1[i << 1 | 1])\nfor i in range(q):\n    (l, r, x, y) = map(int, stdin.readline().split())\n    ans = 0\n    l += n - 1\n    r += n\n    while l < r:\n        if l & 1:\n            ans += b(ar1[l], y) - bl(ar1[l], x)\n            l += 1\n        if r & 1:\n            ans += b(ar1[r - 1], y) - bl(ar1[r - 1], x)\n            r -= 1\n        l >>= 1\n        r >>= 1\n    stdout.write(str(ans) + '\\n')", "import bisect\nb = bisect.bisect\nbl = bisect.bisect_left\nfrom sys import stdin, stdout\nmx = 10 ** 6 + 1\n\ndef soe():\n    ar = [x for x in range(mx)]\n    for i in range(4, mx, 2):\n        ar[i] = 2\n    for i in range(3, 1001):\n        if ar[i] == i:\n            for j in range(i ** 2, mx, i):\n                if ar[j] == j:\n                    ar[j] = i\n    return ar\nar = soe()\nar1 = [0] * 400\nn = int(stdin.readline())\nlz = list(map(int, stdin.readline().split()))\nq = int(stdin.readline())\n(l1, l3) = ([], [0] * n)\nfor i in range(n):\n    l2 = []\n    k = lz[i]\n    while k != 1:\n        l2.append(ar[k])\n        k //= ar[k]\n    l1.append(l2)\nar1 = l3 + l1 + ar1\nfor i in range(n - 1, 0, -1):\n    ar1[i] = sorted(ar1[i << 1] + ar1[i << 1 | 1])\nfor i in range(q):\n    (l, r, x, y) = map(int, stdin.readline().split())\n    ans = 0\n    l += n - 1\n    r += n\n    while l < r:\n        if l & 1:\n            ans += b(ar1[l], y) - bl(ar1[l], x)\n            l += 1\n        if r & 1:\n            ans += b(ar1[r - 1], y) - bl(ar1[r - 1], x)\n            r -= 1\n        l >>= 1\n        r >>= 1\n    stdout.write(str(ans) + '\\n')"]