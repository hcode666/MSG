["import sys\n\ndef read_coord():\n    (x, y, d) = sys.stdin.readline().rstrip().split()\n    (dx, dy) = {'U': (0.0, 1.0), 'D': (0.0, -1.0), 'L': (-1.0, 0.0), 'R': (1.0, 0.0)}[d]\n    return (float(x), float(y), dx, dy)\n\ndef read_int():\n    return int(sys.stdin.readline().rstrip())\ntestcases = read_int()\nfor _ in range(0, testcases):\n    (xe, ye, dxe, dye) = read_coord()\n    collision = None\n    asteroids = read_int()\n    for _ in range(0, asteroids):\n        (xa, ya, dxa, dya) = read_coord()\n        dxa -= dxe\n        dya -= dye\n        candidate = None\n        if dxa != 0.0:\n            t = (xe - xa) / dxa\n            if ya + t * dya == ye:\n                candidate = t\n        elif dya != 0.0:\n            t = (ye - ya) / dya\n            if xa + t * dxa == xe:\n                candidate = t\n        if candidate is not None and candidate > 0:\n            if collision is None or collision > candidate:\n                collision = candidate\n    if collision is None:\n        print('SAFE')\n    else:\n        print('%.1f' % collision)", "import sys\n\ndef read_coord():\n    (x, y, d) = sys.stdin.readline().rstrip().split()\n    (dx, dy) = {'U': (0.0, 1.0), 'D': (0.0, -1.0), 'L': (-1.0, 0.0), 'R': (1.0, 0.0)}[d]\n    return (float(x), float(y), dx, dy)\n\ndef read_int():\n    return int(sys.stdin.readline().rstrip())\ntestcases = read_int()\nfor _ in range(0, testcases):\n    (xe, ye, dxe, dye) = read_coord()\n    collision = None\n    asteroids = read_int()\n    for _ in range(0, asteroids):\n        (xa, ya, dxa, dya) = read_coord()\n        dxa -= dxe\n        dya -= dye\n        candidate = None\n        if dxa != 0.0:\n            t = (xe - xa) / dxa\n            if ya + t * dya == ye:\n                candidate = t\n        elif dya != 0.0:\n            t = (ye - ya) / dya\n            if xa + t * dxa == xe:\n                candidate = t\n        if candidate is not None and candidate > 0:\n            if collision is None or collision > candidate:\n                collision = candidate\n    if collision is None:\n        print('SAFE')\n    else:\n        print('%.1f' % collision)", "import sys\n\ndef read_coord():\n    (x, y, d) = sys.stdin.readline().rstrip().split()\n    (dx, dy) = {'U': (0.0, 1.0), 'D': (0.0, -1.0), 'L': (-1.0, 0.0), 'R': (1.0, 0.0)}[d]\n    return (float(x), float(y), dx, dy)\n\ndef read_int():\n    return int(sys.stdin.readline().rstrip())\ntestcases = read_int()\nfor _ in range(0, testcases):\n    (xe, ye, dxe, dye) = read_coord()\n    collision = None\n    asteroids = read_int()\n    for _ in range(0, asteroids):\n        (xa, ya, dxa, dya) = read_coord()\n        dxa -= dxe\n        dya -= dye\n        candidate = None\n        if dxa != 0.0:\n            t = (xe - xa) / dxa\n            if ya + t * dya == ye:\n                candidate = t\n        elif dya != 0.0:\n            t = (ye - ya) / dya\n            if xa + t * dxa == xe:\n                candidate = t\n        if candidate is not None and candidate > 0:\n            if collision is None or collision > candidate:\n                collision = candidate\n    if collision is None:\n        print('SAFE')\n    else:\n        print('%.1f' % collision)", "inp = int(input())\ndirc = {'U': 'D', 'D': 'U', 'R': 'L', 'L': 'R'}\ndiru = {'U': [0, 1], 'D': [0, -1], 'R': [1, 0], 'L': [-1, 0]}\nfor i in range(inp):\n    temp = input().split(' ')\n    ear = [int(temp[0]), int(temp[1]), dirc[temp[2]]]\n    n = int(input())\n    time = []\n    for j in range(n):\n        temp = input().split(' ')\n        temp = [int(temp[0]), int(temp[1]), temp[2]]\n        coord = [ear[0] - temp[0], ear[1] - temp[1], [diru[temp[2]][0] + diru[ear[2]][0], diru[temp[2]][1] + diru[ear[2]][1]]]\n        if coord[2][0] == 0 and coord[2][1] == 0:\n            continue\n        elif coord[2][0] == 0 and coord[2][1] != 0 and (coord[0] == 0) and (coord[1] != 0) and (coord[1] / coord[2][1] > 0):\n            time += [coord[1] / coord[2][1]]\n        elif coord[2][0] != 0 and coord[2][1] == 0 and (coord[0] != 0) and (coord[1] == 0) and (coord[0] / coord[2][0] > 0):\n            time += [coord[0] / coord[2][0]]\n        elif coord[2][0] != 0 and coord[2][1] != 0 and (coord[0] / coord[2][0] == coord[1] / coord[2][1]) and (coord[1] / coord[2][1] > 0):\n            time += [coord[0] / coord[2][0]]\n        else:\n            continue\n    if time != []:\n        print(min(time))\n    else:\n        print('SAFE')", "for i in range(int(input())):\n    result = 1000\n    (xe, ye, dire) = input().split()\n    xe = int(xe)\n    ye = int(ye)\n    if dire == 'U':\n        (dex, dey) = (0, 1)\n    elif dire == 'D':\n        (dex, dey) = (0, -1)\n    elif dire == 'R':\n        (dex, dey) = (1, 0)\n    else:\n        (dex, dey) = (-1, 0)\n    n = int(input())\n    for i in range(n):\n        (xa, ya, dira) = input().split()\n        xa = int(xa)\n        ya = int(ya)\n        if dira == 'U':\n            (dax, day) = (0, 1)\n        elif dira == 'D':\n            (dax, day) = (0, -1)\n        elif dira == 'R':\n            (dax, day) = (1, 0)\n        else:\n            (dax, day) = (-1, 0)\n        (vy, vx) = (day - dey, dax - dex)\n        (dy, dx) = (2 * (ye - ya), 2 * (xe - xa))\n        if vx == 0 and vy == 0:\n            continue\n        elif vx * dy == vy * dx and vy * dy >= 0 and (vx * dx >= 0):\n            if vy == 0:\n                val = dx / vx\n            else:\n                val = dy / vy\n            if val < result:\n                result = val\n    if result == 1000:\n        print('SAFE')\n    else:\n        print('%.1f' % (result / 2))", "for i in range(int(input())):\n    result = 1000\n    (xe, ye, dire) = input().split()\n    xe = int(xe)\n    ye = int(ye)\n    if dire == 'U':\n        (dex, dey) = (0, 1)\n    elif dire == 'D':\n        (dex, dey) = (0, -1)\n    elif dire == 'R':\n        (dex, dey) = (1, 0)\n    else:\n        (dex, dey) = (-1, 0)\n    n = int(input())\n    for i in range(n):\n        (xa, ya, dira) = input().split()\n        xa = int(xa)\n        ya = int(ya)\n        if dira == 'U':\n            (dax, day) = (0, 1)\n        elif dira == 'D':\n            (dax, day) = (0, -1)\n        elif dira == 'R':\n            (dax, day) = (1, 0)\n        else:\n            (dax, day) = (-1, 0)\n        (vy, vx) = (day - dey, dax - dex)\n        (dy, dx) = (2 * (ye - ya), 2 * (xe - xa))\n        if vx == 0 and vy == 0:\n            continue\n        elif vx * dy == vy * dx and vy * dy >= 0 and (vx * dx >= 0):\n            if vy == 0:\n                val = dx / vx\n            else:\n                val = dy / vy\n            if val < result:\n                result = val\n    if result == 1000:\n        print('SAFE')\n    else:\n        print('%.1f' % (result / 2))", "import sys\n\nclass Entity:\n\n    def __init__(self, x, y, dir):\n        self.x = x\n        self.y = y\n        self.dir = dir\n\n    def simulate(self, time):\n        if self.dir == 'U':\n            self.y += time\n        elif self.dir == 'D':\n            self.y -= time\n        elif self.dir == 'L':\n            self.x -= time\n        elif self.dir == 'R':\n            self.x += time\n\n    def collision_time(self, other):\n        dist_x = abs(self.x - other.x)\n        dist_y = abs(self.y - other.y)\n        dist = dist_x + dist_y\n        self.simulate(0.5)\n        other.simulate(0.5)\n        cur_dist_x = abs(self.x - other.x)\n        cur_dist_y = abs(self.y - other.y)\n        cur_dist = cur_dist_x + cur_dist_y\n        self.simulate(-0.5)\n        other.simulate(-0.5)\n        if cur_dist < dist and (self.x == other.x or self.y == other.y):\n            return max(dist_x / 2.0, dist_y / 2.0)\n        elif dist_x == dist_y and (cur_dist_x < dist_x and cur_dist_y < dist_y):\n            return dist_x\n        return sys.float_info.max\nT = int(input())\nfor t in range(T):\n    line = input().split()\n    earth = Entity(float(line[0]), float(line[1]), line[2])\n    N = int(input())\n    earliest_time = sys.float_info.max\n    for n in range(N):\n        line = input().split()\n        asteroid = Entity(float(line[0]), float(line[1]), line[2])\n        earliest_time = min(earliest_time, earth.collision_time(asteroid))\n    if earliest_time == sys.float_info.max:\n        print('SAFE')\n    else:\n        print('%.1f' % earliest_time)", "import math\n\ndef checkpp(XE, YE, XA, YA, DIRE, DIRA, dist_to_pp):\n    if DIRE == 'U':\n        pXE = XE\n        pYE = YE + dist_to_pp\n    elif DIRE == 'D':\n        pXE = XE\n        pYE = YE - dist_to_pp\n    elif DIRE == 'R':\n        pXE = XE + dist_to_pp\n        pYE = YE\n    elif DIRE == 'L':\n        pXE = XE - dist_to_pp\n        pYE = YE\n    if DIRA == 'U':\n        pXA = XA\n        pYA = YA + dist_to_pp\n    elif DIRA == 'D':\n        pXA = XA\n        pYA = YA - dist_to_pp\n    elif DIRA == 'R':\n        pXA = XA + dist_to_pp\n        pYA = YA\n    elif DIRA == 'L':\n        pXA = XA - dist_to_pp\n        pYA = YA\n    if pXE == pXA and pYE == pYA:\n        return 1\n    else:\n        return 0\nt = int(input())\nfor i in range(t):\n    (XE, YE, DIRE) = input().split()\n    (XE, YE) = (float(XE), float(YE))\n    N = int(input())\n    time = 300\n    for n in range(N):\n        (XA, YA, DIRA) = input().split()\n        (XA, YA) = (float(XA), float(YA))\n        if XA == XE:\n            dist_to_pp = abs((YE - YA) / 2)\n        elif YA == YE:\n            dist_to_pp = abs((XE - XA) / 2)\n        else:\n            dist_to_pp = abs(XE - XA)\n        if checkpp(XE, YE, XA, YA, DIRE, DIRA, dist_to_pp):\n            current_time = dist_to_pp\n            time = min(time, current_time)\n    if time == 300:\n        print('SAFE')\n    else:\n        print('%.1f' % time)"]