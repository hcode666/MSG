["MAX = int(1000000.0) + 1\nis_prime = [True] * MAX\n(a, b) = map(int, input().strip().split())\nfactor = [list() for _ in range(b - a + 1)]\nfor i in range(2, MAX):\n    if is_prime[i]:\n        for j in range(2 * i, MAX, i):\n            is_prime[j] = False\n        for j in range((a + i - 1) // i * i, b + 1, i):\n            factor[j - a].append(i)\n(ans, exp) = (0, list())\nfor i in range(a, b + 1):\n    exp.clear()\n    k = i\n    for x in factor[i - a]:\n        c = 0\n        while k % x == 0:\n            k //= x\n            c += 1\n        exp.append(c)\n    if k > 1:\n        exp.append(1)\n    while exp:\n        (mul, exp) = (1, sorted(exp))\n        for x in exp:\n            mul *= x + 1\n        ans += mul\n        exp[-1] -= 1\n        if exp[-1] == 0:\n            del exp[-1]\nprint(ans)", "MAX = int(1000000.0) + 1\nis_prime = [True] * MAX\n(a, b) = map(int, input().strip().split())\nfactor = [list() for _ in range(b - a + 1)]\nfor i in range(2, MAX):\n    if is_prime[i]:\n        for j in range(2 * i, MAX, i):\n            is_prime[j] = False\n        for j in range((a + i - 1) // i * i, b + 1, i):\n            factor[j - a].append(i)\n(ans, exp) = (0, list())\nfor i in range(a, b + 1):\n    exp.clear()\n    k = i\n    for x in factor[i - a]:\n        c = 0\n        while k % x == 0:\n            k //= x\n            c += 1\n        exp.append(c)\n    if k > 1:\n        exp.append(1)\n    while exp:\n        (mul, exp) = (1, sorted(exp))\n        for x in exp:\n            mul *= x + 1\n        ans += mul\n        exp[-1] -= 1\n        if exp[-1] == 0:\n            del exp[-1]\nprint(ans)", "prime = []\ncheck = [0] * (10 ** 6 + 2)\n\ndef s(num):\n    limit = num ** 0.5 + 2\n    prime.append(2)\n    check[1] = 1\n    for z in range(4, num + 1, 2):\n        check[z] = 1\n    for i in range(3, num + 1, 2):\n        if not check[i]:\n            prime.append(i)\n            if i <= limit:\n                temp = i * 2\n                for j in range(i * i, num + 1, temp):\n                    check[j] = 1\n\ndef max_idx(num):\n    max = 0\n    for i in range(len(num)):\n        if num[i] > max:\n            max = num[i]\n            maxi = i\n    return maxi\n\ndef loop(num):\n    temp = 1\n    for i in num:\n        temp *= i\n    return temp\nn = [0] * (10 ** 6 + 7)\ns(1000000)\ninp = [int(i) for i in input().split()]\nb = [[] for i in range(inp[0], inp[1] + 1)]\nif inp[0] == 1:\n    inp[0] += 1\nfor i in range(inp[0], inp[1] + 1):\n    n[i - inp[0]] = i\nfor i in range(len(prime)):\n    p = prime[i]\n    if p > inp[1]:\n        break\n    for j in range(((inp[0] - 1) // p + 1) * p, inp[1] + 1, p):\n        temp = n[j - inp[0]]\n        count_temp = 0\n        while temp % p == 0:\n            temp //= p\n            count_temp += 1\n        b[j - inp[0]].append(count_temp + 1)\n        n[j - inp[0]] = temp\ncount = 0\nfor i in range(inp[0], inp[1] + 1):\n    if n[i - inp[0]] != 1:\n        b[i - inp[0]].append(2)\n    c = b[i - inp[0]]\n    for j in range(sum(c) - len(c)):\n        count += loop(c)\n        t = max_idx(c)\n        c[t] -= 1\nprint(count)", "from math import sqrt, ceil\ncache = {(): 0}\n\ndef solve(l):\n    if l in cache:\n        return cache[l]\n    l = list(l)\n    s = 1\n    for x in l:\n        s *= x + 1\n    l[0] -= 1\n    l = list(reversed(sorted(l)))\n    if not l[-1]:\n        l.pop()\n    return s + solve(tuple(l))\n\ndef sieve_primes(n):\n    table = [True] * (n + 1)\n    for x in range(3, ceil(sqrt(n)) + 1, 2):\n        if not table[x]:\n            continue\n        for y in range(x * x, n + 1, 2 * x):\n            table[y] = False\n    primes = [2]\n    for x in range(3, n + 1, 2):\n        if table[x]:\n            primes.append(x)\n    return primes\nprimes = sieve_primes(1000000)\n(a, b) = (int(x) for x in input().split())\nc = ceil(sqrt(b))\ntable = [(x, []) for x in range(a, b + 1)]\nfor p in primes:\n    if p > c:\n        break\n    for x in range(ceil(a / p) * p, b + 1, p):\n        (y, z) = table[x - a]\n        d = 0\n        while y % p == 0:\n            y //= p\n            d += 1\n        if d:\n            z.append(d)\n            table[x - a] = (y, z)\ns = 0\nfor (y, z) in table:\n    if y > 1:\n        z.append(1)\n    z = tuple(reversed(sorted(z)))\n    s += solve(z)\nprint(s)", "mark = [0] * (10 ** 6 + 2)\nprime = []\n\ndef reduce(x):\n    a = 1\n    for i in x:\n        a *= i\n    return a\n\ndef to(a):\n    max = 0\n    for i in range(len(a)):\n        if a[i] > max:\n            max = a[i]\n            maxIndex = i\n    return maxIndex\n\ndef sieve(n):\n    mark[1] = 1\n    tmp = n ** 0.5 + 2\n    prime.append(2)\n    for i in range(4, n + 1, 2):\n        mark[i] = 1\n    for i in range(3, n + 1, 2):\n        if not mark[i]:\n            prime.append(i)\n            if i <= tmp:\n                tmp1 = i * 2\n                for j in range(i * i, n + 1, tmp1):\n                    mark[j] = 1\nnum = [0] * (10 ** 6 + 6)\nsieve(1000000)\na = [int(j) for j in input().split()]\ntest = [[] for i in range(a[0], a[1] + 1)]\nif a[0] == 1:\n    a[0] += 1\nfor i in range(a[0], a[1] + 1):\n    num[i - a[0]] = i\nfor i in range(len(prime)):\n    p = prime[i]\n    if p > a[1]:\n        break\n    for j in range(((a[0] - 1) // p + 1) * p, a[1] + 1, p):\n        n = num[j - a[0]]\n        cnt = 0\n        while n % p == 0:\n            n //= p\n            cnt += 1\n        test[j - a[0]].append(cnt + 1)\n        num[j - a[0]] = n\nsu = 0\nfor i in range(a[0], a[1] + 1):\n    if num[i - a[0]] != 1:\n        test[i - a[0]].append(2)\n    b = test[i - a[0]]\n    for j in range(sum(b) - len(b)):\n        su += reduce(b)\n        b[to(b)] -= 1\nprint(su)", "from math import *\nfrom collections import defaultdict\n(a, b) = map(int, input().split())\nans = 0\na = max(2, a)\ntry:\n    xrange\nexcept NameError:\n    xrange = range\n\ndef primeListSofE(n):\n    maxI = (n - 3) // 2\n    maxP = int(sqrt(n))\n    sieve = [True for j in xrange(maxI + 1)]\n    for p in xrange(3, maxP + 1, 2):\n        i = (p - 3) // 2\n        if sieve[i]:\n            i2 = (p * p - 3) // 2\n            for k in xrange(i2, maxI + 1, p):\n                sieve[k] = False\n    ret = [2] + [2 * j + 3 for j in xrange(len(sieve)) if sieve[j]]\n    return ret\nmx = int(sqrt(b)) + 1\nprime = primeListSofE(mx)\ntry:\n    har = defaultdict(list)\n    vij = {i: i for i in xrange(a, b + 1)}\nexcept:\n    print(0)\n    exit(0)\nfor i in prime:\n    lx = a\n    ax = i - a % i\n    if a % i != 0:\n        lx = a + ax\n    for j in xrange(lx, b + 1, i):\n        chk = vij[j]\n        if chk % i == 0:\n            cnt = 0\n            tota = vij[j]\n            while tota % i == 0:\n                cnt += 1\n                tota /= i\n            vij[j] = tota\n            har[j].append(cnt + 1)\nfor i in har:\n    if vij[i] != 1:\n        har[i].append(2)\nfor i in har:\n    ab = har[i][:]\n    from operator import mul\n    mx = 1\n    for i in ab:\n        mx *= i\n    anx = mx\n    ab.sort()\n    while True:\n        drop = ab[-1]\n        if drop == 1:\n            break\n        mx /= drop\n        drop -= 1\n        mx *= drop\n        if mx == 1:\n            break\n        anx += mx\n        ab[-1] = drop\n        ab.sort()\n    ans += anx\nprime = 0\nfor i in xrange(a, b + 1):\n    if i not in har:\n        prime += 1\nprint(int(ans + prime * 2))", "import functools\nfrom math import sqrt\nfrom operator import mul\nMAX_NUM_FACTORS = 30\n\ndef compute_factors(A, B, devisors):\n    factors = [None for i in range(A, B + 1)]\n    for i in range(0, B - A + 1):\n        num_devisors = devisors[i]\n        l = len(num_devisors)\n        num_factors = []\n        candidates = list(num_devisors)\n        filtered = []\n        while candidates:\n            currrent_prime = candidates[0]\n            num_factors.append(currrent_prime)\n            for k in range(1, len(candidates)):\n                if candidates[k] % currrent_prime != 0:\n                    filtered.append(candidates[k])\n            candidates = filtered\n            filtered = []\n        factors[i] = num_factors\n    if A == 1:\n        factors[0] = []\n    return factors\n\ndef compute_devisors(A, B):\n    devisors1 = [[] for i in range(A, B + 1)]\n    devisors2 = [[] for i in range(A, B + 1)]\n    for i in range(2, int(sqrt(B)) + 1):\n        r = A % i\n        if r == 0:\n            n = A\n        else:\n            n = A - r + i\n        j = n\n        while j <= B:\n            if i * i > j:\n                j += i\n                continue\n            devisors1[j - A].append(i)\n            if i * i != j:\n                devisors2[j - A].append(j / i)\n            j += i\n    [devisors1[i].extend(reversed(devisors2[i])) for i in range(0, B - A + 1)]\n    [devisors1[i].append(A + i) for i in range(0, B - A + 1)]\n    return devisors1\n\ndef get_max_power_naive(p, n):\n    count = 0\n    d = 1\n    while True:\n        next_d = d * p\n        if n % next_d != 0:\n            break\n        count += 1\n        d = next_d\n    return (count, d)\n\ndef compute_powers(A, B, factors):\n    powers = [None for i in range(A, B + 1)]\n    for i in range(0, B - A + 1):\n        num = A + i\n        num_factors = factors[i]\n        if num_factors:\n            fact_prod = functools.reduce(mul, num_factors)\n        else:\n            fact_prod = 1\n        current_num = num / fact_prod\n        num_powers = [-1 for s in range(len(num_factors))]\n        for j in range(0, len(num_factors)):\n            (power, exp) = get_max_power_naive(num_factors[j], current_num)\n            num_powers[j] = power + 1\n            current_num /= exp\n        powers[i] = num_powers\n    return powers\ntree_scores = {}\n\ndef cts(powers):\n    power_prod = functools.reduce(lambda s, v: s * (v + 1), powers, 1) - 1\n    m = powers[0]\n    last_max_index = 0\n    while last_max_index + 1 < len(powers) and powers[last_max_index + 1] == m:\n        last_max_index += 1\n    pred_power = list(powers)\n    pred_power[last_max_index] -= 1\n    pred_value = tree_scores[tuple(pred_power)]\n    tree_scores[tuple(powers)] = power_prod + pred_value + 1\n\ndef precompute_tree_scores(max_num_factors):\n    powers = [0 for i in range(max_num_factors)]\n    tree_scores[tuple(powers)] = 0\n    count = 0\n    while True:\n        powers[0] += 1\n        count += 1\n        while count >= max_num_factors + 1:\n            if index == max_num_factors - 1:\n                return\n            index += 1\n            powers[index] += 1\n            count += 1\n            v = powers[index]\n            for i in range(index):\n                count -= powers[i]\n                count += v\n                powers[i] = v\n        index = 0\n        cts(powers)\n\ndef compute_sum(A, B, powers):\n    S = 0\n    for i in range(0, B - A + 1):\n        powers[i].sort(reverse=True)\n        pad_length = MAX_NUM_FACTORS - len(powers[i])\n        powers[i].extend([0 for j in range(pad_length)])\n        if sum(powers[i]) == 0:\n            if A == 1 and i == 0:\n                S += 0\n            else:\n                S += 2\n        else:\n            S += tree_scores[tuple(powers[i])]\n    return S\ndata = input().strip().split()\n(A, B) = (int(data[0]), int(data[1]))\ndevisors = compute_devisors(A, B)\nfactors = compute_factors(A, B, devisors)\npowers = compute_powers(A, B, factors)\nprecompute_tree_scores(MAX_NUM_FACTORS)\nprint(compute_sum(A, B, powers))", "import heapq, math\nispr = [1] * (10 ** 6 + 5)\nispr[0] = ispr[1] = 0\nprimes = []\nfor i in range(2, len(ispr)):\n    if ispr[i]:\n        primes.append(i)\n        for j in range(i + i, len(ispr), i):\n            ispr[j] = 0\n\ndef getdivlist(A, B):\n    nums = [i for i in range(A, B + 1)]\n    divlistall = [[] for i in range(B - A + 1)]\n    for p in primes:\n        st = p * math.ceil(A / p)\n        for i in range(st, B + 1, p):\n            c = 0\n            while nums[i - A] % p == 0:\n                nums[i - A] //= p\n                c += 1\n            divlistall[i - A].append(c)\n    for i in range(B - A + 1):\n        if nums[i] > 1:\n            divlistall[i].append(1)\n    return divlistall\n(A, B) = map(int, input().split())\ndivlistall = getdivlist(A, B)\ntotal = 0\nfor divlist in divlistall:\n    prod = 1\n    for d in divlist:\n        prod *= 1 + d\n    divlist = [-d for d in divlist]\n    count = 0\n    heapq.heapify(divlist)\n    while divlist:\n        count += prod\n        largest = -heapq.heappop(divlist)\n        prod = prod // (largest + 1) * largest\n        largest -= 1\n        if largest:\n            heapq.heappush(divlist, -largest)\n    total += count\nprint(total)"]