["from bisect import bisect_left\n\ndef solve(g, prefixGolombArr, prefixFreq, size, mod):\n    for i in range(1, size):\n        g.append((i + 1, 1 + g[i + 1 - g[g[i][1]][1]][1]))\n        prefixGolombArr.append((prefixGolombArr[i - 1] + g[i + 1][0] * g[i + 1][0] * g[i + 1][1] % mod) % mod)\n        prefixFreq.append(g[i + 1][1] + prefixFreq[i - 1])\n\ndef findAnsLimit(X, g, prefixFreq, prefixGolombArr, mod):\n    K = bisect_left(prefixFreq, X)\n    if prefixFreq[K] == X:\n        return prefixGolombArr[K]\n    else:\n        return (prefixGolombArr[K - 1] + g[K + 1][0] * g[K + 1][0] * (X - prefixFreq[K - 1]) % mod) % mod\n\ndef main():\n    g = [(0, 1), (1, 1)]\n    size = 2000009\n    mod = int(1000000000.0 + 7)\n    prefixGolombArr = [g[1][0] * g[1][0] % mod]\n    prefixFreq = [1]\n    solve(g, prefixGolombArr, prefixFreq, size, mod)\n    T = int(input())\n    for _ in range(T):\n        (L, R) = map(int, input().split())\n        if L == 1:\n            print(findAnsLimit(R, g, prefixFreq, prefixGolombArr, mod))\n        else:\n            print((findAnsLimit(R, g, prefixFreq, prefixGolombArr, mod) - findAnsLimit(L - 1, g, prefixFreq, prefixGolombArr, mod)) % mod)\nmain()", "import bisect\nMAXR = 100\nMAXN = 20000000\nT = int(input().strip())\nqueries = []\nfor t in range(T):\n    (L, R) = map(int, input().strip().split())\n    queries.append((L, R))\n    MAXR = max(MAXR, R + 1)\nMOD = 10 ** 9 + 7\ng = [0, 1, 2]\np = [0, 1, 3]\ns = [0, 1, 9]\nfor n in range(3, MAXN):\n    gg = 1 + g[n - g[g[n - 1]]]\n    pp = p[n - 1] + gg\n    ss = (s[n - 1] + gg * n * n) % MOD\n    g.append(gg)\n    p.append(pp)\n    s.append(ss)\n    if pp > MAXR:\n        break\n\ndef process(m):\n    n = bisect.bisect_right(p, m)\n    return (s[n - 1] + (m - p[n - 1]) * n * n) % MOD\nfor (L, R) in queries:\n    print((process(R) - process(L - 1)) % MOD)", "import bisect\nM = 1000000007\nG = [0, 1, 2, 2]\ncurrPos = 4\nfor i in range(3, 2000000):\n    if currPos > 2000000:\n        break\n    j = 0\n    while j < G[i] and currPos < 2000000:\n        G.append(i)\n        currPos += 1\n        j += 1\nprefixSum1 = [0]\nprefixSum2 = [0]\nfor i in range(1, 2000000):\n    prefixSum1.append(prefixSum1[i - 1] + G[i])\nfor i in range(1, 2000000):\n    prefixSum2.append((prefixSum2[i - 1] + i * i % M * G[i] % M) % M)\n\ndef solve(n):\n    nthterm = bisect.bisect_left(prefixSum1, n, lo=0, hi=len(prefixSum1)) - 0\n    ans = 0\n    if nthterm > 0:\n        ans = prefixSum2[nthterm - 1]\n    ans = (ans + nthterm * nthterm % M * (n - prefixSum1[nthterm - 1]) % M) % M\n    return ans\nfor tc in range(int(input())):\n    (l, r) = map(int, input().split())\n    print((solve(r) - solve(l - 1) + M) % M)", "import bisect as bi\ntemp_g = [0, 1, 2]\ntemp_s = [0, 1, 9]\ntemp_p = [0, 1, 3]\nmax_mod = 10 ** 9 + 7\n\ndef find_gn(n):\n    return 1 + temp_g[n - temp_g[temp_g[n - 1]]]\n\ndef find_sn(n, gn):\n    return (temp_s[n - 1] + gn * n ** 2) % max_mod\n\ndef find_pn(n, gn):\n    return temp_p[n - 1] + gn\n\ndef bisection(x):\n    n = bi.bisect_right(temp_p, x)\n    return (temp_s[n - 1] + (x - temp_p[n - 1]) * n ** 2) % max_mod\n(lr, max_) = ([], 100)\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    lr.append((l, r))\n    max_ = max(max_, r + 1)\nfor n in range(3, 2 * 10 ** 8, 1):\n    gn = find_gn(n)\n    (sn, pn) = (find_sn(n, gn), find_pn(n, gn))\n    temp_g.append(gn)\n    temp_p.append(pn)\n    temp_s.append(sn)\n    if pn > max_:\n        break\nfor pair in lr:\n    print((bisection(pair[1]) - bisection(pair[0] - 1)) % max_mod)", "import bisect as bi\ntemp_g = [0, 1, 2]\ntemp_s = [0, 1, 9]\ntemp_p = [0, 1, 3]\nmax_mod = 10 ** 9 + 7\n\ndef find_gn(n):\n    return 1 + temp_g[n - temp_g[temp_g[n - 1]]]\n\ndef find_sn(n, gn):\n    return (temp_s[n - 1] + gn * n * n) % max_mod\n\ndef find_pn(n, gn):\n    return temp_p[n - 1] + gn\n\ndef bisection(x):\n    n = bi.bisect_right(temp_p, x)\n    return (temp_s[n - 1] + (x - temp_p[n - 1]) * n * n) % max_mod\n(lr, max_) = ([], 100)\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    lr.append((l, r))\n    max_ = max(max_, r + 1)\nfor n in range(3, 2 * 10 ** 8, 1):\n    gn = find_gn(n)\n    (sn, pn) = (find_sn(n, gn), find_pn(n, gn))\n    temp_g.append(gn)\n    temp_p.append(pn)\n    temp_s.append(sn)\n    if pn > max_:\n        break\nfor pair in lr:\n    print((bisection(pair[1]) - bisection(pair[0] - 1)) % max_mod)", "import bisect as bi\ntemp_g = [0, 1, 2]\ntemp_s = [0, 1, 9]\ntemp_p = [0, 1, 3]\nmax_mod = 10 ** 9 + 7\n\ndef find_gn(n):\n    return 1 + temp_g[n - temp_g[temp_g[n - 1]]]\n\ndef find_sn(n, gn):\n    return (temp_s[n - 1] + gn * n * n) % max_mod\n\ndef find_pn(n, gn):\n    return temp_p[n - 1] + gn\n\ndef bisection(x):\n    n = bi.bisect_right(temp_p, x)\n    return (temp_s[n - 1] + (x - temp_p[n - 1]) * n * n) % max_mod\n(lr, max_) = ([], 100)\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    lr.append((l, r))\n    max_ = max(max_, r + 1)\nfor n in range(3, 2 * 10 ** 8, 1):\n    gn = find_gn(n)\n    sn = find_sn(n, gn)\n    pn = find_pn(n, gn)\n    temp_g.append(gn)\n    temp_p.append(pn)\n    temp_s.append(sn)\n    if pn > max_:\n        break\nfor pair in lr:\n    print((bisection(pair[1]) - bisection(pair[0] - 1)) % max_mod)", "import bisect\nm = 10 ** 9 + 7\narr = [0, 1, 2, 2]\nc = 5\ni = 3\nwhile c <= 10 ** 10:\n    for j in range(arr[i]):\n        arr.append(i)\n        c += i\n        if c >= 10 ** 10:\n            break\n    i += 1\nn = len(arr)\npref1 = [0] * n\npref2 = [0] * n\nfor i in range(1, n):\n    pref1[i] = pref1[i - 1] + arr[i]\nfor i in range(1, n):\n    pref2[i] = pref2[i - 1] + i * i * arr[i] % m\n    pref2[i] %= m\n\ndef solve(x):\n    bi = bisect.bisect_left(pref1, x)\n    if pref1[bi] == x:\n        return pref2[bi]\n    ans = x - pref1[bi - 1]\n    return (pref2[bi - 1] + bi * bi * ans) % m\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    print((solve(r) - solve(l - 1)) % m)", "import bisect\nMAXR = 100\nMAXN = 20000000\nT = int(input().strip())\nqueries = []\nfor t in range(T):\n    (L, R) = map(int, input().strip().split())\n    queries.append((L, R))\n    MAXR = max(MAXR, R + 1)\nMOD = 10 ** 9 + 7\ng = [0, 1, 2]\np = [0, 1, 3]\ns = [0, 1, 9]\nfor n in range(3, MAXN):\n    gg = 1 + g[n - g[g[n - 1]]]\n    pp = p[n - 1] + gg\n    ss = (s[n - 1] + gg * n * n) % MOD\n    g.append(gg)\n    p.append(pp)\n    s.append(ss)\n    if pp > MAXR:\n        break\n\ndef process(m):\n    n = bisect.bisect_right(p, m)\n    return (s[n - 1] + (m - p[n - 1]) * n * n) % MOD\nfor (L, R) in queries:\n    print((process(R) - process(L - 1)) % MOD)", "from bisect import bisect_right\nmod = 10 ** 9 + 7\n(mr, mn, q) = (100, 2 * 10 ** 7, [])\n(g, p, s) = ([0, 1, 2], [0, 1, 3], [0, 1, 9])\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    q.append((l, r))\n    mr = max(mr, r + 1)\nfor n in range(3, mn):\n    gg = 1 + g[n - g[g[n - 1]]]\n    pp = p[n - 1] + gg\n    ss = (s[n - 1] + gg * n * n) % mod\n    g.append(gg)\n    p.append(pp)\n    s.append(ss)\n    if pp > mr:\n        break\n\ndef pro(m):\n    n = bisect_right(p, m)\n    return (s[n - 1] + (m - p[n - 1]) * n * n) % mod\nfor (l, r) in q:\n    print((pro(r) - pro(l - 1)) % mod)", "import bisect\nimport sys\ninput = sys.stdin.readline\nMAXR = 100\nMAXN = 20000000\nt = int(input().strip())\nqueries = []\nfor t in range(t):\n    (L, R) = map(int, input().strip().split())\n    queries.append((L, R))\n    MAXR = max(MAXR, R + 1)\nMOD = 10 ** 9 + 7\ng = [0, 1, 2]\np = [0, 1, 3]\ns = [0, 1, 9]\nfor n in range(3, MAXN):\n    gn = 1 + g[n - g[g[n - 1]]]\n    pn = p[n - 1] + gn\n    sn = (s[n - 1] + gn * n * n) % MOD\n    g.append(gn)\n    p.append(pn)\n    s.append(sn)\n    if pn > MAXR:\n        break\n\ndef process(m):\n    n = bisect.bisect_right(p, m)\n    return (s[n - 1] + (m - p[n - 1]) * n * n) % MOD\nfor (L, R) in queries:\n    print((process(R) - process(L - 1)) % MOD)", "def find_left(ar, x, l, r):\n    mid = (l + r) // 2\n    if l > r:\n        return l\n    if ar[mid] == x:\n        return mid\n    elif ar[mid] > x:\n        return find_left(ar, x, l, mid - 1)\n    else:\n        return find_left(ar, x, mid + 1, r)\nMOD = 10 ** 9 + 7\nG = [1, 2, 2]\nright = [1, 3, 5]\nsq_sum = [1, 9, 27]\nnext = 3\ncount = G[next - 1]\nnum = 4\nwhile right[-1] < 10 ** 10:\n    while count > 0:\n        G.append(next)\n        count -= 1\n        right.append(right[-1] + G[-1])\n        sq_sum.append(sq_sum[-1] + num ** 2 * G[-1])\n        sq_sum[-1] %= MOD\n        num += 1\n    next += 1\n    count = G[next - 1]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    (a, b) = (find_left(right, l, 0, len(right)), find_left(right, r, 0, len(right)))\n    ans = 0\n    if a == b:\n        ans += (a + 1) ** 2 * (r - l + 1)\n        ans = ans % MOD\n    elif a + 1 == b:\n        ans += (a + 1) ** 2 * (right[a] - l + 1)\n        ans = ans % MOD\n        ans += (b + 1) ** 2 * (r - right[a])\n        ans = ans % MOD\n    else:\n        ans += (a + 1) ** 2 * (right[a] - l + 1)\n        ans = ans % MOD\n        ans += (b + 1) ** 2 * (r - right[b - 1])\n        ans = ans % MOD\n        ans += sq_sum[b - 1] - sq_sum[a]\n        ans = ans % MOD\n    print(ans)", "import sys, math\nimport io, os\nfrom bisect import bisect_left as bl, bisect_right as br, insort\nfrom heapq import heapify, heappush, heappop\nfrom collections import defaultdict as dd, deque, Counter\n\ndef data():\n    return sys.stdin.readline().strip()\n\ndef mdata():\n    return list(map(int, data().split()))\n\ndef outl(var):\n    sys.stdout.write('\\n'.join(map(str, var)) + '\\n')\n\ndef out(var):\n    sys.stdout.write(str(var) + '\\n')\nfrom fractions import Fraction\nINF = float('inf')\nmod = int(1000000000.0) + 7\na = [(0, 1), (1, 2)]\nb = [0, 1]\nx = 10 ** 10\nans = 1\ncnt = 1\nd = dd(int)\nd[2] = 2\nk = 2\ni = 2\nwhile cnt <= x:\n    d[i] = k\n    if cnt + d[i] > x:\n        ans = (ans + i ** 2 * (x - cnt)) % mod\n        break\n    ans = (ans + i ** 2 * d[i]) % mod\n    cnt += d[i]\n    d[k] -= 1\n    i += 1\n    if d[k] == 0:\n        k += 1\n    a.append((ans, i))\n    b.append(cnt)\nans1 = []\ninp = [int(x) for x in sys.stdin.read().split()]\nii = 0\nT = inp[ii]\nii += 1\nfor t in range(T):\n    l = inp[ii]\n    ii += 1\n    r = inp[ii]\n    ii += 1\n    i = bl(b, r)\n    if i == len(b) or b[i] > r:\n        i -= 1\n    ans = a[i][0] + a[i][1] ** 2 * (r - b[i])\n    if l != 1:\n        i = bl(b, l - 1)\n        if i == len(b) or b[i] > l - 1:\n            i -= 1\n        ans -= a[i][0] + a[i][1] ** 2 * (l - 1 - b[i])\n    ans1.append((ans + mod) % mod)\noutl(ans1)", "import bisect\n\ndef f(R):\n    z = bisect.bisect_right(pref, R)\n    rem = R - pref[z - 1]\n    k = rem * (z + 1) * (z + 1)\n    return (k + ans[z - 1]) % 1000000007\nn = 10 ** 6\ngolem = [0 for i in range(3 * n)]\npref = [0 for i in range(3 * n)]\nans = [0 for i in range(3 * n)]\ngolem[0] = 1\nhashi = dict()\ncnt = 0\npref[0] = 1\nans[0] = 1\nhashi[2] = 2\nfor i in range(1, 3 * n):\n    if cnt == 0:\n        golem[i] = 1 + golem[i - 1]\n        cnt = hashi[golem[i]]\n        cnt -= 1\n    else:\n        golem[i] = golem[i - 1]\n        cnt -= 1\n    hashi[i + 1] = golem[i]\n    pref[i] = pref[i - 1] + golem[i]\n    ans[i] = ans[i - 1] + golem[i] * (i + 1) * (i + 1)\n    ans[i] %= 1000000007\nt = int(input())\nfor you in range(t):\n    l = input().split()\n    L = int(l[0])\n    R = int(l[1])\n    if L == 1:\n        print(f(R))\n    else:\n        po = f(R) - f(L - 1)\n        print(po % 1000000007)", "import sys\nn = 2000000\nM = 10 ** 9 + 7\nans = 1\ndp = [0] * (n + 1)\na = [0, 1]\ns = [0, 1]\ndp[1] = 1\nsu = 1\nfor i in range(2, n + 1):\n    dp[i] = 1 + dp[i - dp[dp[i - 1]]]\n    ans += dp[i]\n    a.append(ans)\n    su = (su + i ** 2 * dp[i]) % M\n    s.append(su)\n    if ans > 10 ** 10:\n        break\nimport bisect as bs\nfrom sys import stdin, stdout, setrecursionlimit\nT = int(stdin.readline())\nfor _ in range(T):\n    (l, r) = list(map(int, stdin.readline().split()))\n    l -= 1\n    lb = bs.bisect_right(a, l)\n    lb -= 1\n    left = s[lb]\n    left = (left + (l - a[lb]) * (lb + 1) * (lb + 1)) % M\n    rb = bs.bisect_right(a, r)\n    rb -= 1\n    right = s[rb]\n    right = (right + (r - a[rb]) * (rb + 1) * (rb + 1)) % M\n    print((right - left) % M)"]