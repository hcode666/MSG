["import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    m = 10 ** 9 + 7\n    print(pow(denom, m - 2, m) * num % m)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    m = 10 ** 9 + 7\n    print(pow(denom, m - 2, m) * num % m)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    m = 10 ** 9 + 7\n    print(pow(denom, m - 2, m) * num % m)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    m = 10 ** 9 + 7\n    print(pow(denom, m - 2, m) * num % m)", "def equilibrium(k, n):\n    if k in [1, 2]:\n        return 0\n    else:\n        (up, down, m) = (pow(2, k - 1) - k, pow(2, k - 1), 10 ** 9 + 7)\n        return up * pow(down, m - 2, m) % m\nk = int(input())\nn = int(input())\nprint(equilibrium(k, n))", "def equilibrium(k, n):\n    if k in [1, 2]:\n        return 0\n    else:\n        (up, down, m) = (pow(2, k - 1) - k, pow(2, k - 1), 10 ** 9 + 7)\n        return up * pow(down, m - 2, m) % m\nk = int(input())\nn = int(input())\nprint(equilibrium(k, n))", "import math\nP = int(input())\nQ = int(input())\nif P == 1 or P == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, P - 1) - P, pow(2, P - 1))\n    m = 10 ** 9 + 7\n    print(pow(denom, m - 2, m) * num % m)", "def equilib(k, n):\n    if k in [1, 2]:\n        return 0\n    else:\n        (up, down, m) = (pow(2, k - 1) - k, pow(2, k - 1), 10 ** 9 + 7)\n        return up * pow(down, m - 2, m) % m\nk = int(input())\nn = int(input())\nprint(equilib(k, n))", "import math\nP = int(input())\nQ = int(input())\nif P == 1 or P == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, P - 1) - P, pow(2, P - 1))\n    m = 10 ** 9 + 7\n    print(pow(denom, m - 2, m) * num % m)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    m = 10 ** 9 + 7\n    print(pow(denom, m - 2, m) * num % m)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    num = pow(2, n - 1) - n\n    denom = pow(2, n - 1)\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\nnin = int(input())\nk = int(input())\nif nin == 1 or nin == 2:\n    print(0)\nelse:\n    (num, deno) = (pow(2, nin - 1) - nin, pow(2, nin - 1))\n    mod = 10 ** 9 + 7\n    print(pow(deno, mod - 2, mod) * num % mod)", "try:\n    import math\n    n = int(input())\n    k = int(input())\n    if n == 1 or n == 2:\n        print(0)\n    else:\n        num = pow(2, n - 1) - n\n        denom = pow(2, n - 1)\n        MOD = 10 ** 9 + 7\n        print(pow(denom, MOD - 2, MOD) * num % MOD)\nexcept:\n    pass", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    num = pow(2, n - 1) - n\n    denom = pow(2, n - 1)\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    num = pow(2, n - 1) - n\n    denom = pow(2, n - 1)\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    num = pow(2, n - 1) - n\n    denom = pow(2, n - 1)\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    num = pow(2, n - 1) - n\n    denom = pow(2, n - 1)\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, deno) = (pow(2, n - 1) - n, pow(2, n - 1))\n    mod = 10 ** 9 + 7\n    print(pow(deno, mod - 2, mod) * num % mod)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, deno) = (pow(2, n - 1) - n, pow(2, n - 1))\n    mod = 10 ** 9 + 7\n    print(pow(deno, mod - 2, mod) * num % mod)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, deno) = (pow(2, n - 1) - n, pow(2, n - 1))\n    mod = 10 ** 9 + 7\n    print(pow(deno, mod - 2, mod) * num % mod)", "mod = 10 ** 9 + 7\nn = int(input())\nk = int(input())\nden = pow(2, n - 1)\nnum = pow(2, n - 1) - n\nans = pow(den, mod - 2, mod) * num % mod\nprint(ans)", "try:\n    n = int(input())\n    k = int(input())\n    mod = 1000000000 + 7\n\n    def pow(a, b, mod):\n        if b == 0:\n            return 1\n        ans = pow(a, b // 2, mod)\n        ans = ans * ans % mod\n        if b % 2 == 1:\n            ans = a * ans % mod\n        return ans\n    den = pow(2, n - 1, mod)\n    num = den - n\n    if num < 0:\n        num += mod\n    iden = pow(den, mod - 2, mod)\n    print(num * iden % mod)\nexcept Exception:\n    pass", "from fractions import Fraction\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    win = Fraction(pow(2, n - 1) - n, pow(2, n - 1))\n    (num, denom) = (win.numerator, win.denominator)\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\ntry:\n    n = int(input())\n    k = int(input())\n    if n == 1 or n == 2:\n        print(0)\n    else:\n        (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n        MOD = 10 ** 9 + 7\n        print(pow(denom, MOD - 2, MOD) * num % MOD)\nexcept:\n    pass", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "def modInverse():\n    import math\n    n = int(input())\n    k = int(input())\n    if n == 1 or n == 2:\n        print('0')\n    else:\n        (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n        MOD = 10 ** 9 + 7\n        print(pow(denom, MOD - 2, MOD) * num % MOD)\nmodInverse()", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    gcd = math.gcd(num, denom)\n    num //= gcd\n    denom //= gcd\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "from fractions import Fraction\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    win = Fraction(pow(2, n - 1) - n, pow(2, n - 1))\n    (num, denom) = (win.numerator, win.denominator)\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    gcd = math.gcd(num, denom)\n    num //= gcd\n    denom //= gcd\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "import math\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    (num, denom) = (pow(2, n - 1) - n, pow(2, n - 1))\n    gcd = math.gcd(num, denom)\n    num //= gcd\n    denom //= gcd\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "from fractions import Fraction\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    win = Fraction(pow(2, n - 1) - n, pow(2, n - 1))\n    (num, denom) = (win.numerator, win.denominator)\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "from fractions import Fraction\nn = int(input())\nk = int(input())\nif n == 1 or n == 2:\n    print(0)\nelse:\n    win = Fraction(pow(2, n - 1) - n, pow(2, n - 1))\n    (num, denom) = (win.numerator, win.denominator)\n    MOD = 10 ** 9 + 7\n    print(pow(denom, MOD - 2, MOD) * num % MOD)", "def inp():\n    return int(input())\n\ndef reads():\n    return [int(x) for x in input().split()]\nMOD = 10 ** 9 + 7\nn = inp()\ninp()\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nans = (1 - n * inv(pow(2, n - 1, MOD))) % MOD\nprint(ans)", "from sys import exit, setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import *\nfrom bisect import *\nfrom heapq import *\nimport operator\nimport math\nfrom fractions import gcd\nfrom random import randint\n\ndef read():\n    return int(input())\n\ndef reads():\n    return [int(x) for x in input().split()]\nMOD = 10 ** 9 + 7\nn = read()\nread()\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nans = (1 - n * inv(pow(2, n - 1, MOD))) % MOD\nprint(ans)", "from sys import exit, setrecursionlimit, stderr\nfrom functools import reduce\nfrom itertools import *\nfrom collections import *\nfrom bisect import *\nfrom heapq import *\nimport operator\nimport math\nfrom fractions import gcd\nfrom random import randint\n\ndef read():\n    return int(input())\n\ndef reads():\n    return [int(x) for x in input().split()]\nMOD = 10 ** 9 + 7\nn = read()\nread()\n\ndef inv(x):\n    return pow(x, MOD - 2, MOD)\nans = (1 - n * inv(pow(2, n - 1, MOD))) % MOD\nprint(ans)", "def extended_euclid(a, b):\n    assert a > 0\n    assert b > 0\n    (x1, y1, m) = (1, 0, a)\n    (x2, y2, n) = (0, 1, b)\n    while m % n != 0:\n        q = m // n\n        (x1, y1, m, x2, y2, n) = (x2, y2, n, x1 - q * x2, y1 - q * y2, m - q * n)\n    return (x2, y2, n)\nmod = 10 ** 9 + 7\nn = int(input())\nk = int(input())\nQ = 2 ** (n - 1)\nP = Q - n\n(x, y, n) = extended_euclid(Q, mod)\nprint((P * x + mod) % mod)", "mod = 1000000007\n\ndef d(p):\n    if p == 0:\n        return 1\n    if p == 1:\n        return 2\n    r = 1\n    dhalf = d(p >> 1)\n    if p % 2:\n        r = 2\n    return dhalf * dhalf * r % mod\nn = int(input())\nk = int(input())\nans = (d(n - 1) - n) % mod\nans *= d(mod - n)\nans %= mod\nprint(ans)", "n = int(input())\nk = int(input())\nmod = 1000000000 + 7\n\ndef pow(a, b, mod):\n    if b == 0:\n        return 1\n    ans = pow(a, b // 2, mod)\n    ans = ans * ans % mod\n    if b % 2 == 1:\n        ans = a * ans % mod\n    return ans\nden = pow(2, n - 1, mod)\nnum = den - n\nif num < 0:\n    num += mod\niden = pow(den, mod - 2, mod)\nprint(num * iden % mod)", "m = 1000000007\n\ndef power(a, b, m):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b = b >> 1\n    return res\n\ndef solve(n):\n    dnum = 1 << n - 1\n    num = dnum - n\n    return num * power(dnum, m - 2, m) % m\nn = int(input())\nk = int(input())\nprint(solve(n))", "n = eval(input())\nk = eval(input())\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nif n < 500:\n    if n == 2:\n        print(0)\n    elif n == 1:\n        if k == 0:\n            print(1)\n        else:\n            print(0)\n    else:\n        var3 = pow(2, n - 1)\n        var2 = var3 - n\n        var3 = power(var3, 1000000005, 1000000007)\n        print(var2 * var3 % 1000000007)\nelse:\n    var3 = pow(2, n - 1)\n    var2 = var3 - n\n    var3 = power(var3, 1000000005, 1000000007)\n    print(var2 * var3 % 1000000007)", "import math\nfrom fractions import gcd\nn = int(input())\nj = int(input())\nP = pow(2, n - 1) - n\nQ = pow(2, n - 1)\nwhile gcd(P, Q) != 1:\n    hh = gcd(P, Q)\n    P = P // hh\n    Q = Q // hh\nk = pow(10, 9) + 7\nkk = pow(Q, k - 2, k)\nans = P * kk % k\nprint(ans)", "def modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nn = int(input())\nk = int(input())\nnume = pow(2, n - 1) - n\ndeno = pow(2, n - 1)\nmodulo = modInverse(deno, 1000000007)\nans = nume * modulo % 1000000007\nprint(ans)", "N = int(input())\nk = int(input())\n\ndef modInverse(a, m):\n    g = gcd(a, m)\n    if g != 1:\n        print(\"Inverse doesn't exist\")\n    else:\n        return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nP = 2 ** (N - 1) - N\nQ = 2 ** (N - 1)\na = gcd(P, Q)\nP = P // a\nQ = Q // a\nQinv = modInverse(Q, 1000000007)\nans = Qinv * P % 1000000007\nprint(ans)", "def invert(num, mod):\n    X = 1\n    Y = 0\n    mcurr = mod\n    flag = 0\n    if mod == 1:\n        flag = 1\n        return 0\n    while num > 1:\n        flag = 0\n        q = num // mod\n        temp = mod\n        mod = num % mod\n        num = temp\n        temp = Y\n        flag = 2\n        Y = X - q * Y\n        X = temp\n    if X < 0:\n        flag = 1\n        X = X + mcurr\n    return X\nn = int(input())\nk = int(input())\np = pow(2, n - 1) - n\nq = pow(2, n - 1)\nans = p * invert(q, 1000000007) % 1000000007\nprint(ans)", "import math\n\ndef q(x, y, m):\n    if m > 0:\n        if y == 0:\n            return 1\n        p = q(x, y // 2, m) % m\n        if y == 0:\n            x += 1\n        p = p * p % m\n        if y % 2 == 0:\n            return p\n        z = x * p % m\n        return z\n    return m\nn = int(input())\nk = int(input())\nb = 2 ** (n - 1) - n\nm = 1000000007\na = 2 ** (n - 1)\nx = q(a, m - 2, m)\nif m > 0:\n    ans = b * x % m\n    print(int(ans))", "def extended_gcd(aa, bb):\n    (lastremainder, remainder) = (abs(aa), abs(bb))\n    (x, lastx, y, lasty) = (0, 1, 1, 0)\n    while remainder:\n        (lastremainder, (quotient, remainder)) = (remainder, divmod(lastremainder, remainder))\n        (x, lastx) = (lastx - quotient * x, x)\n        (y, lasty) = (lasty - quotient * y, y)\n    return (lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1))\n\ndef modinv(a, m):\n    (g, x, y) = extended_gcd(a, m)\n    if g != 1:\n        raise ValueError\n    return x % m\nn = int(input())\nk = int(input())\ndiv = pow(10, 9) + 7\np = 1\ntot = 1\nfor _ in range(n - 1):\n    p = p * 2 % div\n    tot = tot * 2 % div\np = p - n\nres = p * modinv(tot, div) % div\nprint(res)", "n = int(input())\nk = int(input())\nmod = 10 ** 9 + 7\nmodinv = pow(2 ** (n - 1), mod - 2, mod)\nprint((2 ** (n - 1) - n) * modinv % mod)", "def modInverse(a, m):\n    g = gcd(a, m)\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nn = int(input())\nk = int(input())\na = 2 ** (n - 1) - n\nb = 2 ** (n - 1)\nm = 1000000007\nans = modInverse(b, m)\nans = ans * a % m\nprint(ans)", "n = int(input())\nk = input()\na = n - 1\np = 1\nwhile a > 0:\n    p = p << 1\n    a = a - 1\nq = p\np = p - n\np = p % 1000000007\nq_inv = pow(q, 1000000005, 1000000007)\nans = p * q_inv\nans = ans % 1000000007\nprint(ans)", "def fastp(x, n, m):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        v = fastp(x, n / 2, m)\n        return v * v % m\n    else:\n        v = fastp(x, n / 2, m)\n        return x * v % m\n\ndef po(x, y, m):\n    if y == 0:\n        return 1\n    t = y // 2\n    peri = po(x, t, m)\n    peri = peri % m\n    peri = peri * peri % m\n    if y % 2 == 0:\n        return peri\n    else:\n        return x * peri % m\n\ndef gcd(a, c):\n    if a == 0:\n        return c\n    return gcd(c % a, a)\na = int(input())\nk = int(input())\nn = 2 ** (a - 1)\nm = 10 ** 9 + 7\nr = gcd(n, m)\nu = po(n, m - 2, m)\nl = u * (n - a)\nprint(l % (10 ** 9 + 7))", "m = 1000000007\nn = int(input())\nk = int(input())\np = pow(2, n - 1) - n\nq = pow(2, n - 1)\nq_inv = pow(q, m - 2, m)\nres = p * q_inv % m\nprint(res)", "def HCF(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef modI(a, m):\n    mini = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        r = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - r * y\n        x = t\n    if x < 0:\n        x = x + mini\n    return x\nn = int(input(''))\nk = int(input(''))\np = 2 ** (n - 1) - n\nq = 2 ** (n - 1)\nw = HCF(p, q)\np = p // w\nq = q // w\nmh = modI(q, 1000000007)\nkl = mh * p % 1000000007\nprint(kl)", "def inverse(num, mod):\n    o = mod\n    p = 0\n    q = 1\n    if mod == 1:\n        return 0\n    while num > 1:\n        quo = num // mod\n        temp = mod\n        mod = num % mod\n        num = temp\n        temp = p\n        p = q - quo * p\n        q = temp\n    if q < 0:\n        q = q + o\n    return q\nn = int(input())\nk = int(input())\na = pow(2, n - 1)\nP = a - n\nQ = a\nQ = inverse(Q, 1000000007)\nprint(P * Q % 1000000007)", "def ans(num, denom):\n    h = pow(10, 9) + 7\n    inv = pow(denom, h - 2, h)\n    ans = num * inv\n    print(ans % h)\nfrom fractions import gcd\nn = int(input())\ns = int(input())\na = pow(2, n - 1) - n\nb = pow(2, n - 1)\ncheck = 1\nwhile check == 1:\n    q = gcd(a, b)\n    if q == 1:\n        break\n    else:\n        a = a // q\n        b = b // q\nans(a, b)", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nn = int(input())\ntempN = n - 1\nk = int(input())\nwhile n % 2 == 0:\n    n /= 2\n    tempN -= 1\ninv = modinv(2 ** tempN, 1000000007)\nprint(int((1 - n * inv) % 1000000007))", "n = int(input())\nk = int(input())\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\np = 2 ** (n - 1) - n\nq = 2 ** (n - 1)\np = int(p)\nmo = 1000000007\nqinv = modInverse(q, mo)\nprint(p * qinv % 1000000007)", "mod = 1000000007\n\ndef power(a, b):\n    if b == 0:\n        return 1\n    temp = power(a, b // 2)\n    if b % 2 == 0:\n        return temp * temp % mod\n    else:\n        return a * (temp * temp) % mod % mod\nn = int(input())\nk = int(input())\nk = n\nx = 0\nwhile n % 2 == 0:\n    n = n // 2\n    x = x + 1\nden = power(2, k - 1 - x)\nnum = den - n\nprint(num * power(den, mod - 2) % mod)", "x = int(input())\ny = int(input())\nm = 1000000007\nex = pow(2, x - 1)\neu = ex - x\ney = pow(ex, m - 2, m)\nez = eu * ey % m\nprint(ez)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nn = int(input())\nk = int(input())\np = 2 ** (n - 1)\np = p - n\nq = 2 ** (n - 1)\nprint(modInverse(q, 1000000007) * p % 1000000007)", "(n, k) = (int(input()), int(input()))\nq = 2 ** (n - 1)\np = q - n\nres = pow(q, 1000000005, 1000000007)\nprint(p * res % 1000000007)", "MOD = int(1000000000.0 + 7)\n\ndef mmi(x):\n    return pow(x, MOD - 2, MOD)\nn = int(input())\n_ = int(input())\nnum = (pow(2, n - 1, MOD) - n) % MOD\ndenom = pow(2, n - 1, MOD)\nret = num * mmi(denom)\nprint(ret % MOD)", "def fast_exp(x, y, _MOD):\n    if y == 0:\n        return 1\n    p = fast_exp(x, y // 2, _MOD) % _MOD\n    p = p * p % _MOD\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % _MOD\nn = int(input())\nk = int(input())\nq = 2 ** (n - 1)\np = q - n\n_MOD = 1000000007\nprint(p * fast_exp(q, _MOD - 2, _MOD) % _MOD)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nn = int(input())\nk = int(input())\nq = 2 ** (n - 1)\nr = (q - n + 1000000007 + 1000000007 + 1000000007) % 1000000007\nx = modInverse(q, 1000000007) % 1000000007\nx = r * x % 1000000007\nprint(x)", "M = 10 ** 9 + 7\n\ndef mod(e):\n    if e > 30:\n        return mod(e // 2) * mod(e - e // 2) % M\n    return 2 ** e % M\n\ndef modinv(n):\n    g = M + 1\n    for i in range(n):\n        if g % 2 != 0:\n            g += M\n        g //= 2\n    return g\nn = int(input())\nk = int(input())\nm = mod(n - 1)\nq = 0\nm = (m - n) % M\nprint(m * modinv(n - 1) % M)", "from fractions import Fraction\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    return x % m\n\ndef calc(n, m):\n    if n != 2:\n        c = 1 << n - 1\n        frac = Fraction(c - n, c)\n        return frac.numerator * modinv(frac.denominator, m) % m\n    else:\n        return 0\nm = 10 ** 9 + 7\nn = int(input())\nk = input()\nprint(calc(n, m))", "from fractions import Fraction\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    return x % m\n\ndef f(n):\n    if n == 2:\n        return 0\n    c = 2 ** (n - 1)\n    num = c - n\n    den = c\n    frac = Fraction(num, den)\n    return frac.numerator * modinv(frac.denominator, 10 ** 9 + 7) % (10 ** 9 + 7)\nn = int(input())\nk = int(input())\nprint(f(n))", "def power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\nMOD = 1000000007\nn = int(input())\nk = int(input())\nN = power(2, n - 1, MOD)\nn = modInverse(N, MOD) * (N - n) % MOD\nprint(n)", "def power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\np = 1000000007\nn = int(input())\nk = int(input())\ns = power(2, n - 1, p)\nc = power(s, p - 2, p)\nans = (s - n) * c % p\nprint(ans)", "def modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nn = int(input())\nk = int(input())\nq = 2 ** (n - 1)\np = q - n\nr = modInverse(q, 1000000007)\nprint(p * r % 1000000007)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nn = int(input())\nk = int(input())\nm = 1000000007\nq = 2 ** (n - 1)\np = q - n\nq = modInverse(q, m)\nans = p * q % m\nprint(ans)", "M = 1000000007\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef power(x, y):\n    if y == 0:\n        return 1\n    pow = power(x, int(y / 2)) % M\n    pow = pow * pow % M\n    if y % 2 == 0:\n        return pow\n    else:\n        return x * pow % M\nn = input().split(' ')\nn = int(n[0])\nk = input().split(' ')\nk = int(k[0])\nq = power(2, n - 1)\np = q - n\nx = gcd(p, q)\np = int(p / x)\nq = int(q / x)\nq = power(q, M - 2)\nprint(p % M * (q % M) % M)", "import sys\nf = sys.stdin\nn = int(f.readline())\nk = int(f.readline())\nmod = int(1000000000.0 + 7)\nq = pow(2, n - 1)\nqinv = pow(q, mod - 2, mod)\np = q - n\nprint(p * qinv % mod)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nm = 1000000007\nn = int(input())\nk = int(input())\nr = modInverse(2 ** (n - 1), m)\np = (m - 1) * n % m\np = (1 + p * r) % m\nprint(p)", "MOD = 1000000007\n\ndef fastexp(a, b):\n    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % MOD\n        a = a * a % MOD\n        b = b // 2\n    return res\n\ndef modinv(a):\n    return fastexp(a, MOD - 2)\nN = int(input())\nK = int(input())\nQ = fastexp(2, N - 1)\nP = Q - N\nres = P * modinv(Q) % MOD\nprint(res)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nMOD = 10 ** 9 + 7\nn = int(input())\nk = int(input())\nif n == 2:\n    print(0)\nelse:\n    Q = 2 ** (n - 1)\n    P = 2 ** (n - 1) - n\n    inverse = modInverse(Q, MOD)\n    prod = P * inverse % MOD\n    print(prod)", "n = int(input())\nprint((pow(2, n - 1, 1000000007) + 1000000007 - n) % 1000000007 * pow(2, (n - 1) * 1000000005 % 1000000006, 1000000007) % 1000000007)", "def exponential(a, b):\n    a %= modulo\n    sol = 1\n    while b >= 1:\n        if 1 & b:\n            sol *= a\n            sol %= modulo\n        a = pow(a, 2) % modulo\n        b >>= 1\n    return sol\nN = int(input())\nK = int(input())\nmodulo = pow(10, 9) + 7\nX = exponential(2, N - 1)\nY = exponential(X, modulo - 2)\nZ = Y * (X - N) % modulo\nprint(Z % modulo)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef inverse_mod(a, m):\n    g = gcd(a, m)\n    return power(a, m - 2, m)\nn = int(input())\nk = int(input())\nq = 2 ** (n - 1)\np = 2 ** (n - 1) - n\nm = 1000000007\nprint(inverse_mod(q, m) * p % m)", "import math\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nn = int(input())\nk = int(input())\nq = 2 ** (n - 1)\np = q - n\nd = int(math.pow(10, 9) + 7)\nprint(p * modInverse(q, d) % d)", "mod = 1000000007\nnum = int(input())\np = int(input())\nnumber = 2 ** (num - 1)\ninv = pow(number, mod - 2, mod)\nprint((number - num) * inv % mod)", "import math\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nn = int(input())\nk = int(input())\nq = 2 ** (n - 1)\np = q - n\nd = int(math.pow(10, 9) + 7)\nprint(p * modInverse(q, d) % d)", "n = int(input())\nk = int(input())\nm = 10 ** 9 + 7\nzz = 2 ** (n - 1)\nprint((zz - n) * pow(zz, m - 2, m) % m)", "import math\n\ndef modInverse(a, m):\n    g = math.gcd(a, m)\n    if g != 1:\n        return 0\n    else:\n        return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nn = int(input())\nk = int(input())\nq = 2 ** (n - 1)\np = q - n\nf = math.gcd(p, q)\np = p // f\nq = q // f\nprint(p * modInverse(q, 1000000007) % 1000000007)", "n = int(input())\ns = int(input())\np = 2 ** (n - 1)\np = p - n\nq = 2 ** n\nq = q // 2\nm = 1000000000\nm = m + 7\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m)\n    p = p % m\n    p = p ** 2\n    p = p % m\n    if y % 2 != 0:\n        a = x * p\n        a = a % m\n        return a\n    else:\n        a = p\n        return a\n\ndef modd(a, b, c):\n    return a * b % c\nA = power(q, m - 2, m)\nprint(modd(A, p, m))", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef GCD(a, b):\n    if b == 0:\n        return a\n    else:\n        return GCD(b, a % b)\nN = int(input())\nK = int(input())\nNum = 2 ** (N - 1) - N\nDen = 2 ** (N - 1)\nGCD = GCD(Den, Num)\nNum = Num // GCD\nDen = Den // GCD\nMod = 1000000007\nprint(Num % Mod * (modInverse(Den, Mod) % Mod) % Mod)", "def modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nn = int(input())\nk = int(input())\nmod = 1000000007\nq = 2 ** (n - 1)\np = q - n\nqInv = modInverse(q, mod)\nans = p % mod * (qInv % mod) % mod\nprint(ans)", "import math\nn = int(input())\nk = int(input())\nq = int(pow(2, n - 1))\np = q - n\nwhile math.gcd(p, q) > 1:\n    r = math.gcd(p, q)\n    p = p // r\n    q = q // r\ng = 1\nh = 0\nm = 1000000007\nl = m\nwhile q > 1:\n    s = q // m\n    n = m\n    m = q % m\n    q = n\n    n = h\n    h = g - s * h\n    g = n\n    if g < 0:\n        g = g + l\nprint(p * g % 1000000007)", "from fractions import Fraction\nfrom math import gcd\n\ndef inverse(a, n):\n    t = 0\n    newt = 1\n    r = n\n    newr = a\n    while newr != 0:\n        quotient = r // newr\n        (t, newt) = (newt, t - quotient * newt)\n        (r, newr) = (newr, r - quotient * newr)\n    if r > 1:\n        return 0\n    if t < 0:\n        t += n\n    return t\n\ndef modInverse(a, m):\n    g = gcd(a, m)\n    if g != 1:\n        return 0\n    else:\n        return pow(a, m - 2, m)\n\ndef reach_equilibrium():\n    mod = 10 ** 9 + 7\n    num_of_vectors = int(input())\n    k = int(input())\n    if num_of_vectors == 2:\n        return 0\n    return mod - num_of_vectors * modInverse(pow(2, num_of_vectors - 1), mod) % mod + 1\nprint(reach_equilibrium())", "def modInverse(a, m):\n    g = gcd(a, m)\n    if g == 1:\n        w = power(a, m - 2, m)\n        l = s * w % m\n        print(l)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nn = int(input())\nk = int(input())\nm = 1000000007\na = 2 ** (n - 1)\ns = 2 ** (n - 1) - n\nmodInverse(a, m)", "def modInverse(a, m):\n    g = gcd(a, m)\n    if g == 1:\n        z = power(a, m - 2, m)\n        t = b * z % m\n        print(t)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nn = int(input())\nx = int(input())\nm = 1000000007\na = 2 ** (n - 1)\nb = 2 ** (n - 1) - n\nmodInverse(a, m)", "def modInverse(a, m, zz):\n    if zz:\n        g = gcd(a, m, True)\n        if g != 1:\n            return 0\n        else:\n            return power(a, m - 2, m, True)\n\ndef power(x, y, m, flag):\n    if flag:\n        if y == 0:\n            return 1\n        p = power(x, y // 2, m, True) % m\n        p = p * p % m\n        if y % 2 == 0:\n            return p\n        else:\n            return x * p % m\n\ndef gcd(a, b, zz):\n    if zz:\n        if a == 0:\n            return b\n        return gcd(b % a, a, True)\nN = int(input())\nK = int(input())\nif N == 2:\n    print(0)\nelse:\n    num = pow(2, N - 1, 1000000007) - N\n    den = pow(2, N - 1, 1000000007)\n    mod = modInverse(den, 1000000007, True)\n    zz = mod * num\n    ans = zz % 1000000007\n    print(ans)", "def modInv(a):\n    m = 1000000007\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nn = int(input())\nk = int(input())\nq = 2 ** (n - 1)\np = q - n\nd = modInv(q)\nx = p * d % 1000000007\nprint(x)", "p = 10 ** 9 + 7\nn = int(input())\n_ = input()\nk = pow(2, n - 1)\nprint((k - n) * pow(k, p - 2, p) % p)", "m = 1000000007\nn = int(input())\nk = int(input())\ndeno = 2 ** (n - 1)\nnume = deno - n\ndeno = int(pow(deno, m - 2, m))\nnume = nume % m * deno % m % m\nprint(nume)", "import math\nfrom sys import exit\nfrom decimal import Decimal as dec\n\ndef li():\n    return list(map(int, input().split()))\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef num():\n    return map(int, input().split())\n\ndef main():\n    n = nu()\n    uselessfellow = nu()\n    print((pow(2, n - 1, 1000000007) - n) * modInverse(pow(2, n - 1, 1000000007), 1000000007) % 1000000007)\n\ndef nu():\n    return int(input())\nmain()", "from fractions import Fraction as f\np = 10 ** 9 + 7\nn = int(input())\n_ = input()\nk = pow(2, n - 1)\na = f(k - n, k)\nprint(a.numerator * pow(a.denominator, p - 2, p) % p)", "from math import gcd\nMOD = 1000000007\nn = int(input())\nk = int(input())\nq = pow(2, n - 1)\np = q - n\nqinv = pow(q, MOD - 2, MOD)\nprint(p % MOD * (qinv % MOD) % MOD)", "from math import gcd\n\ndef mod(a, n, m):\n    r = 1\n    while n > 0:\n        if n % 2 == 1:\n            r = int(r * a % m)\n        a = int(a * a % m)\n        n = int(n / 2)\n    return r\nn = int(input())\nk = int(input())\nnum = int(pow(2, n - 1) - n)\nden = int(pow(2, n - 1))\ng = gcd(num, den)\nnum = int(num // g)\nden = int(den // g)\nprint(num * mod(den, 1000000005, 1000000007) % 1000000007)"]