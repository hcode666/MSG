["from sys import stdin, stdout\nimport math\n\ndef update(bit, n, pos, v):\n    pos += 1\n    while pos <= n:\n        bit[pos] += v\n        pos += -pos & pos\n    return\n\ndef getsum(bit, i):\n    su = 0\n    while i > 0:\n        su += bit[i]\n        i -= -i & i\n    return su\n\ndef main():\n    try:\n        (n, nQ) = In()\n        bit = [0] * (n + 1)\n        l = list(In())\n        task = []\n        for i in range(n - 1):\n            task.append([min(l[i], l[i + 1]), 1, i])\n            task.append([max(l[i], l[i + 1]), 3, i])\n        Q = []\n        ans = [0 for x in range(nQ)]\n        for q in range(nQ):\n            (l, r, y) = In()\n            l -= 1\n            r -= 1\n            Q.append([l, r])\n            task.append([y, 2, q])\n        task.sort(key=lambda x: [x[0], x[1]])\n        for x in task:\n            if x[1] == 1:\n                update(bit, n, x[2], 1)\n            elif x[1] == 3:\n                update(bit, n, x[2], -1)\n            else:\n                ans[x[2]] = getsum(bit, Q[x[2]][1]) - getsum(bit, Q[x[2]][0])\n        for x in ans:\n            print(x)\n    except:\n        pass\n\ndef add(a, b, c):\n    res = a + b\n    if res >= c:\n        return res - c\n    else:\n        return res\n\ndef mod(a, b, c):\n    res = a * b\n    if res >= c:\n        return res % c\n    else:\n        return res\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    w = a // gcd(a, b)\n    return w * b\n\ndef expo(a, b):\n    (x, y) = (1, a)\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, m):\n    (x, y) = (1,)\n    while b > 0:\n        if b & 1:\n            x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nfor _ in range(I()):\n    main()", "from sys import stdin, stdout\nimport math\n\ndef update(bit, n, pos, v):\n    pos += 1\n    while pos <= n:\n        bit[pos] += v\n        pos += -pos & pos\n    return\n\ndef getsum(bit, i):\n    su = 0\n    while i > 0:\n        su += bit[i]\n        i -= -i & i\n    return su\n\ndef main():\n    try:\n        (n, nQ) = In()\n        bit = [0] * (n + 1)\n        l = list(In())\n        task = []\n        for i in range(n - 1):\n            task.append([min(l[i], l[i + 1]), 1, i])\n            task.append([max(l[i], l[i + 1]), 3, i])\n        Q = []\n        ans = [0 for x in range(nQ)]\n        for q in range(nQ):\n            (l, r, y) = In()\n            l -= 1\n            r -= 1\n            Q.append([l, r])\n            task.append([y, 2, q])\n        task.sort(key=lambda x: [x[0], x[1]])\n        for x in task:\n            if x[1] == 1:\n                update(bit, n, x[2], 1)\n            elif x[1] == 3:\n                update(bit, n, x[2], -1)\n            else:\n                ans[x[2]] = getsum(bit, Q[x[2]][1]) - getsum(bit, Q[x[2]][0])\n        for x in ans:\n            print(x)\n    except:\n        pass\n\ndef add(a, b, c):\n    res = a + b\n    if res >= c:\n        return res - c\n    else:\n        return res\n\ndef mod(a, b, c):\n    res = a * b\n    if res >= c:\n        return res % c\n    else:\n        return res\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    w = a // gcd(a, b)\n    return w * b\n\ndef expo(a, b):\n    (x, y) = (1, a)\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, m):\n    (x, y) = (1,)\n    while b > 0:\n        if b & 1:\n            x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nfor _ in range(I()):\n    main()", "from sys import stdin, stdout\nimport math\n\ndef update(bit, n, pos, v):\n    pos += 1\n    while pos <= n:\n        bit[pos] += v\n        pos += -pos & pos\n    return\n\ndef getsum(bit, i):\n    su = 0\n    while i > 0:\n        su += bit[i]\n        i -= -i & i\n    return su\n\ndef main():\n    try:\n        (n, nQ) = In()\n        bit = [0] * (n + 1)\n        l = list(In())\n        task = []\n        for i in range(n - 1):\n            task.append([min(l[i], l[i + 1]), 1, i])\n            task.append([max(l[i], l[i + 1]), 3, i])\n        Q = []\n        ans = [0 for x in range(nQ)]\n        for q in range(nQ):\n            (l, r, y) = In()\n            l -= 1\n            r -= 1\n            Q.append([l, r])\n            task.append([y, 2, q])\n        task.sort(key=lambda x: [x[0], x[1]])\n        for x in task:\n            if x[1] == 1:\n                update(bit, n, x[2], 1)\n            elif x[1] == 3:\n                update(bit, n, x[2], -1)\n            else:\n                ans[x[2]] = getsum(bit, Q[x[2]][1]) - getsum(bit, Q[x[2]][0])\n        for x in ans:\n            print(x)\n    except:\n        pass\n\ndef add(a, b, c):\n    res = a + b\n    if res >= c:\n        return res - c\n    else:\n        return res\n\ndef mod(a, b, c):\n    res = a * b\n    if res >= c:\n        return res % c\n    else:\n        return res\n\ndef gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef lcm(a, b):\n    w = a // gcd(a, b)\n    return w * b\n\ndef expo(a, b):\n    (x, y) = (1, a)\n    while b > 0:\n        if b & 1:\n            x = x * y\n        y = y * y\n        b >>= 1\n    return x\n\ndef power(a, b, m):\n    (x, y) = (1,)\n    while b > 0:\n        if b & 1:\n            x = mod(x, y, m)\n        y = mod(y, y, m)\n        b >>= 1\n    return x\n\ndef L():\n    return list(map(int, stdin.readline().split()))\n\ndef In():\n    return map(int, stdin.readline().split())\n\ndef I():\n    return int(stdin.readline())\nP = 1000000007\nfor _ in range(I()):\n    main()", "def read_int():\n    return int(input().strip())\n\ndef read_int_array():\n    return map(int, input().strip().split())\n\ndef update(v, i, x):\n    while i < len(v):\n        v[i] += x\n        i += i & -i\n\ndef query(v, i):\n    s = 0\n    i -= 1\n    while i > 0:\n        s += v[i]\n        i -= i & -i\n    return s\nfor t in range(read_int()):\n    (n, q) = tuple(read_int_array())\n    events = []\n    points = tuple(read_int_array())\n    x = []\n    v = [0 for i in range(n)]\n    res = [0 for i in range(q)]\n    for i in range(0, n - 1):\n        y1 = min(points[i], points[i + 1])\n        y2 = max(points[i], points[i + 1])\n        events.append((y1, 1, i + 1))\n        events.append((y2, 3, i + 1))\n    for i in range(q):\n        (x1, x2, y) = tuple(read_int_array())\n        events.append((y, 2, i))\n        x.append((x1, x2))\n    events.sort(key=lambda x: (x[0], x[1]))\n    for ev in events:\n        if ev[1] == 1:\n            update(v, ev[2], 1)\n        elif ev[1] == 2:\n            i = ev[2]\n            (x1, x2) = x[i]\n            res[i] = query(v, x2) - query(v, x1)\n        elif ev[1] == 3:\n            update(v, ev[2], -1)\n    print('\\n'.join(map(str, res)))", "def isolateOneBit(n):\n    return n & -n\n\ndef getSum(BIT, ind):\n    s = 0\n    num = ind\n    while num > 0:\n        s += BIT[num]\n        num -= isolateOneBit(num)\n    return s\n\ndef rangeSum(BIT, l, u):\n    uSum = getSum(BIT, u)\n    lSum = getSum(BIT, l - 1)\n    return uSum - lSum\n\ndef updateSums(BIT, nBIT, ind, delta):\n    while ind <= nBIT:\n        BIT[ind] += delta\n        ind += isolateOneBit(ind)\n\ndef main():\n    t = int(input())\n    while t:\n        t -= 1\n        (n, q) = map(int, input().split())\n        pts = list(map(int, input().split()))\n        qArr = []\n        for i in range(q):\n            quer = list(map(int, input().split()))\n            quer.append(i)\n            qArr.append(quer[:])\n        ptsArr = []\n        for i in range(1, n):\n            a = pts[i - 1]\n            b = pts[i]\n            if a > b:\n                (a, b) = (b, a)\n            ptsArr.append((a, b, i))\n        startArr = sorted(ptsArr[:])\n        endArr = sorted(ptsArr[:], key=lambda x: x[1])\n        qArr.sort(key=lambda x: x[2])\n        fenStart = [0 for i in range(n + 10)]\n        fenEnd = [0 for i in range(n + 10)]\n        answers = []\n        i = 0\n        j = 0\n        for query in qArr:\n            while i < n - 1 and startArr[i][0] <= query[2]:\n                updateSums(fenStart, n + 1, startArr[i][2], 1)\n                i += 1\n            while j < n - 1 and endArr[j][1] < query[2]:\n                updateSums(fenEnd, n + 1, endArr[j][2], 1)\n                j += 1\n            st = rangeSum(fenStart, query[0], query[1] - 1)\n            ed = rangeSum(fenEnd, query[0], query[1] - 1)\n            answers.append((query[3], ed - st))\n        answers.sort()\n        for i in answers:\n            print(-i[1])\nmain()", "def upd(ft, i, x):\n    i += 1\n    while i < n:\n        ft[i] += x\n        i += i & -i\n\ndef qry(ft, i):\n    r = 0\n    while i > 0:\n        r += ft[i]\n        i -= i & -i\n    return r\n\ndef solve():\n    a = list(map(int, input().split()))\n    ft = [0] * mxn\n    ans = [0] * q\n    (ql, qr, qy) = ([], [], [])\n    for i in range(q):\n        (x1, x2, y) = map(int, input().split())\n        ql.append(x1 - 1)\n        qr.append(x2 - 1)\n        qy.append(y)\n    event = []\n    for i in range(0, n - 1):\n        event.append((min(a[i], a[i + 1]), 1, i))\n        event.append((max(a[i], a[i + 1]), 3, i))\n    for i in range(q):\n        event.append((qy[i], 2, i))\n    event.sort()\n    for (y, t, i) in event:\n        if t == 1:\n            upd(ft, i, 1)\n        elif t == 2:\n            ans[i] = qry(ft, qr[i]) - qry(ft, ql[i])\n        else:\n            upd(ft, i, -1)\n    for i in ans:\n        print(i)\nmxn = 100000\nn = 0\nq = 0\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    solve()", "def isolateOneBit(n):\n    return n & -n\n\ndef getSum(BIT, ind):\n    s = 0\n    num = ind\n    while num > 0:\n        s += BIT[num]\n        num -= isolateOneBit(num)\n    return s\n\ndef rangeSum(BIT, l, u):\n    uSum = getSum(BIT, u)\n    lSum = getSum(BIT, l - 1)\n    return uSum - lSum\n\ndef updateSums(BIT, nBIT, ind, delta):\n    while ind <= nBIT:\n        BIT[ind] += delta\n        ind += isolateOneBit(ind)\n\ndef main():\n    t = int(input())\n    while t:\n        t -= 1\n        (n, q) = map(int, input().split())\n        pts = list(map(int, input().split()))\n        qArr = []\n        for i in range(q):\n            quer = list(map(int, input().split()))\n            quer.append(i)\n            qArr.append(quer[:])\n        ptsArr = []\n        for i in range(1, n):\n            a = pts[i - 1]\n            b = pts[i]\n            if a > b:\n                (a, b) = (b, a)\n            ptsArr.append((a, b, i))\n        startArr = sorted(ptsArr[:])\n        endArr = sorted(ptsArr[:], key=lambda x: x[1])\n        qArr.sort(key=lambda x: x[2])\n        fenStart = [0 for i in range(n + 10)]\n        fenEnd = [0 for i in range(n + 10)]\n        answers = []\n        i = 0\n        j = 0\n        for query in qArr:\n            while i < n - 1 and startArr[i][0] <= query[2]:\n                updateSums(fenStart, n + 1, startArr[i][2], 1)\n                i += 1\n            while j < n - 1 and endArr[j][1] < query[2]:\n                updateSums(fenEnd, n + 1, endArr[j][2], 1)\n                j += 1\n            st = rangeSum(fenStart, query[0], query[1] - 1)\n            ed = rangeSum(fenEnd, query[0], query[1] - 1)\n            answers.append((query[3], ed - st))\n        answers.sort()\n        for i in answers:\n            print(-i[1])\nmain()", "def read_int():\n    return int(input().strip())\n\ndef read_int_array():\n    return map(int, input().strip().split())\n\ndef update(v, i, x):\n    while i < len(v):\n        v[i] += x\n        i += i & -i\n\ndef query(v, i):\n    s = 0\n    i -= 1\n    while i > 0:\n        s += v[i]\n        i -= i & -i\n    return s\nfor t in range(read_int()):\n    (n, q) = tuple(read_int_array())\n    events = []\n    points = tuple(read_int_array())\n    x = []\n    v = [0 for i in range(n)]\n    res = [0 for i in range(q)]\n    for i in range(0, n - 1):\n        y1 = min(points[i], points[i + 1])\n        y2 = max(points[i], points[i + 1])\n        events.append((y1, 1, i + 1))\n        events.append((y2, 3, i + 1))\n    for i in range(q):\n        (x1, x2, y) = tuple(read_int_array())\n        events.append((y, 2, i))\n        x.append((x1, x2))\n    events.sort(key=lambda x: (x[0], x[1]))\n    for ev in events:\n        if ev[1] == 1:\n            update(v, ev[2], 1)\n        elif ev[1] == 2:\n            i = ev[2]\n            (x1, x2) = x[i]\n            res[i] = query(v, x2) - query(v, x1)\n        elif ev[1] == 3:\n            update(v, ev[2], -1)\n    print('\\n'.join(map(str, res)))", "def update(tree, n, i, v):\n    i += 1\n    while i < n:\n        tree[i] += v\n        i += i & -i\n\ndef query(tree, i):\n    r = 0\n    while i > 0:\n        r += tree[i]\n        i -= i & -i\n    return r\nt = int(input())\nfor _ in range(t):\n    (n, q) = [int(i) for i in input().split()]\n    tree = [0] * (n + 1)\n    ql = []\n    qr = []\n    qy = []\n    arr = [int(i) for i in input().split()]\n    for i in range(q):\n        (a, b, y1) = [int(i) for i in input().split()]\n        ql.append(a - 1)\n        qr.append(b - 1)\n        qy.append(y1)\n    events = []\n    for i in range(n - 1):\n        events.append((min(arr[i], arr[i + 1]), 1, i))\n        events.append((max(arr[i], arr[i + 1]), 3, i))\n    for i in range(q):\n        events.append((qy[i], 2, i))\n    events.sort()\n    ans = [0] * q\n    for i in events:\n        if i[1] == 1:\n            update(tree, n, i[2], 1)\n        elif i[1] == 2:\n            ans[i[2]] = query(tree, qr[i[2]]) - query(tree, ql[i[2]])\n        else:\n            update(tree, n, i[2], -1)\n    for i in range(q):\n        print(ans[i])", "import numpy as np\nII = lambda : [int(x) for x in input().split()]\n\ndef solve2():\n    (N, Q) = II()\n    A = II()\n    A = np.array([A[:-1], A[1:]])\n    A.sort(axis=0)\n    ranges = []\n    ys = []\n    for q in range(Q):\n        (x1, x2, y) = II()\n        ranges.append((x1, x2))\n        ys.append((q, y))\n    ys = sorted(ys, key=lambda x: x[1])\n    A_l = sorted(list(zip(A[0], range(N - 1))))\n    A_r = sorted(list(zip(A[1], range(N - 1))))\n    l_res = np.array([False] * (N - 1))\n    r_res = np.array([True] * (N - 1))\n    res = np.array([False] * (N - 1))\n    results = [None] * Q\n    l = 0\n    r = 0\n    for (q, y) in ys:\n        while l < len(A_l) and y >= A_l[l][0]:\n            l_res[A_l[l][1]] = True\n            res[A_l[l][1]] = r_res[A_r[r][1]]\n            l += 1\n        while r < len(A_r) and y > A_r[r][0]:\n            r_res[A_r[r][1]] = False\n            res[A_r[r][1]] = False\n            r += 1\n        (x1, x2) = ranges[q]\n        result = np.count_nonzero(res[x1 - 1:x2 - 1])\n        results[q] = result\n    for r in results:\n        print(r)\nT = int(input())\nfor _ in range(T):\n    solve2()", "def isolateOneBit(n):\n    return n & -n\n\ndef getSum(BIT, ind):\n    s = 0\n    num = ind\n    while num > 0:\n        s += BIT[num]\n        num -= isolateOneBit(num)\n    return s\n\ndef rangeSum(BIT, l, u):\n    uSum = getSum(BIT, u)\n    lSum = getSum(BIT, l - 1)\n    return uSum - lSum\n\ndef updateSums(BIT, nBIT, ind, delta):\n    while ind <= nBIT:\n        BIT[ind] += delta\n        ind += isolateOneBit(ind)\n\ndef main():\n    t = int(input())\n    while t:\n        t -= 1\n        (n, q) = map(int, input().split())\n        pts = list(map(int, input().split()))\n        qArr = []\n        for i in range(q):\n            quer = list(map(int, input().split()))\n            quer.append(i)\n            qArr.append(quer[:])\n        ptsArr = []\n        for i in range(1, n):\n            a = pts[i - 1]\n            b = pts[i]\n            if a > b:\n                (a, b) = (b, a)\n            ptsArr.append((a, b, i))\n        startArr = sorted(ptsArr[:])\n        endArr = sorted(ptsArr[:], key=lambda x: x[1])\n        qArr.sort(key=lambda x: x[2])\n        fenStart = [0 for i in range(n + 10)]\n        fenEnd = [0 for i in range(n + 10)]\n        answers = []\n        i = 0\n        j = 0\n        for query in qArr:\n            while i < n - 1 and startArr[i][0] <= query[2]:\n                updateSums(fenStart, n + 1, startArr[i][2], 1)\n                i += 1\n            while j < n - 1 and endArr[j][1] < query[2]:\n                updateSums(fenEnd, n + 1, endArr[j][2], 1)\n                j += 1\n            st = rangeSum(fenStart, query[0], query[1] - 1)\n            ed = rangeSum(fenEnd, query[0], query[1] - 1)\n            answers.append((query[3], ed - st))\n        answers.sort()\n        for i in answers:\n            print(-i[1])\nmain()", "def getsum(BITTree, i):\n    s = 0\n    i = i + 1\n    while i > 0:\n        s += BITTree[i]\n        i -= i & -i\n    return s\n\ndef updatebit(BITTree, n, i, v):\n    i += 1\n    while i <= n:\n        BITTree[i] += v\n        i += i & -i\n\ndef construct(arr, n):\n    BITTree = [0] * (n + 1)\n    for i in range(n):\n        updatebit(BITTree, n, i, arr[i])\n    return BITTree\nt = int(input())\nwhile t:\n    t -= 1\n    (n, q) = map(int, input().split())\n    cknc = [0 for _ in range(n)]\n    dawg = construct(cknc, len(cknc))\n    cat = construct(cknc, len(cknc))\n    final_ans = [0 for _ in range(q)]\n    jake = list(map(int, input().split()))\n    oooo = []\n    jakex = []\n    jakey = []\n    for i in range(n - 1):\n        jakey.append((min(jake[i], jake[i + 1]), max(jake[i], jake[i + 1]), i))\n        jakex.append((min(jake[i], jake[i + 1]), max(jake[i], jake[i + 1]), i))\n    jakex.sort(key=lambda x: x[0])\n    jakey.sort(key=lambda x: x[1])\n    loq = []\n    q1 = q\n    for i in range(q1):\n        (x1, x2, x3) = map(int, input().split())\n        x1 -= 1\n        x2 -= 2\n        loq.append((x1, x2, x3, i))\n    loq.sort(key=lambda x: x[2])\n    a = 0\n    b = 0\n    c = 0\n    for i in range(q):\n        while a < n - 1 and jakex[a][0] <= loq[i][2]:\n            updatebit(dawg, n, jakex[a][2] + 1, 1)\n            a += 1\n        while b < n - 1 and jakey[b][1] < loq[i][2]:\n            updatebit(cat, n, jakey[b][2] + 1, 1)\n            b += 1\n        temp1 = getsum(dawg, loq[i][1] + 1) - getsum(dawg, loq[i][0])\n        temp2 = getsum(cat, loq[i][1] + 1) - getsum(cat, loq[i][0])\n        final_ans[loq[i][3]] = temp1 - temp2\n    for prawn in final_ans:\n        print(prawn, end='\\n')", "def change(x, delta):\n    while x <= n:\n        fenwick[x] += delta\n        x += x & -x\n\ndef getsum(x):\n    s = 0\n    while x > 0:\n        s += fenwick[x]\n        x -= x & -x\n    return s\n\ndef change1(x, delta):\n    while x <= n:\n        fenwick1[x] += delta\n        x += x & -x\n\ndef getsum1(x):\n    s = 0\n    while x > 0:\n        s += fenwick1[x]\n        x -= x & -x\n    return s\nfor _ in range(int(input())):\n    (m, q) = map(int, input().split())\n    a = [int(o) for o in input().split()]\n    a1 = []\n    a2 = []\n    fenwick = [0] * 150212\n    fenwick1 = [0] * 150212\n    n = 150212\n    for i in range(m - 1):\n        a1.append([min(a[i], a[i + 1]), i + 1])\n        a2.append([max(a[i], a[i + 1]), i + 1])\n    a1 = sorted(a1)\n    a2 = sorted(a2)\n    qu = []\n    for i in range(q):\n        (u, v, w) = map(int, input().split())\n        qu.append([w, u, v - 1, i])\n    qu.sort()\n    i = 0\n    j = 0\n    ans = [0] * q\n    for u in range(q):\n        while j < m - 1 and a2[j][0] < qu[u][0]:\n            change1(a2[j][1], 1)\n            j += 1\n        ans2 = getsum1(qu[u][2]) - getsum1(qu[u][1] - 1)\n        while i < m - 1 and a1[i][0] <= qu[u][0]:\n            change(a1[i][1], 1)\n            i += 1\n        ans1 = getsum(qu[u][2]) - getsum(qu[u][1] - 1)\n        ans[qu[u][3]] = ans1 - ans2\n    for i in ans:\n        print(i)", "import numpy as np\nII = lambda : [int(x) for x in input().split()]\n\ndef solve2():\n    (N, Q) = II()\n    A = II()\n    A = np.array([A[:-1], A[1:]])\n    A.sort(axis=0)\n    ranges = []\n    ys = []\n    for q in range(Q):\n        (x1, x2, y) = II()\n        ranges.append((x1, x2))\n        ys.append((q, y))\n    ys = sorted(ys, key=lambda x: x[1])\n    A_l = sorted(list(zip(A[0], range(N - 1))))\n    A_r = sorted(list(zip(A[1], range(N - 1))))\n    l_res = np.array([False] * (N - 1))\n    r_res = np.array([True] * (N - 1))\n    res = np.array([False] * (N - 1))\n    results = [None] * Q\n    l = 0\n    r = 0\n    for (q, y) in ys:\n        while l < len(A_l) and y >= A_l[l][0]:\n            l_res[A_l[l][1]] = True\n            res[A_l[l][1]] = r_res[A_r[r][1]]\n            l += 1\n        while r < len(A_r) and y > A_r[r][0]:\n            r_res[A_r[r][1]] = False\n            res[A_r[r][1]] = False\n            r += 1\n        (x1, x2) = ranges[q]\n        result = np.count_nonzero(res[x1 - 1:x2 - 1])\n        results[q] = result\n    for r in results:\n        print(r)\nT = int(input())\nfor _ in range(T):\n    solve2()"]