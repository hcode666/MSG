["import math\nfor _ in range(int(input())):\n    (n, k, d) = [int(x) for x in input().split()]\n    x = [int(x) for x in input().split()]\n    l = [int(x) - 1 for x in input().split()]\n    lane = l[0]\n    switch_time = -math.inf\n    i = 0\n    while True:\n        while i < n and l[i] == lane:\n            i += 1\n        if i == n:\n            break\n        switch_time = max(switch_time + d, x[i - 1] + 1)\n        if switch_time >= x[i]:\n            break\n        lane = 1 - lane\n    print(x[i] if i < n else k)", "import math\nfor _ in range(int(input())):\n    (n, k, d) = [int(x) for x in input().split()]\n    x = [int(x) for x in input().split()]\n    l = [int(x) - 1 for x in input().split()]\n    lane = l[0]\n    switch_time = -math.inf\n    i = 0\n    while True:\n        while i < n and l[i] == lane:\n            i += 1\n        if i == n:\n            break\n        switch_time = max(switch_time + d, x[i - 1] + 1)\n        if switch_time >= x[i]:\n            break\n        lane = 1 - lane\n    print(x[i] if i < n else k)", "for _ in range(int(input())):\n    (n, k, d) = [int(x) for x in input().split()]\n    x = [int(x) for x in input().split()]\n    l = [int(x) - 1 for x in input().split()]\n    initial_lane = 1 - l[0]\n    i = 0\n    while i < n and l[i] != initial_lane:\n        i += 1\n    if i == n:\n        print(k)\n        continue\n    if x[i] == x[i - 1] + 1:\n        print(x[i])\n        continue\n    lane = 1 - initial_lane\n    until_switch = d\n    while i < n:\n        if until_switch > x[i] - 1 - (x[i - 1] + 1):\n            if l[i] == lane:\n                break\n            else:\n                until_switch -= x[i] + 1 - (x[i - 1] + 1)\n                if until_switch < 0:\n                    until_switch = 0\n                i += 1\n                continue\n        if lane != l[i]:\n            until_switch = 0\n        else:\n            time = x[i - 1] + 1 + until_switch\n            until_switch = d - (x[i] + 1 - time)\n            if until_switch < 0:\n                until_switch = 0\n            lane = 1 - lane\n        i += 1\n    print(x[i] if i < n else k)", "t = int(input())\nfor _ in range(t):\n    (n, k, d) = map(int, input().split())\n    x = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    lane = 3 - l[0]\n    switched = -float('inf')\n    ans = k\n    for i in range(n):\n        if l[i] == lane:\n            if switched + d < x[i] and x[i - 1] + 1 < x[i]:\n                lane = 3 - lane\n                switched = max(x[i - 1] + 1, switched + d)\n            else:\n                ans = x[i]\n                break\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, k, d) = map(int, input().split())\n    x = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    lane = 3 - l[0]\n    switched = -float('inf')\n    ans = k\n    for i in range(n):\n        if l[i] == lane:\n            if switched + d < x[i] and x[i - 1] + 1 < x[i]:\n                lane = 3 - lane\n                switched = max(x[i - 1] + 1, switched + d)\n            else:\n                ans = x[i]\n                break\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n, k, d) = map(int, input().split())\n    x = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    lane = 3 - l[0]\n    switched = -float('inf')\n    ans = k\n    for i in range(n):\n        if l[i] == lane:\n            if switched + d < x[i] and x[i - 1] + 1 < x[i]:\n                lane = 3 - lane\n                switched = max(x[i - 1] + 1, switched + d)\n            else:\n                ans = x[i]\n                break\n    print(ans)", "def two_lane(n, k, d, l, x):\n    flag = 0\n    z = -10 ** 10\n    for i in range(n - 1):\n        if l[i] != l[i + 1]:\n            z = max(x[i] + 1, z + d)\n            if z >= x[i + 1]:\n                return x[i + 1]\n                flag = 1\n                break\n    return k\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k, d) = map(int, input().split())\n    x = list(map(int, input().split()))\n    l = list(map(int, input().split()))\n    print(two_lane(n, k, d, l, x))", "for _ in range(int(input())):\n    (n, k, d) = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    (x, z) = (0, 0)\n    if b[0] == 1:\n        y = 1\n    else:\n        y = 2\n    c = True\n    for i in range(1, n):\n        if y != b[i]:\n            if a[i] - x <= d and z != 0 or a[i] - a[i - 1] == 1:\n                c = False\n                print(a[i])\n                break\n            if z == 0:\n                z = 1\n                x = a[i - 1] + 1\n            else:\n                x = max(a[i - 1] + 1, x + d)\n            y = b[i]\n    if c:\n        print(k)", "for _t in range(int(input())):\n    (n, k, d) = map(int, input().split())\n    xs = list(map(int, input().split()))\n    ls = list(map(int, input().split()))\n    my_x = 0\n    my_l = 3 - ls[0]\n    for (x, l_) in zip(xs, ls):\n        if l_ == my_l:\n            if x <= my_x:\n                print(x)\n                break\n            my_l = 3 - my_l\n            my_x = max(x + 1, my_x + d)\n        else:\n            my_x = max(x + 1, my_x)\n    else:\n        print(k)", "def opp(n):\n    if n == 1:\n        return 2\n    return 1\n\ndef main():\n    (n, k, d) = [int(j) for j in input().split()]\n    x = [int(j) for j in input().split()]\n    l = [int(j) for j in input().split()]\n    for i in range(n - 1):\n        if l[i] != l[i + 1] and x[i + 1] != x[i] + 1:\n            last_turn = x[i] + 1\n            curr_lane = l[i]\n            last_obs_encounter = i\n            break\n        elif l[i] != l[i + 1] and x[i + 1] == x[i] + 1:\n            print(x[i + 1])\n            return\n    for j in range(last_obs_encounter, n - 1):\n        if l[j + 1] == curr_lane:\n            if x[j + 1] - last_turn + 1 >= d and x[i + 1] != x[i] + 1:\n                curr_lane = opp(curr_lane)\n                last_turn = last_turn + d\n            elif l[i] != l[i + 1] and x[i + 1] == x[i] + 1:\n                print(x[i + 1])\n                return\n            else:\n                flag = False\n                last_spot = x[j + 1]\n                print(last_spot)\n                return\n                break\n        else:\n            pass\n    print(k)\n    return\n\ndef setter_main():\n    (n, k, d) = [int(j) for j in input().split()]\n    x = [int(j) for j in input().split()]\n    l = [int(j) for j in input().split()]\n    last_turn = -10 ** 10\n    ans = k\n    lane = opp(l[0])\n    for i in range(n):\n        if l[i] != lane:\n            continue\n        bst = max(last_turn + d, x[i - 1] + 1)\n        if bst >= x[i]:\n            ans = x[i]\n            break\n        lane = opp(lane)\n        last_turn = bst\n    print(ans)\nfor t in range(int(input())):\n    setter_main()", "for _ in range(int(input())):\n    (n, k, d) = [int(a) for a in input().split()]\n    blocks = [int(a) for a in input().split()]\n    lanes = list(map(int, input().split()))\n    Flag = 0\n    z = -10000000000000\n    for i in range(n - 1):\n        if lanes[i] != lanes[i + 1]:\n            z = max(blocks[i] + 1, z + d)\n            if z >= blocks[i + 1]:\n                print(blocks[i + 1])\n                Flag = 1\n                break\n    if Flag == 0:\n        print(k)", "for _t in range(int(input())):\n    (n, k, d) = map(int, input().split())\n    xs = list(map(int, input().split()))\n    ls = list(map(int, input().split()))\n    my_x = 0\n    my_l = 3 - ls[0]\n    for (x, l_) in zip(xs, ls):\n        if l_ == my_l:\n            if x <= my_x:\n                print(x)\n                break\n            my_l = 3 - my_l\n            my_x = max(x + 1, my_x + d)\n        else:\n            my_x = max(x + 1, my_x)\n    else:\n        print(k)"]