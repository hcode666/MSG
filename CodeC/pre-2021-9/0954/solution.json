["M = 10 ** 9 + 7\ndp = {}\n\ndef MODmul(a, b):\n    return a % M * (b % M) % M\n\ndef MODdiv(a, b):\n    return a * pow(b, M - 2, M) % M\n\ndef MODdivFake(a, b):\n    return (a, b)\n\ndef MODadd(a, b):\n    return (a % M + b % M) % M\n\ndef MODsub(a, b):\n    return (a % M - b % M + M) % M\n\ndef gcd(a, b):\n    if (a, b) in dp:\n        return dp[a, b]\n    if a == 0:\n        dp[a, b] = b\n        return b\n    dp[a, b] = gcd(b % a, a)\n    return dp[a, b]\n\ndef gm(c, r, k):\n    if c % 2:\n        m = (c - 1) // 2\n        rm_1 = pow(r - 1, m, M)\n        rm = pow(r, m, M)\n        n1 = MODmul(rm, r + k)\n        n2 = rm_1 * (1 - r - k)\n        d = MODmul(rm, r + k)\n        return [MODadd(n1, n2), d]\n    m = c // 2\n    rm = pow(r, m, M)\n    return [MODsub(rm, pow(r - 1, m, M)), rm]\n\ndef fracAdd(n1, d1, n2, d2):\n    d1 = d1\n    d2 = d2\n    g = gcd(d1, d2)\n    lcm = d1 * (d2 / g)\n    n1 = n1 * (lcm // d1) % M\n    n2 = n2 * (lcm // d2) % M\n    n = (n1 + n2) % M\n    return [int(n), int(lcm)]\n\ndef getFrac(n, k, c):\n    if n == 1:\n        return [1, 1]\n    if c == 1:\n        return [1, n]\n    if n <= k:\n        if c == 2:\n            return [2 * n + k - 1, n * (n + k)]\n        else:\n            r = (n + k) % k\n            if r == 0:\n                r = n\n            (n1, d1) = (1, n)\n            (n2, d2) = (n - 1, n)\n            (n3, d3) = gm(c - 1, r, k)\n            n2 = MODmul(n2, n3)\n            d2 = MODmul(d2, d3)\n            return fracAdd(n1, d1, n2, d2)\n    r = n % k\n    if r == 1:\n        return [1, 1]\n    if r == 0:\n        r = k\n    return gm(c, r, k)\n\ndef ans(n, k, c):\n    (n, d) = getFrac(n, k, c)\n    g = gcd(n, d)\n    (n, d) = [n // g, d // g]\n    return MODdiv(n, d)\nfor _ in range(int(input())):\n    (n, k, c) = map(int, input().split())\n    print(ans(n, k, c))", "M = 10 ** 9 + 7\ndp = {}\n\ndef MODmul(a, b):\n    return a % M * (b % M) % M\n\ndef MODdiv(a, b):\n    return a * pow(b, M - 2, M) % M\n\ndef MODdivFake(a, b):\n    return (a, b)\n\ndef MODadd(a, b):\n    return (a % M + b % M) % M\n\ndef MODsub(a, b):\n    return (a % M - b % M + M) % M\n\ndef gcd(a, b):\n    if (a, b) in dp:\n        return dp[a, b]\n    if a == 0:\n        dp[a, b] = b\n        return b\n    dp[a, b] = gcd(b % a, a)\n    return dp[a, b]\n\ndef gm(c, r, k):\n    if c % 2:\n        m = (c - 1) // 2\n        rm_1 = pow(r - 1, m, M)\n        rm = pow(r, m, M)\n        n1 = MODmul(rm, r + k)\n        n2 = rm_1 * (1 - r - k)\n        d = MODmul(rm, r + k)\n        return [MODadd(n1, n2), d]\n    m = c // 2\n    rm = pow(r, m, M)\n    return [MODsub(rm, pow(r - 1, m, M)), rm]\n\ndef fracAdd(n1, d1, n2, d2):\n    d1 = d1\n    d2 = d2\n    g = gcd(d1, d2)\n    lcm = d1 * (d2 / g)\n    n1 = n1 * (lcm // d1) % M\n    n2 = n2 * (lcm // d2) % M\n    n = (n1 + n2) % M\n    return [int(n), int(lcm)]\n\ndef getFrac(n, k, c):\n    if n == 1:\n        return [1, 1]\n    if c == 1:\n        return [1, n]\n    if n <= k:\n        if c == 2:\n            return [2 * n + k - 1, n * (n + k)]\n        else:\n            r = (n + k) % k\n            if r == 0:\n                r = n\n            (n1, d1) = (1, n)\n            (n2, d2) = (n - 1, n)\n            (n3, d3) = gm(c - 1, r, k)\n            n2 = MODmul(n2, n3)\n            d2 = MODmul(d2, d3)\n            return fracAdd(n1, d1, n2, d2)\n    r = n % k\n    if r == 1:\n        return [1, 1]\n    if r == 0:\n        r = k\n    return gm(c, r, k)\n\ndef ans(n, k, c):\n    (n, d) = getFrac(n, k, c)\n    g = gcd(n, d)\n    (n, d) = [n // g, d // g]\n    return MODdiv(n, d)\nfor _ in range(int(input())):\n    (n, k, c) = map(int, input().split())\n    print(ans(n, k, c))", "M = 10 ** 9 + 7\ndp = {}\n\ndef MODmul(a, b):\n    return a % M * (b % M) % M\n\ndef MODdiv(a, b):\n    return a * pow(b, M - 2, M) % M\n\ndef MODdivFake(a, b):\n    return (a, b)\n\ndef MODadd(a, b):\n    return (a % M + b % M) % M\n\ndef MODsub(a, b):\n    return (a % M - b % M + M) % M\n\ndef gcd(a, b):\n    if (a, b) in dp:\n        return dp[a, b]\n    if a == 0:\n        dp[a, b] = b\n        return b\n    dp[a, b] = gcd(b % a, a)\n    return dp[a, b]\n\ndef gm(c, r, k):\n    if c % 2:\n        m = (c - 1) // 2\n        rm_1 = pow(r - 1, m, M)\n        rm = pow(r, m, M)\n        n1 = MODmul(rm, r + k)\n        n2 = rm_1 * (1 - r - k)\n        d = MODmul(rm, r + k)\n        return [MODadd(n1, n2), d]\n    m = c // 2\n    rm = pow(r, m, M)\n    return [MODsub(rm, pow(r - 1, m, M)), rm]\n\ndef fracAdd(n1, d1, n2, d2):\n    d1 = d1\n    d2 = d2\n    g = gcd(d1, d2)\n    lcm = d1 * (d2 / g)\n    n1 = n1 * (lcm // d1) % M\n    n2 = n2 * (lcm // d2) % M\n    n = (n1 + n2) % M\n    return [int(n), int(lcm)]\n\ndef getFrac(n, k, c):\n    if n == 1:\n        return [1, 1]\n    if c == 1:\n        return [1, n]\n    if n <= k:\n        if c == 2:\n            return [2 * n + k - 1, n * (n + k)]\n        else:\n            r = (n + k) % k\n            if r == 0:\n                r = n\n            (n1, d1) = (1, n)\n            (n2, d2) = (n - 1, n)\n            (n3, d3) = gm(c - 1, r, k)\n            n2 = MODmul(n2, n3)\n            d2 = MODmul(d2, d3)\n            return fracAdd(n1, d1, n2, d2)\n    r = n % k\n    if r == 1:\n        return [1, 1]\n    if r == 0:\n        r = k\n    return gm(c, r, k)\n\ndef ans(n, k, c):\n    (n, d) = getFrac(n, k, c)\n    g = gcd(n, d)\n    (n, d) = [n // g, d // g]\n    return MODdiv(n, d)\nfor _ in range(int(input())):\n    (n, k, c) = [int(i) for i in input().split()]\n    print(ans(n, k, c))", "M = 10 ** 9 + 7\ndp = {}\n\ndef MODmul(a, b):\n    return a % M * (b % M) % M\n\ndef MODdiv(a, b):\n    return a * pow(b, M - 2, M) % M\n\ndef MODdivFake(a, b):\n    return (a, b)\n\ndef MODadd(a, b):\n    return (a % M + b % M) % M\n\ndef MODsub(a, b):\n    return (a % M - b % M + M) % M\n\ndef gcd(a, b):\n    if (a, b) in dp:\n        return dp[a, b]\n    if a == 0:\n        dp[a, b] = b\n        return b\n    dp[a, b] = gcd(b % a, a)\n    return dp[a, b]\n\ndef gm(c, r, k):\n    if c % 2:\n        m = (c - 1) // 2\n        rm_1 = pow(r - 1, m, M)\n        rm = pow(r, m, M)\n        n1 = MODmul(rm, r + k)\n        n2 = rm_1 * (1 - r - k)\n        d = MODmul(rm, r + k)\n        return [MODadd(n1, n2), d]\n    m = c // 2\n    rm = pow(r, m, M)\n    return [MODsub(rm, pow(r - 1, m, M)), rm]\n\ndef fracAdd(n1, d1, n2, d2):\n    d1 = d1\n    d2 = d2\n    g = gcd(d1, d2)\n    lcm = d1 * (d2 / g)\n    n1 = n1 * (lcm // d1) % M\n    n2 = n2 * (lcm // d2) % M\n    n = (n1 + n2) % M\n    return [int(n), int(lcm)]\n\ndef getFrac(n, k, c):\n    if n == 1:\n        return [1, 1]\n    if c == 1:\n        return [1, n]\n    if n <= k:\n        if c == 2:\n            return [2 * n + k - 1, n * (n + k)]\n        else:\n            r = (n + k) % k\n            if r == 0:\n                r = n\n            (n1, d1) = (1, n)\n            (n2, d2) = (n - 1, n)\n            (n3, d3) = gm(c - 1, r, k)\n            n2 = MODmul(n2, n3)\n            d2 = MODmul(d2, d3)\n            return fracAdd(n1, d1, n2, d2)\n    r = n % k\n    if r == 1:\n        return [1, 1]\n    if r == 0:\n        r = k\n    return gm(c, r, k)\n\ndef ans(n, k, c):\n    (n, d) = getFrac(n, k, c)\n    g = gcd(n, d)\n    (n, d) = [n // g, d // g]\n    return MODdiv(n, d)\nfor _ in range(int(input())):\n    (n, k, c) = [int(i) for i in input().split()]\n    print(ans(n, k, c))", "import math\nMOD = 1000000007\n\ndef multinv(x, mod):\n    a = dev(x, mod)\n    if a != 1:\n        return 0\n    else:\n        return exp(x, mod - 2, mod)\n\ndef exp(a, b, mod):\n    if b == 0:\n        return 1\n    m = exp(a, b // 2, mod) % mod\n    m = m * m % mod\n    if b % 2 == 0:\n        return m\n    else:\n        return a * m % mod\n\ndef dev(m, n):\n    if m == 0:\n        return n\n    return dev(n % m, m)\ntest = int(input())\nfor fu in range(test):\n    (n, k, m) = map(int, input().split(' '))\n    if m % 2 == 0:\n        temp2 = exp(n, m // 2, MOD)\n        temp4 = exp(n - 1, m // 2, MOD)\n        p = (temp2 - temp4) * (n + k) % MOD + temp4\n        q = temp2 * (n + k) % MOD\n        q = multinv(q, MOD)\n        res = p * q % MOD\n    else:\n        temp5 = exp(n, (m + 1) // 2, MOD)\n        temp6 = exp(n - 1, (m + 1) // 2, MOD)\n        p = (temp5 - temp6) % MOD\n        q = multinv(temp5, MOD)\n        res = p * q % MOD\n    print(res)", "import math\nMOD = 1000000007\n\ndef multinv(x, mod):\n    a = dev(x, mod)\n    if a != 1:\n        return 0\n    else:\n        return exp(x, mod - 2, mod)\n\ndef exp(a, b, mod):\n    if b == 0:\n        return 1\n    m = exp(a, b // 2, mod) % mod\n    m = m * m % mod\n    if b % 2 == 0:\n        return m\n    else:\n        return a * m % mod\n\ndef dev(m, n):\n    if m == 0:\n        return n\n    return dev(n % m, m)\ntest = int(input())\nfor fu in range(test):\n    (n, k, m) = map(int, input().split(' '))\n    if m % 2 == 0:\n        temp2 = exp(n, m // 2, MOD)\n        temp4 = exp(n - 1, m // 2, MOD)\n        p = (temp2 - temp4) * (n + k) % MOD + temp4\n        q = temp2 * (n + k) % MOD\n        q = multinv(q, MOD)\n        res = p * q % MOD\n    else:\n        temp5 = exp(n, (m + 1) // 2, MOD)\n        temp6 = exp(n - 1, (m + 1) // 2, MOD)\n        p = (temp5 - temp6) % MOD\n        q = multinv(temp5, MOD)\n        res = p * q % MOD\n    print(res)", "import math\nMOD = 1000000007\n\ndef multinv(x, mod):\n    a = dev(x, mod)\n    if a != 1:\n        return 0\n    else:\n        return exp(x, mod - 2, mod)\n\ndef exp(a, b, mod):\n    if b == 0:\n        return 1\n    m = exp(a, b // 2, mod) % mod\n    m = m * m % mod\n    if b % 2 == 0:\n        return m\n    else:\n        return a * m % mod\n\ndef dev(m, n):\n    if m == 0:\n        return n\n    return dev(n % m, m)\ntest = int(input())\nfor fu in range(test):\n    (n, k, m) = map(int, input().split(' '))\n    if m % 2 == 0:\n        temp2 = exp(n, m // 2, MOD)\n        temp4 = exp(n - 1, m // 2, MOD)\n        p = (temp2 - temp4) * (n + k) % MOD + temp4\n        q = temp2 * (n + k) % MOD\n        q = multinv(q, MOD)\n        res = p * q % MOD\n    else:\n        temp5 = exp(n, (m + 1) // 2, MOD)\n        temp6 = exp(n - 1, (m + 1) // 2, MOD)\n        p = (temp5 - temp6) % MOD\n        q = multinv(temp5, MOD)\n        res = p * q % MOD\n    print(res)", "md = 7 + pow(10, 9)\n\ndef StupidExponent(a, b):\n    c = 1\n    while b > 0:\n        if b & 1:\n            c = c * a % md\n        b //= 2\n        a = a * a % md\n    return c\n\ndef StupidInverse(a):\n    return StupidExponent(a, md - 2)\nfor z in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m % 2:\n        num = (StupidExponent(n, 1 + m // 2) - StupidExponent(n - 1, 1 + m // 2)) % md\n        den = StupidExponent(n, 1 + m // 2)\n    else:\n        num = ((n + k) % md * StupidExponent(n, m // 2) % md - (n + k - 1) % md * StupidExponent(n - 1, m // 2) % md) % md\n        den = (n + k) % md * StupidExponent(n, m // 2) % md\n    print(num * StupidInverse(den) % md)", "import math\nN = 10 ** 9 + 7\na = int(input())\nfor i in range(a):\n    (n, k, m) = [int(i) for i in input().split()]\n    if m % 2 == 1:\n        h = pow(n, (m + 1) // 2, N)\n        t = pow(n, (m + 1) // 2, N) - pow(n - 1, (m + 1) // 2, N)\n        gcd = math.gcd(h, t)\n        h = h // gcd\n        t = t // gcd\n        print(pow(h, N - 2, N) * t % N)\n    else:\n        h = (n + k) * pow(n, m // 2, N) % N\n        t = (n + k) * pow(n, m // 2, N) - (n + k - 1) * pow(n - 1, m // 2, N)\n        gcd = math.gcd(h, t)\n        h = h // gcd\n        t = t // gcd\n        print(pow(h, N - 2, N) * t % N)", "import math\nfrom fractions import Fraction\nh = 10 ** 9 + 7\n\ndef modinv(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nfor _ in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m % 2 != 0:\n        u = pow(n, (m + 1) // 2, h)\n        v = (pow(n, (m + 1) // 2, h) - pow(n - 1, (m + 1) // 2, h)) % h\n    else:\n        u = pow(n, m // 2, h) * ((n + k) % h) % h\n        v = (pow(n - 1, m // 2, h) * ((1 - n - k) % h) + pow(n, m // 2, h) * ((n + k) % h)) % h\n    print(v * modinv(u, h) % h)", "from math import floor\n\ndef modInverse(a, m):\n    g = gcd(a, m)\n    if g != 1:\n        return 0\n    else:\n        return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nla = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 1:\n        x = floor(m / 2 + 1)\n        a1 = power(n, x, la)\n        b1 = power(n - 1, x, la)\n        p1 = (a1 - b1) % la\n        q1 = a1\n        q2 = modInverse(q1, la)\n        ans = p1 % la * (q2 % la) % la\n        print(ans)\n    else:\n        x = m / 2\n        k1 = power(n, x, la)\n        part1 = (n + k) * k1 % la\n        k2 = power(n - 1, x, la)\n        part2 = k2 * (1 - (n + k)) % la\n        p1 = (part1 + part2) % la\n        q1 = part1\n        q2 = modInverse(q1, la)\n        ans = p1 * q2 % la\n        print(ans)", "mod = int(1000000000.0 + 7)\n\ndef expo(b, e):\n    ans = 1\n    while e:\n        if e & 1:\n            ans = ans * b % mod\n            e -= 1\n        else:\n            b = b ** 2 % mod\n            e = e >> 1\n    return int(ans)\nt = int(input())\nwhile t:\n    (n, k, m) = map(int, input().strip().split())\n    if m & 1:\n        den = expo(n, (m + 1) // 2)\n        num = expo(n - 1, (m + 1) // 2)\n        invden = expo(den, mod - 2) % mod\n        ans = (den - num + mod) % mod * invden % mod\n    else:\n        den = expo(n, m // 2) * (k + n) % mod % mod\n        num = expo(n - 1, m // 2) * ((k + n - 1) % mod) % mod\n        invden = expo(den, mod - 2) % mod\n        ans = (den - num + mod) % mod * invden % mod\n    print(int(ans))\n    t -= 1", "def modulo(a, b, c):\n    x = 1\n    y = a\n    while b > 0:\n        if b & 1:\n            x = x * y % c\n        y = y * y % c\n        b = b >> 1\n    return x % c\nmod = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    (n, k, m) = map(int, input().split())\n    if m == 1:\n        p = 1\n        q = n\n        ans = p * modulo(q, mod - 2, mod) % mod\n    elif m == 2:\n        p = n + n + k - 1\n        q = n * (n + k)\n        ans = p * modulo(q, mod - 2, mod) % mod\n    else:\n        z = (m + 1) // 2\n        p = modulo(n, z, mod) - modulo(n - 1, z, mod)\n        if p < 0:\n            p += mod\n        q = modulo(n, z, mod)\n        ans = p * modulo(q, mod - 2, mod) % mod\n        if m % 2 == 0:\n            a = modulo(n - 1, z, mod)\n            b = modulo(n, z, mod) * (n + k) % mod\n            ans += a * modulo(b, mod - 2, mod) % mod\n            ans %= mod\n    print(ans)", "import math\nfor t1 in range(int(input())):\n    po = 10 ** 9 + 7\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 0:\n        d = m - 1\n    else:\n        d = m\n    if m % 2 == 1:\n        temp = int((m + 2) / 2)\n        a1 = pow(n, temp, po)\n        p1 = a1 - pow(n - 1, temp, po)\n        q1 = a1 % po\n    else:\n        a1 = pow(n, m // 2, po)\n        a2 = pow(n - 1, m // 2, po)\n        a3 = n + k\n        p1 = ((a1 - a2) * a3 + a2) % po\n        q1 = a1 * a3 % po\n    divi = math.gcd(p1, q1)\n    p = p1 // divi\n    q = q1 // divi\n    print(pow(q, po - 2, po) * p % po)", "import math\npo = 1000000007\nfor t1 in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 0:\n        d = m - 1\n    else:\n        d = m\n    if m % 2 == 1:\n        temp = int((m + 2) / 2)\n        a1 = pow(n, temp, po)\n        p1 = a1 - pow(n - 1, temp, po)\n        q1 = a1\n    else:\n        a1 = pow(n, m // 2, po)\n        a2 = pow(n - 1, m // 2, po)\n        a3 = (n + k) % po\n        p1 = ((a1 - a2) * a3 % po + a2) % po\n        q1 = a1 * a3 % po\n    divi = math.gcd(p1, q1)\n    p = p1 // divi\n    q = q1 // divi\n    print(pow(q, po - 2, po) * p % po)", "import math\n\ndef modinverse(a):\n    m = 1000000007\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nt = int(input())\nwhile t > 0:\n    t = t - 1\n    mod = int(pow(10, 9)) + 7\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 1:\n        x = int((m + 1) // 2)\n        a = pow(n, x, mod) - pow(n - 1, x, mod)\n        b = pow(n, x, mod)\n    else:\n        x = int(m // 2)\n        a = pow(n, x, mod) - pow(n - 1, x, mod)\n        b = pow(n, x, mod)\n        c = pow(n - 1, x, mod)\n        d = pow(n, x, mod) * (n + k)\n        a = a * d % mod + b * c % mod\n        b = b * d\n    x = math.gcd(a, b)\n    a = int(a // x)\n    b = int(b // x)\n    b = modinverse(b)\n    print(a * b % mod)", "MOD = 1000000007\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef GCD(a, b):\n    if b == 0:\n        return a\n    return GCD(b, a % b)\ntestCase = int(input())\nwhile testCase:\n    testCase -= 1\n    values = input()\n    values = values.split(' ')\n    values = list(map(int, values))\n    n = values[0]\n    k = values[1]\n    m = values[2]\n    if m % 2 != 0:\n        term1 = power(n, (m + 1) // 2, MOD)\n        term2 = power(n - 1, (m + 1) // 2, MOD)\n        ans = term1 - term2\n        GCD01 = GCD(ans, term1)\n        ans //= GCD01\n        term1 //= GCD01\n        term3 = modinv(term1, MOD)\n        print(ans * term3 % MOD)\n    else:\n        term1 = power(n, m // 2, MOD)\n        term1 %= MOD\n        term2 = power(n - 1, m // 2, MOD)\n        term3 = term2\n        term2 = term1 - term2\n        term2 = term2 * (n + k)\n        term2 += term3\n        tErm4 = power(n, m // 2, MOD)\n        term4 = tErm4 * (n + k)\n        GCD01 = GCD(term2, term4)\n        term2 //= GCD01\n        term4 //= GCD01\n        term4 = modinv(term4, MOD)\n        print(term2 * term4 % MOD)", "from fractions import Fraction\nfrom math import ceil\np = 10 ** 9 + 7\n\ndef modinv(n, p):\n    return pow(n, p - 2, p)\n\ndef get_ans(n, k, m):\n    r = ceil(m / 2)\n    top = pow(n, r, p) - pow(n - 1, r, p)\n    top %= p\n    if m % 2 == 0:\n        top = top * (n + k) % p + pow(n - 1, r, p) % p\n        top = top % p\n        bottom = pow(n, r, p) * (n + k) % p\n        f = Fraction(top, bottom)\n        top = f.numerator\n        bottom = f.denominator\n        return top * pow(bottom, p - 2, p) % p\n    else:\n        bottom = pow(n, r, p)\n        f = Fraction(top, bottom)\n        top = f.numerator\n        bottom = f.denominator\n        return top * pow(bottom, p - 2, p) % p\n\ndef main():\n    t = int(input())\n    for i in range(t):\n        x = input()\n        (n, k, m) = [int(temp) for temp in x.split(' ')]\n        print(get_ans(n, k, m))\n    pass\nmain()", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef computeHCF(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef minimum(a, b):\n    while 1:\n        x = computeHCF(a, b)\n        if x == 1:\n            break\n        a //= x\n        b //= x\n    return (a, b)\nfor _ in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    a = 0\n    b = 0\n    if m == 1:\n        print(modInverse(n, 1000000007) % 1000000007)\n        continue\n    tes = (m - 1) // 2 + 1\n    nk = pow(n, tes, 1000000007)\n    n1k = pow(n - 1, tes, 1000000007)\n    a = nk - n1k\n    b = nk\n    if m % 2 == 0:\n        a = a * (n + k) + n1k\n        b = b * (n + k)\n        a %= 1000000007\n        b %= 1000000007\n    (a, b) = minimum(a, b)\n    print(a * modInverse(b, 1000000007) % 1000000007)", "mod = 1000000007\nfrom math import gcd\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        print(3 / 0)\n    else:\n        return x % m\nt = int(input())\nfor i in range(t):\n    lst = str(input()).split(' ')\n    n = int(lst[0])\n    k = int(lst[1])\n    m = int(lst[2])\n    if m % 2 == 0:\n        j = m // 2\n        q = pow(n, j, mod) * (n + k)\n        p = q - pow(n - 1, j, mod) * (n + k - 1)\n    else:\n        j = (m + 1) // 2\n        q = pow(n, j, mod)\n        p = q - pow(n - 1, j, mod)\n    g = gcd(p, q)\n    p /= g\n    q /= g\n    p = int((p + mod) % mod)\n    q = int((q + mod) % mod)\n    print(int(p * modinv(q, mod)) % mod)", "import math\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nt = int(input())\nm = 1000000007\nkl = m // 1000000007\nfor i in range(t):\n    (n, k, mv) = map(int, input().split())\n    nmv = (mv + 1) // 2\n    if mv % 2 == 1:\n        p = (power(n, nmv, m) - power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) + m) % m\n    else:\n        p = ((n + k) * (power(n, nmv, m) - power(n - 1, nmv, m)) + power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) * (n + k) + m) % m\n    q = modInverse(q, m)\n    ans = (p % m * (q % m) + m) % m\n    print(ans)", "import math\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nt = int(input())\nm = 1000000007\nkl = m // 1000000007\nfor i in range(t):\n    (n, k, mv) = map(int, input().split())\n    nmv = (mv + 1) // 2\n    if mv % 2 == 1:\n        p = (power(n, nmv, m) - power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) + m) % m\n    else:\n        p = ((n + k) * (power(n, nmv, m) - power(n - 1, nmv, m)) + power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) * (n + k) + m) % m\n    q = modInverse(q, m)\n    ans = (p % m * (q % m) + m) % m\n    print(ans)", "import math\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nm = 1000000007\nfor i in range(int(input())):\n    (n, k, mv) = map(int, input().split())\n    nmv = (mv + 1) // 2\n    if mv % 2 == 1:\n        p = (power(n, nmv, m) - power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) + m) % m\n    else:\n        p = ((n + k) * (power(n, nmv, m) - power(n - 1, nmv, m)) + power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) * (n + k) + m) % m\n    q = modInverse(q, m)\n    ans = (p % m * (q % m) + m) % m\n    print(ans)", "def moduloInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef isEven(x):\n    if x % 2 == 0:\n        return 1\n    return 0\nn = int(input())\nmod = 1000000007\nfor i in range(n):\n    list1 = list(map(int, input().split(' ')))\n    if isEven(list1[2]) == 0:\n        b = pow(list1[0], list1[2] // 2 + 1, mod) - pow(list1[0] - 1, list1[2] // 2 + 1, mod)\n        b = b + 1000\n        b = b - 1000\n        c = pow(list1[0], list1[2] // 2 + 1, mod)\n        c = c + 1000000\n        c = c - 1000000\n        if b < 0:\n            b += mod\n        print(b * moduloInverse(c, mod) % mod)\n    elif isEven(list1[2]) == 1:\n        a = list1[2] // 2\n        b = pow(list1[0], a, mod) - pow(list1[0] - 1, a, mod)\n        c = pow(list1[0], a, mod)\n        if b < 0:\n            b += mod\n        d = moduloInverse(c, mod)\n        print((moduloInverse(pow(list1[0], a, mod), mod) * pow(list1[0] - 1, a, mod) * moduloInverse((list1[0] + list1[1]) % mod, mod) + b * d % mod) % mod)", "import math\nfrom fractions import Fraction\nh = 10 ** 9 + 7\n\ndef modinv(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nfor _ in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m % 2 != 0:\n        u = pow(n, (m + 1) // 2, h)\n        v = (pow(n, (m + 1) // 2, h) - pow(n - 1, (m + 1) // 2, h)) % h\n    else:\n        u = pow(n, m // 2, h) * ((n + k) % h) % h\n        v = (pow(n - 1, m // 2, h) * ((1 - n - k) % h) + pow(n, m // 2, h) * ((n + k) % h)) % h\n    print(v * modinv(u, h) % h)", "def findHcf(a, b):\n    if b > a:\n        return findHcf(b, a)\n    if b == 0:\n        return a\n    return findHcf(b, a % b)\n\ndef findInverseMod(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    while a > 1:\n        q = a // m\n        temp = m\n        m = a % m\n        a = temp\n        temp = y\n        y = x - q * y\n        x = temp\n    if x < 0:\n        x = x + m0\n    return x\n\ndef modularExponentiation(a, b, divisor):\n    res = 1\n    a = a % divisor\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % divisor\n        b = b >> 1\n        a = a * a % divisor\n    return res\nT = int(input())\nfor t in range(T):\n    divisor = 1000000000 + 7\n    (N, K, M) = list(map(int, input().split()))\n    p = 1\n    q = N\n    if M % 2 == 1:\n        power = M // 2 + 1\n        temp = modularExponentiation(N, power, divisor)\n        temp2 = modularExponentiation(N - 1, power, divisor)\n        p = temp - temp2\n        q = temp\n    else:\n        power = M // 2\n        temp = modularExponentiation(N, power, divisor)\n        temp2 = modularExponentiation(N - 1, power, divisor)\n        p = (temp - temp2) * (N + K) + temp2\n        q = temp * (N + K)\n    qInverse = findInverseMod(q, divisor)\n    print(p * qInverse % divisor)", "def fpower(a, b):\n    ans = 1\n    while b > 0:\n        if b & 1 == 1:\n            ans = ans * a % 1000000007\n        b = b >> 1\n        a = a * a % 1000000007\n    return ans\n\ndef gcd(m, n):\n    if n == 0:\n        return m\n    return gcd(n, m % n)\n\ndef modinverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x += m0\n    return x\n\ndef addfrac(m, n, o, p):\n    a = gcd(n, p)\n    num = (m * p // a + o * n // a) % 1000000007\n    den = n * p // a % 1000000007\n    return (int(num), int(den))\nt = int(input())\nwhile t > 0:\n    (n, k, m) = map(int, input().split())\n    if m % 2 != 0:\n        num2 = fpower(n, m // 2 + 1) - fpower(n - 1, m // 2 + 1)\n        den2 = fpower(n, m // 2 + 1)\n        print(num2 * modinverse(den2, 1000000007) % 1000000007)\n    else:\n        num2 = fpower(n, m // 2) - fpower(n - 1, m // 2)\n        den2 = fpower(n, m // 2)\n        num3 = fpower(n - 1, m // 2)\n        den3 = (n + k) * fpower(n, m // 2)\n        (numerator, denominator) = addfrac(num2, den2, num3, den3)\n        print(numerator * modinverse(denominator, 1000000007) % 1000000007)\n    t = t - 1", "import math\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef power(x, y):\n    p = 1000000007\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nt = int(input())\nfor i in range(0, t):\n    inp = input().split(' ')\n    n = int(inp[0])\n    k = int(inp[1])\n    m = int(inp[2])\n    if m % 2 == 0:\n        t_p1 = power(n, m // 2)\n        t_p2 = power(n - 1, m // 2)\n        temp1 = (t_p1 - t_p2) % 1000000007 * (n + k) % 1000000007\n        pro_x = (temp1 + t_p2) % 1000000007\n        pro_y = t_p1 * (n + k) % 1000000007\n        temp_gcd = math.gcd(pro_x, pro_y)\n        temp_inv = modinv(temp_gcd, 1000000007)\n        pro_x = pro_x * temp_inv % 1000000007\n        pro_y = pro_y * temp_inv % 1000000007\n    else:\n        p1 = (m - 1) // 2 + 1\n        temp_p = power(n, p1)\n        pro_x = (temp_p - power(n - 1, p1)) % 1000000007\n        pro_y = temp_p\n        temp_gcd = math.gcd(pro_x, pro_y)\n        temp_inv = modinv(temp_gcd, 1000000007)\n        pro_x = pro_x * temp_inv % 1000000007\n        pro_y = pro_y * temp_inv % 1000000007\n    print(int(pro_x % 1000000007 * modinv(pro_y, 1000000007) % 1000000007))", "import math\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef power(x, y):\n    p = 1000000007\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nt = int(input())\nfor i in range(0, t):\n    inp = input().split(' ')\n    n = int(inp[0])\n    k = int(inp[1])\n    m = int(inp[2])\n    if m % 2 == 0:\n        t_p1 = power(n, m // 2)\n        t_p2 = power(n - 1, m // 2)\n        temp1 = (t_p1 - t_p2) % 1000000007 * (n + k) % 1000000007\n        pro_x = (temp1 + t_p2) % 1000000007\n        pro_y = t_p1 * (n + k) % 1000000007\n        temp_gcd = math.gcd(pro_x, pro_y)\n        pro_x = pro_x * modinv(temp_gcd, 1000000007) % 1000000007\n        pro_y = pro_y * modinv(temp_gcd, 1000000007) % 1000000007\n    else:\n        p1 = (m - 1) // 2 + 1\n        temp_p = power(n, p1)\n        pro_x = (temp_p - power(n - 1, p1)) % 1000000007\n        pro_y = temp_p\n        temp_gcd = math.gcd(pro_x, pro_y)\n        pro_x = pro_x * modinv(temp_gcd, 1000000007) % 1000000007\n        pro_y = pro_y * modinv(temp_gcd, 1000000007) % 1000000007\n    print(int(pro_x % 1000000007 * modinv(pro_y, 1000000007) % 1000000007))", "import math\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nt = int(input())\nm = 1000000007\nfor i in range(t):\n    (n, k, mv) = map(int, input().split())\n    nmv = (mv + 1) // 2\n    if mv % 2 == 1:\n        p = (power(n, nmv, m) - power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) + m) % m\n    else:\n        p = ((n + k) * (power(n, nmv, m) - power(n - 1, nmv, m)) + power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) * (n + k) + m) % m\n    q = modInverse(q, m)\n    ans = (p % m * (q % m) + m) % m\n    print(ans)", "import math\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nt = int(input())\nm = 1000000007\nfor i in range(t):\n    (n, k, mv) = map(int, input().split())\n    nmv = (mv + 1) // 2\n    if mv % 2 == 1:\n        p = (power(n, nmv, m) - power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) + m) % m\n    else:\n        p = ((n + k) * (power(n, nmv, m) - power(n - 1, nmv, m)) + power(n - 1, nmv, m) + m) % m\n        q = (power(n, nmv, m) * (n + k) + m) % m\n    q = modInverse(q, m)\n    ans = (p % m * (q % m) + m) % m\n    print(ans)", "def modInverse(a, m):\n    g = gcd(a, m)\n    if g != 1:\n        print(\"Inverse doesn't exist\")\n    else:\n        return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nn = int(input())\nfor i in range(n):\n    l1 = list(map(int, input().split(' ')))\n    if l1[2] % 2 != 0:\n        a = l1[2] // 2 + 1\n        b = pow(l1[0], a, 1000000007) - pow(l1[0] - 1, a, 1000000007)\n        c = pow(l1[0], a, 1000000007)\n        if b < 0:\n            b = b + 1000000007\n        d = modInverse(c, 1000000007)\n        print(b * d % 1000000007)\n    elif l1[2] % 2 == 0:\n        a = l1[2] // 2\n        b = pow(l1[0], a, 1000000007) - pow(l1[0] - 1, a, 1000000007)\n        c = pow(l1[0], a, 1000000007)\n        if b < 0:\n            b = b + 1000000007\n        d = modInverse(c, 1000000007)\n        e = b * d % 1000000007\n        f = pow(l1[0], a, 1000000007)\n        z = (l1[0] + l1[1]) % 1000000007\n        g = modInverse(f, 1000000007)\n        y = modInverse(z, 1000000007)\n        h = pow(l1[0] - 1, a, 1000000007)\n        print((g * h * y + e) % 1000000007)", "import math\nmod = 10 ** 9 + 7\n\ndef sumg(r, p, n):\n    xp1 = pow(r, n, mod) - pow(p, n, mod)\n    xp2 = pow(r, n, mod)\n    return (xp1, xp2)\n\ndef f2(r, p, n):\n    x2 = pow(r, n, mod)\n    x1 = pow(p, n, mod)\n    x2 = pow(x2, mod - 2, mod)\n    rp = x1 * x2 % mod\n    return rp\nfor i in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m == 1:\n        pm = pow(n, mod - 2, mod)\n        print(pm)\n    elif m % 2 == 1:\n        rp = math.ceil(m / 2)\n        (a, m) = sumg(n, n - 1, rp)\n        mp = pow(m, mod - 2, mod)\n        print(a * mp % mod)\n    else:\n        rp = math.ceil(m // 2)\n        (a, m) = sumg(n, n - 1, rp)\n        mp = pow(m, mod - 2, mod)\n        sum1 = a * mp % mod\n        xp = pow(n, rp, mod)\n        xp1 = pow(n - 1, rp, mod)\n        xp3 = pow(n + k, mod - 2, mod)\n        xp = pow(xp, mod - 2, mod)\n        ans = xp * xp1 * xp3 % mod\n        print((sum1 + ans) % mod)", "def modInverse(a, m):\n    g = gcd(a, m)\n    if g != 1:\n        return\n    else:\n        return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nt = int(input())\nfor i in range(t):\n    (n, k, m) = map(int, input().split())\n    r = 0\n    if m % 2 != 0:\n        p = power(n, m // 2 + 1, 1000000007) - power(n - 1, m // 2 + 1, 1000000007)\n        p = p % 1000000007\n        q = power(n, m // 2 + 1, 1000000007)\n        q = modInverse(q, 1000000007)\n        r = p % 1000000007 * (q % 1000000007) % 1000000007\n    else:\n        x = power(n, m // 2, 1000000007)\n        x = x * (n + k) % 1000000007\n        y = power(n - 1, m // 2, 1000000007)\n        y = y * (1 - (n + k)) % 1000000007\n        p = (x + y) % 1000000007\n        q = power(n, m // 2, 1000000007)\n        q = q * (n + k) % 1000000007\n        q = modInverse(q, 1000000007)\n        r = p * q % 1000000007\n    print(r)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 0:\n        return 1\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nt = int(input())\nmod = 10 ** 9 + 7\nwhile t > 0:\n    t = t - 1\n    (n, k, m) = map(int, input().split(' '))\n    p = m // 2 + m % 2\n    temp = pow(n - 1, p, mod)\n    denom = pow(n, p, mod)\n    num = (denom - temp) % mod\n    if m % 2 == 0:\n        nnum = temp\n        ndenom = denom * (n + k) % mod\n        num = (num * ndenom % mod + denom * nnum % mod) % mod\n        denom = denom * ndenom % mod\n    hcf = gcd(num, denom)\n    num = num // hcf\n    denom = denom // hcf\n    print(int(num % mod * modInverse(denom, mod) % mod) % mod)", "M = 10 ** 9 + 7\n\ndef po(x, y):\n    res = 1\n    x = x % M\n    while y > 0:\n        if int(y) & 1:\n            res = res * x % M\n        y = int(y / 2)\n        x = x * x % M\n    return res\nfor _ in range(int(input())):\n    (n, k, m) = list(map(int, input().split()))\n    if m == 1:\n        deno = po(n, M - 2)\n        print(deno)\n        continue\n    answer = 0\n    if m % 2 != 0:\n        m = int(m / 2)\n        m += 1\n        r = po(n, M - 2) * (n - 1) % M\n        mul = po(n, M - 2)\n        uhi = (1 - po(r, m) + M) % M\n        uhi2 = (1 - r + M) % M\n        uhi2 = po(uhi2, M - 2)\n        uhi = uhi * uhi2 % M\n        mul = mul * uhi % M\n        print(mul)\n    elif m % 2 == 0:\n        m = m / 2\n        r = po(n, M - 2) * (n - 1) % M\n        mul = po(n, M - 2)\n        uhi = (1 - po(r, m) + M) % M\n        uhi2 = (1 - r + M) % M\n        uhi2 = po(uhi2, M - 2)\n        uhi = uhi * uhi2 % M\n        mul = mul * uhi % M\n        uhi3 = po(r, m)\n        uhi4 = po(n + k, M - 2)\n        uhi3 = uhi3 * uhi4 % M\n        mul = (mul + uhi3) % M\n        print(mul)", "from fractions import Fraction\n\ndef ext_gcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    (d, x1, y1) = ext_gcd(b % a, a)\n    x = y1 - b // a * x1\n    y = x1\n    return (d, x, y)\n\ndef inverse(a, m):\n    (g, x, _) = ext_gcd(a, m)\n    if g != 1:\n        return\n    return (x % m + m) % m\nMOD = 10 ** 9 + 7\n\ndef pow(a, b, mod):\n    res = 1\n    x = a\n    while b > 0:\n        if b % 2 == 0:\n            x = x * x % mod\n            b //= 2\n        else:\n            res = res * x % mod\n            b -= 1\n    return res\n\ndef calc_fraction(a, b):\n    p = a\n    q = inverse(b, MOD)\n    return p * q % MOD\n\ndef solve(n, k, m):\n    n_mod = n % k\n    f1 = Fraction(1, n)\n    f2 = Fraction(1, n) + Fraction(n - 1, n) * Fraction(1, n + k)\n    if n > k:\n        f2 = max(f2, Fraction(1, n_mod))\n    t = (m + 1) // 2 - 1\n    f = f2 if m % 2 == 0 else f1\n    (a, b) = (f.numerator, f.denominator)\n    x = pow(n_mod - 1, t, MOD)\n    y = pow(n_mod, t, MOD)\n    numerator = (x * (a - b) % MOD + y * b % MOD) % MOD\n    denominator = y * b % MOD\n    return calc_fraction(numerator, denominator)\ntry:\n    t = int(input())\nexcept:\n    pass\nelse:\n    for _ in range(t):\n        (n, k, m) = map(int, input().split())\n        print(solve(n, k, m))", "M = 1000000007\n\ndef po(x, y):\n    res = 1\n    x = x % M\n    while y > 0:\n        if int(y) & 1:\n            res = res * x % M\n        y = int(y / 2)\n        x = x * x % M\n    return res\nfor _ in range(int(input())):\n    (n, k, m) = list(map(int, input().split()))\n    if m == 1:\n        deno = po(n, M - 2)\n        print(deno)\n        continue\n    answer = 0\n    if m % 2:\n        m = int(m / 2)\n        m += 1\n        r = po(n, M - 2) * (n - 1) % M\n        mul = po(n, M - 2)\n        uhi = (1 - po(r, m) + M) % M\n        uhi2 = (1 - r + M) % M\n        uhi2 = po(uhi2, M - 2)\n        uhi = uhi * uhi2 % M\n        mul = mul * uhi % M\n        print(mul)\n    else:\n        m = m / 2\n        r = po(n, M - 2) * (n - 1) % M\n        mul = po(n, M - 2)\n        uhi = (1 - po(r, m) + M) % M\n        uhi2 = (1 - r + M) % M\n        uhi2 = po(uhi2, M - 2)\n        uhi = uhi * uhi2 % M\n        mul = mul * uhi % M\n        uhi3 = po(r, m)\n        uhi4 = po(n + k, M - 2)\n        uhi3 = uhi3 * uhi4 % M\n        mul = (mul + uhi3) % M\n        print(mul)", "import math\nMOD = 1000000007\n\ndef multinv(x, mod):\n    a = dev(x, mod)\n    if a != 1:\n        return 0\n    else:\n        return exp(x, mod - 2, mod)\n\ndef exp(a, b, mod):\n    if b == 0:\n        return 1\n    m = exp(a, b // 2, mod) % mod\n    m = m * m % mod\n    if b % 2 == 0:\n        return m\n    else:\n        return a * m % mod\n\ndef dev(m, n):\n    if m == 0:\n        return n\n    return dev(n % m, m)\ntest = int(input())\nfor fu in range(test):\n    (n, k, m) = map(int, input().split(' '))\n    if m % 2 == 0:\n        temp2 = exp(n, m // 2, MOD)\n        temp4 = exp(n - 1, m // 2, MOD)\n        p = (temp2 - temp4) * (n + k) % MOD + temp4\n        q = temp2 * (n + k) % MOD\n        q = multinv(q, MOD)\n        res = p * q % MOD\n    else:\n        temp5 = exp(n, (m + 1) // 2, MOD)\n        temp6 = exp(n - 1, (m + 1) // 2, MOD)\n        p = (temp5 - temp6) % MOD\n        q = multinv(temp5, MOD)\n        res = p * q % MOD\n    print(res)", "def fast_exp(num, power):\n    result = 1\n    while power > 0:\n        if power % 2 == 1:\n            result = result * num % 1000000007\n        power = power // 2\n        num = num * num % 1000000007\n    return result\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nt = int(input())\nfor i in range(t):\n    (n, k, m) = map(int, input().split(' '))\n    e1 = fast_exp(n, (m + 1) // 2)\n    e2 = fast_exp(n - 1, (m + 1) // 2)\n    if m % 2 == 0:\n        a2 = int(e1) * (n + k)\n        a1 = (e1 - e2) * (n + k) + e2\n    else:\n        a1 = e1 - e2\n        a2 = int(e1)\n    nu = a1\n    de = a2\n    p = 10 ** 9 + 7\n    q = nu * (modinv(de, p) % p) % p\n    print(q)", "MOD = 1000000007\ndp = [0] * (100000 + 5)\n\ndef modularInverse(n, prime):\n    dp[0] = dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[prime % i] * (prime - prime // i) % prime\nmodularInverse(100000, MOD)\nt = int(input())\n\ndef power(x, y, p=MOD):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nwhile t > 0:\n    t -= 1\n    [n, k, m] = [int(i) for i in input().split()]\n    if m == 1:\n        print(dp[n])\n    else:\n        if n > k:\n            if n % k == 0:\n                n = k\n            else:\n                n = n - n // k * k\n            m -= 1\n        first = dp[n]\n        second = dp[n + k]\n        p = m // 2\n        if m % 2 == 0:\n            res = ((power(n, p) - power(n - 1, p)) % MOD * power(first, p) % MOD % MOD + power(n - 1, p) % MOD * power(first, p) % MOD * second % MOD % MOD) % MOD\n        else:\n            res = ((power(n, p) - power(n - 1, p)) % MOD * power(first, p) % MOD % MOD + power(n - 1, p) % MOD * power(first, p) % MOD * first % MOD % MOD) % MOD\n        print(res % MOD)", "mod = 1000000007\nfrom math import gcd\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        print(3 / 0)\n    else:\n        return x % m\nt = int(input())\nfor i in range(t):\n    lst = str(input()).split(' ')\n    n = int(lst[0])\n    k = int(lst[1])\n    m = int(lst[2])\n    if m % 2 == 0:\n        j = m // 2\n        q = pow(n, j, mod) * (n + k)\n        p = q - pow(n - 1, j, mod) * (n + k - 1)\n    else:\n        j = (m + 1) // 2\n        q = pow(n, j, mod)\n        p = q - pow(n - 1, j, mod)\n    g = gcd(p, q)\n    p /= g\n    q /= g\n    p = int((p + mod) % mod)\n    q = int((q + mod) % mod)\n    print(int(p * modinv(q, mod)) % mod)", "import math\n\ndef modinv(a, pwr, modval):\n    if pwr == 0:\n        return 1\n    p = modinv(a, pwr // 2, modval) % modval\n    p = p * p % modval\n    if pwr % 2 == 0:\n        return p\n    else:\n        return a * p % modval\nt = int(input())\nfor i in range(t):\n    data = input().split(' ')\n    n = int(data[0])\n    k = int(data[1])\n    m = int(data[2])\n    cnt = n\n    mod = 10 ** 9 + 7\n    if m % 2 == 1:\n        m = m // 2 + 1\n        print((pow(n, m, mod) - pow(n - 1, m, mod)) % mod * modinv(n, mod - 1 - m, mod) % mod)\n    else:\n        p = m - 1\n        p = p // 2 + 1\n        val = (pow(n, p, mod) - pow(n - 1, p, mod)) % mod * modinv(n, mod - 1 - p, mod) % mod\n        val2 = pow(n - 1, p, mod) * modinv(n, mod - 1 - p, mod) % mod * modinv(n + k, mod - 2, mod) % mod\n        val = (val + val2) % mod\n        print(val)", "import math\n\ndef addfract(f1n, f1d, f2n, f2d):\n    den = f1d * f2d\n    num = f1n * f2d + f2n * f1d\n    retval = math.gcd(min(num, den), max(num, den))\n    num = num // retval\n    den = den // retval\n    return (num, den)\n\ndef modinv(a, pwr, modval):\n    if pwr == 0:\n        return 1\n    p = modinv(a, pwr // 2, modval) % modval\n    p = p * p % modval\n    if pwr % 2 == 0:\n        return p\n    else:\n        return a * p % modval\nt = int(input())\nfor i in range(t):\n    data = input().split(' ')\n    n = int(data[0])\n    k = int(data[1])\n    m = int(data[2])\n    cnt = n\n    mod = 10 ** 9 + 7\n    if m % 2 == 1:\n        m = m // 2 + 1\n        print((pow(n, m, mod) - pow(n - 1, m, mod)) % mod * modinv(n, mod - 1 - m, mod) % mod)\n    else:\n        p = m - 1\n        p = p // 2 + 1\n        val = (pow(n, p, mod) - pow(n - 1, p, mod)) % mod * modinv(n, mod - 1 - p, mod) % mod\n        val2 = pow(n - 1, p, mod) * modinv(n, mod - 1 - p, mod) % mod * modinv(n + k, mod - 2, mod) % mod\n        val = (val + val2) % mod\n        print(val)", "test = int(input())\nwhile test > 0:\n    (N, K, M) = map(int, input().split())\n    p = int(1000000007)\n    if M % 2 == 1:\n        den = pow(N, (M + 1) // 2, p)\n        num = den - pow(N - 1, (M + 1) // 2, p)\n    else:\n        den = pow(N, M // 2, p) * ((N + K) % p) % p\n        num = (den - pow(N - 1, M // 2, p) * (N + K - 1) % p) % p\n    modin = pow(den, p - 2, p)\n    ans = modin * num % p\n    print(ans)\n    test -= 1", "def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef fast_exp(num, power):\n    result = 1\n    while power > 0:\n        if power % 2 == 1:\n            result = result * num % 1000000007\n        power = power // 2\n        num = num * num % 1000000007\n    return result\n\ndef gcd(aa, bb):\n    if bb == 0:\n        return aa\n    else:\n        return gcd(bb, aa % bb)\nfor i in range(int(input())):\n    (n, k, p) = map(int, input().split())\n    q = p // 2\n    r = p % 2\n    if r == 1:\n        numf = fast_exp(n, q + 1) - fast_exp(n - 1, q + 1)\n        denf = fast_exp(n, q + 1)\n        t = gcd(numf, denf)\n        numf = numf // t\n        denf = denf // t\n    else:\n        numi = fast_exp(n, q) - fast_exp(n - 1, q)\n        deni = fast_exp(n, q)\n        numf = numi * (n + k) + (deni - numi)\n        denf = deni * (n + k)\n        t = gcd(numf, denf)\n        numf = numf // t\n        denf = denf // t\n    h = 10 ** 9 + 7\n    ll = modinv(denf, h)\n    result = ll * numf % h\n    print(result)", "from fractions import Fraction\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef minv(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nfor i in range(int(input())):\n    h = 10 ** 9 + 7\n    [n, k, m] = map(int, input().split())\n    if m == 1:\n        p = 1\n        q = n\n        result = p % h * minv(q, h) % h\n        print(result)\n    elif m % 2 != 0:\n        x = m // 2 + 1\n        p = power(n, x, h) - power(n - 1, x, h)\n        q = power(n, x, h)\n        result = p % h * minv(q, h) % h\n        print(result)\n    else:\n        x = m // 2\n        p = (power(n, x, h) - power(n - 1, x, h)) * (n + k) + power(n - 1, x, h)\n        q = power(n, x, h) * (n + k)\n        result = p % h * minv(q, h) % h\n        print(result)", "from fractions import Fraction\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef minv(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nfor i in range(int(input())):\n    h = 10 ** 9 + 7\n    [n, k, m] = map(int, input().split())\n    if m == 1:\n        p = 1\n        q = n\n        result = p % h * minv(q, h) % h\n        print(result)\n    elif m % 2 != 0:\n        x = m // 2 + 1\n        p = power(n, x, h) - power(n - 1, x, h)\n        q = power(n, x, h)\n        result = p % h * minv(q, h) % h\n        print(result)\n    else:\n        x = m // 2\n        p = (power(n, x, h) - power(n - 1, x, h)) * (n + k) + power(n - 1, x, h)\n        q = power(n, x, h) * (n + k)\n        result = p % h * minv(q, h) % h\n        print(result)", "import math\n\ndef computeGCD(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\nfrom fractions import Fraction\nt = int(input())\nfor i in range(t):\n    (n, k, mi) = [int(x) for x in input().split()]\n    mi = mi - 1\n    num = n - 1\n    den = n\n    if mi % 2 == 1:\n        num = num * pow(n - 1, mi // 2, 1000000007) * (n + k - 1)\n        den = den * pow(n, mi // 2, 1000000007) * (n + k)\n    else:\n        num = num * pow(n - 1, mi // 2, 1000000007)\n        den = den * pow(n, mi // 2, 1000000007)\n    num = den - num\n    gc = computeGCD(num, den)\n    frac = Fraction(num, den)\n    num = frac.numerator\n    den = frac.denominator\n    den = pow(den, 1000000005, 1000000007)\n    print(num * den % 1000000007)", "def computeGCD(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\nfrom fractions import Fraction\nt = int(input())\nfor i in range(t):\n    (n, k, mi) = [int(x) for x in input().split()]\n    mi = mi - 1\n    num = n - 1\n    den = n\n    if mi % 2 == 1:\n        num = num * pow(n - 1, mi // 2, 1000000007) * (n + k - 1)\n        den = den * pow(n, mi // 2, 1000000007) * (n + k)\n    else:\n        num = num * pow(n - 1, mi // 2, 1000000007)\n        den = den * pow(n, mi // 2, 1000000007)\n    num = den - num\n    gc = computeGCD(num, den)\n    frac = Fraction(num, den)\n    num = frac.numerator\n    den = frac.denominator\n    den = pow(den, 1000000005, 1000000007)\n    print(num * den % 1000000007)", "M = 1000000007\n\ndef modularExponentiation(x, n, M):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        return modularExponentiation(x * x % M, n // 2, M)\n    else:\n        return x * modularExponentiation(x * x % M, (n - 1) // 2, M) % M\n\ndef modInverse(A, M):\n    return modularExponentiation(A, M - 2, M)\n\ndef power(a, b):\n    if b == 0:\n        return 1\n    if b % 2 == 0:\n        return power(a * a % M, b // 2) % M\n    else:\n        return a * power(a * a % M, (b - 1) // 2) % M\nt = int(input())\nmi = 100000\ndp = [0] * (mi + 1)\ndp[0] = dp[1] = 1\nfor i in range(2, mi + 1):\n    dp[i] = dp[M % i] * (M - M // i) % M\nwhile t > 0:\n    t -= 1\n    [n, k, m] = [int(i) for i in input().split()]\n    if m == 1:\n        print(dp[n])\n    else:\n        if n > k:\n            if n % k == 0:\n                n = k\n            else:\n                n = n - n // k * k\n            m -= 1\n        first = dp[n]\n        second = dp[n + k]\n        if m % 2 == 0:\n            p = m // 2\n            pfp = power(first, p)\n            pnp = power(n - 1, p)\n            res = (power(n, p) - pnp) * pfp % M + pnp * pfp * second % M\n        else:\n            p = m // 2\n            pfp = power(first, p)\n            pnp = power(n - 1, p)\n            res = (power(n, p) - pnp) * pfp % M + pnp * pfp * first % M\n        print(res % M)", "MOD = 1000000007\n\ndef powerLL(x, n):\n    result = 1\n    while n:\n        if n & 1:\n            result = result * x % MOD\n        n = int(n / 2)\n        x = x * x % MOD\n    return result\n\ndef powerStrings(sa, sb):\n    a = 0\n    b = 0\n    for i in range(len(sa)):\n        a = (a * 10 + (ord(sa[i]) - ord('0'))) % MOD\n    for i in range(len(sb)):\n        b = (b * 10 + (ord(sb[i]) - ord('0'))) % (MOD - 1)\n    return powerLL(a, b)\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nt = int(input())\nfor x in range(t):\n    (n, k, m) = input().split()\n    n = int(n)\n    k = int(k)\n    m = int(m)\n    if m % 2 == 0:\n        s1 = str(n)\n        s2 = str(n - 1)\n        ex = str(m // 2)\n        a = powerStrings(s1, ex)\n        b = powerStrings(s2, ex)\n        num = ((a - b) * (n + k) % MOD + b % MOD) % MOD\n        den = a * (n + k) % MOD\n        minv = power(den, MOD - 2, MOD)\n        ans = num * minv % MOD\n    else:\n        s1 = str(n)\n        s2 = str(n - 1)\n        ex = str((m + 1) // 2)\n        a = powerStrings(s1, ex)\n        b = powerStrings(s2, ex)\n        num = a - b\n        den = a\n        minv = power(den, MOD - 2, MOD)\n        ans = num * minv % MOD\n    print(ans)", "from fractions import Fraction\np = 1000000007\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nfor i in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m & 1:\n        m >>= 1\n        m += 1\n        denom = power(n, m, p)\n        num = denom - power(n - 1, m, p)\n        modInv = power(denom, p - 2, p)\n        print(num % p * (modInv % p) % p)\n    else:\n        m >>= 1\n        tmp_denom = power(n, m, p)\n        tmp_num = power(n - 1, m, p)\n        frac = Fraction(tmp_denom - tmp_num, tmp_denom) + (1 - Fraction(tmp_denom - tmp_num, tmp_denom)) * Fraction(1, n + k)\n        num = frac.numerator\n        modInv = power(frac.denominator, p - 2, p)\n        print(num % p * (modInv % p) % p)", "def modpow(a, n, modnum):\n    result = 1\n    while n > 0:\n        if n & 1:\n            result = result * a % modnum\n        a = a * a % modnum\n        n = n >> 1\n    return result\n\ndef modinv(a, modnum):\n    return modpow(a, modnum - 2, modnum)\nmodnum = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = list(map(int, input().split()))\n    r0 = modinv(n, modnum)\n    r = modinv(n % k, modnum)\n    nk = n % k % modnum\n    if m % 2 == 1:\n        m2 = (m - 1) // 2\n        bunshi = (modpow(r, m2, modnum) * modpow(nk - 1, m2, modnum) - 1) % modnum\n        inv = modinv(r * (nk - 1) - 1, modnum)\n        ans = (r0 + r0 * (n - 1) * r * bunshi * inv) % modnum\n    else:\n        m2 = (m - 2) // 2\n        bunshi = (modpow(r, m2, modnum) * modpow(nk - 1, m2, modnum) - 1) % modnum\n        inv = modinv(r * (nk - 1) - 1, modnum)\n        ans = (r0 + r0 * (n - 1) * r * bunshi * inv) % modnum\n        ans = (ans + r0 * (n - 1) * modpow(r, m2, modnum) * modpow(nk - 1, m2, modnum) * modinv(nk + k, modnum)) % modnum\n    print(ans)", "M = 1000000007\n\ndef po(x, y):\n    res = 1\n    x = x % M\n    while y > 0:\n        if int(y) & 1:\n            res = res * x % M\n        y = int(y / 2)\n        x = x * x % M\n    return res\nfor _ in range(int(input())):\n    (n, k, m) = list(map(int, input().split()))\n    if m == 1:\n        deno = po(n, M - 2)\n        print(deno)\n        continue\n    answer = 0\n    if n > k:\n        value = int(n / k)\n        value = value * k\n        n -= value\n        m -= 1\n    if m % 2:\n        m = int(m / 2)\n        m += 1\n        r = po(n, M - 2) * (n - 1) % M\n        mul = po(n, M - 2)\n        uhi = (1 - po(r, m) + M) % M\n        uhi2 = (1 - r + M) % M\n        uhi2 = po(uhi2, M - 2)\n        uhi = uhi * uhi2 % M\n        mul = mul * uhi % M\n        print(mul)\n    else:\n        m = m / 2\n        r = po(n, M - 2) * (n - 1) % M\n        mul = po(n, M - 2)\n        uhi = (1 - po(r, m) + M) % M\n        uhi2 = (1 - r + M) % M\n        uhi2 = po(uhi2, M - 2)\n        uhi = uhi * uhi2 % M\n        mul = mul * uhi % M\n        uhi3 = po(r, m)\n        uhi4 = po(n + k, M - 2)\n        uhi3 = uhi3 * uhi4 % M\n        mul = (mul + uhi3) % M\n        print(mul)", "M = 1000000007\n\ndef power(x, y):\n    res = 1\n    x = x % M\n    while y > 0:\n        if int(y) & 1:\n            res = res * x % M\n        y = int(y / 2)\n        x = x * x % M\n    return res\nfor _ in range(int(input())):\n    (n, k, m) = list(map(int, input().split()))\n    if m == 1:\n        deno = power(n, M - 2)\n        print(deno)\n        continue\n    ans = 0\n    if n > k:\n        val = int(n / k)\n        val = val * k\n        n -= val\n        m -= 1\n    if m % 2:\n        m = int(m / 2)\n        m += 1\n        r = power(n, M - 2) * (n - 1) % M\n        mul = power(n, M - 2)\n        temp = (1 - power(r, m) + M) % M\n        temp2 = (1 - r + M) % M\n        temp2 = power(temp2, M - 2)\n        temp = temp * temp2 % M\n        mul = mul * temp % M\n        print(mul)\n    else:\n        m = m / 2\n        r = power(n, M - 2) * (n - 1) % M\n        mul = power(n, M - 2)\n        temp = (1 - power(r, m) + M) % M\n        temp2 = (1 - r + M) % M\n        temp2 = power(temp2, M - 2)\n        temp = temp * temp2 % M\n        mul = mul * temp % M\n        temp3 = power(r, m)\n        temp4 = power(n + k, M - 2)\n        temp3 = temp3 * temp4 % M\n        mul = (mul + temp3) % M\n        print(mul)", "from fractions import Fraction\nfor i in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 1:\n        a = pow(n, int(m / 2) + 1, 1000000007)\n        b = a - pow(n - 1, int(m / 2) + 1, 1000000007)\n        mdi = pow(a, 1000000005, 1000000007)\n        print(b * mdi % 1000000007)\n    else:\n        a = pow(n, int(m / 2), 1000000007)\n        b = pow(n - 1, int(m / 2), 1000000007)\n        c = Fraction(a - b, a) + (1 - Fraction(a - b, a)) * Fraction(1, n + k)\n        N = c.numerator\n        denm = pow(c.denominator, 1000000005, 1000000007)\n        print(N * denm % 1000000007)", "from fractions import Fraction\nfor i in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 1:\n        mau = pow(n, int(m / 2) + 1, 1000000007)\n        tu = mau - pow(n - 1, int(m / 2) + 1, 1000000007)\n        maund = pow(mau, 1000000005, 1000000007)\n        print(tu * maund % 1000000007)\n    else:\n        nx = pow(n, int(m / 2), 1000000007)\n        n1x = pow(n - 1, int(m / 2), 1000000007)\n        a = Fraction(nx - n1x, nx) + (1 - Fraction(nx - n1x, nx)) * Fraction(1, n + k)\n        num = a.numerator\n        dend = pow(a.denominator, 1000000005, 1000000007)\n        print(num * dend % 1000000007)", "import math\nmod = 1000000007\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef fast_power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nt = int(input())\nwhile t > 0:\n    (n, k, m) = map(int, input().split())\n    ne = 0\n    de = 0\n    if m % 2 == 0:\n        a = fast_power(n, int(m / 2), mod)\n        b = fast_power(n - 1, int(m / 2), mod)\n        ne = (a - b) * (n + k) + b\n        de = a * (n + k)\n    else:\n        aa = fast_power(n, int(m / 2) + 1, mod)\n        bb = fast_power(n - 1, int(m / 2) + 1, mod)\n        ne = aa - bb\n        de = aa\n    hcf = math.gcd(ne, de)\n    ne = ne / hcf\n    de = de / hcf\n    ans = int(int(ne) * int(modInverse(de, mod)) % mod)\n    print(ans)\n    t = t - 1", "from fractions import Fraction\nimport math\n\ndef modInverse(a, m):\n    g = math.gcd(a, m)\n    if g != 1:\n        return -1\n    else:\n        return pow(a, m - 2, m)\n\ndef fun(n, k, m):\n    b = Fraction(1, n + k)\n    x = (m - 1) // 2 + 1\n    y = (m - 2) // 2 + 1\n    ans = 0\n    if m & 1:\n        c = pow(n - 1, x, 1000000007)\n        d = pow(n, x, 1000000007)\n        a = Fraction(c, d)\n        ans = Fraction(1, 1) - a\n    else:\n        c = pow(n - 1, y, 1000000007)\n        d = pow(n, y, 1000000007)\n        a = Fraction(c, d)\n        ans = Fraction(1, 1) - a + a * b\n    ans = str(ans)\n    if ans == '1':\n        print(1)\n    else:\n        (a, b) = list(map(int, ans.split('/')))\n        x = modInverse(b, 1000000007)\n        print(a % 1000000007 * (x % 1000000007) % 1000000007)\n\ndef main():\n    for _ in range(int(input())):\n        (n, k, m) = list(map(int, input().split()))\n        fun(n, k, m)\nmain()", "from fractions import Fraction\nfor i in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 1:\n        mau = pow(n, int(m / 2) + 1, 1000000007)\n        tu = mau - pow(n - 1, int(m / 2) + 1, 1000000007)\n        maund = pow(mau, 1000000005, 1000000007)\n        print(tu * maund % 1000000007)\n    else:\n        nx = pow(n, int(m / 2), 1000000007)\n        n1x = pow(n - 1, int(m / 2), 1000000007)\n        a = Fraction(nx - n1x, nx) + (1 - Fraction(nx - n1x, nx)) * Fraction(1, n + k)\n        num = a.numerator\n        dend = pow(a.denominator, 1000000005, 1000000007)\n        print(num * dend % 1000000007)", "def modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nimport math\nt = int(input())\nmod = 10 ** 9 + 7\nwhile t > 0:\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 0:\n        p = pow(n, int(m / 2), mod) * (n + k) % mod - pow(n - 1, int(m / 2), mod) * (n + k - 1) % mod\n        q = pow(n, int(m / 2), mod) * (n + k) % mod\n    else:\n        p = pow(n, int(m / 2) + 1, mod) % mod - pow(n - 1, int(m / 2) + 1, mod) % mod\n        q = pow(n, int(m / 2) + 1, mod) % mod\n    ans = p * modInverse(q, mod) % mod\n    print(ans)\n    t = t - 1", "import math\nmodulo = int(1000000007)\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef intpow(base, exp):\n    if exp == 0:\n        return 1\n    elif exp == 1:\n        return base\n    elif exp & 1 != 0:\n        return base * intpow(base * base % modulo, exp // 2) % modulo\n    return intpow(base * base % modulo, exp // 2)\nt = int(input())\nfor l in range(t):\n    (n, k, m) = map(int, input().split())\n    j = int(0)\n    x = int(1)\n    y = int(0)\n    a = int(1)\n    b = int(1)\n    if n > k and n % k != 0:\n        n = n % k\n        m = m - 1\n    elif n > k:\n        n = k\n        m = m - 1\n    if m % 2 == 0:\n        a = int(intpow(n, m // 2))\n        b = int(intpow(n - 1, m // 2))\n        y = int(a - b)\n        x = int(a)\n        y = y * (n + k) + b\n        x = x * (n + k)\n    elif m % 2 != 0:\n        a = int(intpow(n, (m + 1) // 2))\n        b = int(intpow(n - 1, (m + 1) // 2))\n        y = int(a - b)\n        x = int(a)\n    x = int(x % modulo)\n    y = int(y % modulo)\n    z = y\n    (g, x, y) = egcd(x, modulo)\n    a = (x % modulo + modulo) % modulo\n    k = z * a % modulo\n    print(k)", "def modinverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nfor T in range(int(input())):\n    value = 1000000007\n    (N, K, M) = map(int, input().split())\n    a = (N - 1) * modinverse(N, value)\n    if M == 1:\n        answer = modinverse(N, value)\n    elif M == 2:\n        answer = modinverse(N, value) + a * modinverse(N + K, value)\n    elif M % 2 == 1:\n        n = (M + 1) // 2\n        b = power(a, n, value)\n        answer = 1 - b\n    else:\n        n = M // 2\n        b = power(a, n, value)\n        d = 1 - b\n        e = b * modinverse(N + K, value)\n        answer = d + e\n    print(answer % value)", "from math import gcd\nmod = 10 ** 9 + 7\n\ndef modInverse(a, mod):\n    return power(a, mod - 2, mod)\n\ndef power(x, y, mod):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, mod) % mod\n    p = p * p % mod\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % mod\n\ndef answer(p, q):\n    x = gcd(p, q)\n    p = p // x\n    q = q // x\n    return p % mod * (modInverse(q, mod) % mod) % mod\nfor i in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m == 1:\n        print(answer(1, n))\n    else:\n        if m % 2 == 0:\n            x = m // 2\n        else:\n            x = (m + 1) // 2\n        p = n - 1\n        q = n\n        num1 = power(q, x, mod) - power(p, x, mod)\n        deno = power(q, x, mod)\n        if m % 2 == 0:\n            num1 = (power(q, x, mod) - power(p, x, mod)) * (n + k) + power(p, x, mod)\n            deno = power(n, x, mod) * (n + k)\n        print(answer(num1, deno))", "import math\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    return x * p % m\nMOD = 1000000007\nfor _ in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    x = (m + 1) // 2\n    p = power(n - 1, x, MOD)\n    q = power(n, x, MOD)\n    y = p * modInverse(q, MOD)\n    result = 1 - y + MOD\n    if m % 2 == 0:\n        result += y * modInverse(n + k, MOD)\n    print(result % MOD)", "mod = 1000000007\n\ndef modular(x, n, mod):\n    if n == 0:\n        return 1\n    elif n % 2 == 0:\n        y = modular(x, n / 2, mod)\n        return y % mod * (y % mod) % mod\n    else:\n        return x % mod * modular(x, n - 1, mod) % mod\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nt = int(input())\nwhile t:\n    t = t - 1\n    (n, k, m) = [int(x) for x in input().split()]\n    if m % 2 != 0:\n        x = int((m + 1) / 2)\n        num = (modular(n, x, mod) % mod - modular(n - 1, x, mod) % mod + mod) % mod\n        den = int(modular(n, x, mod))\n    else:\n        x = int(m / 2)\n        num = int(((n + k) * ((modular(n, x, mod) % mod - modular(n - 1, x, mod) % mod + mod) % mod) + modular(n - 1, x, mod)) % mod)\n        den = int((n + k) * modular(n, x, mod))\n    y = gcd(num, den)\n    num = num // y\n    den = den // y\n    ss = modInverse(den, mod)\n    ans = num % mod * (ss % mod) % mod\n    print(ans)", "def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef lowest(den3, num3):\n    common_factor = gcd(num3, den3)\n    den3 = int(den3 / common_factor)\n    num3 = int(num3 / common_factor)\n    return (num3, den3)\n\ndef add_frac(num1, den1, num2, den2):\n    den3 = gcd(den1, den2)\n    den3 = den1 * den2 / den3\n    num3 = num1 * (den3 / den1) + num2 * (den3 / den2)\n    (num3, den3) = lowest(den3, num3)\n    return (num3, den3)\n\ndef power(x, y, mod):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, mod) % mod\n    p = p * p % mod\n    return p if y % 2 == 0 else x * p % mod\nmodulus = 1000000007\nfor t in range(int(input())):\n    l = input().split()\n    n = int(l[0])\n    k = int(l[1])\n    m = int(l[2])\n    if m % 2 == 0:\n        terms = m // 2\n        gp_n = power(n - 1, terms, modulus)\n        gp_d = power(n, terms, modulus)\n        n1 = gp_d - gp_n\n        d2 = gp_d * (n + k)\n        (n1, d1) = add_frac(n1, gp_d, gp_n, d2)\n    else:\n        terms = (m + 1) // 2\n        gp_n = power(n - 1, terms, modulus)\n        gp_d = power(n, terms, modulus)\n        n1 = gp_d - gp_n\n        d1 = gp_d\n    print(n1 * power(d1, modulus - 2, modulus) % modulus)", "mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if n <= k:\n        (a, b, val) = (n, n - 1, m // 2)\n        if m % 2 != 0:\n            ans = 1 - pow(b * pow(a, mod - 2, mod) % mod, val + 1, mod)\n        else:\n            ans = 1 - pow(b * pow(a, mod - 2, mod) % mod, val, mod) * (1 - pow(n + k, mod - 2, mod))\n    else:\n        (a, b, val) = (n - k * (n // k), n - k * (n // k) - 1, m // 2)\n        if m % 2 == 0:\n            ans = 1 - pow(b * pow(a, mod - 2, mod) % mod, val, mod)\n        else:\n            ans = 1 - pow(b * pow(a, mod - 2, mod) % mod, val, mod) * (1 - pow(a + k, mod - 2, mod))\n    ans %= mod\n    print(ans)", "from math import gcd\n\ndef power(x, y):\n    mo = 1000000007\n    res = 1\n    while y > 0:\n        if y & 1 == 1:\n            res = res % mo * (x % mo) % mo\n        y = y >> 1\n        x = x % mo * (x % mo) % mo\n    return res\n\ndef mI(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nt = int(input())\nwhile t:\n    mm = 1000000007\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 0:\n        m = m // 2\n        a = power(n - 1, m)\n        c = a\n        b = power(n, m)\n        a = b - a\n        d = b % mm * ((k + n) % mm) % mm\n        a = a % mm * ((k + n) % mm) % mm + c\n        b = d\n    else:\n        m = m // 2 + 1\n        a = power(n - 1, m)\n        b = power(n, m)\n        a = b - a\n    c = gcd(b, mm)\n    b = b // c\n    mm = mm // c\n    an = mI(b, mm)\n    re = a % mm * (an % mm) % mm\n    print(re)\n    t -= 1", "import math\nfrom sys import stdin, stdout\nmaxn = 1000000007\nnp = stdin.readline\nfor _ in range(int(np())):\n    (n, k, m) = map(int, np().split())\n    if m % 2 == 0:\n        ch = m // 2\n        num = pow(n - 1, ch, maxn) * (n + k - 1) % maxn\n        den = pow(n, ch, maxn) * (n + k) % maxn\n    else:\n        ch = (m + 1) // 2\n        num = pow(n - 1, ch, maxn) % maxn\n        den = pow(n, ch, maxn) % maxn\n    num = den - num\n    print(num * pow(den, maxn - 2, maxn) % maxn)", "def power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nt = int(input())\na = 1000000007\nwhile t:\n    t = t - 1\n    (n, k, m) = map(int, input().split())\n    if m % 2 == 1:\n        p = power(n, m // 2 + 1, a) - power(n - 1, m // 2 + 1, a)\n        q = power(n, m // 2 + 1, a)\n    else:\n        p = power(n, m // 2, a) * (n + k) - power(n - 1, m // 2, a) * (n + k - 1)\n        q = power(n, m // 2, a) * (n + k)\n    print(p * modInverse(q, a) % a)", "h = 1000000007\n\ndef modin(n):\n    (ri, rj) = (h, n)\n    (ti, tj) = (0, 1)\n    while rj != 0:\n        q = ri // rj\n        (ri, rj) = (rj, ri - q * rj)\n        (ti, tj) = (tj, ti - q * tj)\n    ans = ti % h\n    if ans < 0:\n        return ans + h\n    else:\n        return ans\n\ndef power(a, n):\n    if n == 1:\n        return a % h\n    if n == 2:\n        return a ** 2\n    elif n == 3:\n        return a ** 3\n    if n % 2 == 0:\n        b = power(a, n // 2)\n        return b * b % h\n    else:\n        b = power(a, n // 2)\n        return b * b * a % h\n\ndef solve(i):\n    (n, k, c) = i\n    if c == 1:\n        return modin(n)\n    if n % k == 1:\n        return 1\n    roll = 1 + (c - 1) // 2\n    if c % 2 == 1:\n        s = (1 - power((n - 1) * modin(n) % h, roll)) % h\n    else:\n        s = (1 - power((n - 1) * modin(n) % h, roll) % h * ((n + k - 1) * modin(n + k)) % h) % h\n    return s\na = []\nfor _ in range(int(input())):\n    a.append([int(x) for x in input().split()])\nfor i in a:\n    print(solve(i))", "h = 1000000007\n\ndef modin(n):\n    (ri, rj) = (h, n)\n    (ti, tj) = (0, 1)\n    while rj != 0:\n        q = ri // rj\n        (ri, rj) = (rj, ri - q * rj)\n        (ti, tj) = (tj, ti - q * tj)\n    ans = ti % h\n    if ans < 0:\n        return ans + h\n    else:\n        return ans\n\ndef power(a, n):\n    if n == 1:\n        return a % h\n    if n == 2:\n        return a ** 2\n    elif n == 3:\n        return a ** 3\n    if n % 2 == 0:\n        b = power(a, n // 2)\n        return b * b % h\n    else:\n        b = power(a, n // 2)\n        return b * b * a % h\n\ndef solve(i):\n    (n, k, c) = i\n    if c == 1:\n        return modin(n)\n    if n % k == 1:\n        return 1\n    roll = 1 + (c - 1) // 2\n    if c % 2 == 1:\n        s = (1 - power((n - 1) * modin(n) % h, roll)) % h\n    else:\n        s = (1 - power((n - 1) * modin(n) % h, roll) % h * ((n + k - 1) * modin(n + k)) % h) % h\n    return s\na = []\nfor _ in range(int(input())):\n    a.append([int(x) for x in input().split()])\nfor i in a:\n    print(solve(i))", "import math\n\ndef modInverse(a, m):\n    g = gcd(a, m)\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nt = int(input())\nwhile t != 0:\n    a = list(map(int, input().split()))\n    n = a[0]\n    del a[0]\n    k = a[0]\n    del a[0]\n    m = a[0]\n    del a[0]\n    if m % 2 == 0:\n        x = pow(int(n), int(m / 2), 10 ** 9 + 7)\n        y = int(x)\n        y *= int(n + k)\n        y %= 10 ** 9 + 7\n        x -= pow(int(n - 1), int(m / 2), 10 ** 9 + 7)\n        x *= int(n + k)\n        x %= 10 ** 9 + 7\n        x += pow(int(n - 1), int(m / 2), 10 ** 9 + 7)\n    else:\n        x = pow(int(n), int((m + 1) / 2), 10 ** 9 + 7)\n        y = int(x)\n        x -= pow(int(n - 1), int((m + 1) / 2), 10 ** 9 + 7)\n    x %= 1000000007\n    y %= 1000000007\n    print(int(x * modInverse(y, 1000000007)) % 1000000007)\n    t -= 1", "from math import *\n\ndef powww(x, y):\n    val = 1\n    mod = 1000000007\n    while y != 0:\n        if y & 1:\n            val = val * x % mod\n        x = x * x % mod\n        y >>= 1\n    return val\n\ndef solve(t):\n    mod = 1000000007\n    while t > 0:\n        t -= 1\n        (n, k, m) = input().split()\n        n = int(n)\n        m = int(m)\n        k = int(k)\n        if n <= 1:\n            val = powww(1, mod - 2) % mod\n        else:\n            r1 = int(ceil(float(m + 1) / 2.0))\n            if m & 1 == 0:\n                n1 = powww(n, r1 - 1)\n                n2 = powww(n - 1, r1 - 1)\n                n3 = (n1 * (n + k) - (n + k) * n2 + n2) % mod\n                d1 = powww(n, (r1 - 1) * (mod - 2))\n                d2 = powww(n + k, mod - 2)\n                d3 = d1 * d2 % mod\n                val = n3 * d3 % mod\n            else:\n                n1 = powww(n, r1)\n                n2 = powww(n - 1, r1)\n                d1 = powww(n, r1 * (mod - 2))\n                val = (n1 - n2) % mod * d1 % mod\n        print(val)\nt = int(input())\nsolve(t)", "from fractions import Fraction as f\nimport sys\nsys.setrecursionlimit(300002)\n\ndef mod(a):\n    return (a % 1000000007 + 1000000007) % 1000000007\n\ndef power2(x, y):\n    if y == 0:\n        return 1\n    elif int(y % 2) == 0:\n        tmp = power2(x, int(y / 2))\n        return mod(tmp * tmp)\n    else:\n        tmp = power2(x, int(y / 2))\n        return mod(x * mod(tmp * tmp))\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modInverse(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef Test():\n    a = [int(i) for i in input().split(' ')]\n    N = a[0]\n    K = a[1]\n    M = a[2]\n    pp = power2(N, M / 2 + 1) - power2(N - 1, M / 2 + 1)\n    qq = power2(N, M / 2 + 1)\n    if M % 2 == 0:\n        qq = (N + K) * power2(N, M / 2)\n        pp = mod((power2(N, M / 2) - power2(N - 1, M / 2)) * (N + K))\n        pp += power2(N - 1, M / 2)\n    m = modInverse(qq, 1000000007)\n    print(mod(pp * m))\nT = int(input())\nfor i in range(0, T):\n    Test()", "import math\nfor _ in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    if m % 2 != 0:\n        ra = pow(n, m // 2 + 1, 10 ** 9 + 7) - pow(n - 1, m // 2 + 1, 10 ** 9 + 7)\n        num = ra * n\n        den = n * pow(n, m // 2 + 1, 10 ** 9 + 7)\n        factor = math.gcd(num, den)\n        tmp1 = num // factor\n        tmp2 = den // factor\n        mod = 10 ** 9 + 7\n        g = math.gcd(tmp2, mod)\n        if g == 1:\n            print(tmp1 * pow(tmp2, mod - 2, mod) % mod)\n        else:\n            print(0)\n    else:\n        ra = pow(n, m // 2, 10 ** 9 + 7) - pow(n - 1, m // 2, 10 ** 9 + 7)\n        num = ra * n\n        den = n * pow(n, m // 2 + 1, 10 ** 9 + 7)\n        nul = pow(n - 1, m // 2, 10 ** 9 + 7)\n        dul = (n + k) * pow(n, m // 2, 10 ** 9 + 7)\n        den = n * pow(n, m // 2, 10 ** 9 + 7)\n        num = num * dul + nul * den\n        den = dul * den\n        factor = math.gcd(num, den)\n        tmp1 = num // factor\n        tmp2 = den // factor\n        mod = 10 ** 9 + 7\n        g = math.gcd(tmp2, mod)\n        if g == 1:\n            print(tmp1 * pow(tmp2, mod - 2, mod) % mod)\n        else:\n            print(0)", "M = 10 ** 9 + 7\nimport math\nfor _ in range(int(input())):\n    (n, k, m) = list(map(int, input().split()))\n    if m == 1:\n        print(pow(n, M - 2, M))\n    else:\n        if n > k:\n            if n % k != 0:\n                m -= 1\n                n = n % k\n                if m & 1:\n                    out = (1 - pow(n - 1, m // 2 + 1, M) * pow(pow(n, M - 2, M), m // 2 + 1, M) % M + M) % M\n                else:\n                    inv = pow(n, M - 2, M)\n                    z = pow(n - 1, m // 2, M) * pow(inv, m // 2, M) % M\n                    out = (1 - z + M + z * pow(n + k, M - 2, M) % M + M) % M\n            else:\n                n = k\n                m -= 1\n                if m & 1:\n                    inv = pow(n, M - 2, M)\n                    out = (1 - pow(n - 1, m // 2 + 1, M) * pow(inv, m // 2 + 1, M) % M + M) % M\n                else:\n                    inv = pow(n, M - 2, M)\n                    z = pow(n - 1, m // 2, M) * pow(inv, m // 2, M) % M\n                    out = (1 - z + M + z * pow(n + k, M - 2, M) % M + M) % M\n        elif m & 1:\n            inv = pow(n, M - 2, M)\n            out = (1 - pow(n - 1, m // 2 + 1, M) * pow(inv, m // 2 + 1, M) % M + M) % M\n        else:\n            inv = pow(n, M - 2, M)\n            z = pow(n - 1, m // 2, M) * pow(inv, m // 2, M) % M\n            out = (1 - z + M + z * pow(n + k, M - 2, M) % M + M) % M\n        print(out)", "def modinve(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nt = int(input())\nfor i in range(t):\n    (n, k, m) = list(map(int, input().strip().split()))\n    if m % 2 == 0:\n        p = (pow(n, m // 2, 10 ** 9 + 7) * (n + k) - pow(n - 1, m // 2, 10 ** 9 + 7) * (n + k) + pow(n - 1, m // 2, 10 ** 9 + 7)) % (10 ** 9 + 7)\n        q = pow(n, m // 2, 10 ** 9 + 7) * (n + k) % (10 ** 9 + 7)\n    else:\n        p = (pow(n, (m + 1) // 2, 10 ** 9 + 7) - pow(n - 1, (m + 1) // 2, 10 ** 9 + 7)) % (10 ** 9 + 7)\n        q = pow(n, (m + 1) // 2, 10 ** 9 + 7) % (10 ** 9 + 7)\n    op = modinve(q % (10 ** 9 + 7), 10 ** 9 + 7) * p\n    op = op % (10 ** 9 + 7)\n    print(int(op))", "tt = int(input())\nmod = 1000000007\nx = 1\nif tt <= 1000:\n    x = 0\nfor _ in range(tt):\n    if x == 1:\n        (N, k, m) = map(int, input().split(' '))\n        res = pow(N, mod - 2, mod)\n        if m % 2 == 1:\n            n = m // 2 + 1\n        else:\n            n = m // 2\n        y = pow(N, n, mod)\n        y = pow(y, mod - 2, mod)\n        s = pow(N, n, mod) - pow(N - 1, n, mod)\n        s += mod * 1000\n        s = s % mod\n        s = s * y % mod\n        if m == 2:\n            temp = (N - 1) * pow(N, mod - 2, mod) * pow(N + k, mod - 2, mod)\n            s += temp % mod\n            s = s % temp\n        elif m % 2 == 0:\n            temp = pow(N, n, mod)\n            s += pow(N - 1, n, mod) * pow(N + k, mod - 2, mod) * pow(temp, mod - 2, mod) % mod\n            s = s % mod\n        if m == 1:\n            print(res)\n        else:\n            print(s % mod)\n    else:\n        (n, k, m) = map(int, input().split(' '))\n        y = pow(n, mod - 2, mod)\n        l1 = []\n        l1.append(pow(n, mod - 2, mod))\n        i = 1\n        m = m - 1\n        while m > 0:\n            if m >= 2:\n                x = pow(n - 1, 1, mod)\n                x = x * y % mod\n                l1.append(l1[i - 1] * x % mod)\n                m = m - 2\n                i += 1\n            else:\n                x = l1[i - 1] * n\n                x *= n - 1\n                x *= pow(n, mod - 2, mod)\n                x = x % mod\n                x = x * pow(1, 1, mod) % mod\n                x *= pow(n + k, mod - 2, mod)\n                x = x % mod\n                l1.append(x)\n                i = i + 1\n                m = m - 1\n        print(sum(l1) % mod)", "import math\nte = int(input())\nfor i in range(te):\n    arr = list(map(int, input().split()))\n    N = int(arr[0])\n    K = int(arr[1])\n    M = int(arr[2])\n    pr = int(pow(10, 9) + 7)\n    if M % 2 == 1:\n        T = int((M + 1) // 2)\n        Q = int(pow(N, T, pr))\n        P = int(Q - pow(N - 1, T, pr))\n    else:\n        T = int(M // 2)\n        Q = int(pow(N, T, pr) * (N + K))\n        P = int(Q - (N + K - 1) * pow(N - 1, T, pr))\n    p = int(pr - 2)\n    print(P % pr * pow(Q, p, pr) % pr)", "def power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nMOD = 1000000007\n\ndef powerLL(x, n):\n    result = 1\n    while n:\n        if n & 1:\n            result = result * x % MOD\n        n = int(n / 2)\n        x = x * x % MOD\n    return result\n\ndef powerStrings(sa, sb):\n    a = 0\n    b = 0\n    for i in range(len(sa)):\n        a = (a * 10 + (ord(sa[i]) - ord('0'))) % MOD\n    for i in range(len(sb)):\n        b = (b * 10 + (ord(sb[i]) - ord('0'))) % (MOD - 1)\n    return powerLL(a, b)\nT = int(input())\nfor M in range(T):\n    (n, k, m) = input().split()\n    n = int(n)\n    k = int(k)\n    m = int(m)\n    n1 = str(n)\n    n2 = str(n - 1)\n    if m % 2 != 0:\n        x = (m + 1) // 2\n        x1 = str(x)\n        a = powerStrings(n1, x1)\n        b = powerStrings(n2, x1)\n        P = a - b\n        Q = a\n    else:\n        x = m // 2\n        x1 = str(x)\n        a = powerStrings(n1, x1)\n        b = powerStrings(n2, x1)\n        P = (n + k) * (a - b) + b\n        Q = a * (n + k)\n    m = 1000000007\n    mi = power(Q, m - 2, m)\n    print(P * mi % m)", "mod = 1000000007\n\ndef mcounter(M, counter):\n    if M % 2 == 0:\n        m = M // 2\n        counter = 1\n    else:\n        m = (M + 1) // 2\n    return (m, counter)\ncases = int(input())\nfor case in range(cases):\n    (N, K, M) = [int(i) for i in input().split()]\n    n = N\n    p = 0\n    q = 1\n    counter = 0\n    m = 0\n    (m, counter) = mcounter(M, counter)\n    p = (pow(N, m, mod) - pow(N - 1, m, mod)) % mod\n    q = pow(N, m, mod) % mod\n    if counter == 1:\n        n = N + K\n        p = p * n + (q - p)\n        q = n * q\n    q = pow(q, mod - 2, mod)\n    print(p % mod * (q % mod) % mod)", "mod = 1000000007\n\ndef expo(x, y, m):\n    if y == 0:\n        return 1\n    elif y == 1:\n        return x % mod\n    else:\n        p = expo(x, y // 2, m) % m\n        p = p * p % m\n        if y % 2 == 1:\n            return x * p % m\n        else:\n            return p\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef inverseMod(a, m):\n    g = gcd(a, m)\n    if g != 1:\n        return 0\n    else:\n        return expo(a, m - 2, m)\nt = int(input())\nfor i in range(t):\n    n = 0\n    k = 0\n    m = 0\n    a = 0\n    b = 0\n    c = 0\n    d = 0\n    p = 0\n    q = 0\n    (n, k, m) = list(map(int, input().split()))\n    if m & 1:\n        a = expo(n, (m + 1) // 2, mod)\n        b = expo(n - 1, (m + 1) // 2, mod)\n        p = a - b\n        q = a\n    else:\n        a = expo(n, m // 2, mod)\n        b = expo(n - 1, m // 2, mod)\n        p = (a - b) * (n + k) % mod + b\n        q = a * (n + k) % mod\n    c = inverseMod(q, mod)\n    d = p * c % mod\n    print(d)", "from math import gcd\n\ndef calc(b, po, m):\n    ans = 1\n    while po > 0:\n        if po % 2 == 1:\n            ans = ans * b % m\n        po = po // 2\n        b = b * b % m\n    return ans\n\ndef common(n, m):\n    mod = 10 ** 9 + 7\n    a = calc(n, m, mod)\n    b = calc(n - 1, m, mod)\n    inv = calc(n, mod - 2, mod)\n    inv = calc(inv, m, mod) % mod\n    ans = (a - b) * inv\n    ans %= mod\n    return ans\nt = int(input())\nfor z in range(t):\n    (n, k, m) = [int(x) for x in input().split()]\n    p = m\n    mod = 10 ** 9 + 7\n    if p % 2 == 0:\n        m = m // 2\n        num = common(n, m)\n        dum = calc(n - 1, m, mod) % mod\n        inv = calc(n, mod - 2, mod) % mod\n        p = calc(inv, m, mod) % mod\n        inv2 = calc(n + k, mod - 2, mod) % mod\n        p *= inv2\n        p %= mod\n        dum = dum * p\n        dum %= mod\n        print((num + dum) % mod)\n    else:\n        num = common(n, p // 2 + 1)\n        print(num)", "modd = 1000000007\n\ndef mox(n):\n    modd = 1000000007\n    return pow(n, modd - 2, modd)\n\ndef get(n, tries):\n    p = n - 1\n    q = n\n    k = p % modd * (mox(q) % modd) % modd\n    return pow(k, tries, modd)\nt = int(input())\nfor _ in range(t):\n    (n, k, m) = list(map(int, input().split()))\n    if m == 1:\n        print(mox(n) % modd)\n    else:\n        flag = 0\n        if m % 2 == 0:\n            flag = 1\n        tries = m // 2 + 1\n        if flag == 0:\n            ans = (1 - get(n, tries) + modd) % modd\n        else:\n            tries -= 1\n            kk = get(n, tries) % modd\n            ans = (1 - kk + modd) % modd\n            ans = (ans % modd + mox(n + k) % modd * kk) % modd\n        print(ans)", "import math\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nt = int(input())\nwhile t != 0:\n    (n, k, m) = map(int, input().split(' '))\n    mod = int(1000000007)\n    if m == 1:\n        nu = 1\n        de = n\n    elif m == 2:\n        nu = n + k + (n - 1)\n        de = n * (n + k)\n    elif m % 2 != 0:\n        x = m // 2 + 1\n        n1 = pow(n, x, mod)\n        n2 = pow(n - 1, x, mod)\n        nu = n1 - n2\n        de = n1\n    elif m % 2 == 0:\n        x = m // 2 + 1\n        n1 = pow(n - 1, x - 1, mod)\n        n2 = pow(n, x - 1, mod)\n        nu = n2 - n1\n        nu = nu % mod * ((n + k) % mod) % mod\n        nu = (nu % mod + n1 % mod) % mod\n        de = n2 % mod * ((n + k) % mod) % mod\n    gcd = math.gcd(nu, de)\n    nu = nu // gcd\n    de = de // gcd\n    ans = modinv(de, mod)\n    ans = ans % mod * (nu % mod) % mod\n    print(ans)\n    t -= 1", "from math import gcd\n\ndef modExPow(x, y):\n    bigMod = 10 ** 9 + 7\n    p = bigMod\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef modInv(a):\n    bigMod = 10 ** 9 + 7\n    m = bigMod\n    m0 = m\n    y = 0\n    x = 1\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nt = int(input())\nwhile t:\n    t -= 1\n    (n, k, m) = map(int, input().split())\n    bigMod = 10 ** 9 + 7\n    if m % 2 == 0:\n        x = int(m / 2)\n        q = modExPow(n, x)\n        y = modExPow(n - 1, x)\n        q = q % bigMod\n        q = (n + k) * q % bigMod\n        p = (q - (n + k - 1) * (y % bigMod) % bigMod) % bigMod\n        newq = modInv(q)\n        ans = p * newq % bigMod\n        print(ans)\n    else:\n        x = int(m / 2) + 1\n        q = modExPow(n, x)\n        y = modExPow(n - 1, x)\n        q = q % bigMod\n        p = (q - y % bigMod) % bigMod\n        newq = modInv(q)\n        ans = p * newq % bigMod\n        print(ans)", "t = int(input())\nwhile t > 0:\n    t = t - 1\n    s = input()\n    e = s.split(' ')\n    n = int(e[0])\n    k = int(e[1])\n    m = int(e[2])\n    j = 1000000007\n    if m % 2 == 0:\n        p1 = (n + k) % j\n        p2 = pow(n, int(m / 2), j)\n        p3 = 1 - n - k\n        p4 = pow(n - 1, int(m / 2), j)\n        p11 = p1 * p2 % j\n        p22 = p3 * p4 % j\n        p = (p11 + p22) % j\n        q = p11\n        qin = pow(q, j - 2, j) % j\n        print(p * qin % j)\n    else:\n        p1 = pow(n, int(m / 2) + 1, j)\n        p2 = pow(n - 1, int(m / 2) + 1, j)\n        p = (p1 - p2) % j\n        q = p1\n        qin = pow(q, j - 2, j) % j\n        print(p * qin % j)", "z = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (n, k, m) = map(int, input().split())\n    t = m // 2 if m / 2 - m // 2 == 0 else m // 2 + 1\n    den = pow(n, t, z)\n    x = pow(n - 1, t, z)\n    num = den - x\n    if m % 2 == 1:\n        print(pow(den, z - 2, z) * num % z)\n    else:\n        num = den * (n + k) - x * (n + k - 1)\n        den = den * (n + k)\n        print(pow(den, z - 2, z) * num % z)", "c = 10 ** 9 + 7\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\nfor _ in range(int(input())):\n    (n, k, m) = [int(k) for k in input().split()]\n    if m % 2 == 1:\n        p = (pow(n, (m + 1) // 2, c) - pow(n - 1, (m + 1) // 2, c)) % c\n        q = pow(n, (m + 1) // 2, c)\n    else:\n        p = ((n + k) % c * pow(n, m // 2, c) % c - (n + k - 1) % c * pow(n - 1, m // 2, c) % c) % c\n        q = pow(n, m // 2, c) * (n + k) % c % c\n    print(p % 1000000007 * (modInverse(q, 1000000007) % 1000000007) % 1000000007)", "import math as ma\nimport sys\nfrom sys import exit\nfrom decimal import Decimal as dec\nfrom itertools import permutations\nM = 1000000007\n\ndef li():\n    return list(map(int, input().split()))\n\ndef num():\n    return map(int, input().split())\n\ndef nu():\n    return int(input())\n\ndef find_gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\nt = nu()\nfor i in range(t):\n    (n, k, m) = num()\n    lol = m // 2\n    x = 1\n    x += lol\n    if m % 2 == 0:\n        x = (m - 1) // 2 + 1\n    P = (pow(n, x, M) - pow(n - 1, x, M) + M) % M\n    Q = pow(n, x, M)\n    G = find_gcd(P, Q)\n    P //= G\n    Q //= G\n    P = P * pow(Q, M - 2, M) % M\n    if m % 2 == 0:\n        A = pow(n - 1, x, M)\n        B = pow(n, x, M) * (n + k) % M\n        G = find_gcd(A, B)\n        A //= G\n        B //= G\n        P = (P + A * pow(B, M - 2, M) % M) % M\n    print(P)", "from fractions import Fraction\n\ndef modpow(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a, m):\n    (g, x, y) = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\nfor _ in range(int(input())):\n    (n, k, m) = [int(x) for x in input().split(' ')]\n    num = 0\n    den = 0\n    if n == 1:\n        print(1)\n    else:\n        if n > k:\n            n = n % k\n            if n == 0:\n                n = k\n            m -= 1\n        p = int(m / 2 + 1) - 1\n        den = modpow(n, p, 1000000007)\n        num = modpow(n, p, 1000000007) - modpow(n - 1, p, 1000000007)\n        den1 = modpow(n, p, 1000000007)\n        num1 = modpow(n - 1, p, 1000000007)\n        if m % 2 == 0:\n            n = n + k\n        num1 = num1 * 1\n        den1 = den1 * n\n        top = num * den1 + num1 * den\n        bot = den * den1\n        answer = top * modinv(bot, 1000000007) % 1000000007\n        print(answer)", "raw_input = input\nmod = 10 ** 9 + 7\nfor _ in range(int(raw_input())):\n    (n, k, m) = map(int, raw_input().split())\n    if m % 2 == 1:\n        a = pow(n, m // 2 + 1, mod)\n        b = pow(n - 1, m // 2 + 1, mod)\n        num = a - b\n        den = a\n        print(num % mod * (pow(den, mod - 2, mod) % mod) % mod)\n    else:\n        a = pow(n, m // 2, mod)\n        b = pow(n - 1, m // 2, mod)\n        num = (n + k) * (a - b) + b\n        den = (n + k) * a\n        print(num % mod * (pow(den, mod - 2, mod) % mod) % mod)", "import sys\n\ndef inverse(fir, nm):\n    return por(fir, nm - 2, nm)\n\ndef por(x, y, nm):\n    if y == 0:\n        return 1\n    p1 = por(x, y // 2, nm) % nm\n    p1 = p1 * p1 % nm\n    if y % 2 == 0:\n        return p1\n    else:\n        return x * p1 % nm\n\ndef gcd(fir, b):\n    if fir == 0:\n        return b\n    return gcd(b % fir, fir)\nfor _ in range(int(input())):\n    (n, k, nm) = tuple(list(map(int, input().split())))\n    if n == 1:\n        print(1)\n        continue\n    elif nm == 1:\n        p1 = 1\n        p2 = n\n        print(inverse(p2, 1000000007))\n    elif nm % 2 != 0:\n        p1 = por(n, nm // 2 + 1, 1000000007) - por(n - 1, nm // 2 + 1, 1000000007)\n        p2 = por(n, nm // 2 + 1, 1000000007)\n        g = gcd(p1, p2)\n        if g == 1:\n            print(p1 % 1000000007 * (inverse(p2, 1000000007) % 1000000007) % 1000000007)\n        else:\n            print(p1 // g % 1000000007 * (inverse(p2 // g, 1000000007) % 1000000007) % 1000000007)\n    else:\n        nm -= 1\n        pp = por(n, nm // 2 + 1, 1000000007) - por(n - 1, nm // 2 + 1, 1000000007)\n        qq = por(n, nm // 2 + 1, 1000000007)\n        nm += 1\n        ppp = por(n - 1, nm // 2, 1000000007)\n        qqq = por(n, nm // 2, 1000000007) * (n + k) % 1000000007\n        p1 = (pp * qqq % 1000000007 + ppp * qq % 1000000007) % 1000000007\n        p2 = qqq * qq % 1000000007\n        g = gcd(p1, p2)\n        if g == 1:\n            print(p1 % 1000000007 * (inverse(p2, 1000000007) % 1000000007) % 1000000007)\n        else:\n            print(p1 // g % 1000000007 * (inverse(p2 // g, 1000000007) % 1000000007) % 1000000007)", "import math\nmod = 1000000007\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef modInverse(a, m):\n    return power(a, m - 2, m)\n\ndef gcd(a, b):\n    return math.gcd(a, b)\n\ndef power1(x, y):\n    if y == 0:\n        return 1\n    temp = power1(x, int(y / 2))\n    if y % 2 == 0:\n        return temp * temp\n    elif y > 0:\n        return x * temp * temp\n    else:\n        return temp * temp / x\nT = int(input())\nwhile T:\n    a = [int(j) for j in input().split()]\n    N = a[0]\n    K = a[1]\n    M = a[2]\n    if N == 1:\n        result = 1\n    else:\n        if M % 2:\n            nu = power(N, int((M + 1) / 2), mod) - power(N - 1, int((M + 1) / 2), mod)\n            deno = power(N, int((M + 1) / 2), mod)\n        else:\n            nu = power(N, int(M / 2), mod) * (N + K) - power(N - 1, int(M / 2), mod) * (N + K - 1)\n            deno = power(N, int(M / 2), mod) * (N + K)\n        gcd = math.gcd(nu, deno)\n        nu = nu // gcd\n        deno = deno // gcd\n        deno = modInverse(deno, mod)\n        result = nu % mod * (deno % mod) % mod\n    print(result)\n    T -= 1", "from fractions import Fraction\n\ndef ext_gcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    (d, x1, y1) = ext_gcd(b % a, a)\n    x = y1 - b // a * x1\n    y = x1\n    return (d, x, y)\n\ndef inverse(a, m):\n    (g, x, _) = ext_gcd(a, m)\n    if g != 1:\n        return\n    return (x % m + m) % m\nMOD = 10 ** 9 + 7\n\ndef pow(a, b, mod):\n    res = 1\n    x = a\n    while b > 0:\n        if b % 2 == 0:\n            x = x * x % mod\n            b //= 2\n        else:\n            res = res * x % mod\n            b -= 1\n    return res\n\ndef calc_fraction(a, b):\n    p = a\n    q = inverse(b, MOD)\n    return p * q % MOD\n\ndef solve(n, k, m):\n    n_mod = n % k\n    p = [[0] * 4 for _ in range(3)]\n    for i in range(1, 3):\n        for j in range(2 if i > 1 else 3):\n            nj = n_mod + j * k\n            res = Fraction(1, nj) + Fraction(nj - 1, nj) * p[i - 1][j + 1]\n            if nj > k:\n                res = max(res, p[i - 1][0])\n            p[i][j] = res\n    t = (m + 1) // 2 - 1\n    f = [p[2][0], p[1][0]][m % 2]\n    (a, b) = (f.numerator, f.denominator)\n    x = pow(n_mod - 1, t, MOD)\n    y = pow(n_mod, t, MOD)\n    numerator = (x * (a - b) % MOD + y * b % MOD) % MOD\n    denominator = y * b % MOD\n    return calc_fraction(numerator, denominator)\ntry:\n    t = int(input())\nexcept:\n    pass\nelse:\n    for _ in range(t):\n        (n, k, m) = map(int, input().split())\n        print(solve(n, k, m))"]