["def bpm(u, match, seen, n, graph):\n    for j in range(n):\n        if graph[u][j] == 1 and seen[j] == False:\n            seen[j] = True\n            if match[j] == -1 or bpm(match[j], match, seen, n, graph):\n                match[j] = u\n                return True\n    return False\n\ndef solve():\n    (n, k) = [int(i) for i in input().split()]\n    valid_points = [[1 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        valid_points[i][i] = 0\n    for i in range(k):\n        perm = [int(d) - 1 for d in input().split()]\n        for j in range(1, n):\n            for r in range(j - 1, -1, -1):\n                valid_points[perm[j]][perm[r]] = 0\n    result = 0\n    match = [-1] * n\n    for i in range(n):\n        seen = [False] * n\n        if bpm(i, match, seen, n, valid_points):\n            result += 1\n    print(n - result)\n    final_ans = [0] * n\n    for i in range(n):\n        if match[i] != -1:\n            final_ans[match[i]] = i + 1\n    for i in final_ans:\n        print(i, end=' ')\n    print()\nt = int(input())\nwhile t > 0:\n    solve()\n    t -= 1", "def bpm(u, match, seen, n, graph):\n    for j in range(n):\n        if graph[u][j] == 1 and seen[j] == False:\n            seen[j] = True\n            if match[j] == -1 or bpm(match[j], match, seen, n, graph):\n                match[j] = u\n                return True\n    return False\n\ndef solve():\n    (n, k) = [int(i) for i in input().split()]\n    valid_points = [[1 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        valid_points[i][i] = 0\n    for i in range(k):\n        perm = [int(d) - 1 for d in input().split()]\n        for j in range(1, n):\n            for r in range(j - 1, -1, -1):\n                valid_points[perm[j]][perm[r]] = 0\n    result = 0\n    match = [-1] * n\n    for i in range(n):\n        seen = [False] * n\n        if bpm(i, match, seen, n, valid_points):\n            result += 1\n    print(n - result)\n    final_ans = [0] * n\n    for i in range(n):\n        if match[i] != -1:\n            final_ans[match[i]] = i + 1\n    for i in final_ans:\n        print(i, end=' ')\n    print()\nt = int(input())\nwhile t > 0:\n    solve()\n    t -= 1", "def bpm(u, match, seen, n, graph):\n    for j in range(n):\n        if graph[u][j] == 1 and seen[j] == False:\n            seen[j] = True\n            if match[j] == -1 or bpm(match[j], match, seen, n, graph):\n                match[j] = u\n                return True\n    return False\n\ndef solve():\n    (n, k) = [int(i) for i in input().split()]\n    valid_points = [[1 for i in range(n)] for j in range(n)]\n    for i in range(n):\n        valid_points[i][i] = 0\n    for i in range(k):\n        perm = [int(d) - 1 for d in input().split()]\n        for j in range(1, n):\n            for r in range(j - 1, -1, -1):\n                valid_points[perm[j]][perm[r]] = 0\n    result = 0\n    match = [-1] * n\n    for i in range(n):\n        seen = [False] * n\n        if bpm(i, match, seen, n, valid_points):\n            result += 1\n    print(n - result)\n    final_ans = [0] * n\n    for i in range(n):\n        if match[i] != -1:\n            final_ans[match[i]] = i + 1\n    for i in final_ans:\n        print(i, end=' ')\n    print()\nt = int(input())\nwhile t > 0:\n    solve()\n    t -= 1", "def hopcroft_karp(U, adj):\n    upair = {}\n    vpair = {}\n    inf = float('inf')\n    dist = {}\n\n    def bfs() -> bool:\n        q = []\n        for u in U:\n            if upair.get(u) is not None:\n                dist[u] = inf\n            else:\n                dist[u] = 0\n                q.append(u)\n        dist[None] = inf\n        while q:\n            q2 = []\n            for u in q:\n                if dist[u] < dist[None]:\n                    for v in adj[u]:\n                        if dist.get(vpair.get(v), inf) == inf:\n                            dist[vpair.get(v)] = dist[u] + 1\n                            q2.append(vpair.get(v))\n            q = q2\n        return dist[None] != inf\n\n    def dfs(u):\n        if u is not None:\n            for v in adj[u]:\n                if dist.get(vpair.get(v), inf) == dist.get(u, inf) + 1:\n                    if dfs(vpair.get(v)):\n                        vpair[v] = u\n                        upair[u] = v\n                        return True\n            dist[u] = inf\n            return False\n        return True\n    while bfs():\n        for u in U:\n            if upair.get(u) is None:\n                dfs(u)\n    return upair\n\ndef sol(n, k, ps):\n    ps = list(set(ps))\n    k = len(ps)\n    adj = {u: set(ps[0][i + 1:]) for (i, u) in enumerate(ps[0])}\n    seens = {j: set() for j in range(1, k)}\n    for i in range(n - 1, -1, -1):\n        for j in range(1, k):\n            u = ps[j][i]\n            adj[u] = set((v for v in adj[u] if v in seens[j]))\n            seens[j].add(u)\n    us = hopcroft_karp(range(1, n + 1), adj)\n    res = [0] * n\n    for (u, v) in us.items():\n        res[u - 1] = v\n    return (sum((1 for x in res if x == 0)), res)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        (n, k) = map(int, input().split())\n        ps = []\n        for i in range(k):\n            ps.append(tuple((int(x) for x in input().split())))\n        (z, res) = sol(n, k, ps)\n        print(z)\n        print(' '.join((str(x) for x in res)))\nmain()", "import sys\ninput = sys.stdin.readline\n\ndef FindMinimum(Ans):\n    Minimum = float('inf')\n    key = -1\n    for (i, j) in Ans.items():\n        if len(j) < Minimum:\n            key = i\n            Minimum = len(j)\n    return key\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    count = 0\n    Ans = {}\n    for i in range(N):\n        x = list((x for x in range(1, N + 1)))\n        Ans[i + 1] = x\n    for i in range(K):\n        X = list(map(int, input().split()))\n        for i in range(N):\n            Ans[X[i]] = set(Ans[X[i]]) & set(X[i + 1:])\n    Counter = defaultdict(lambda : 0)\n    for i in Ans.values():\n        for j in i:\n            Counter[j] += 1\n    OutDegree = defaultdict(lambda : 0)\n    InDegree = defaultdict(lambda : 0)\n    while len(Ans.keys()) > 0:\n        T = FindMinimum(Ans)\n        for (i, j) in Ans.items():\n            if len(j) == len(Ans[T]) and i != j:\n                Min1 = float('inf')\n                for k in j:\n                    if Counter[k] < Min1:\n                        Min1 = Counter[k]\n                Min2 = float('inf')\n                for z in Ans[T]:\n                    if Counter[z] < Min2:\n                        Min2 = Counter[z]\n                if Min1 >= Min2:\n                    T = i\n        FLAG = 0\n        Min = float('inf')\n        index = -1\n        for i in Ans[T]:\n            if Counter[i] < Min:\n                Min = Counter[i]\n                index = i\n        if index != -1:\n            OutDegree[T] = index\n            InDegree[index] = 1\n            val = index\n            FLAG = 1\n            for i in Ans[T]:\n                Counter[i] -= 1\n            del Ans[T]\n        if FLAG == 0:\n            OutDegree[T] = 0\n            for i in Ans[T]:\n                Counter[i] -= 1\n            del Ans[T]\n        else:\n            for (i, j) in Ans.items():\n                if val in j:\n                    Counter[val] = -1\n                    j.remove(val)\n    count = 0\n    for i in range(1, N + 1):\n        if OutDegree[i] == 0:\n            count += 1\n    print(count)\n    for i in range(1, N + 1):\n        print(OutDegree[i], end=' ')\n    print()", "def main():\n    for _ in range(int(input())):\n        (n, k) = list(map(int, input().split()))\n        p = [list(map(int, input().split())) for i in range(k)]\n        ans = [-1] * n\n        as1 = [0] * n\n        visited = [False] * n\n        freqin = [0] * n\n        for i in p:\n            for j in range(n):\n                if ans[i[j] - 1] == -1:\n                    ans[i[j] - 1] = [i[j] - 1, set(i[j + 1:])]\n                else:\n                    ans[i[j] - 1][1] = ans[i[j] - 1][1].intersection(i[j + 1:])\n        for i in range(n):\n            ans[i][1] = list(ans[i][1])\n        for i in ans:\n            for j in i[1]:\n                freqin[j - 1] += 1\n        ans.sort(key=lambda a: len(a[1]))\n        maxi = max(freqin)\n        visited = [False] * n\n        i1 = -1\n        for i in range(len(ans)):\n            mini = maxi + 1\n            ans1 = -1\n            sans1 = -1\n            k1 = 0\n            m = min(ans, key=lambda a: ([visited[j - 1] for j in a[1]].count(False), -len(a[1])))\n            for j in range(len(m[1])):\n                if not visited[m[1][j] - 1] and mini >= freqin[m[1][j] - 1]:\n                    mini = freqin[m[1][j] - 1]\n                    ans1 = m[1][j]\n                    k1 = 1\n            if k1 == 1:\n                as1[m[0]] = ans1\n                visited[ans1 - 1] = True\n            ans.remove(m)\n        print(visited.count(False))\n        print(' '.join(list(map(str, as1))))\nmain()", "import time\nfrom copy import deepcopy\n\nclass HopcroftKarp(object):\n\n    def __init__(self, graph):\n        self._matching = {}\n        self._dfs_paths = []\n        self._dfs_parent = {}\n        self._graph = deepcopy(graph)\n        self._left = set(self._graph.keys())\n        self._right = set()\n        for value in self._graph.values():\n            self._right.update(value)\n        for vertex in self._left:\n            for neighbour in self._graph[vertex]:\n                if neighbour not in self._graph:\n                    self._graph[neighbour] = set()\n                    self._graph[neighbour].add(vertex)\n                else:\n                    self._graph[neighbour].add(vertex)\n\n    def __bfs(self):\n        layers = []\n        layer = set()\n        for vertex in self._left:\n            if vertex not in self._matching:\n                layer.add(vertex)\n        layers.append(layer)\n        visited = set()\n        while True:\n            layer = layers[-1]\n            new_layer = set()\n            for vertex in layer:\n                if vertex in self._left:\n                    visited.add(vertex)\n                    for neighbour in self._graph[vertex]:\n                        if neighbour not in visited and (vertex not in self._matching or neighbour != self._matching[vertex]):\n                            new_layer.add(neighbour)\n                else:\n                    visited.add(vertex)\n                    for neighbour in self._graph[vertex]:\n                        if neighbour not in visited and (vertex in self._matching and neighbour == self._matching[vertex]):\n                            new_layer.add(neighbour)\n            layers.append(new_layer)\n            if len(new_layer) == 0:\n                return layers\n            if any((vertex in self._right and vertex not in self._matching for vertex in new_layer)):\n                return layers\n\n    def __dfs(self, v, index, layers):\n        if index == 0:\n            path = [v]\n            while self._dfs_parent[v] != v:\n                path.append(self._dfs_parent[v])\n                v = self._dfs_parent[v]\n            self._dfs_paths.append(path)\n            return True\n        for neighbour in self._graph[v]:\n            if neighbour in layers[index - 1]:\n                if neighbour in self._dfs_parent:\n                    continue\n                if neighbour in self._left and (v not in self._matching or neighbour != self._matching[v]) or (neighbour in self._right and (v in self._matching and neighbour == self._matching[v])):\n                    self._dfs_parent[neighbour] = v\n                    if self.__dfs(neighbour, index - 1, layers):\n                        return True\n        return False\n\n    def maximum_matching(self, keys_only=False):\n        while True:\n            layers = self.__bfs()\n            if len(layers[-1]) == 0:\n                break\n            free_vertex = set([vertex for vertex in layers[-1] if vertex not in self._matching])\n            del self._dfs_paths[:]\n            self._dfs_parent.clear()\n            for vertex in free_vertex:\n                self._dfs_parent[vertex] = vertex\n                self.__dfs(vertex, len(layers) - 1, layers)\n            if len(self._dfs_paths) == 0:\n                break\n            for path in self._dfs_paths:\n                for i in range(len(path)):\n                    if i % 2 == 0:\n                        self._matching[path[i]] = path[i + 1]\n                        self._matching[path[i + 1]] = path[i]\n        if keys_only:\n            self._matching = {k: v for (k, v) in self._matching.items() if k in self._left}\n        return self._matching\ntests = int(input())\nwhile tests:\n    tests -= 1\n    (n, K) = map(int, input().split())\n    Yes = {}\n    No = {}\n    d = {}\n    l = []\n    graph = {}\n    for i in range(1, n + 1):\n        d[i] = 0\n        Yes[i] = []\n        No[i] = []\n    for _ in range(K):\n        l.append(list(map(int, input().split())))\n    for i in range(K):\n        for j in range(n):\n            Yes[l[i][j]] += l[i][j + 1:]\n            No[l[i][j]] += l[i][:j]\n    for i in Yes:\n        Yes[i] = set(Yes[i]) - set(No[i])\n        if len(Yes[i]) != 0:\n            graph[i + 10 ** 9] = Yes[i]\n    g = HopcroftKarp(graph).maximum_matching(keys_only=True)\n    for i in g:\n        d[i - 10 ** 9] = g[i]\n    d = dict(sorted(d.items()))\n    print(list(d.values()).count(0))\n    print(*d.values())", "import time\nfrom copy import deepcopy\n\nclass HopcroftKarp(object):\n\n    def __init__(self, graph):\n        self._matching = {}\n        self._dfs_paths = []\n        self._dfs_parent = {}\n        self._graph = deepcopy(graph)\n        self._left = set(self._graph.keys())\n        self._right = set()\n        for value in self._graph.values():\n            self._right.update(value)\n        for vertex in self._left:\n            for neighbour in self._graph[vertex]:\n                if neighbour not in self._graph:\n                    self._graph[neighbour] = set()\n                    self._graph[neighbour].add(vertex)\n                else:\n                    self._graph[neighbour].add(vertex)\n\n    def __bfs(self):\n        layers = []\n        layer = set()\n        for vertex in self._left:\n            if vertex not in self._matching:\n                layer.add(vertex)\n        layers.append(layer)\n        visited = set()\n        while True:\n            layer = layers[-1]\n            new_layer = set()\n            for vertex in layer:\n                if vertex in self._left:\n                    visited.add(vertex)\n                    for neighbour in self._graph[vertex]:\n                        if neighbour not in visited and (vertex not in self._matching or neighbour != self._matching[vertex]):\n                            new_layer.add(neighbour)\n                else:\n                    visited.add(vertex)\n                    for neighbour in self._graph[vertex]:\n                        if neighbour not in visited and (vertex in self._matching and neighbour == self._matching[vertex]):\n                            new_layer.add(neighbour)\n            layers.append(new_layer)\n            if len(new_layer) == 0:\n                return layers\n            if any((vertex in self._right and vertex not in self._matching for vertex in new_layer)):\n                return layers\n\n    def __dfs(self, v, index, layers):\n        if index == 0:\n            path = [v]\n            while self._dfs_parent[v] != v:\n                path.append(self._dfs_parent[v])\n                v = self._dfs_parent[v]\n            self._dfs_paths.append(path)\n            return True\n        for neighbour in self._graph[v]:\n            if neighbour in layers[index - 1]:\n                if neighbour in self._dfs_parent:\n                    continue\n                if neighbour in self._left and (v not in self._matching or neighbour != self._matching[v]) or (neighbour in self._right and (v in self._matching and neighbour == self._matching[v])):\n                    self._dfs_parent[neighbour] = v\n                    if self.__dfs(neighbour, index - 1, layers):\n                        return True\n        return False\n\n    def maximum_matching(self, keys_only=False):\n        while True:\n            layers = self.__bfs()\n            if len(layers[-1]) == 0:\n                break\n            free_vertex = set([vertex for vertex in layers[-1] if vertex not in self._matching])\n            del self._dfs_paths[:]\n            self._dfs_parent.clear()\n            for vertex in free_vertex:\n                self._dfs_parent[vertex] = vertex\n                self.__dfs(vertex, len(layers) - 1, layers)\n            if len(self._dfs_paths) == 0:\n                break\n            for path in self._dfs_paths:\n                for i in range(len(path)):\n                    if i % 2 == 0:\n                        self._matching[path[i]] = path[i + 1]\n                        self._matching[path[i + 1]] = path[i]\n        if keys_only:\n            self._matching = {k: v for (k, v) in self._matching.items() if k in self._left}\n        return self._matching\ntests = int(input())\nwhile tests:\n    tests -= 1\n    start = time.time()\n    (n, K) = map(int, input().split())\n    Yes = {}\n    No = {}\n    d = {}\n    l = []\n    graph = {}\n    for i in range(1, n + 1):\n        d[i] = 0\n        Yes[i] = []\n        No[i] = []\n    for _ in range(K):\n        l.append(list(map(int, input().split())))\n    count = 0\n    for i in range(K):\n        for j in range(n):\n            Yes[l[i][j]] += l[i][j + 1:]\n            No[l[i][j]] += l[i][:j]\n    inter1 = time.time()\n    for i in Yes:\n        Yes[i] = set(Yes[i]) - set(No[i])\n        if len(Yes[i]) != 0:\n            graph[i + 10 ** 9] = Yes[i]\n    inter = time.time()\n    g = HopcroftKarp(graph).maximum_matching(keys_only=True)\n    for i in g:\n        d[i - 10 ** 9] = g[i]\n    d = dict(sorted(d.items()))\n    print(list(d.values()).count(0))\n    print(*d.values())"]