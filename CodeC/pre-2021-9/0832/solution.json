["def chefora(c):\n    a = list(str(c))\n    a = a + a[-2::-1]\n    b = int(''.join(a))\n    return b\nl1 = [0]\nfor i in range(1, 100001):\n    l1.append(chefora(i))\n    l1[i] += l1[i - 1]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    ans = 0\n    t = chefora(l)\n    ans = l1[r] - l1[l]\n    print(pow(t, ans, 1000000007))", "def chefora(c):\n    a = list(str(c))\n    a = a + a[-2::-1]\n    b = int(''.join(a))\n    return b\nl1 = [0]\nfor i in range(1, 100001):\n    l1.append(chefora(i))\n    l1[i] += l1[i - 1]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    ans = 0\n    t = chefora(l)\n    ans = l1[r] - l1[l]\n    print(pow(t, ans, 1000000007))", "def chefora(c):\n    a = list(str(c))\n    a = a + a[-2::-1]\n    b = int(''.join(a))\n    return b\nl1 = [0]\nfor i in range(1, 100001):\n    l1.append(chefora(i))\n    l1[i] += l1[i - 1]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    ans = 0\n    t = chefora(l)\n    ans = l1[r] - l1[l]\n    print(pow(t, ans, 1000000007))", "try:\n\n    class xyz:\n\n        def __init__(self, n):\n            self.n = n\n            self.i = 0\n            self.palin = [0] * n\n            self.prefix = [0] * n\n\n        def add(self, v):\n            self.palin[self.i] = v\n            self.prefix[self.i] = v\n            if self.i != 0:\n                self.prefix[self.i] += self.prefix[self.i - 1]\n            self.i = self.i + 1\n\n        def fill(self):\n            return self.i == self.n\n\n        def rangedprefix(self, l, r):\n            return self.prefix[r] - self.prefix[l]\n\n        def basepalindrome(self, l):\n            return self.palin[l]\n\n    def addpalindrome(a):\n        n = a\n        pal = a\n        n = n // 10\n        while n > 0:\n            pal = pal * 10 + n % 10\n            n = n // 10\n        return pal\n\n    def makepalin(palin):\n        i = 1\n        while not palin.fill():\n            palin.add(addpalindrome(i))\n            i += 1\n\n    def calculate(l, r, palin):\n        power = palin.rangedprefix(l - 1, r - 1)\n        base = palin.basepalindrome(l - 1)\n        return pow(base, power, 1000000007)\n    palin = xyz(100001)\n    makepalin(palin)\n    r = int(input())\n    while r > 0:\n        (l, r) = map(int, input().split())\n        print(calculate(l, r, palin))\n        r -= 1\nexcept:\n    pass", "def chefora(c):\n    a = list(str(c))\n    a = a + a[-2::-1]\n    b = int(''.join(a))\n    return b\nl1 = [0]\nfor i in range(1, 100001):\n    l1.append(chefora(i))\n    l1[i] += l1[i - 1]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    ans = 0\n    t = chefora(l)\n    ans = l1[r] - l1[l]\n    print(pow(t, ans, 1000000007))", "def chefora(c):\n    a = list(str(c))\n    a = a + a[-2::-1]\n    b = int(''.join(a))\n    return b\nl1 = [0]\nfor i in range(1, 100001):\n    l1.append(chefora(i))\n    l1[i] += l1[i - 1]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    ans = 0\n    t = chefora(l)\n    ans = l1[r] - l1[l]\n    print(pow(t, ans, 1000000007))", "try:\n\n    def findpower(base, power):\n        mod = 10 ** 9 + 7\n        res = 1\n        while power != 0:\n            if power % 2 == 0:\n                base = base % mod * (base % mod) % mod\n                power = power // 2\n            else:\n                res = res % mod * (base % mod) % mod\n                power = power - 1\n        return res\n\n    def findchefora(num):\n        palin = num\n        num = num // 10\n        while num > 0:\n            palin = palin * 10 + num % 10\n            num = num // 10\n        return palin\n    arr = [0] * (10 ** 5 + 1)\n    arrsm = [0] * (10 ** 5 + 1)\n    for i in range(1, 10 ** 5 + 1):\n        arr[i] = findchefora(i)\n        arrsm[i] = arrsm[i - 1] + arr[i]\n    for _ in range(int(input())):\n        (l, r) = map(int, input().split())\n        power = arrsm[r] - arrsm[l]\n        print(findpower(arr[l], power))\nexcept:\n    pass", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef find(num):\n    palin = num\n    num = num // 10\n    while num > 0:\n        palin = palin * 10 + num % 10\n        num = num // 10\n    return palin\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = find(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "def binpov(a, b, m):\n    a %= m\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res\nchefora = []\nchefora.append(0)\nfor i in range(1, 100001):\n    res = i\n    num = i // 10\n    while num != 0:\n        res = res * 10 + num % 10\n        num = num // 10\n    chefora.append(res)\nsub_sum = []\nsum1 = 0\nsub_sum.append(0)\nlength = len(chefora)\nfor i in range(1, length):\n    sum1 += chefora[i]\n    sub_sum.append(sum1)\nt = int(input())\nfor z in range(t):\n    (l, r) = map(int, input().split())\n    A = chefora[l]\n    print(binpov(A, sub_sum[r] - sub_sum[l], 1000000007))", "try:\n\n    class Palin:\n\n        def __init__(self, n):\n            self.n = n\n            self.i = 0\n            self.palin = [0] * n\n            self.prefix = [0] * n\n\n        def add(self, v):\n            self.palin[self.i] = v\n            self.prefix[self.i] = v\n            if self.i != 0:\n                self.prefix[self.i] += self.prefix[self.i - 1]\n            self.i = self.i + 1\n\n        def fill(self):\n            return self.i == self.n\n\n        def rangedPrefix(self, l, r):\n            return self.prefix[r] - self.prefix[l]\n\n        def basePalindrome(self, l):\n            return self.palin[l]\n\n    def oddPalindrome(a):\n        n = a\n        pal = a\n        n = n // 10\n        while n > 0:\n            pal = pal * 10 + n % 10\n            n = n // 10\n        return pal\n\n    def makePalin(palin):\n        i = 1\n        while not palin.fill():\n            palin.add(oddPalindrome(i))\n            i += 1\n\n    def calculate(l, r, palin):\n        power = palin.rangedPrefix(l - 1, r - 1)\n        base = palin.basePalindrome(l - 1)\n        return pow(base, power, 1000000007)\n    palin = Palin(100001)\n    makePalin(palin)\n    t = int(input())\n    while t > 0:\n        (l, r) = map(int, input().split())\n        print(calculate(l, r, palin))\n        t -= 1\nexcept:\n    pass", "mod = 10 ** 9 + 7\nans = [a for a in range(1, 10)]\nfor x in range(1, 10001):\n    s = str(x)\n    for y in range(10):\n        ans.append(int(s + str(y) + s[::-1]))\npre = [0] * len(ans)\npre[0] = 0\nfor i in range(1, len(ans)):\n    pre[i] = pre[i - 1] + ans[i - 1]\n\ndef power(a, b):\n    res = 1\n    a = a % mod\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % mod\n        b = b // 2\n        a = a * a % mod\n    return res\nfor testcase in range(int(input())):\n    (l, r) = map(int, input().split())\n    print(power(ans[l - 1], pre[r] - pre[l]))", "mod = 10 ** 9 + 7\nans = [a for a in range(1, 10)]\nfor x in range(1, 10001):\n    s = str(x)\n    for y in range(10):\n        ans.append(int(s + str(y) + s[::-1]))\npre = [0] * len(ans)\npre[0] = 0\nfor i in range(1, len(ans)):\n    pre[i] = pre[i - 1] + ans[i - 1]\n\ndef power(a, b):\n    res = 1\n    a = a % mod\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % mod\n        b = b // 2\n        a = a * a % mod\n    return res\nfor testcase in range(int(input())):\n    (l, r) = map(int, input().split())\n    print(power(ans[l - 1], pre[r] - pre[l]))", "mod = 10 ** 9 + 7\nans = [a for a in range(1, 10)]\nfor x in range(1, 10001):\n    s = str(x)\n    for y in range(10):\n        ans.append(int(s + str(y) + s[::-1]))\npre = [0] * len(ans)\npre[0] = 0\nfor i in range(1, len(ans)):\n    pre[i] = pre[i - 1] + ans[i - 1]\n\ndef power(a, b):\n    res = 1\n    a = a % mod\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % mod\n        b = b // 2\n        a = a * a % mod\n    return res\nfor testcase in range(int(input())):\n    (l, r) = map(int, input().split())\n    print(power(ans[l - 1], pre[r] - pre[l]))", "def getpow(a, b):\n    res = 1\n    m = 10 ** 9 + 7\n    while b >= 1:\n        if b % 2:\n            res = res % m * (a % m) % m\n            b -= 1\n        a = a % m * (a % m) % m\n        b = b // 2\n    return res\n\ndef getchf(n):\n    st = str(n)\n    st1 = st[-2::-1]\n    st = st + st1\n    return int(st)\nchfarr = [0]\nprfsum = [0]\nfor i in range(1, 100001):\n    chfarr.append(getchf(i))\n    prfsum.append(prfsum[i - 1] + chfarr[i])\nq = int(input())\nfor i in range(0, q):\n    (l, r) = map(int, input().split())\n    res = 1\n    res = getpow(chfarr[l], prfsum[r] - prfsum[l])\n    print(res)", "chefora = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nm = 10 ** 9 + 7\n\ndef rev(N):\n    rm = str(N)[::-1]\n    return rm\nfor i in range(1, 10 ** 4 + 1):\n    for j in range(10):\n        chefora.append(int(str(i) + str(j) + str(rev(i))))\npresum = [0 for i in range(len(chefora))]\npresum[0] = chefora[0]\nfor i in range(1, len(chefora)):\n    presum[i] = presum[i - 1] + chefora[i]\n\ndef exp(a, b):\n    rem = 1\n    while b > 0:\n        if b % 2 == 1:\n            rem = rem * a % m\n        a = a * a % m\n        b = b // 2\n    return rem % m\nfor _ in range(int(input())):\n    (L, R) = map(int, input().split())\n    ans = exp(chefora[L - 1], presum[R - 1] - presum[L - 1])\n    print(ans)", "chefora = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nm = 10 ** 9 + 7\n\ndef rev(N):\n    rm = str(N)[::-1]\n    return rm\nfor i in range(1, 10 ** 4 + 1):\n    for j in range(10):\n        chefora.append(int(str(i) + str(j) + str(rev(i))))\npresum = [0 for i in range(len(chefora))]\npresum[0] = chefora[0]\nfor i in range(1, len(chefora)):\n    presum[i] = presum[i - 1] + chefora[i]\n\ndef exp(a, b):\n    rem = 1\n    while b > 0:\n        if b % 2 == 1:\n            rem = rem * a % m\n        a = a * a % m\n        b = b // 2\n    return rem % m\nfor _ in range(int(input())):\n    (L, R) = map(int, input().split())\n    ans = exp(chefora[L - 1], presum[R - 1] - presum[L - 1])\n    print(ans)", "Q = int(input())\narr = []\narr.append(0)\nfor i in range(1, 10 ** 5 + 1):\n    temp = i\n    num = i // 10\n    while num > 0:\n        rem = num % 10\n        temp = temp * 10 + rem\n        num = num // 10\n    arr.append(temp)\nsm = []\nsm.append(0)\nfor i in range(1, 10 ** 5 + 1):\n    sm.append(sm[i - 1] + arr[i])\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nmod = 1000000007\nwhile Q != 0:\n    (l, r) = map(int, input().split())\n    res = 1\n    prefix = sm[r] - sm[l]\n    base = arr[l]\n    print(power(base, prefix, mod))\n    Q -= 1", "from math import ceil, gcd\nMOD = 10 ** 9 + 7\ninp = lambda x: map(int, x.split())\n\ndef find_oddn(l):\n    (s, s1) = (str(l), list(str(l))[:-1])\n    s1.reverse()\n    s1 = ''.join(s1)\n    s += s1\n    return int(s)\narr = [0] * (10 ** 5 + 1)\n(lr, l1, r1) = ([], 10 ** 5, 0)\nt = int(input())\nfor _ in range(t):\n    (l, r) = inp(input())\n    lr.append([l, r])\n    (l1, r1) = (min(l1, l), max(r1, r))\ns = 0\nfor i in range(l1, r1 + 1):\n    s += find_oddn(i)\n    arr[i] = s\nfor _ in range(t):\n    (l, r) = lr[_]\n    a_l = arr[l] - arr[l - 1]\n    v = a_l\n    l_exp = [v]\n    for i in range(50):\n        v = v * v % MOD\n        l_exp.append(v)\n    s = arr[r] - arr[l]\n    b = list(bin(s))[2:]\n    b.reverse()\n    (ans, l) = (1, len(b))\n    for i in range(l):\n        if b[i] == '1':\n            ans *= l_exp[i]\n    print(ans % MOD)", "chf = []\nfor i in range(100001):\n    if i >= 10:\n        a = str(i)\n        chf.append(int(str(i) + a[-2::-1]))\n    else:\n        chf.append(i)\nprs = []\nsm = 0\nfor x in chf:\n    sm += x\n    prs.append(sm)\nq = int(input())\nfor i in range(q):\n    (l, r) = map(int, input().split())\n    print(pow(chf[l], prs[r] - prs[l], 10 ** 9 + 7))", "def power(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef rev(a):\n    b = a\n    b = b // 10\n    while b > 0:\n        a = a * 10 + b % 10\n        b = b // 10\n    return a\nt = int(input())\nmod = 1000000007\nc = [0] * (10 ** 5 + 1)\nfor i in range(1, 100001):\n    c[i] = rev(i)\n    c[i] = c[i] + c[i - 1]\nwhile t > 0:\n    (l, r) = map(int, input().split())\n    s = c[r] - c[l]\n    a = c[l] - c[l - 1]\n    pro = power(a, s)\n    pro = pro % mod\n    print(pro)\n    t = t - 1", "def power(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef rev(a):\n    b = a\n    b = b // 10\n    while b > 0:\n        a = a * 10 + b % 10\n        b = b // 10\n    return a\nt = int(input())\nmod = 1000000007\nc = [0] * (10 ** 5 + 1)\nfor i in range(1, 100001):\n    c[i] = rev(i)\n    c[i] = c[i] + c[i - 1]\nwhile t > 0:\n    (l, r) = map(int, input().split())\n    s = c[r] - c[l]\n    a = c[l] - c[l - 1]\n    pro = power(a, s)\n    pro = pro % mod\n    print(pro)\n    t = t - 1", "j = [i for i in range(1, 10 ** 5 + 1)]\ny = []\nfor i in j:\n    r = i // 10\n    if r == 0:\n        y.append(i)\n    else:\n        u = str(i)\n        h = str(r)\n        y.append(int(u + h[::-1]))\nz = y.copy()\nfor i in range(1, len(y)):\n    y[i] += y[i - 1]\nt = int(input())\nwhile t > 0:\n    (l, r) = map(int, input().split())\n    ans = pow(z[l - 1], y[r - 1] - y[l - 1], 10 ** 9 + 7)\n    print(ans)\n    t -= 1", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palindrome = num\n    num = num // 10\n    while num > 0:\n        palindrome = palindrome * 10 + num % 10\n        num = num // 10\n    return palindrome\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "class main:\n\n    def __init__(self):\n        self.mod = 1000000007\n\n    def power(self, base, pow):\n        pow = int(pow)\n        res = 1\n        while not pow == 0:\n            if pow % 2 == 0:\n                pow = int(pow / 2)\n                base = int(base % self.mod * (base % self.mod) % self.mod)\n            else:\n                pow = pow - 1\n                res = int(res % self.mod * (base % self.mod) % self.mod)\n        return int(res)\n\n    def chefora_num(self, i):\n        if i < 10:\n            return int(i)\n        ch = str(int(i / 10))\n        ch_0 = str(int(i % 10))\n        res = ch + ch_0 + ch[::-1]\n        return int(res)\nC = main()\na = [0] * 100001\npresum = [0] * 100001\nfor i in range(1, 100001):\n    a[i] = C.chefora_num(i)\n    presum[i] = presum[i - 1] + a[i]\nq = int(input())\nwhile q > 0:\n    x = list(map(int, input().strip().split(' ')))\n    (l, r) = (x[0], x[1])\n    diff = presum[r] - presum[l]\n    res = C.power(a[l], diff)\n    print(res)\n    q -= 1", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "sum_chefora = [1, 3, 6, 10, 15, 21, 28, 36, 45]\ns = 45\ncount = 9\nfor i in range(2, 7):\n    d = i - 1\n    start = 10 ** (d - 1)\n    end = -1 + 10 ** d\n    for j in range(start, end + 1):\n        for k in range(0, 10):\n            if count == 100000:\n                break\n            temp = int(str(j) + str(k) + str(j)[::-1])\n            s += temp\n            sum_chefora.append(s)\n            count += 1\n        if count == 100000:\n            break\n    if count == 100000:\n        break\nq = int(input())\nmod = 1000000007\nfor i in range(q):\n    (l, r) = map(int, input().split())\n    base = 0\n    if l == 1:\n        base = sum_chefora[0]\n    else:\n        base = sum_chefora[l - 1] - sum_chefora[l - 2]\n    exponent = sum_chefora[r - 1] - sum_chefora[l - 1]\n    print(pow(base, exponent, mod))", "q = int(input())\n\ndef digits(n):\n    d = 0\n    while n:\n        n = n // 10\n        d += 1\n    return d\n\ndef chefora(N):\n    d = digits(N)\n    temp = N // 10\n    N = N * 10 ** (d - 1)\n    for i in range(d - 1):\n        N += temp % 10 * 10 ** (d - 2 - i)\n        temp = temp // 10\n    return N\n\ndef power(a, n):\n    M = 1000000007\n    res = 1\n    while n:\n        if n & 1:\n            res = res * (a % M) % M\n        n = n // 2\n        a = a % M * (a % M) % M\n    return res\nchefsum = [0] * 100001\nfor i in range(1, 100001):\n    chefsum[i] = chefsum[i - 1] + chefora(i)\nfor t in range(q):\n    (L, R) = list(map(int, input().split(' ')))\n    M = 1000000007\n    s = (chefsum[R] - chefsum[L]) % (M - 1)\n    print(power(chefora(L), s))", "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nL = [0]\nfor i in range(1, 10 ** 5 + 1):\n    x = i\n    n = x // 10\n    m = 0\n    c = 0\n    while n > 0:\n        x = x * 10 + n % 10\n        n = n // 10\n        c += 1\n    L.append(x)\nmod = 10 ** 9 + 7\nT = [0]\nfor i in range(1, 10 ** 5 + 1):\n    T.append(L[i] + T[-1])\nt = int(int(input()))\nk = []\nfor test in range(t):\n    (l, r) = map(int, input().split())\n    x = T[r] - T[l]\n    s = power(L[l], x, mod)\n    k.append(s)\nprint(*k, sep='\\n')", "a = [0] * (10 ** 5 + 1)\na_sum = [0] * (10 ** 5 + 1)\n\ndef palindrome(num):\n    result = num\n    num //= 10\n    while num > 0:\n        result = result * 10 + num % 10\n        num //= 10\n    return result\nfor i in range(1, 10 ** 5 + 1):\n    a[i] = palindrome(i)\n    a_sum[i] = a_sum[i - 1] + a[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    result = 1\n    power = a_sum[r] - a_sum[l]\n    base = a[l]\n    while power:\n        if power % 2 == 0:\n            base = base % (10 ** 9 + 7) * (base % (10 ** 9 + 7)) % (10 ** 9 + 7)\n            power //= 2\n        else:\n            result = result % (10 ** 9 + 7) * (base % (10 ** 9 + 7)) % (10 ** 9 + 7)\n            power -= 1\n    print(result)", "MOD = int(1000000000.0 + 7)\nMX = int(100000.0 + 1)\n\ndef genChefora(L, R):\n    chefora = []\n    for i in range(L, R + 1):\n        if i > 9:\n            num = str(i)\n            num += num[len(num) - 2::-1]\n            num = int(num)\n        else:\n            num = i\n        chefora.append(num)\n    return chefora\n\ndef prefixSum(arr):\n    ps = []\n    ps.append(arr[0])\n    for i in range(1, len(arr)):\n        ps.append(arr[i] + ps[i - 1])\n    return ps\n\ndef binPow(n, p):\n    ans = 1\n    n %= MOD\n    while p:\n        if p & 1:\n            ans *= n % MOD\n        n *= n % MOD\n        p >>= 1\n    return ans % MOD\ncf = genChefora(1, MX)\npf = prefixSum(cf)\nfor _ in range(int(input())):\n    (L, R) = map(int, input().split())\n    firstL = cf[L - 1]\n    totalPow = pf[R - 1] - pf[L - 1]\n    print(binPow(firstL, totalPow))", "def power(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\nL = [0]\nfor i in range(1, 10 ** 5 + 1):\n    x = i\n    n = x // 10\n    m = 0\n    c = 0\n    while n > 0:\n        x = x * 10 + n % 10\n        n = n // 10\n        c += 1\n    L.append(x)\nmod = 10 ** 9 + 7\nT = [0]\nfor i in range(1, 10 ** 5 + 1):\n    T.append(L[i] + T[-1])\nt = int(int(input()))\nk = []\nfor test in range(t):\n    (l, r) = map(int, input().split())\n    x = T[r] - T[l]\n    s = power(L[l], x, mod)\n    k.append(s)\nprint(*k, sep='\\n')", "import math\nimport builtins\nfrom itertools import accumulate\nfrom sys import *\n\ndef countDigit(n):\n    return math.floor(math.log10(n) + 1)\nchefora = []\nfor i in range(1, 100001):\n    if i < 10:\n        chefora.append(i)\n    else:\n        c1 = countDigit(i)\n        chefora.append(int(str(i) + str(i)[c1 - 2::-1]))\nres = list(accumulate(chefora))\nt = int(stdin.readline())\nwhile t:\n    line = stdin.readline().split(' ')\n    (l, r) = (int(line[0]), int(line[1]))\n    b = res[r - 1] - res[l - 1]\n    a = chefora[l - 1]\n    p = builtins.pow(a, b, 1000000007)\n    print(p)\n    t = t - 1", "arr = []\nfor i in range(10):\n    arr.append(i)\nfor i in range(10, pow(10, 5) + 1):\n    arr.append(int(str(i) + str(i)[len(str(i)) - 2::-1]))\nT = int(input())\nsum_arr = []\ns = 0\nfor j in arr:\n    s += j\n    sum_arr.append(s)\nfor i in range(T):\n    (L, R) = map(int, input().split())\n    print(pow(arr[L], sum_arr[R] - sum_arr[L], pow(10, 9) + 7))", "mod = 10 ** 9 + 7\n\ndef reverse(n):\n    m = n\n    ans = m\n    n = n // 10\n    while n:\n        rem = n % 10\n        ans = ans * 10 + rem\n        n = n // 10\n    return ans\n\ndef mul(x, y):\n    ans = x * y\n    return ans % mod if ans > mod else ans\n\ndef exponential_power(a, b):\n    if b < 0:\n        return 1\n    elif a == 0 or b == 1 or a == 1:\n        return a % mod\n    else:\n        ans = 1\n        a = a % mod\n        while b:\n            if b & 1:\n                ans = mul(ans, a)\n            a = mul(a, a)\n            b = b >> 1\n        return ans\narr = [reverse(i) for i in range(10 ** 5 + 5)]\nprefix_sum = [0] * (10 ** 5 + 5)\nfor i in range(1, 10 ** 5 + 5):\n    prefix_sum[i] = prefix_sum[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    n = arr[l]\n    ans = exponential_power(n, prefix_sum[r] - prefix_sum[l])\n    print(ans)", "mod = int(1000000000.0 + 7)\n\ndef chef(x):\n    y = x // 10\n    while y:\n        x = x * 10 + y % 10\n        y //= 10\n    return x\nlt = [0]\ns = [0]\nfor i in range(1, 100001):\n    lt.append(chef(i))\n    s.append(lt[i] + s[i - 1])\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    ans = pow(lt[l], s[r] - s[l], mod)\n    print(ans)", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palin = num\n    num = num // 10\n    while num > 0:\n        palin = palin * 10 + num % 10\n        num = num // 10\n    return palin\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palin = num\n    num = num // 10\n    while num > 0:\n        palin = palin * 10 + num % 10\n        num = num // 10\n    return palin\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "try:\n\n    class Palin:\n\n        def __init__(self, n):\n            self.n = n\n            self.i = 0\n            self.palin = [0] * n\n            self.prefix = [0] * n\n\n        def add(self, v):\n            self.palin[self.i] = v\n            self.prefix[self.i] = v\n            if self.i != 0:\n                self.prefix[self.i] += self.prefix[self.i - 1]\n            self.i = self.i + 1\n\n        def fill(self):\n            return self.i == self.n\n\n        def rangedPrefix(self, l, r):\n            return self.prefix[r] - self.prefix[l]\n\n        def basePalindrome(self, l):\n            return self.palin[l]\n\n    def oddPalindrome(a):\n        n = a\n        pal = a\n        n = n // 10\n        while n > 0:\n            pal = pal * 10 + n % 10\n            n = n // 10\n        return pal\n\n    def makePalin(palin):\n        i = 1\n        while not palin.fill():\n            palin.add(oddPalindrome(i))\n            i += 1\n\n    def calculate(l, r, palin):\n        power = palin.rangedPrefix(l - 1, r - 1)\n        base = palin.basePalindrome(l - 1)\n        return pow(base, power, 1000000007)\n    palin = Palin(100001)\n    makePalin(palin)\n    t = int(input())\n    while t > 0:\n        (l, r) = map(int, input().split())\n        print(calculate(l, r, palin))\n        t -= 1\nexcept:\n    pass", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palin = num\n    num = num // 10\n    while num > 0:\n        palin = palin * 10 + num % 10\n        num = num // 10\n    return palin\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "try:\n\n    class Palin:\n\n        def __init__(self, n):\n            self.n = n\n            self.i = 0\n            self.palin = [0] * n\n            self.prefix = [0] * n\n\n        def add(self, v):\n            self.palin[self.i] = v\n            self.prefix[self.i] = v\n            if self.i != 0:\n                self.prefix[self.i] += self.prefix[self.i - 1]\n            self.i = self.i + 1\n\n        def fill(self):\n            return self.i == self.n\n\n        def rangedPrefix(self, l, r):\n            return self.prefix[r] - self.prefix[l]\n\n        def basePalindrome(self, l):\n            return self.palin[l]\n\n    def oddPalindrome(a):\n        n = a\n        pal = a\n        n = n // 10\n        while n > 0:\n            pal = pal * 10 + n % 10\n            n = n // 10\n        return pal\n\n    def makePalin(palin):\n        i = 1\n        while not palin.fill():\n            palin.add(oddPalindrome(i))\n            i += 1\n\n    def calculate(l, r, palin):\n        power = palin.rangedPrefix(l - 1, r - 1)\n        base = palin.basePalindrome(l - 1)\n        return pow(base, power, 1000000007)\n    palin = Palin(100001)\n    makePalin(palin)\n    t = int(input())\n    while t > 0:\n        (l, r) = map(int, input().split())\n        print(calculate(l, r, palin))\n        t -= 1\nexcept:\n    pass", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palin = num\n    num = num // 10\n    while num > 0:\n        palin = palin * 10 + num % 10\n        num = num // 10\n    return palin\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palin = num\n    num = num // 10\n    while num > 0:\n        palin = palin * 10 + num % 10\n        num = num // 10\n    return palin\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef abc(num):\n    palindrome_ = num\n    num = num // 10\n    while num > 0:\n        palindrome_ = palindrome_ * 10 + num % 10\n        num = num // 10\n    return palindrome_\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = abc(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\ntest = int(input())\nfor _ in range(int(test)):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "summ = []\nfor ii in range(0, 10 ** 5 + 1):\n    summ.append(0)\nb1 = 0\n\ndef modu():\n    return 10 ** 9 + 7\n\ndef p2(xx):\n    return xx + 1\n\ndef p3(xx):\n    if xx % 2 == 0:\n        return True\n    return False\n\ndef p4(xx):\n    return xx // 2\n\ndef p5(a, b):\n    return a % b\nxxx = 0\nx9 = 10 ** 5 + 1\n\ndef cal(b, p):\n    a1 = 0\n    mod = modu()\n    res = 1\n    l1 = []\n    while p != 0:\n        tempu = p3(p)\n        if tempu:\n            b = p5(b, mod) ** 2 % mod\n            l1.append(b)\n            p = p4(p)\n            b1 = xxx\n            l1.append(b1)\n        else:\n            xz = p5(res, mod)\n            l1.append(xz)\n            xz1 = p5(b, mod)\n            res = xz * xz1 % mod\n            l1.append(res)\n            p -= 1\n            a1 = xxx\n    return res\narr = []\nfor ii in range(0, 10 ** 5 + 1):\n    arr.append(0)\na1 = 0\n\ndef p1(xx):\n    return xx // 10\n\ndef find(a):\n    result = []\n    temp = a\n    a1 = xxx\n    a = p1(a)\n    while a > xxx:\n        temp = temp * 10 + a % 10\n        result.append(temp)\n        a = p1(a)\n        a1 = p2(a1)\n        result.append(a1)\n    return temp\ntempyy = 0\nt = []\nfor ii in range(0, x9):\n    t.append(0)\nfor i in range(1, x9):\n    yc = []\n    arr[i] = find(i)\n    yc.append(arr[i])\n    res1 = 0\n    summ[i] = summ[i - 1] + arr[i]\nttt = int(input())\nfor tt in range(0, ttt):\n    inn = list(map(int, input().split()))\n    l = inn[0]\n    r = inn[1]\n    ans = summ[r] - summ[l]\n    res2 = ''\n    out = cal(arr[l], ans)\n    print(out)", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palindrome = num\n    num = num // 10\n    while num > 0:\n        palindrome = palindrome * 10 + num % 10\n        num = num // 10\n    return palindrome\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palindrome = num\n    num = num // 10\n    while num > 0:\n        palindrome = palindrome * 10 + num % 10\n        num = num // 10\n    return palindrome\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palindrome = num\n    num = num // 10\n    while num > 0:\n        palindrome = palindrome * 10 + num % 10\n        num = num // 10\n    return palindrome\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palindrome = num\n    num = num // 10\n    while num > 0:\n        palindrome = palindrome * 10 + num % 10\n        num = num // 10\n    return palindrome\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "import math\nimport itertools\nfrom sys import stdin\nfrom functools import reduce\nfrom collections import deque\nfrom sys import setrecursionlimit\nfrom collections import defaultdict\nimport heapq\ninput = stdin.readline\n\ndef I():\n    return int(input())\n\ndef IN():\n    return map(int, input().split())\n\ndef LI():\n    return list(map(int, input().split()))\n\ndef LIN(N):\n    return [list(map(int, input().split())) for _ in range(N)]\ngcd = math.gcd\nInf = float('Inf')\na = [0] * (10 ** 5 + 1)\na_sum = [0] * (10 ** 5 + 1)\n\ndef palindrome(num):\n    result = num\n    num //= 10\n    while num > 0:\n        result = result * 10 + num % 10\n        num //= 10\n    return result\nfor i in range(1, 10 ** 5 + 1):\n    a[i] = palindrome(i)\n    a_sum[i] = a_sum[i - 1] + a[i]\n\ndef solve():\n    (l, r) = IN()\n    result = 1\n    power = a_sum[r] - a_sum[l]\n    base = a[l]\n    while power:\n        if power % 2 == 0:\n            base = base % (10 ** 9 + 7) * (base % (10 ** 9 + 7)) % (10 ** 9 + 7)\n            power //= 2\n        else:\n            result = result % (10 ** 9 + 7) * (base % (10 ** 9 + 7)) % (10 ** 9 + 7)\n            power -= 1\n    print(result)\n\ndef main():\n    t = 1\n    t = I()\n    for i in range(1, t + 1):\n        solve()\nmain()", "chfr = [0] * 100001\npch = [0] * 100001\nfor i in range(1, 100001):\n    temp = i // 10\n    if temp != 0:\n        temp = str(temp)\n        temp = temp[::-1]\n        chfr[i] = int(str(i) + temp)\n    else:\n        chfr[i] = i\n    pch[i] = chfr[i] + pch[i - 1]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    y = pch[r] - pch[l]\n    x = chfr[l]\n    ans = int(pow(x, y, 1000000007))\n    print(ans)", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "try:\n\n    class Pl:\n\n        def __init__(self, n):\n            self.n = n\n            self.i = 0\n            self.pl = [0] * n\n            self.pre = [0] * n\n\n        def add(self, v):\n            self.pl[self.i] = v\n            self.pre[self.i] = v\n            if self.i != 0:\n                self.pre[self.i] += self.pre[self.i - 1]\n            self.i = self.i + 1\n\n        def fill(self):\n            return self.i == self.n\n\n        def rangedpre(self, l, r):\n            return self.pre[r] - self.pre[l]\n\n        def basePl(self, l):\n            return self.pl[l]\n\n    def Opl(a):\n        n = a\n        pal = a\n        n = n // 10\n        while n > 0:\n            pal = pal * 10 + n % 10\n            n = n // 10\n        return pal\n\n    def makePl(pl):\n        i = 1\n        while not pl.fill():\n            pl.add(Opl(i))\n            i += 1\n\n    def cal(l, r, pl):\n        power = pl.rangedpre(l - 1, r - 1)\n        base = pl.basePl(l - 1)\n        return pow(base, power, 1000000007)\n    pl = Pl(100001)\n    makePl(pl)\n    T = int(input())\n    while T > 0:\n        (l, r) = map(int, input().split())\n        print(cal(l, r, pl))\n        T -= 1\nexcept:\n    pass", "def odd_Palindrome(val):\n    (n, pd) = (val, val)\n    n //= 10\n    while n > 0:\n        pd = pd * 10 + n % 10\n        n //= 10\n    return pd\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palin = num\n    num = num // 10\n    while num > 0:\n        palin = palin * 10 + num % 10\n        num = num // 10\n    return palin\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "class palindrome:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def fill(self):\n        return self.i == self.n\n\n    def rangeprefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\n    def basepalindrome(self, l):\n        return self.palindrome[l]\n\ndef oddpalindrome(a):\n    n = a\n    pal = a\n    n = n // 10\n    while n > 0:\n        pal = pal * 10 + n % 10\n        n = n // 10\n    return pal\n\ndef makepalindrome(palindrome):\n    i = 1\n    while not palindrome.fill():\n        palindrome.add(oddpalindrome(i))\n        i += 1\n\ndef cal(l, r, palindrome):\n    power = palindrome.rangeprefix(l - 1, r - 1)\n    base = palindrome.basepalindrome(l - 1)\n    return pow(base, power, 1000000007)\npalindrome = palindrome(100001)\nmakepalindrome(palindrome)\nt = int(input())\nwhile t > 0:\n    (l, r) = map(int, input().split())\n    print(cal(l, r, palindrome))\n    t -= 1", "class palin_Prefix_sum:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef genPalin(palin_Prefix_sum):\n    i = 1\n    while not palin_Prefix_sum.isFull():\n        palin_Prefix_sum.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palin_Prefix_sum):\n    power = palin_Prefix_sum.getPrefixSumInRange(L - 1, R - 1)\n    base = palin_Prefix_sum.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalin_Prefix_sum = palin_Prefix_sum(100001)\ngenPalin(palin_Prefix_sum)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palin_Prefix_sum))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "def binom(al, ar):\n    mod = 10 ** 9 + 7\n    res = 1\n    while ar:\n        if ar % 2 != 0:\n            res = res * al % mod\n        ar = ar // 2\n        al = al * al % mod\n    return res\nq = int(input())\nar = [0] * (10 ** 5 + 1)\narsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    temp = i\n    n1 = list(map(int, str(i // 10)))\n    res = int(''.join(map(str, n1[::-1])))\n    if res > 0:\n        temp = temp * 10 ** len(n1) + res\n    ar[i] = temp\n    arsm[i] = arsm[i - 1] + ar[i]\nfor _ in range(q):\n    (l, r) = map(int, input().split())\n    sm = arsm[r] - arsm[l]\n    z = binom(ar[l], sm)\n    print(z)", "def ans(base, power):\n    m = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % m * (base % m) % m\n            power = power // 2\n        else:\n            res = res % m * (base % m) % m\n            power = power - 1\n    return res\n\ndef palin(i):\n    temp = i\n    i = i // 10\n    while i > 0:\n        temp = temp * 10 + i % 10\n        i = i // 10\n    return temp\narr = [0] * (10 ** 5 + 1)\np = [0] * (10 ** 5 + 1)\nfor i in range(1, len(arr)):\n    arr[i] = palin(i)\n    p[i] = p[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    power = p[k] - p[n]\n    print(ans(arr[n], power))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def ans(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef palin(i):\n    temp = i\n    i = i // 10\n    while i > 0:\n        temp = temp * 10 + i % 10\n        i = i // 10\n    return temp\narr = [0] * (10 ** 5 + 1)\np = [0] * (10 ** 5 + 1)\nfor i in range(1, len(arr)):\n    arr[i] = palin(i)\n    p[i] = p[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    power = p[k] - p[n]\n    print(ans(arr[n], power))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "class Plinprefsumencap:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef CRODDPLIN(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(Plinprefsumencap):\n    i = 1\n    while not Plinprefsumencap.isFull():\n        Plinprefsumencap.add(CRODDPLIN(i))\n        i = i + 1\n\ndef solve(L, R, Plinprefsumencap):\n    power = Plinprefsumencap.getPrefixSumInRange(L - 1, R - 1)\n    base = Plinprefsumencap.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\nPlinprefsumencap = Plinprefsumencap(100001)\ngeneratePalindromes(Plinprefsumencap)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, Plinprefsumencap))", "def chefora(n):\n    if n <= 9:\n        return n\n    k = n // 10\n    return int(str(n) + str(k)[::-1])\npre_sum = [0]\nfor i in range(1, 100001):\n    pre_sum.append(pre_sum[i - 1] + chefora(i))\nmod = 10 ** 9 + 7\ntest = int(input())\n\ndef power(base, poer):\n    sol = 1\n    while poer > 0:\n        if poer % 2 != 0:\n            sol = sol % mod * base % mod % mod\n            poer -= 1\n        else:\n            poer = poer // 2\n            base = base % mod * (base % mod) % mod\n    return sol\nans = []\nfor _ in range(test):\n    x = list(map(int, input().split()))\n    l = x[0]\n    r = x[1]\n    m = pre_sum[r] - pre_sum[l]\n    ans.append(power(chefora(l), m))\nfor i in ans:\n    print(i)", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palin = num\n    num = num // 10\n    while num > 0:\n        palin = palin * 10 + num % 10\n        num = num // 10\n    return palin\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def power(a, n):\n    res = 1\n    p = n\n    base = a\n    while p > 0:\n        if p % 2 == 0:\n            p = p // 2\n            base = base % (10 ** 9 + 7) * (base % (10 ** 9 + 7)) % (10 ** 9 + 7)\n        else:\n            p -= 1\n            res = res % (10 ** 9 + 7) * (base % (10 ** 9 + 7)) % (10 ** 9 + 7)\n    return res\n\ndef createChefora(n):\n    temp = n\n    n = n // 10\n    while n > 0:\n        temp = temp * 10 + n % 10\n        n = n // 10\n    return temp\nchefora = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    chefora[i] = createChefora(i)\nprefixsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    prefixsm[i] = prefixsm[i - 1] + chefora[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    ans = power(chefora[l], prefixsm[r] - prefixsm[l])\n    print(ans)", "class palin_Prefix_sum:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef genPalin(palin_Prefix_sum):\n    i = 1\n    while not palin_Prefix_sum.isFull():\n        palin_Prefix_sum.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palin_Prefix_sum):\n    power = palin_Prefix_sum.getPrefixSumInRange(L - 1, R - 1)\n    base = palin_Prefix_sum.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalin_Prefix_sum = palin_Prefix_sum(100001)\ngenPalin(palin_Prefix_sum)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palin_Prefix_sum))", "class Pre:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef odd(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef gen(pre):\n    i = 1\n    while not pre.isFull():\n        pre.add(odd(i))\n        i = i + 1\n\ndef solve(L, R, pre):\n    power = pre.getPrefixSumInRange(L - 1, R - 1)\n    base = pre.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npre = Pre(100001)\ngen(pre)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, pre))", "def fp(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef fsf(num):\n    pa = num\n    num = num // 10\n    while num > 0:\n        pa = pa * 10 + num % 10\n        num = num // 10\n    return pa\narr = [0] * (10 ** 5 + 1)\nar = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = fsf(i)\n    ar[i] = ar[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = ar[r] - ar[l]\n    print(fp(arr[l], power))", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "def oddPalindrome(val):\n    (n, pal) = (val, val)\n    n //= 10\n    while n > 0:\n        pal = pal * 10 + n % 10\n        n //= 10\n    return pal\n\nclass Palindrome:\n\n    def __init__(self, n):\n        super(Palindrome, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palin = [0] * n\n        self.pre = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palin[self.i] = v\n        self.pre[self.i] = v\n        if self.i != 0:\n            self.pre[self.i] += self.pre[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalindrome(self, l):\n        return self.palin[l]\n\n    def rangedPrefix(self, l, r):\n        return self.pre[r] - self.pre[l]\n\ndef create(palin):\n    idx = 1\n    while not palin.fill():\n        palin.add(oddPalindrome(idx))\n        idx += 1\n\ndef cal(l, r, palin):\n    power = palin.rangedPrefix(l - 1, r - 1)\n    base = palin.basePalindrome(l - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj = Palindrome(100001)\n        create(obj)\n        q = int(input())\n        while q > 0:\n            (l, r) = map(int, input().split())\n            print(cal(l, r, obj))\n            q -= 1\n    except Exception as e:\n        raise e", "def power(bs, pw):\n    mod = 10 ** 9 + 7\n    if pw == 0:\n        return 1\n    elif pw == 1:\n        return bs\n    if pw & 1:\n        res = bs % mod * power(bs, pw - 1) % mod % mod\n    else:\n        res = power(bs, pw // 2) % mod\n        res *= res\n        res %= mod\n    return res\nchefola_no = [0]\npresums = [0]\nfor i in range(1, 10 ** 5 + 1):\n    s = str(i)\n    num = int(s[:-1] + s[::-1])\n    chefola_no.append(num)\n    presums.append(presums[i - 1] + num)\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    pwr = presums[r] - presums[l]\n    print(power(chefola_no[l], pwr))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input(''))\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def power(b, p):\n    mod = 10 ** 9 + 7\n    ans = 1\n    while p != 0:\n        if p % 2 == 0:\n            b = b % mod * (b % mod) % mod\n            p = p // 2\n        else:\n            ans = ans % mod * (b % mod) % mod\n            p = p - 1\n    return ans\n\ndef find(n):\n    k = n\n    n = n // 10\n    while n > 0:\n        k = k * 10 + n % 10\n        n = n // 10\n    return k\na = [0] * (10 ** 5 + 1)\ns = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    a[i] = find(i)\n    s[i] = s[i - 1] + a[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    p = s[r] - s[l]\n    print(power(a[l], p))", "def findpower(base, power):\n    mod = 10 ** 9 + 7\n    res = 1\n    while power != 0:\n        if power % 2 == 0:\n            base = base % mod * (base % mod) % mod\n            power = power // 2\n        else:\n            res = res % mod * (base % mod) % mod\n            power = power - 1\n    return res\n\ndef findshefola(num):\n    palin = num\n    num = num // 10\n    while num > 0:\n        palin = palin * 10 + num % 10\n        num = num // 10\n    return palin\narr = [0] * (10 ** 5 + 1)\narrsm = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    arr[i] = findshefola(i)\n    arrsm[i] = arrsm[i - 1] + arr[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    power = arrsm[r] - arrsm[l]\n    print(findpower(arr[l], power))", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "def power(b, p):\n    mod = 10 ** 9 + 7\n    ans = 1\n    while p != 0:\n        if p % 2 == 0:\n            b = b % mod * (b % mod) % mod\n            p = p // 2\n        else:\n            ans = ans % mod * (b % mod) % mod\n            p = p - 1\n    return ans\n\ndef find(n):\n    k = n\n    n = n // 10\n    while n > 0:\n        k = k * 10 + n % 10\n        n = n // 10\n    return k\na = [0] * (10 ** 5 + 1)\ns = [0] * (10 ** 5 + 1)\nfor i in range(1, 10 ** 5 + 1):\n    a[i] = find(i)\n    s[i] = s[i - 1] + a[i]\nfor _ in range(int(input())):\n    (l, r) = map(int, input().split())\n    p = s[r] - s[l]\n    print(power(a[l], p))", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "def odd_Palindrome(val):\n    (n, palindrome) = (val, val)\n    n //= 10\n    while n > 0:\n        palindrome = palindrome * 10 + n % 10\n        n //= 10\n    return palindrome\n\nclass Palin:\n\n    def __init__(self, n):\n        super(Palin, self).__init__()\n        self.n = n\n        self.i = 0\n        self.palindrome = [0] * n\n        self.prefix = [0] * n\n\n    def fill(self):\n        return self.i == self.n\n\n    def add(self, v):\n        self.palindrome[self.i] = v\n        self.prefix[self.i] = v\n        if self.i != 0:\n            self.prefix[self.i] += self.prefix[self.i - 1]\n        self.i = self.i + 1\n\n    def basePalin(self, l):\n        return self.palindrome[l]\n\n    def rangedPrefix(self, l, r):\n        return self.prefix[r] - self.prefix[l]\n\ndef create_Palin(palindrome):\n    idx = 1\n    while not palindrome.fill():\n        palindrome.add(odd_Palindrome(idx))\n        idx += 1\n\ndef calc(left, right, palindrome):\n    power = palindrome.rangedPrefix(left - 1, right - 1)\n    base = palindrome.basePalin(left - 1)\n    return pow(base, power, 1000000007)\n\nclass Solution(object):\n    try:\n        obj_Palin = Palin(100001)\n        create_Palin(obj_Palin)\n        num_Of_Queries = int(input())\n        while num_Of_Queries > 0:\n            (left, right) = map(int, input().split())\n            print(calc(left, right, obj_Palin))\n            num_Of_Queries -= 1\n    except Exception as e:\n        raise e", "class PalindromeAndPrefixSumEncapsulated:\n\n    def __init__(self, n):\n        self.n = n\n        self.i = 0\n        self.palindromes = [0] * n\n        self.prefixSums = [0] * n\n\n    def add(self, val):\n        self.palindromes[self.i] = val\n        self.prefixSums[self.i] = val\n        if self.i != 0:\n            self.prefixSums[self.i] += self.prefixSums[self.i - 1]\n        self.i = self.i + 1\n\n    def isFull(self):\n        return self.i == self.n\n\n    def getPrefixSumInRange(self, L, R):\n        return self.prefixSums[R] - self.prefixSums[L]\n\n    def getFirstPalin(self, index):\n        return self.palindromes[index]\n\ndef createOddPalin(inp):\n    n = inp\n    palin = inp\n    n = n // 10\n    while n > 0:\n        palin = palin * 10 + n % 10\n        n = n // 10\n    return palin\n\ndef generatePalindromes(palindromeAndPrefixSumEncapsulated):\n    i = 1\n    while not palindromeAndPrefixSumEncapsulated.isFull():\n        palindromeAndPrefixSumEncapsulated.add(createOddPalin(i))\n        i = i + 1\n\ndef solve(L, R, palindromeAndPrefixSumEncapsulated):\n    power = palindromeAndPrefixSumEncapsulated.getPrefixSumInRange(L - 1, R - 1)\n    base = palindromeAndPrefixSumEncapsulated.getFirstPalin(L - 1)\n    return pow(base, power, 1000000007)\npalindromeAndPrefixSumEncapsulated = PalindromeAndPrefixSumEncapsulated(100001)\ngeneratePalindromes(palindromeAndPrefixSumEncapsulated)\nq = int(input())\nwhile q > 0:\n    q = q - 1\n    line = input().split(' ')\n    (L, R) = (int(line[0]), int(line[1]))\n    print(solve(L, R, palindromeAndPrefixSumEncapsulated))", "def convert(i):\n    n = i // 10\n    while n != 0:\n        i = i * 10 + n % 10\n        n = n // 10\n    return i\narr = [0] * 100005\npre = [0] * 100005\nfor i in range(1, len(arr)):\n    arr[i] = convert(i)\n    pre[i] = arr[i] + pre[i - 1]\nm = 10 ** 9 + 7\nfor t in range(int(input())):\n    (l, r) = list(map(int, input().split()))\n    a = arr[l]\n    p = pre[r] - pre[l]\n    res = 1\n    while p > 0:\n        if p % 2 == 0:\n            a = a % m * (a % m) % m\n            p //= 2\n        else:\n            p -= 1\n            res = res % m * (a % m) % m\n    print(res % m)"]