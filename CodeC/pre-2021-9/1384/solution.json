["from sys import stdin\n\nclass Edge:\n\n    def __init__(self, to, rev, f, cap):\n        self.to = to\n        self.rev = rev\n        self.f = f\n        self.cap = cap\n\nclass DinicsAlgo:\n\n    def __init__(self, N):\n        self.dist = [-1] * N\n        self.q = [0] * N\n        self.g = [[] for i in range(N)]\n\n    def add_edge(self, s, t, cap):\n        a = Edge(s, len(self.g[s]), 0, cap)\n        b = Edge(t, len(self.g[t]), 0, cap)\n        self.g[s].append(b)\n        self.g[t].append(a)\n\n    def bfs(self, N):\n        self.dist = [-1] * N\n        self.dist[0] = 0\n        qsz = 0\n        self.q[qsz] = self.src\n        qsz += 1\n        i = 0\n        while i < qsz:\n            u = self.q[i]\n            i += 1\n            for e in self.g[u]:\n                v = e.to\n                if self.dist[v] < 0 and e.f < e.cap:\n                    self.dist[v] = self.dist[u] + 1\n                    self.q[qsz] = v\n                    qsz += 1\n        return self.dist[self.dest] >= 0\n\n    def dfs(self, u, f):\n        if u == self.dest:\n            return f\n        for e in self.g[u]:\n            if e.cap <= e.f:\n                continue\n            v = e.to\n            if self.dist[v] == self.dist[u] + 1:\n                df = self.dfs(v, min(f, e.cap - e.f))\n                if df > 0:\n                    e.f += df\n                    self.g[v][e.rev].f -= df\n                    return df\n        return 0\n\n    def mf(self, s, t, N):\n        self.src = s\n        self.dest = t\n        ret = 0\n        while self.bfs(N):\n            delta = self.dfs(s, 1000000000)\n            while delta:\n                ret += delta\n                delta = self.dfs(s, 1000000000)\n        return ret\n\ndef dfs_up(node, G):\n    up[node] = 1\n    for e in G.g[node]:\n        if e.cap > e.f and up[e.to] == -1:\n            dfs_up(e.to, G)\nfor _ in range(int(stdin.readline())):\n    (h, w, n) = map(int, stdin.readline().split())\n    arr = [[0] * w]\n    for i in range(1, h + 1):\n        arr.append([0] + list(map(int, stdin.readline().split())))\n    x = [0] * (n + 1)\n    y = [0] * (n + 1)\n    p = [0] * (n + 1)\n    for i in range(1, n + 1):\n        (x[i], y[i], p[i]) = map(int, stdin.readline().split())\n    G = DinicsAlgo(n + 2)\n    V = 0\n    for i in range(1, n + 1):\n        V += abs(arr[x[i]][y[i]] * p[i])\n        if arr[x[i]][y[i]] >= 0:\n            G.add_edge(0, i, arr[x[i]][y[i]] * p[i])\n        if arr[x[i]][y[i]] < 0:\n            G.add_edge(i, n + 1, -arr[x[i]][y[i]] * p[i])\n        for j in range(i + 1, n + 1):\n            if abs(x[i] - x[j]) + abs(y[i] - y[j]) == 1:\n                G.add_edge(i, j, p[i] * p[j])\n                V += p[i] * p[j]\n    V -= 2 * G.mf(0, n + 1, n + 2)\n    up = [-1] * (n + 2)\n    dfs_up(0, G)\n    print(V)\n    for i in range(1, n + 1):\n        print(up[i], end=' ')", "from sys import stdin\n\nclass Edge:\n\n    def __init__(self, to, rev, f, cap):\n        self.to = to\n        self.rev = rev\n        self.f = f\n        self.cap = cap\n\nclass DinicsAlgo:\n\n    def __init__(self, N):\n        self.dist = [-1] * N\n        self.q = [0] * N\n        self.g = [[] for i in range(N)]\n\n    def add_edge(self, s, t, cap):\n        a = Edge(s, len(self.g[s]), 0, cap)\n        b = Edge(t, len(self.g[t]), 0, cap)\n        self.g[s].append(b)\n        self.g[t].append(a)\n\n    def bfs(self, N):\n        self.dist = [-1] * N\n        self.dist[0] = 0\n        qsz = 0\n        self.q[qsz] = self.src\n        qsz += 1\n        i = 0\n        while i < qsz:\n            u = self.q[i]\n            i += 1\n            for e in self.g[u]:\n                v = e.to\n                if self.dist[v] < 0 and e.f < e.cap:\n                    self.dist[v] = self.dist[u] + 1\n                    self.q[qsz] = v\n                    qsz += 1\n        return self.dist[self.dest] >= 0\n\n    def dfs(self, u, f):\n        if u == self.dest:\n            return f\n        for e in self.g[u]:\n            if e.cap <= e.f:\n                continue\n            v = e.to\n            if self.dist[v] == self.dist[u] + 1:\n                df = self.dfs(v, min(f, e.cap - e.f))\n                if df > 0:\n                    e.f += df\n                    self.g[v][e.rev].f -= df\n                    return df\n        return 0\n\n    def mf(self, s, t, N):\n        self.src = s\n        self.dest = t\n        ret = 0\n        while self.bfs(N):\n            delta = self.dfs(s, 1000000000)\n            while delta:\n                ret += delta\n                delta = self.dfs(s, 1000000000)\n        return ret\n\ndef dfs_up(node, G):\n    up[node] = 1\n    for e in G.g[node]:\n        if e.cap > e.f and up[e.to] == -1:\n            dfs_up(e.to, G)\nfor _ in range(int(stdin.readline())):\n    (h, w, n) = map(int, stdin.readline().split())\n    arr = [[0] * w]\n    for i in range(1, h + 1):\n        arr.append([0] + list(map(int, stdin.readline().split())))\n    x = [0] * (n + 1)\n    y = [0] * (n + 1)\n    p = [0] * (n + 1)\n    for i in range(1, n + 1):\n        (x[i], y[i], p[i]) = map(int, stdin.readline().split())\n    G = DinicsAlgo(n + 2)\n    V = 0\n    for i in range(1, n + 1):\n        V += abs(arr[x[i]][y[i]] * p[i])\n        if arr[x[i]][y[i]] >= 0:\n            G.add_edge(0, i, arr[x[i]][y[i]] * p[i])\n        if arr[x[i]][y[i]] < 0:\n            G.add_edge(i, n + 1, -arr[x[i]][y[i]] * p[i])\n        for j in range(i + 1, n + 1):\n            if abs(x[i] - x[j]) + abs(y[i] - y[j]) == 1:\n                G.add_edge(i, j, p[i] * p[j])\n                V += p[i] * p[j]\n    V -= 2 * G.mf(0, n + 1, n + 2)\n    up = [-1] * (n + 2)\n    dfs_up(0, G)\n    print(V)\n    for i in range(1, n + 1):\n        print(up[i], end=' ')", "from sys import stdin\n\nclass Edge:\n\n    def __init__(self, to, rev, f, cap):\n        self.to = to\n        self.rev = rev\n        self.f = f\n        self.cap = cap\n\nclass DinicsAlgo:\n\n    def __init__(self, N):\n        self.dist = [-1] * N\n        self.work = [0] * N\n        self.q = [0] * N\n        self.g = [[] for i in range(N)]\n\n    def add_edge(self, s, t, cap):\n        a = Edge(s, len(self.g[s]), 0, cap)\n        b = Edge(t, len(self.g[t]), 0, cap)\n        self.g[s].append(b)\n        self.g[t].append(a)\n\n    def bfs(self, N):\n        self.dist = [-1] * N\n        self.dist[0] = 0\n        qsz = 0\n        self.q[qsz] = self.src\n        qsz += 1\n        i = 0\n        while i < qsz:\n            u = self.q[i]\n            i += 1\n            for e in self.g[u]:\n                v = e.to\n                if self.dist[v] < 0 and e.f < e.cap:\n                    self.dist[v] = self.dist[u] + 1\n                    self.q[qsz] = v\n                    qsz += 1\n        return self.dist[self.dest] >= 0\n\n    def dfs(self, u, f):\n        if u == self.dest:\n            return f\n        for e in self.g[u]:\n            if e.cap <= e.f:\n                continue\n            v = e.to\n            if self.dist[v] == self.dist[u] + 1:\n                df = self.dfs(v, min(f, e.cap - e.f))\n                if df > 0:\n                    e.f += df\n                    self.g[v][e.rev].f -= df\n                    return df\n        return 0\n\n    def mf(self, s, t, N):\n        self.src = s\n        self.dest = t\n        ret = 0\n        while self.bfs(N):\n            delta = self.dfs(s, 1000000000)\n            while delta:\n                ret += delta\n                delta = self.dfs(s, 1000000000)\n        return ret\n\ndef dfs_up(node, G):\n    up[node] = 1\n    for e in G.g[node]:\n        if e.cap > e.f and up[e.to] == -1:\n            dfs_up(e.to, G)\nfor _ in range(int(stdin.readline())):\n    (h, w, n) = map(int, stdin.readline().split())\n    arr = [[0] * w]\n    for i in range(1, h + 1):\n        arr.append([0] + list(map(int, stdin.readline().split())))\n    x = [0] * (n + 1)\n    y = [0] * (n + 1)\n    p = [0] * (n + 1)\n    for i in range(1, n + 1):\n        (x[i], y[i], p[i]) = map(int, stdin.readline().split())\n    G = DinicsAlgo(n + 2)\n    V = 0\n    for i in range(1, n + 1):\n        V += abs(arr[x[i]][y[i]] * p[i])\n        if arr[x[i]][y[i]] >= 0:\n            G.add_edge(0, i, arr[x[i]][y[i]] * p[i])\n        if arr[x[i]][y[i]] < 0:\n            G.add_edge(i, n + 1, -arr[x[i]][y[i]] * p[i])\n        for j in range(i + 1, n + 1):\n            if abs(x[i] - x[j]) + abs(y[i] - y[j]) == 1:\n                G.add_edge(i, j, p[i] * p[j])\n                V += p[i] * p[j]\n    V -= 2 * G.mf(0, n + 1, n + 2)\n    up = [-1] * (n + 2)\n    dfs_up(0, G)\n    print(V)\n    for i in range(1, n + 1):\n        print(up[i], end=' ')", "def min_cut(capacity, src, sink):\n    from collections import deque\n    N = len(capacity)\n\n    def bfs():\n        queue = deque([src])\n        parents = {src: -1}\n        found = False\n        while queue:\n            u = queue.popleft()\n            if u == sink:\n                found = True\n                break\n            for v in range(N):\n                if v not in parents and capacity[u][v] > 0:\n                    parents[v] = u\n                    queue.append(v)\n        return (found, parents)\n    while True:\n        (found, parents) = bfs()\n        if not found:\n            break\n        mn = float('inf')\n        v = sink\n        while parents[v] != -1:\n            u = parents[v]\n            mn = min(mn, capacity[u][v])\n            v = u\n        v = sink\n        while parents[v] != -1:\n            u = parents[v]\n            capacity[u][v] -= mn\n            capacity[v][u] += mn\n            v = u\n    queue = deque([src])\n    src_nodes = set([src])\n    while queue:\n        u = queue.popleft()\n        for v in range(N):\n            if v not in src_nodes and capacity[u][v] > 0:\n                src_nodes.add(v)\n                queue.append(v)\n    return src_nodes\n\ndef solve(nr, nc, grid, particles):\n    particles = [(r - 1, c - 1, x) for (r, c, x) in particles]\n    N = len(particles)\n    (pos, neg) = (N, N + 1)\n    capacity = [[0] * (N + 2) for _ in range(N + 2)]\n    for (i, (r, c, x)) in enumerate(particles):\n        if grid[r][c] > 0:\n            capacity[pos][i] = x * grid[r][c]\n        if grid[r][c] < 0:\n            capacity[i][neg] = -x * grid[r][c]\n        for j in range(i + 1, len(particles)):\n            (rr, cc, xx) = particles[j]\n            if r == rr and abs(c - cc) == 1 or (c == cc and abs(r - rr) == 1):\n                capacity[i][j] = x * xx\n                capacity[j][i] = x * xx\n    pos_nodes = min_cut(capacity, pos, neg)\n    sign = [1 if u in pos_nodes else -1 for u in range(N)]\n    res = 0\n    for (i, (r, c, x)) in enumerate(particles):\n        res += grid[r][c] * x * sign[i]\n        for j in range(i + 1, len(particles)):\n            (rr, cc, xx) = particles[j]\n            if r == rr and abs(c - cc) == 1 or (c == cc and abs(r - rr) == 1):\n                res += x * xx * sign[i] * sign[j]\n    return (res, sign)\n\ndef main():\n    from sys import stdin\n    T = int(stdin.readline().strip())\n    for t in range(T):\n        (H, W, N) = list(map(int, stdin.readline().strip().split()))\n        grid = [list(map(int, stdin.readline().strip().split())) for _ in range(H)]\n        particles = [list(map(int, stdin.readline().strip().split())) for _ in range(N)]\n        (res, sign) = solve(H, W, grid, particles)\n        print(res)\n        print(' '.join(map(str, sign)))\nmain()"]