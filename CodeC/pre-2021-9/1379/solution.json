["from collections import deque\n\ndef merge(x, y):\n    if len(x) > len(y):\n        (x, y) = (y, x)\n    for i in x:\n        y[i] = y[i] + x[i] if i in y else x[i]\n    return (y, y)\n\ndef NC_Dij(lis, start):\n    ret = [float('inf')] * len(lis)\n    ret[start] = 0\n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n    return (ret, plis)\nmod = 10 ** 9 + 7\nfor loop in range(int(input())):\n    N = int(input())\n    lis = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n    (dlis, P) = NC_Dij(lis, 0)\n    chnum = [0] * N\n    for i in range(1, N):\n        chnum[P[i]] += 1\n    a = list(map(int, input().split()))\n    cds = [{} for i in range(N)]\n    allsum = [0] * N\n    q = deque([])\n    leaf = [False] * N\n    ans = 0\n    for i in range(N):\n        if chnum[i] == 0:\n            q.append(i)\n            leaf[i] = True\n    while q:\n        v = q.popleft()\n        nans = allsum[v] if a[v] not in cds[v] else allsum[v] - cds[v][a[v]]\n        if leaf[v]:\n            nans = 1\n        nans %= mod\n        ans += nans\n        ans %= mod\n        if a[v] not in cds[v]:\n            cds[v][a[v]] = 0\n        cds[v][a[v]] += nans\n        cds[v][a[v]] %= mod\n        if P[v] != v:\n            chnum[P[v]] -= 1\n            (cds[P[v]], cds[v]) = merge(cds[P[v]], cds[v])\n            allsum[P[v]] = (allsum[P[v]] + allsum[v] + nans) % mod\n            if chnum[P[v]] == 0:\n                q.append(P[v])\n    print(ans)", "from collections import deque\n\ndef merge(x, y):\n    if len(x) > len(y):\n        (x, y) = (y, x)\n    for i in x:\n        y[i] = y[i] + x[i] if i in y else x[i]\n    return (y, y)\n\ndef NC_Dij(lis, start):\n    ret = [float('inf')] * len(lis)\n    ret[start] = 0\n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n    return (ret, plis)\nmod = 10 ** 9 + 7\nfor loop in range(int(input())):\n    N = int(input())\n    lis = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n    (dlis, P) = NC_Dij(lis, 0)\n    chnum = [0] * N\n    for i in range(1, N):\n        chnum[P[i]] += 1\n    a = list(map(int, input().split()))\n    cds = [{} for i in range(N)]\n    allsum = [0] * N\n    q = deque([])\n    leaf = [False] * N\n    ans = 0\n    for i in range(N):\n        if chnum[i] == 0:\n            q.append(i)\n            leaf[i] = True\n    while q:\n        v = q.popleft()\n        nans = allsum[v] if a[v] not in cds[v] else allsum[v] - cds[v][a[v]]\n        if leaf[v]:\n            nans = 1\n        nans %= mod\n        ans += nans\n        ans %= mod\n        if a[v] not in cds[v]:\n            cds[v][a[v]] = 0\n        cds[v][a[v]] += nans\n        cds[v][a[v]] %= mod\n        if P[v] != v:\n            chnum[P[v]] -= 1\n            (cds[P[v]], cds[v]) = merge(cds[P[v]], cds[v])\n            allsum[P[v]] = (allsum[P[v]] + allsum[v] + nans) % mod\n            if chnum[P[v]] == 0:\n                q.append(P[v])\n    print(ans)", "from collections import deque\n\ndef merge(x, y):\n    if len(x) > len(y):\n        (x, y) = (y, x)\n    for i in x:\n        y[i] = y[i] + x[i] if i in y else x[i]\n    return (y, y)\n\ndef NC_Dij(lis, start):\n    ret = [float('inf')] * len(lis)\n    ret[start] = 0\n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n    return (ret, plis)\nmod = 10 ** 9 + 7\nfor loop in range(int(input())):\n    N = int(input())\n    lis = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n    (dlis, P) = NC_Dij(lis, 0)\n    chnum = [0] * N\n    for i in range(1, N):\n        chnum[P[i]] += 1\n    a = list(map(int, input().split()))\n    cds = [{} for i in range(N)]\n    allsum = [0] * N\n    q = deque([])\n    leaf = [False] * N\n    ans = 0\n    for i in range(N):\n        if chnum[i] == 0:\n            q.append(i)\n            leaf[i] = True\n    while q:\n        v = q.popleft()\n        nans = allsum[v] if a[v] not in cds[v] else allsum[v] - cds[v][a[v]]\n        if leaf[v]:\n            nans = 1\n        nans %= mod\n        ans += nans\n        ans %= mod\n        if a[v] not in cds[v]:\n            cds[v][a[v]] = 0\n        cds[v][a[v]] += nans\n        cds[v][a[v]] %= mod\n        if P[v] != v:\n            chnum[P[v]] -= 1\n            (cds[P[v]], cds[v]) = merge(cds[P[v]], cds[v])\n            allsum[P[v]] = (allsum[P[v]] + allsum[v] + nans) % mod\n            if chnum[P[v]] == 0:\n                q.append(P[v])\n    print(ans)", "from collections import deque\n\ndef merge(x, y):\n    if len(x) > len(y):\n        (x, y) = (y, x)\n    for i in x:\n        y[i] = y[i] + x[i] if i in y else x[i]\n    return (y, y)\n\ndef NC_Dij(lis, start):\n    ret = [float('inf')] * len(lis)\n    ret[start] = 0\n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n    return (ret, plis)\nmod = 10 ** 9 + 7\nfor loop in range(int(input())):\n    N = int(input())\n    lis = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n    (dlis, P) = NC_Dij(lis, 0)\n    chnum = [0] * N\n    for i in range(1, N):\n        chnum[P[i]] += 1\n    a = list(map(int, input().split()))\n    cds = [{} for i in range(N)]\n    allsum = [0] * N\n    q = deque([])\n    leaf = [False] * N\n    ans = 0\n    for i in range(N):\n        if chnum[i] == 0:\n            q.append(i)\n            leaf[i] = True\n    while q:\n        v = q.popleft()\n        nans = allsum[v] if a[v] not in cds[v] else allsum[v] - cds[v][a[v]]\n        if leaf[v]:\n            nans = 1\n        nans %= mod\n        ans += nans\n        ans %= mod\n        if a[v] not in cds[v]:\n            cds[v][a[v]] = 0\n        cds[v][a[v]] += nans\n        cds[v][a[v]] %= mod\n        if P[v] != v:\n            chnum[P[v]] -= 1\n            (cds[P[v]], cds[v]) = merge(cds[P[v]], cds[v])\n            allsum[P[v]] = (allsum[P[v]] + allsum[v] + nans) % mod\n            if chnum[P[v]] == 0:\n                q.append(P[v])\n    print(ans)", "from collections import deque\n\ndef merge(x, y):\n    if len(x) > len(y):\n        (x, y) = (y, x)\n    for i in x:\n        y[i] = y[i] + x[i] if i in y else x[i]\n    return (y, y)\n\ndef NC_Dij(lis, start):\n    ret = [float('inf')] * len(lis)\n    ret[start] = 0\n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n    return (ret, plis)\nmod = 10 ** 9 + 7\nfor loop in range(int(input())):\n    N = int(input())\n    lis = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n    (dlis, P) = NC_Dij(lis, 0)\n    chnum = [0] * N\n    for i in range(1, N):\n        chnum[P[i]] += 1\n    a = list(map(int, input().split()))\n    cds = [{} for i in range(N)]\n    allsum = [0] * N\n    q = deque([])\n    leaf = [False] * N\n    for i in range(N):\n        if chnum[i] == 0:\n            q.append(i)\n            leaf[i] = True\n    ans = 0\n    while q:\n        v = q.popleft()\n        nans = allsum[v] if a[v] not in cds[v] else allsum[v] - cds[v][a[v]]\n        if leaf[v]:\n            nans = 1\n        nans %= mod\n        ans += nans\n        ans %= mod\n        if a[v] not in cds[v]:\n            cds[v][a[v]] = 0\n        cds[v][a[v]] += nans\n        cds[v][a[v]] %= mod\n        if P[v] != v:\n            chnum[P[v]] -= 1\n            (cds[P[v]], cds[v]) = merge(cds[P[v]], cds[v])\n            allsum[P[v]] = (allsum[P[v]] + allsum[v] + nans) % mod\n            if chnum[P[v]] == 0:\n                q.append(P[v])\n    print(ans)", "def merge(x, y):\n    if len(x) > len(y):\n        (x, y) = (y, x)\n    for i in x:\n        y[i] = y[i] + x[i] if i in y else x[i]\n    return (y, y)\nfrom collections import deque\n\ndef NC_Dij(lis, start):\n    ret = [float('inf')] * len(lis)\n    ret[start] = 0\n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n    return (ret, plis)\nmod = 10 ** 9 + 7\nANS = []\nfor loop in range(int(input())):\n    N = int(input())\n    lis = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n    (dlis, P) = NC_Dij(lis, 0)\n    chnum = [0] * N\n    for i in range(1, N):\n        chnum[P[i]] += 1\n    a = list(map(int, input().split()))\n    cds = [{} for i in range(N)]\n    allsum = [0] * N\n    q = deque([])\n    leaf = [False] * N\n    for i in range(N):\n        if chnum[i] == 0:\n            q.append(i)\n            leaf[i] = True\n    ans = 0\n    while q:\n        v = q.popleft()\n        nans = allsum[v] if a[v] not in cds[v] else allsum[v] - cds[v][a[v]]\n        if leaf[v]:\n            nans = 1\n        nans %= mod\n        ans += nans\n        ans %= mod\n        if a[v] not in cds[v]:\n            cds[v][a[v]] = 0\n        cds[v][a[v]] += nans\n        cds[v][a[v]] %= mod\n        if P[v] != v:\n            chnum[P[v]] -= 1\n            (cds[P[v]], cds[v]) = merge(cds[P[v]], cds[v])\n            allsum[P[v]] = (allsum[P[v]] + allsum[v] + nans) % mod\n            if chnum[P[v]] == 0:\n                q.append(P[v])\n    ANS.append(str(ans))\nprint('\\n'.join(ANS))", "import sys\nfrom sys import stdin\n\ndef merge(x, y):\n    if len(x) > len(y):\n        (x, y) = (y, x)\n    for i in x:\n        if i in y:\n            y[i] += x[i]\n        else:\n            y[i] = x[i]\n    return (y, y)\nfrom collections import deque\n\ndef NC_Dij(lis, start):\n    ret = [float('inf')] * len(lis)\n    ret[start] = 0\n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n    while len(q) > 0:\n        now = q.popleft()\n        for nex in lis[now]:\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n    return (ret, plis)\ntt = int(stdin.readline())\nmod = 10 ** 9 + 7\nANS = []\nfor loop in range(tt):\n    N = int(stdin.readline())\n    lis = [[] for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, stdin.readline().split())\n        u -= 1\n        v -= 1\n        lis[u].append(v)\n        lis[v].append(u)\n    (dlis, P) = NC_Dij(lis, 0)\n    chnum = [0] * N\n    for i in range(1, N):\n        chnum[P[i]] += 1\n    a = list(map(int, stdin.readline().split()))\n    cds = [{} for i in range(N)]\n    allsum = [0] * N\n    q = deque([])\n    leaf = [False] * N\n    for i in range(N):\n        if chnum[i] == 0:\n            q.append(i)\n            leaf[i] = True\n    ans = 0\n    while q:\n        v = q.popleft()\n        nans = allsum[v] if a[v] not in cds[v] else allsum[v] - cds[v][a[v]]\n        if leaf[v]:\n            nans = 1\n        nans %= mod\n        ans += nans\n        ans %= mod\n        if a[v] not in cds[v]:\n            cds[v][a[v]] = 0\n        cds[v][a[v]] += nans\n        cds[v][a[v]] %= mod\n        if P[v] != v:\n            chnum[P[v]] -= 1\n            (cds[P[v]], cds[v]) = merge(cds[P[v]], cds[v])\n            allsum[P[v]] = (allsum[P[v]] + allsum[v] + nans) % mod\n            if chnum[P[v]] == 0:\n                q.append(P[v])\n    ANS.append(str(ans))\nprint('\\n'.join(ANS))"]