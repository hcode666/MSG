["import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef solve(t, i, parent):\n    arr = []\n    for child in t[i]:\n        if child != parent:\n            arr.append(solve(t, child, i))\n    arr.sort(reverse=True)\n    _sum = 1\n    for (i, j) in enumerate(arr):\n        _sum += (i + 1) * j\n    return _sum\nfor _ in range(int(input())):\n    (n, x) = list(map(int, input().split(' ')))\n    t = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split(' ')))\n        t[u].append(v)\n        t[v].append(u)\n    print(x * solve(t, 1, 0) % mod)", "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef solve(t, i, parent):\n    arr = []\n    for child in t[i]:\n        if child != parent:\n            arr.append(solve(t, child, i))\n    arr.sort(reverse=True)\n    _sum = 1\n    for (i, j) in enumerate(arr):\n        _sum += (i + 1) * j\n    return _sum\nfor _ in range(int(input())):\n    (n, x) = list(map(int, input().split(' ')))\n    t = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split(' ')))\n        t[u].append(v)\n        t[v].append(u)\n    print(x * solve(t, 1, 0) % mod)", "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\nM = 1000000007\n\ndef dfs(adj, node, parent):\n    ans = 1\n    values = []\n    children = adj.get(node, [])\n    for child in children:\n        if child != parent:\n            values.append(dfs(adj, child, node))\n    values.sort(reverse=True)\n    for i in range(len(values)):\n        ans += values[i] * (i + 1)\n    return ans\nT = int(input())\nfor _ in range(T):\n    (n, x) = map(int, input().split())\n    adj = {}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        try:\n            adj[u].append(v)\n        except:\n            adj[u] = [v]\n        try:\n            adj[v].append(u)\n        except:\n            adj[v] = [u]\n    print(dfs(adj, 1, 0) % M * x % M)", "from collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(1000000)\nM = 1000000007\n\ndef dfs(adj, node, parent):\n    ans = 1\n    values = []\n    children = adj.get(node, [])\n    for child in children:\n        if child != parent:\n            values.append(dfs(adj, child, node))\n    values.sort(reverse=True)\n    for i in range(len(values)):\n        ans += values[i] * (i + 1)\n    return ans\nT = int(input())\nfor _ in range(T):\n    (n, x) = map(int, input().split())\n    adj = {}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        try:\n            adj[u].append(v)\n        except:\n            adj[u] = [v]\n        try:\n            adj[v].append(u)\n        except:\n            adj[v] = [u]\n    print(dfs(adj, 1, 0) % M * x % M)", "from collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(1000000)\nM = 1000000007\nadj = defaultdict(list)\n\ndef dfs(adj, node, parent):\n    ans = 1\n    values = []\n    children = adj.get(node, [])\n    for child in children:\n        if child != parent:\n            values.append(dfs(adj, child, node))\n    values.sort(reverse=True)\n    for i in range(len(values)):\n        ans += values[i] * (i + 1)\n    return ans\nT = int(input())\nfor _ in range(T):\n    (n, x) = map(int, input().split())\n    adj.clear()\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    print(dfs(adj, 1, 0) % M * x % M)", "import sys\nsys.setrecursionlimit(10 ** 7)\n\ndef dfs(root):\n    arr = []\n    visited.add(root)\n    for node in graph[root]:\n        if node not in visited:\n            arr.append(dfs(node))\n    arr.sort(reverse=True)\n    summ = 1\n    for (k, v) in enumerate(arr):\n        summ += (k + 1) * v\n    return summ\nfrom collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    graph = defaultdict(list)\n    visited = set()\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    print(x * dfs(1) % (10 ** 9 + 7))", "import sys\nsys.setrecursionlimit(10 ** 6)\np = 10 ** 9 + 7\n\ndef findSum(node, children, parent):\n    if parent != -1 and len(children[node]) == 1:\n        return 1\n    childSums = []\n    for child in children[node]:\n        if child == parent:\n            continue\n        s = findSum(child, children, node)\n        childSums.append((child, s))\n    childSums.sort(key=lambda x: x[1], reverse=True)\n    totalSum = 1\n    for i in range(len(childSums)):\n        totalSum += childSums[i][1] * (i + 1)\n    return totalSum\nt = int(input())\nfor i in range(t):\n    (n, x) = map(int, input().split())\n    children = {x: [] for x in range(n)}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        children[u - 1].append(v - 1)\n        children[v - 1].append(u - 1)\n    print(findSum(0, children, -1) * x % p)", "import sys\nsys.setrecursionlimit(300034)\np = 10 ** 9 + 7\n\ndef tsum(nd, ar):\n    if len(ar[nd]) == 0:\n        return 1\n    s = 0\n    li = []\n    for i in ar[nd]:\n        li.append(tsum(i, ar))\n    li = sorted(li)\n    l = len(li)\n    for i in li:\n        s += i * l\n        l -= 1\n    s += 1\n    return s\n\ndef assg(p, no, ar, far):\n    if ar[no] == [p] or ar[no] == []:\n        return far\n    for i in ar[no]:\n        if i != p:\n            far[no].append(i)\n            assg(no, i, ar, far)\n    return far\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    ar = [[] for i in range(n + 7)]\n    far = [[] for i in range(n + 7)]\n    ls = [0] * (n + 1)\n    ls[1] = 1\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        ar[u].append(v)\n        ar[v].append(u)\n    far = assg(0, 1, ar, far)\n    print(x * (tsum(1, far) % p) % p)", "from sys import setrecursionlimit\nsetrecursionlimit(1 << 30)\n\ndef dfs(child, parent, graph):\n    count = 1\n    child_arr = []\n    for ele in graph[child]:\n        if ele != parent:\n            child_arr.append(dfs(ele, child, graph))\n    child_arr.sort(reverse=True)\n    for (i, j) in enumerate(child_arr):\n        count += (i + 1) * j\n    return count\nM = 1000000007\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    print(x * (dfs(1, -1, graph) % M) % M)", "from sys import setrecursionlimit\nfrom collections import defaultdict\nsetrecursionlimit(1 << 30)\n\ndef dfs(child, parent, graph):\n    count = 1\n    child_arr = []\n    for ele in graph[child]:\n        if ele != parent:\n            child_arr.append(dfs(ele, child, graph))\n    child_arr.sort(reverse=True)\n    for (i, j) in enumerate(child_arr):\n        count += (i + 1) * j\n    return count\nM = 1000000007\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(1, n + 1):\n        graph[i] = []\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    print(x * (dfs(1, -1, graph) % M) % M)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 7)\nmod = 10 ** 9 + 7\n\ndef value(v, x, parent):\n    l = []\n    for node in adj[v]:\n        if node != parent:\n            l.append(value(node, x, v))\n    l.sort(reverse=True)\n    ans = x\n    for (i, val) in enumerate(l):\n        ans += (i + 1) * val\n    return ans\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    print(x * value(1, 1, -1) % mod)", "import sys\nfrom os import path\nimport math\nimport time\nfrom collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\nMOD = 10 ** 9 + 7\nINT_MAX = 10 ** 9\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef dfs(v, p):\n    b = []\n    ans = 1\n    for i in tree[v]:\n        if i != p:\n            b.append(dfs(i, v))\n    b = sorted(b, reverse=True)\n    x = 1\n    for i in range(len(b)):\n        ans += b[i] * x\n        x += 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    (N, X) = map(int, input().split())\n    tree = defaultdict(list)\n    parent = []\n    ans = 1\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    ans = dfs(1, -1)\n    print(X * ans % MOD)", "import sys\nsys.setrecursionlimit(3 * int(100000.0) + 11)\nMOD = int(1000000000.0) + 7\n\ndef dfs(node, parent):\n    subtree_values = []\n    for child in graph[node]:\n        if child != parent:\n            child_val = dfs(child, node)\n            subtree_values.append(child_val)\n    subtree_values.sort(reverse=True)\n    children = len(graph[node]) - (1 if node != 1 else 0)\n    node_val = children * (children + 1) // 2\n    for i in range(len(subtree_values)):\n        node_val += (i + 1) * subtree_values[i]\n    return node_val\n\ndef solve():\n    root_val = dfs(1, 1) + 1\n    return X * root_val % MOD\ntest_cases = int(input())\nfor test_case in range(test_cases):\n    (N, X) = map(int, input().split())\n    graph = [[] for i in range(N + 1)]\n    for i in range(N - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    print(solve())", "def solve():\n    child = {}\n    parent = {}\n    (depth, max_depth) = ({}, 1)\n    for (u, v) in edges:\n        child.setdefault(u, []).append(v)\n        child.setdefault(v, []).append(u)\n    used = set()\n    (que, p_que) = ([1], 0)\n    depth[1] = 1\n    used.add(1)\n    while p_que < len(que):\n        node = que[p_que]\n        child[node] = [x for x in child[node] if x not in used]\n        for x in child[node]:\n            used.add(x)\n        child_depth = depth[node] + 1\n        for x in child[node]:\n            que.append(x)\n            parent[x] = node\n            depth[x] = child_depth\n            if child_depth > max_depth:\n                max_depth = child_depth\n        p_que += 1\n    level = [set() for x in range(max_depth)]\n    level[0].add(1)\n    for node in child:\n        for x in child[node]:\n            level[depth[node]].add(x)\n    weight = {x: 0 for x in range(N + 1)}\n    for l in range(max_depth - 1, 0, -1):\n        used = set()\n        for node in level[l]:\n            if node in used:\n                continue\n            p = parent[node]\n            lc = len(child[p])\n            for (i, ci) in enumerate(sorted(child[p], key=lambda x: weight[x], reverse=True), start=1):\n                weight[p] += i * (weight[ci] + 1)\n                used.add(ci)\n    return (weight[1] + 1) * X % MOD\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    (N, X) = [int(x) for x in input().split()]\n    edges = [[int(x) for x in input().split()] for i in range(N - 1)]\n    print(solve())", "import sys\nsys.setrecursionlimit(10 ** 9)\nmod = 1000000007\n\ndef dfs(rt, par):\n    for g in graph[rt]:\n        if g != par:\n            dfs(g, rt)\n    c = []\n    for g in graph[rt]:\n        if g != par:\n            c.append(g)\n    c.sort(reverse=True, key=lambda x: sm[x])\n    _m = 1\n    for i in c:\n        m[i] = _m\n        _m += 1\n    for g in graph[rt]:\n        if g != par:\n            sm[rt] += m[g] * sm[g]\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (s, e) = map(int, input().split())\n        graph[s].append(e)\n        graph[e].append(s)\n    sm = [1 for i in range(n + 1)]\n    m = [0 for i in range(n + 1)]\n    dfs(1, 0)\n    print(sm[1] % mod * x % mod)", "import sys\nsys.setrecursionlimit(10 ** 9)\nmod = 1000000007\n\ndef dfs(rt, par):\n    for g in graph[rt]:\n        if g != par:\n            dfs(g, rt)\n    c = []\n    for g in graph[rt]:\n        if g != par:\n            c.append(g)\n    c.sort(reverse=True, key=lambda x: sm[x])\n    _m = 1\n    for i in c:\n        m[i] = _m\n        _m += 1\n    for g in graph[rt]:\n        if g != par:\n            sm[rt] += m[g] * sm[g]\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (s, e) = map(int, input().split())\n        graph[s].append(e)\n        graph[e].append(s)\n    sm = [1 for i in range(n + 1)]\n    m = [0 for i in range(n + 1)]\n    dfs(1, 0)\n    print(sm[1] % mod * x % mod)", "import sys\nfrom os import path\nimport math\nimport time\nfrom collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\nMOD = 10 ** 9 + 7\nINT_MAX = 10 ** 9\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef dfs(v, p):\n    b = []\n    ans = 1\n    for i in tree[v]:\n        if i != p:\n            b.append(dfs(i, v))\n    b = sorted(b, reverse=True)\n    x = 1\n    for i in range(len(b)):\n        ans += b[i] * x\n        x += 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    (N, X) = map(int, input().split())\n    tree = defaultdict(list)\n    parent = []\n    ans = 1\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    ans = dfs(1, -1)\n    print(X * ans % MOD)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef solve(ver):\n    vist[ver - 1] = 1\n    l = []\n    for i in range(len(d[ver])):\n        if vist[d[ver][i] - 1] == 0:\n            tmp = solve(d[ver][i])\n            l.append(tmp)\n    l.sort(reverse=True)\n    ans = 1\n    for i in range(len(l)):\n        ans += (i + 1) * l[i]\n        ans = ans\n    return ans\nt = int(input())\nwhile t != 0:\n    mod = int(1000000000.0 + 7)\n    (n, x) = map(int, input().split())\n    d = defaultdict(list)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        d[a].append(b)\n        d[b].append(a)\n    vist = [0 for i in range(n)]\n    x = x % mod\n    print(solve(1) % mod * x % mod)\n    t -= 1", "from sys import setrecursionlimit\nfrom collections import defaultdict\nsetrecursionlimit(1 << 30)\nMOD = pow(10, 9) + 7\n\ndef dfs(n, p, graph):\n    count = 1\n    child = []\n    for i in graph[n]:\n        if i == p:\n            continue\n        child.append(dfs(i, n, graph))\n    child.sort(reverse=True)\n    for (i, j) in enumerate(child):\n        count += (i + 1) * j\n    return count\n\ndef solve():\n    (n, x) = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    result = dfs(1, -1, graph) % MOD\n    result = result * x % MOD\n    return result\nt = 1\nt = int(input())\nfor _ in range(t):\n    print(solve())", "from sys import setrecursionlimit\nsetrecursionlimit(10 ** 6)\nMODULO = 10 ** 9 + 7\ntest_cases = int(input().strip())\n\nclass Tree:\n\n    def __init__(self):\n        self.children = dict()\n\n    def add_edge(self, node1, node2):\n        if node1 in self.children:\n            self.children[node1].append(node2)\n        else:\n            self.children[node1] = [node2]\n        if node2 in self.children:\n            self.children[node2].append(node1)\n        else:\n            self.children[node2] = [node1]\n\ndef compute_value(t, node, parent_node):\n    if node in t.children:\n        child_values = [compute_value(t, y, node) for y in t.children[node] if y != parent_node]\n        child_values.sort(reverse=True)\n        child_sum = 0\n        for (idx, el) in enumerate(child_values):\n            child_sum = child_sum + el * (idx + 1)\n        return 1 + child_sum\n    else:\n        return 1\nwhile test_cases > 0:\n    test_cases -= 1\n    [n, x] = list(map(int, input().strip().split()))\n    tree = Tree()\n    for i in range(n - 1):\n        [u, v] = list(map(int, input().strip().split()))\n        tree.add_edge(u, v)\n    val = compute_value(tree, 1, 0)\n    val = val * x % MODULO\n    print(val)", "import sys\nsys.setrecursionlimit(10 ** 9)\nmod = 1000000007\n\ndef dfs(rt, par):\n    for g in graph[rt]:\n        if g != par:\n            dfs(g, rt)\n    c = []\n    for g in graph[rt]:\n        if g != par:\n            c.append(g)\n    c.sort(reverse=True, key=lambda x: sm[x])\n    _m = 1\n    for i in c:\n        m[i] = _m\n        _m += 1\n    for g in graph[rt]:\n        if g != par:\n            sm[rt] += m[g] * sm[g]\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (s, e) = map(int, input().split())\n        graph[s].append(e)\n        graph[e].append(s)\n    sm = [1 for i in range(n + 1)]\n    m = [0 for i in range(n + 1)]\n    dfs(1, 0)\n    print(sm[1] % mod * x % mod)", "from sys import stdin, stdout, setrecursionlimit\nfrom math import ceil, floor, sqrt, log, log2, log10\nfrom collections import Counter\nsetrecursionlimit(pow(10, 6))\ninput = stdin.readline\n\ndef solve():\n    pass\nt = int(input())\nmaxx = 3 * 10 ** 5 + 2\n\ndef dfs(v, p):\n    b = []\n    for i in range(len(edges[v])):\n        if edges[v][i] == p:\n            continue\n        else:\n            b.append(dfs(edges[v][i], v))\n    b.sort(reverse=True)\n    out = 1\n    k = 1\n    for i in b:\n        out += i * k\n        k += 1\n    return out\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    edges = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        edges[a].append(b)\n        edges[b].append(a)\n    output = dfs(1, -1) % 1000000007\n    print(output * x % 1000000007)", "import heapq as h\nimport sys\nsys.setrecursionlimit(300000)\n\ndef subCount(root=1, parent=None):\n    children = d.get(root, [])\n    if parent is not None and len(children) == 1:\n        return 1\n    count = 1\n    pq = []\n    for i in children:\n        if i != parent:\n            h.heappush(pq, subCount(i, root))\n    for i in range(len(pq), 0, -1):\n        count += i * h.heappop(pq)\n    return count\nt = int(input())\nfor i in range(t):\n    (n, x) = map(int, input().split())\n    d = {}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        if d.get(u, 0) == 0:\n            d[u] = [v]\n        else:\n            d[u].append(v)\n        if d.get(v, 0) == 0:\n            d[v] = [u]\n        else:\n            d[v].append(u)\n    vals = subCount() * x\n    print(vals % 1000000007)", "from collections import defaultdict\nfrom functools import cmp_to_key\nimport sys\nsys.setrecursionlimit(200000)\nd = defaultdict(list)\nM = 10 ** 9 + 7\n\ndef dfs1(src, parent, d):\n    s = []\n    for g in d[src]:\n        if g == parent:\n            continue\n        ans = dfs1(g, src, d)\n        s.append(ans)\n    s.sort(reverse=True)\n    val = 1\n    res = 1\n    for t in s:\n        res += t * val\n        val += 1\n    return res\nfor _ in range(int(input())):\n    (N, X) = map(int, input().split())\n    d.clear()\n    for _ in range(N - 1):\n        (src, dest) = map(int, input().split())\n        d[src].append(dest)\n        d[dest].append(src)\n    ans = dfs1(1, -1, d)\n    print(ans * X % M)", "from collections import defaultdict\nfrom functools import cmp_to_key\nimport sys\nsys.setrecursionlimit(200000)\nd = defaultdict(list)\nM = 10 ** 9 + 7\n\ndef dfs1(src, parent, d):\n    s = []\n    for g in d[src]:\n        if g == parent:\n            continue\n        ans = dfs1(g, src, d)\n        s.append(ans)\n    s.sort(reverse=True)\n    val = 1\n    res = 1\n    for t in s:\n        res += t * val\n        val += 1\n    return res\nfor _ in range(int(input())):\n    (N, X) = map(int, input().split())\n    d.clear()\n    for _ in range(N - 1):\n        (src, dest) = map(int, input().split())\n        d[src].append(dest)\n        d[dest].append(src)\n    ans = dfs1(1, -1, d)\n    print(ans * X % M)", "from collections import deque\nimport sys\nsys.setrecursionlimit(10 ** 6)\nMOD = 1000000007\n\nclass Solution:\n\n    def solve(self, tree, n, x):\n        values = [0] * n\n\n        def dfs(s, e):\n            values[s] = 1\n            tmp = []\n            for u in tree[s]:\n                if u == e:\n                    continue\n                dfs(u, s)\n                tmp.append(values[u])\n            tmp.sort(reverse=True)\n            for i in range(len(tmp)):\n                values[s] += (i + 1) * tmp[i]\n        dfs(0, -1)\n        return values[0] * x % MOD\nsol = Solution()\nfor _ in range(int(input())):\n    (n, x) = [int(y) for y in input().split()]\n    tree = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = [int(y) for y in input().split()]\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n    print(sol.solve(tree, n, x))", "import sys\nsys.setrecursionlimit(10 ** 9)\nmod = 1000000007\n\ndef dfs(rt, par):\n    for g in graph[rt]:\n        if g != par:\n            dfs(g, rt)\n    c = [g for g in graph[rt] if g != par]\n    c.sort(reverse=True, key=lambda x: sm[x])\n    _m = 1\n    for i in c:\n        m[i] = _m\n        _m += 1\n    sm[rt] += sum([m[g] * sm[g] for g in graph[rt] if g != par])\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (s, e) = map(int, input().split())\n        graph[s].append(e)\n        graph[e].append(s)\n    sm = [1 for i in range(n + 1)]\n    m = [0 for i in range(n + 1)]\n    dfs(1, 0)\n    print(sm[1] % mod * x % mod)", "import sys\nsys.setrecursionlimit(10 ** 9)\nmod = 1000000007\n\ndef dfs(rt, par):\n    for g in graph[rt]:\n        if g != par:\n            dfs(g, rt)\n    c = [g for g in graph[rt] if g != par]\n    c.sort(reverse=True, key=lambda x: sm[x])\n    _m = 1\n    for i in c:\n        m[i] = _m\n        _m += 1\n    sm[rt] += sum([m[g] * sm[g] for g in graph[rt] if g != par])\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (s, e) = map(int, input().split())\n        graph[s].append(e)\n        graph[e].append(s)\n    sm = [1 for i in range(n + 1)]\n    m = [0 for i in range(n + 1)]\n    dfs(1, 0)\n    print(sm[1] % mod * x % mod)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 8)\nmx = 3 * 100000 + 2\nmod = 1000000007\n\ndef tt(p):\n    vis[p] = 1\n    for c in l[p]:\n        if not vis[c]:\n            tt(c)\n    l[p].sort(key=lambda x: ans[x], reverse=True)\n    ans[p] = 1\n    for i in range(1, len(l[p]) + 1):\n        ans[p] += i * ans[l[p][i - 1]]\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    l = defaultdict(list)\n    vis = [0] * mx\n    ans = [0] * mx\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        l[a].append(b)\n        l[b].append(a)\n    tt(1)\n    print(ans[1] % mod * x % mod % mod)", "import sys\nsys.setrecursionlimit(pow(10, 6))\nvis = set()\n\ndef dfs(c):\n    ans = 1\n    nans = []\n    vis.add(c)\n    for i in g[c]:\n        if i in vis:\n            continue\n        nans.append(dfs(i))\n    k = sorted(nans, reverse=True)\n    for (i, j) in enumerate(k):\n        ans += j * (i + 1)\n    return ans\nm = 1000000007\nfor _ in range(int(input())):\n    vis = set()\n    (n, x) = map(int, input().split(' '))\n    g = list(([] for i in range(n + 1)))\n    for i in range(n - 1):\n        (u, v) = map(int, input().split(' '))\n        g[u].append(v)\n        g[v].append(u)\n    print(dfs(1) * x % m)", "from collections import defaultdict as dd\nimport sys\nsys.setrecursionlimit(1000000000)\nfor tc in range(int(input())):\n    (n, k) = map(int, input().split())\n    tree = dd(set)\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        tree[x].add(y)\n        tree[y].add(x)\n\n    def assignValues(root, par):\n        children = []\n        for child in tree[root]:\n            if child == par:\n                continue\n            sumOfValues = assignValues(child, root)\n            children.append((child, sumOfValues))\n        children = sorted(children, key=lambda x: x[1], reverse=True)\n        ans = 1\n        assignVal = 1\n        for (child, sumOfValues) in children:\n            ans += assignVal * sumOfValues\n            assignVal += 1\n        return ans\n    ans = assignValues(1, 0)\n    print(k * (ans % 1000000007) % 1000000007)", "mod = 1000000007\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 8)\n\ndef dfs(current, parent, g, dp, total):\n    dp[current] = 1\n    total[current] = dp[current]\n    s = 0\n    for i in range(len(g[current])):\n        node = g[current][i]\n        if node != parent:\n            dp[current] += 2 * dp[node] % mod\n            dp[current] %= mod\n            total[current] += total[node]\n            total[current] %= mod\n            total[current] += dp[node]\n            total[current] %= mod\n            s += dp[node]\n\ndef solve(r, p, mul, smul):\n    for nd in graph[r]:\n        if nd != p:\n            solve(nd, r, mul, smul)\n    c = []\n    for nd in graph[r]:\n        if nd != p:\n            c.append(nd)\n    c.sort(reverse=True, key=lambda x: smul[x])\n    _mul = 1\n    a = 0\n    for i in range(10):\n        a += i\n    for j in range(1, 10, 10):\n        a += j\n    for i in c:\n        mul[i] = _mul\n        _mul += 1\n    for value in graph[r]:\n        if value != p:\n            smul[r] += mul[value] * smul[value]\n\ndef solve1(a, b, k):\n    f = 0\n    ans = 0\n    for i in range(k):\n        if a[i] == b[i]:\n            f = 1\n        elif f:\n            ans = ans + 2\n            f = 0\n    if a[1] != b[1]:\n        ans = ans - 1\n    return ans\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    smul = [1 for i in range(n + 1)]\n    mul = [0 for i in range(n + 1)]\n    solve(1, 0, mul, smul)\n    print(smul[1] % mod * x % mod)", "try:\n    import sys\n    mod = 1000000007\n    sys.setrecursionlimit(1000000)\n\n    def solve(node, previous):\n        for adj in subnodes[node]:\n            if adj != previous:\n                solve(adj, node)\n        b = []\n        for i in subnodes[node]:\n            if i != previous:\n                b.append([count[i], i])\n        b.sort(reverse=True)\n        init = 1\n        for i in b:\n            res[i[1]] = init\n            init += 1\n        for i in subnodes[node]:\n            if i != previous:\n                count[node] += res[i] * count[i]\n    t = int(input())\n    for i in range(t):\n        (n, x) = map(int, input().strip().split())\n        subnodes = [[] for i in range(n + 1)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().strip().split())\n            subnodes[u].append(v)\n            subnodes[v].append(u)\n        count = [1] * (n + 1)\n        res = [0] * (n + 1)\n        solve(1, -1)\n        ans = count[1] % mod * x % mod\n        print(ans % mod)\nexcept:\n    pass", "import sys\nsys.setrecursionlimit(10 ** 9)\nmod = 1000000007\n\ndef dfs(rt, par):\n    for g in graph[rt]:\n        if g != par:\n            dfs(g, rt)\n    c = []\n    for g in graph[rt]:\n        if g != par:\n            c.append(g)\n    c.sort(reverse=True, key=lambda x: sm[x])\n    _m = 1\n    for i in c:\n        m[i] = _m\n        _m += 1\n    for g in graph[rt]:\n        if g != par:\n            sm[rt] += m[g] * sm[g]\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (s, e) = map(int, input().split())\n        graph[s].append(e)\n        graph[e].append(s)\n    sm = [1 for i in range(n + 1)]\n    m = [0 for i in range(n + 1)]\n    dfs(1, 0)\n    print(sm[1] % mod * x % mod)", "mod = 10 ** 9 + 7\n\ndef sdfdsfsdf(v):\n    temp = []\n    temp.append(v)\n    while temp:\n        k = temp[-1]\n        if visited[k] == 1:\n            temp.pop()\n            continue\n        visited[k] = -1\n        flag = 0\n        if inx[k] < len(asdsad[k]):\n            asdsadsddsfsdf = asdsad[k][inx[k]]\n            inx[k] += 1\n            if visited[asdsadsddsfsdf] == 0:\n                temp.append(asdsadsddsfsdf)\n                visited[asdsadsddsfsdf] = -1\n        else:\n            child = []\n            factor = 0\n            for i in asdsad[k]:\n                child.append((val[i], i))\n                factor += 1\n            child.sort()\n            t_x_par = 0\n            for j in child:\n                tt = j[0] * factor\n                t_x_par += tt\n                factor -= 1\n            t_x_par += 1\n            val[k] = t_x_par\n            visited[temp.pop()] = 1\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    asdsad = [[0, 0] for i in range(n)]\n    visited = [0 for i in range(n)]\n    val = [0 for i in range(n)]\n    inx = [2 for i in range(n)]\n    for i in range(n - 1):\n        (l, r) = map(int, input().split())\n        l -= 1\n        r -= 1\n        asdsad[r].append(l)\n        asdsad[l].append(r)\n    sdfdsfsdf(0)\n    print(val[0] % mod * x % mod)", "n_max = int(300000.0 + 5)\nmod = 10 ** 9 + 7\nadjacent = []\nlokesh = []\nvalue = []\nking = []\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(cur, last=-1):\n    for x in adjacent[cur]:\n        if x == last:\n            continue\n        dfs(x, cur)\n    king = []\n    for x in adjacent[cur]:\n        if x != last:\n            king.append((lokesh[x], x))\n    king.sort(reverse=True)\n    nv = 1\n    for (valuei, idv) in king:\n        value[idv] = nv\n        nv += 1\n    for x in adjacent[cur]:\n        if x != last:\n            lokesh[cur] += value[x] * lokesh[x]\nfor _ in range(int(input())):\n    (n, x) = [int(i) for i in input().split()]\n    lokesh = [1 for i in range(n)]\n    value = [0 for i in range(n)]\n    adjacent = [[] for i in range(n_max)]\n    for j in range(n - 1):\n        (u, v) = [int(i) - 1 for i in input().split()]\n        adjacent[u].append(v)\n        adjacent[v].append(u)\n    dfs(0)\n    print(lokesh[0] % mod * x % mod)", "from queue import Queue\ntest = int(input())\nfor i in range(test):\n    (N, X) = map(int, input().strip().split())\n    ar = []\n    lis = []\n    ab = [0] * (N + 1)\n    ab[1] = 1\n    ze = 0\n    l = []\n    v = []\n    ze = 0\n    ze = 0\n    for l in range(N + 1):\n        lis.append([])\n        v.append([])\n    for j in range(N - 1):\n        (a, b) = map(int, input().strip().split())\n        v[a].append(b)\n        v[b].append(a)\n    for x in v[1]:\n        ar.append([1, x])\n        ab[x] = 1\n        q = Queue(maxsize=0)\n        q.put(x)\n        while q.empty() == False:\n            o = q.get()\n            for y in v[o]:\n                if ab[y] == 0:\n                    ar.append([o, y])\n                    ab[y] = 1\n                    q.put(y)\n    for j in range(N - 2, -1, -1):\n        r = 1\n        f = 0\n        lis[ar[j][1]].sort(reverse=True)\n        for l in lis[ar[j][1]]:\n            f += r * l\n            r = r + 1\n        lis[ar[j][0]].append(f + 1)\n    r = 1\n    f = 0\n    lis[1].sort(reverse=True)\n    for l in lis[1]:\n        f += r * l\n        r = r + 1\n    print((f * X + X) % (10 ** 9 + 7))", "from collections import deque\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\ndef conv_2_directed(node):\n    visited[node] = 1\n    a = list(span_tr[node])\n    for x in a:\n        if visited[x] == 1:\n            span_tr[node].remove(x)\n        else:\n            conv_2_directed(x)\n\ndef treehouse(z):\n    children = span_tr[z]\n    if span_tr[z]:\n        arr = []\n        k = 0\n        for node in children:\n            arr.append(treehouse(node))\n        arr.sort(reverse=True)\n        i = 1\n        for val in arr:\n            k += val * i + i\n            i += 1\n        return k\n    return 0\nt = int(input())\nwhile t:\n    (n, x) = map(int, input().split())\n    span_tr = {}\n    for __ in range(n - 1):\n        (a, b) = map(int, input().split())\n        if a not in span_tr:\n            span_tr[a] = [b]\n        else:\n            span_tr[a].append(b)\n        if b not in span_tr:\n            span_tr[b] = [a]\n        else:\n            span_tr[b].append(a)\n    visited = [0] * (n + 1)\n    conv_2_directed(1)\n    ans1 = treehouse(1) + 1\n    ansx = ans1 * x\n    print(ansx % 1000000007)\n    t -= 1", "import sys\nsys.setrecursionlimit(10000000)\nfrom collections import deque\n\ndef find_sum(node):\n    c = []\n    if not tree[node]:\n        return 1\n    for x in tree[node]:\n        if x != -1:\n            c.append(find_sum(x))\n    c.sort(reverse=True)\n    s = 0\n    for x in range(len(c)):\n        s += (x + 1) * c[x]\n    return s + 1\n\ndef directed():\n    trash = set()\n    edges = {}\n    q = deque([1])\n    while q:\n        a = q.popleft()\n        trash.add(a)\n        edges[a] = []\n        for u in tree[a]:\n            if u not in trash:\n                q.append(u)\n                edges[a].append(u)\n    return edges\nk = 1000000007\nt = int(input())\nfor _ in range(t):\n    (n, x) = [int(i) for i in input().split()]\n    tree = {}\n    for __ in range(n - 1):\n        (a, b) = map(int, input().split())\n        if a in tree:\n            tree[a].append(b)\n        else:\n            tree[a] = [b]\n        (a, b) = (b, a)\n        if a in tree:\n            tree[a].append(b)\n        else:\n            tree[a] = [b]\n    visited = [0] * n\n    tree = directed()\n    visited = [0] * n\n    print(x * find_sum(1) % k)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom functools import cmp_to_key\n\ndef fcr(i, fc):\n    return fc[i]\n\ndef compare(i1, i2):\n    return fcr(i2, fc) - fcr(i1, fc)\n\ndef v(tree, root, fc, l):\n    for i in tree[root]:\n        if i == l:\n            continue\n        if len(tree[i]) > 0:\n            v(tree, i, fc, root)\n    tree[root].sort(key=cmp_to_key(compare))\n    k = 1\n    for i in tree[root]:\n        if i != l:\n            fc[root] += fc[i] * k\n            k += 1\nt = int(input())\nfor i in range(t):\n    (n, x) = map(int, input().split())\n    tree = [[] for x in range(n + 1)]\n    for j in range(n - 1):\n        (p, c) = map(int, input().split())\n        tree[p].append(c)\n        tree[c].append(p)\n    fc = [1] * (n + 1)\n    v(tree, 1, fc, -1)\n    print(fc[1] * x % 1000000007)", "import heapq as h\nimport sys\nsys.setrecursionlimit(300000)\n\ndef subCount(root=1, parent=None):\n    children = d.get(root, [])\n    if parent is not None and len(children) == 1:\n        return 1\n    count = 1\n    pq = []\n    for i in children:\n        if i != parent:\n            h.heappush(pq, subCount(i, root))\n    for i in range(len(pq), 0, -1):\n        count += i * h.heappop(pq)\n    return count\nt = int(input())\nfor i in range(t):\n    (n, x) = map(int, input().split())\n    d = {}\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        if d.get(u, 0) == 0:\n            d[u] = [v]\n        else:\n            d[u].append(v)\n        if d.get(v, 0) == 0:\n            d[v] = [u]\n        else:\n            d[v].append(u)\n    vals = subCount() * x\n    print(vals % 1000000007)", "import sys\nsys.setrecursionlimit(10 ** 6)\nm = 1000000007\nfor a0 in range(int(input())):\n    (n, x) = [int(x) for x in input().split()]\n    l = [[-1, -1] for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = [int(x) for x in input().split()]\n        l[a - 1].append(b - 1)\n        l[b - 1].append(a - 1)\n\n    def val(l, a, b):\n        if l[a][0] != -1:\n            return l[a][0]\n        elif len(l[a]) < 3:\n            l[a][0] = 1\n        else:\n            vp = []\n            for i in range(2, len(l[a])):\n                if l[a][i] != b:\n                    vp.append(val(l, l[a][i], a))\n            vp.sort(reverse=True)\n            l[a][0] = 1\n            for i in range(len(vp)):\n                l[a][0] += (i + 1) * vp[i]\n        return l[a][0]\n    print(val(l, 0, -1) * x % m)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(300000)\n\ndef solution(k: str, l: str):\n    for c in graph[k]:\n        if c == l:\n            continue\n        solution(c, k)\n    arr = sorted(((value[c], c) for c in graph[k] if c != l))\n    for (key, val) in zip(arr, range(len(arr), 0, -1)):\n        value[k] += val * key[0]\nfor _ in range(int(input())):\n    graph = defaultdict(list)\n    value = defaultdict(lambda : 1)\n    (n, x) = map(int, input().split())\n    for i in range(n - 1):\n        (p, c) = input().split()\n        graph[p].append(c)\n        graph[c].append(p)\n    solution('1', '0')\n    print(value['1'] * x % 1000000007)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(300000)\n\ndef solution(k: str, l: str):\n    try:\n        for c in graph[k]:\n            if c == l:\n                continue\n            solution(c, k)\n    except:\n        pass\n    arr = sorted(((value[c], c) for c in graph[k] if c != l))\n    for (key, val) in zip(arr, range(len(arr), 0, -1)):\n        value[k] += val * key[0]\nfor _ in range(int(input())):\n    graph = defaultdict(list)\n    value = defaultdict(lambda : 1)\n    (n, x) = map(int, input().split())\n    for i in range(n - 1):\n        (p, c) = input().split()\n        graph[p].append(c)\n        graph[c].append(p)\n    solution('1', '0')\n    print(value['1'] * x % 1000000007)", "from queue import PriorityQueue\nfrom queue import Queue\nimport math\nfrom collections import defaultdict\nimport sys\nimport operator as op\nfrom functools import reduce\nsys.setrecursionlimit(10 ** 6)\nii = lambda : list(map(int, sys.stdin.readline().strip().split()))\nist = lambda : list(sys.stdin.readline().strip().split())\nmod = 1000000007\n\ndef dfs(st, tree, subval, value, last=-1):\n    for x in tree[st]:\n        if x != last:\n            dfs(x, tree, subval, value, st)\n    cnt = []\n    for x in tree[st]:\n        if x != last:\n            cnt.append((subval[x], x))\n    cnt.sort(reverse=True)\n    tmp = 1\n    for (a, b) in cnt:\n        value[b] = tmp\n        tmp += 1\n    for x in tree[st]:\n        if x != last:\n            subval[st] += value[x] * subval[x]\nfor _ in range(int(input())):\n    (n, x) = ii()\n    tree = [[] for k in range(n)]\n    subval = [1 for k in range(n)]\n    value = [0 for k in range(n)]\n    for __ in range(n - 1):\n        (u, v) = ii()\n        tree[u - 1].append(v - 1)\n        tree[v - 1].append(u - 1)\n    dfs(0, tree, subval, value)\n    print(subval[0] % mod * x % mod % mod)", "import sys\nM = 10 ** 9 + 7\nsys.setrecursionlimit(100000000)\n\nclass Tree:\n\n    def __init__(self, n):\n        self.adj = [set() for _ in range(n + 1)]\n        self.priority = [1 for _ in range(n + 1)]\n        self.sum = 0\n\n    def __dfs_assign(self, node, parent):\n        if parent in self.adj[node]:\n            self.adj[node].remove(parent)\n        for v in self.adj[node]:\n            self.__dfs_assign(v, node)\n        for (i, v) in enumerate(sorted(self.adj[node], key=lambda n: self.priority[n], reverse=True), 1):\n            self.priority[node] += self.priority[v] * i\n\n    def __dfs_calc(self, node, parent, x):\n        for (i, v) in enumerate(sorted(self.adj[node], key=lambda n: self.priority[n], reverse=True), 1):\n            if v != parent:\n                self.sum += x * i % M\n                self.sum %= M\n                self.__dfs_calc(v, node, x * i)\n\n    def insertEdge(self, u, v):\n        self.adj[u].add(v)\n        self.adj[v].add(u)\n\n    def assignValue(self):\n        self.__dfs_assign(1, 0)\n\n    def minSum(self, x):\n        self.sum += x\n        self.__dfs_calc(1, 0, x)\n        return self.sum\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    tree = Tree(n)\n    for i in range(1, n):\n        tree.insertEdge(*map(int, input().split()))\n    tree.assignValue()\n    print(tree.minSum(x))", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(3100000)\nM = 1000000007\nvisited = [0] * (1000000 + 1)\n\ndef KZS(tree, node, level):\n    visited[node] = 1\n    for i in tree[node]:\n        if visited[i]:\n            continue\n        level[node].append(KZS(tree, i, level))\n    ll = len(level[node])\n    level[node].sort(reverse=True)\n    value = 1\n    for i in range(ll):\n        value += level[node][i] * (i + 1)\n    return value\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    tree = defaultdict(list)\n    for i in range(0, n + 1):\n        visited[i] = 0\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n    level = defaultdict(list)\n    ans = KZS(tree, 1, level) % M\n    print(ans * x % M)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(3100000)\nM = 1000000007\nvisited = [0] * (1000000 + 1)\n\ndef KZS(tree, node, level):\n    visited[node] = 1\n    for i in tree[node]:\n        if visited[i]:\n            continue\n        level[node].append(KZS(tree, i, level))\n    ll = len(level[node])\n    level[node].sort(reverse=True)\n    value = 1\n    for i in range(ll):\n        value += level[node][i] * (i + 1)\n    return value\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    tree = defaultdict(list)\n    for i in range(0, n + 1):\n        visited[i] = 0\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n    level = defaultdict(list)\n    ans = KZS(tree, 1, level) % M\n    print(ans * x % M)", "import sys\nsys.setrecursionlimit(5 * 10 ** 5)\nmodd = 1000000007\nimport collections\n\ndef depth(u, k=-1):\n    for x in g[u]:\n        if x == k:\n            continue\n        depth(x, u)\n    chroot = []\n    for x in g[u]:\n        if x != k:\n            chroot.append([ub[x], x])\n    chroot.sort(reverse=True)\n    text = 1\n    for (vox, iddd) in chroot:\n        alue[iddd] = text\n        text = text + 1\n    for x in g[u]:\n        if x != k:\n            ub[u] += alue[x] * ub[x]\nfor _ in range(int(input())):\n    (n, yy) = map(int, input().split())\n    g = collections.defaultdict(list)\n    for i in range(n - 1):\n        (x, y) = map(int, input().split())\n        g[x - 1].append(y - 1)\n        g[y - 1].append(x - 1)\n    ub = [1] * n\n    alue = [0] * n\n    depth(0)\n    sys.stdout.write(str(ub[0] % 1000000007 * yy % 1000000007 % 1000000007))\n    print()", "try:\n    import sys\n    from collections import defaultdict\n    sys.setrecursionlimit(10 ** 6)\n\n    def DepthFirstSearch(current, house, par, child, n, end):\n        for i in house[current]:\n            if i == end:\n                continue\n            DepthFirstSearch(i, house, par, child, n, current)\n        children = []\n        for i in house[current]:\n            if i != end:\n                children.append([par[i], i])\n        children.sort(reverse=True)\n        count = 1\n        for i in children:\n            child[i[1]] = count\n            count += 1\n        for i in house[current]:\n            if i != end:\n                par[current] += par[i] * child[i]\n    for _ in range(int(input())):\n        m = 10 ** 9 + 7\n        (n, x) = map(int, input().split())\n        par = [1] * n\n        child = [0] * n\n        house = defaultdict(list)\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            house[u - 1].append(v - 1)\n            house[v - 1].append(u - 1)\n        DepthFirstSearch(0, house, par, child, n, -1)\n        print(par[0] % m * (x % m) % m)\nexcept:\n    pass", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(curr, tree, parent, child, n, end):\n    for i in tree[curr]:\n        if i == end:\n            continue\n        dfs(i, tree, parent, child, n, curr)\n    children = []\n    for i in tree[curr]:\n        if i != end:\n            children.append([parent[i], i])\n    children.sort(reverse=True)\n    cnt = 1\n    for i in children:\n        child[i[1]] = cnt\n        cnt += 1\n    for i in tree[curr]:\n        if i != end:\n            parent[curr] += parent[i] * child[i]\ntry:\n    for test in range(int(input())):\n        mod = 10 ** 9 + 7\n        (N, X) = map(int, input().split())\n        parent = [1] * N\n        child = [0] * N\n        tree = defaultdict(list)\n        for i in range(N - 1):\n            (u, v) = map(int, input().split())\n            tree[u - 1].append(v - 1)\n            tree[v - 1].append(u - 1)\n        dfs(0, tree, parent, child, N, -1)\n        print(parent[0] % mod * (X % mod) % mod)\nexcept EOFError:\n    pass", "import sys\nsys.setrecursionlimit(110000)\nmod = 10 ** 9 + 7\n\ndef solve(t, i, parent):\n    arr = []\n    for child in t[i]:\n        if child != parent:\n            arr.append(solve(t, child, i))\n    arr.sort(reverse=True)\n    _sum = 1\n    for (i, j) in enumerate(arr):\n        _sum += (i + 1) * j\n    return _sum\nfor _ in range(int(input())):\n    (n, x) = list(map(int, input().split(' ')))\n    t = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split(' ')))\n        t[u].append(v)\n        t[v].append(u)\n    print(x * solve(t, 1, 0) % mod)", "import sys\nsys.setrecursionlimit(10 ** 8)\nmytree = []\nansarr = []\nmyarr = []\nch = []\nMOD = 1000000007\n\ndef DepthFirstSearch(present, lst):\n    for x in mytree[present]:\n        if x == lst:\n            continue\n        else:\n            DepthFirstSearch(x, present)\n    ch.clear()\n    for x in mytree[present]:\n        if x != lst:\n            mylist = [ansarr[x], x]\n            ch.append(mylist)\n    ch.sort(reverse=True)\n    tol = 1\n    for t in ch:\n        temp = t[1]\n        myarr[temp] += tol\n        tol += 1\n    for x in mytree[present]:\n        if x != lst:\n            ansarr[present] += myarr[x] * ansarr[x]\nfor _ in range(int(sys.stdin.readline())):\n    (n, m) = map(int, sys.stdin.readline().strip().split())\n    myarr = [0] * n\n    ansarr = [1] * n\n    mytree = [[] for i in range(n)]\n    for i in range(n - 1):\n        (x, y) = map(int, sys.stdin.readline().strip().split())\n        x -= 1\n        y -= 1\n        mytree[x].append(y)\n        mytree[y].append(x)\n    DepthFirstSearch(0, -1)\n    Answer = ansarr[0] % MOD * m % MOD\n    sys.stdout.write(str(Answer) + '\\n')\n    mytree.clear()\n    myarr.clear()\n    ansarr.clear()", "import sys\nsys.setrecursionlimit(10 ** 8)\nmytree = []\nansarr = []\nmyarr = []\nch = []\nMOD = 1000000007\n\ndef DepthFirstSearch(present, lst):\n    for x in mytree[present]:\n        if x == lst:\n            continue\n        else:\n            DepthFirstSearch(x, present)\n    ch.clear()\n    for x in mytree[present]:\n        if x != lst:\n            mylist = [ansarr[x], x]\n            ch.append(mylist)\n    ch.sort(reverse=True)\n    tol = 1\n    for t in ch:\n        temp = t[1]\n        myarr[temp] += tol\n        tol += 1\n    for x in mytree[present]:\n        if x != lst:\n            ansarr[present] += myarr[x] * ansarr[x]\nfor _ in range(int(sys.stdin.readline())):\n    (n, m) = map(int, sys.stdin.readline().strip().split())\n    myarr = [0] * n\n    ansarr = [1] * n\n    mytree = [[] for i in range(n)]\n    for i in range(n - 1):\n        (x, y) = map(int, sys.stdin.readline().strip().split())\n        x -= 1\n        y -= 1\n        mytree[x].append(y)\n        mytree[y].append(x)\n    DepthFirstSearch(0, -1)\n    Answer = ansarr[0] % MOD * m % MOD\n    sys.stdout.write(str(Answer) + '\\n')\n    mytree.clear()\n    myarr.clear()\n    ansarr.clear()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(tree, node, parent):\n    if len(tree[node]) == 0:\n        return 0\n    val = []\n    for i in range(len(tree[node])):\n        ans = 0\n        if tree[node][i] != parent:\n            ans = dfs(tree, tree[node][i], node)\n            val.append(ans)\n    val.sort(reverse=True)\n    ans = 0\n    count = 1\n    for i in val:\n        ans = ans + count + count * i\n        count += 1\n    return ans\nt = int(input())\nfor i in range(t):\n    (n, x) = list(map(int, input().strip().split()))\n    tree = [[] for i in range(300005)]\n    for j in range(n - 1):\n        (u, v) = list(map(int, input().strip().split()))\n        tree[u].append(v)\n        tree[v].append(u)\n    ans = (x + x * dfs(tree, 1, 0)) % (10 ** 9 + 7)\n    print(ans)", "import sys\nsys.setrecursionlimit(300000)\nmod = 10 ** 9 + 7\n\ndef dfs(now, adj, subval, val, lst=-1):\n    for x in adj[now]:\n        if x == lst:\n            continue\n        dfs(x, adj, subval, val, now)\n    ch = []\n    for x in adj[now]:\n        if x != lst:\n            ch.append([subval[x], x])\n    ch.sort(key=lambda x: x[0], reverse=True)\n    tok = 1\n    for (_val, id) in ch:\n        val[id] = tok\n        tok += 1\n    for x in adj[now]:\n        if x != lst:\n            subval[now] += val[x] * subval[x]\n\ndef solve():\n    (N, X) = map(int, input().split())\n    adj = [[] for i in range(N)]\n    subval = [1 for i in range(N)]\n    val = [0 for i in range(N)]\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    dfs(0, adj, subval, val)\n    print(subval[0] % mod * X % mod)\nfor _ in range(int(input())):\n    solve()", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(node, adj, parent, x):\n    val = []\n    for n in adj[node]:\n        if n != parent:\n            val.append(dfs(n, adj, node, x))\n    ls = len(val)\n    val.sort()\n    rev = [i + 1 for i in range(ls)][::-1]\n    total = x\n    for i in range(ls):\n        total += rev[i] * val[i]\n    return total\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for i in range(1, n):\n        (p, c) = map(int, input().split())\n        adj[p].append(c)\n        adj[c].append(p)\n    sum = dfs(1, adj, 0, x)\n    print(sum % 1000000007)", "import sys\nfrom os import path\nif path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n\ndef dfs(tree: list, depth: list, visited, node: int) -> int:\n    if visited[node]:\n        return 0\n    visited[node] = True\n    if not tree[node]:\n        depth[node] = 1\n        return 1\n    depth[node] = sum((dfs(tree, depth, visited, x) for x in tree[node])) + 1\n    return depth[node]\n\ndef put_values(tree: list, value: list, node: int) -> None:\n    x = value[node]\n    children: list = tree[node]\n    for child in children:\n        value[child] = x\n        put_values(tree, value, child)\n    child_with_value = [(value[child], child) for child in children]\n    child_with_value.sort(reverse=True)\n    for (index, (_, child)) in enumerate(child_with_value):\n        value[child] = (index + 1) * value[child]\n    value[node] = sum((value[child] for child in children)) + x\n\ndef put_values_with_stack(tree: list, value: list, node: int) -> None:\n    x = value[node]\n    stack = [node]\n    visited = [False for _ in range(len(value))]\n    while stack:\n        node = stack.pop()\n        children: list = tree[node]\n        if children:\n            if not visited[node]:\n                visited[node] = True\n                stack.append(node)\n                stack += children\n            else:\n                child_with_value = [(value[child], child) for child in children]\n                child_with_value.sort(reverse=True)\n                for (index, (_, child)) in enumerate(child_with_value):\n                    value[child] = (index + 1) * value[child]\n                value[node] = sum((value[child] for child in children)) + x\n        else:\n            value[node] = x\n\ndef create_proper_tree(tree, visited, node) -> None:\n    queue = [node]\n    while queue:\n        node = queue.pop()\n        visited[node] = True\n        to_remove = []\n        for child in tree[node]:\n            if visited[child]:\n                to_remove.append(child)\n                continue\n        for x in to_remove:\n            tree[node].remove(x)\n        for child in tree[node]:\n            queue.append(child)\n\ndef test_memory():\n    n = 300000\n    tree = [[] for _ in range(n + 1)]\n    for i in range(1, n):\n        tree[i].append(i + 1)\n        tree[i + 1].append(i)\n    print(sys.getsizeof(tree))\n    visited = [False for _ in range(2 * n + 1)]\n    create_proper_tree(tree, visited, 1)\n    value = [0 for _ in range(2 * n + 1)]\n    put_values_with_stack(tree, value, 1)\nt = int(input())\nwhile t != 0:\n    t -= 1\n    (n, x) = (int(x) for x in input().split())\n    tree = [[] for _ in range(2 * n + 1)]\n    value = [0 for _ in range(2 * n + 1)]\n    visited = [False for _ in range(2 * n + 1)]\n    for _ in range(n - 1):\n        (u, v) = (int(x) for x in input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    value[1] = x\n    visited = [False for _ in range(n + 1)]\n    try:\n        create_proper_tree(tree, visited, 1)\n        put_values_with_stack(tree, value, 1)\n        print(value[1] % 1000000007)\n    except:\n        raise\n        print(1)", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(3100000)\nM = 1000000007\nvisited = [0] * (1000000 + 1)\n\ndef KZS(tree, node, level):\n    visited[node] = 1\n    for i in tree[node]:\n        if visited[i]:\n            continue\n        level[node].append(KZS(tree, i, level))\n    ll = len(level[node])\n    level[node].sort(reverse=True)\n    value = 1\n    for i in range(ll):\n        value += level[node][i] * (i + 1)\n    return value\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    tree = defaultdict(list)\n    for i in range(0, n + 1):\n        visited[i] = 0\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n    level = defaultdict(list)\n    ans = KZS(tree, 1, level) % M\n    print(ans * x % M)", "import sys\n\ndef cal(adj, n):\n    val = [0] * n\n    wgt = [1] * n\n    stk = [[-1, 0, adj[0]]]\n    vst = [False] * n\n    while len(stk) > 0:\n        this = stk[-1]\n        prev = this[0]\n        curr = this[1]\n        chld = this[2]\n        if not vst[curr]:\n            vst[curr] = True\n            dive = False\n            for node in chld:\n                if node == prev:\n                    continue\n                stk.append([curr, node, adj[node]])\n                dive = True\n            if dive:\n                continue\n        wgts = []\n        for node in chld:\n            if node == prev:\n                continue\n            wgts.append([node, wgt[node]])\n        wgts.sort(reverse=True, key=lambda x: x[1])\n        cnt = 1\n        for i in wgts:\n            val[i[0]] = cnt\n            cnt += 1\n        for node in chld:\n            if node == prev:\n                continue\n            wgt[curr] += val[node] * wgt[node]\n        stk.pop()\n    return wgt[0]\n\ndef solution(inp):\n    mod = 10 ** 9 + 7\n    pos = 1\n    for i in range(int(inp[0])):\n        (n, x) = map(int, inp[pos].split())\n        pos += 1\n        adj = dict()\n        for j in range(pos, pos + n - 1):\n            (u, v) = map(int, inp[j].split())\n            u -= 1\n            v -= 1\n            if u in adj:\n                adj[u].append(v)\n            else:\n                adj[u] = [v]\n            if v in adj:\n                adj[v].append(u)\n            else:\n                adj[v] = [u]\n        pos += n - 1\n        ans = cal(adj, n) % mod * x % mod\n        print(ans)\n\ndef main():\n    inp = sys.stdin.read().split('\\n')\n    solution(inp)\nmain()", "import sys\nfrom collections import defaultdict\nsys.setrecursionlimit(3100000)\nM = 1000000007\nvisited = [0] * (1000000 + 1)\n\ndef KZS(tree, node, level):\n    visited[node] = 1\n    for i in tree[node]:\n        if visited[i]:\n            continue\n        level[node].append(KZS(tree, i, level))\n    level[node].sort(reverse=True)\n    ll = len(level[node])\n    value = 1\n    for i in range(ll):\n        value += level[node][i] * (i + 1)\n    return value\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    tree = defaultdict(list)\n    for i in range(0, n + 1):\n        visited[i] = 0\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        tree[a].append(b)\n        tree[b].append(a)\n    level = defaultdict(list)\n    ans = KZS(tree, 1, level) % M\n    print(ans * x % M)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    adj = [[] for i in range(n + 100)]\n\n    def addEdge(a, b):\n        adj[a].append(b)\n        adj[b].append(a)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        addEdge(u, v)\n    sub_val = [1] * (n + 100)\n    value = [0] * (n + 100)\n\n    def dfs(current, last):\n        for i in adj[current]:\n            if i == last:\n                continue\n            dfs(i, current)\n        queue = []\n        for i in adj[current]:\n            if i == last:\n                continue\n            queue.append([sub_val[i], i])\n        queue.sort(reverse=True)\n        temp = 1\n        for (i, j) in queue:\n            value[j] += temp\n            temp += 1\n        for i in adj[current]:\n            if i == last:\n                continue\n            sub_val[current] += value[i] * sub_val[i]\n    dfs(1, -1)\n    mod = 10 ** 9 + 7\n    ans = sub_val[1] % mod * k % mod\n    print(ans)\nexit()", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 7)\nmod = 10 ** 9 + 7\n\ndef value(v, x, parent):\n    l = []\n    for node in adj[v]:\n        if node != parent:\n            l.append(value(node, x, v))\n    l.sort(reverse=True)\n    ans = x\n    for (i, val) in enumerate(l):\n        ans += (i + 1) * val\n    return ans\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    print(x * value(1, 1, -1) % mod)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef traversal(node, parent):\n    for x in edges[node]:\n        if x != parent:\n            traversal(x, node)\n    child = []\n    for x in edges[node]:\n        if x != parent:\n            child.append((sum_child[x], x))\n    child.sort(reverse=True)\n    cnt = 1\n    for (_, idx) in child:\n        child_val[idx] = cnt\n        cnt += 1\n    for x in edges[node]:\n        if x != parent:\n            sum_child[node] += child_val[x] * sum_child[x]\nmod = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    (N, X) = map(int, input().split())\n    sum_child = [1] * N\n    child_val = [0] * N\n    edges = {}\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u = u - 1\n        v = v - 1\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    traversal(0, -1)\n    ans = sum_child[0] * X\n    print(ans % mod)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef traversal(node, parent=-1):\n    for x in edges[node]:\n        if x != parent:\n            traversal(x, node)\n    child = []\n    for x in edges[node]:\n        if x != parent:\n            child.append((sum_child[x], x))\n    child.sort(reverse=True)\n    cnt = 1\n    for (_, idx) in child:\n        child_val[idx] = cnt\n        cnt += 1\n    for x in edges[node]:\n        if x != parent:\n            sum_child[node] += child_val[x] * sum_child[x]\nmod = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    (N, X) = map(int, input().split())\n    sum_child = [1] * N\n    child_val = [0] * N\n    edges = {}\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u = u - 1\n        v = v - 1\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    traversal(0)\n    ans = sum_child[0] * X\n    print(ans % mod)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef traversal(node, parent=-1):\n    for x in edges[node]:\n        if x == parent:\n            continue\n        traversal(x, node)\n    child = []\n    for x in edges[node]:\n        if x != parent:\n            child.append((sum_child[x], x))\n    child.sort(reverse=True)\n    cnt = 1\n    for (_, idx) in child:\n        child_val[idx] = cnt\n        cnt += 1\n    for x in edges[node]:\n        if x != parent:\n            sum_child[node] += child_val[x] * sum_child[x]\nmod = 10 ** 9 + 7\nT = int(input())\nfor _ in range(T):\n    (N, X) = map(int, input().split())\n    sum_child = [1] * N\n    child_val = [0] * N\n    edges = {}\n    for i in range(N - 1):\n        (u, v) = map(int, input().split())\n        u = u - 1\n        v = v - 1\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    traversal(0)\n    ans = sum_child[0] * X\n    print(ans % mod)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom collections import defaultdict\n\ndef addEdge(graph, u, v):\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef method_1(val_node, val_under_node, graph, current, parent):\n    arr = []\n    for v in graph[current]:\n        if v != parent:\n            method_1(val_node, val_under_node, graph, v, current)\n            arr.append((val_under_node[v], v))\n        else:\n            continue\n    arr.sort(reverse=True)\n    temp = 1\n    for i in arr:\n        val_node[i[1]] = temp\n        temp = temp + 1\n    for v in graph[current]:\n        if v != parent:\n            val_under_node[current] = val_under_node[current] + val_node[v] * val_under_node[v]\nt = int(input())\nfor _ in range(t):\n    (n, x) = map(int, input().split())\n    graph = defaultdict(list)\n    val_node = [0] * n\n    val_under_node = [1] * n\n    for __ in range(n - 1):\n        (u, v) = map(int, input().split())\n        addEdge(graph, u - 1, v - 1)\n    method_1(val_node, val_under_node, graph, 0, -1)\n    print(val_under_node[0] * x % (10 ** 9 + 7))", "from collections import defaultdict, deque\nPRIME = int(1000000000.0 + 7)\n\ndef BuildTree(root, adjacencies):\n    parents = {}\n    children = defaultdict(list)\n    queue = deque([(root, None)])\n    while len(queue) > 0:\n        (node, parent) = queue.popleft()\n        parents[node] = parent\n        children[parent].append(node)\n        for nbr in adjacencies[node]:\n            if nbr != parent:\n                queue.append((nbr, node))\n    return (parents, children)\n\ndef PostOrderTraversal(children):\n    output = deque()\n    stack = [1]\n    while len(stack) > 0:\n        node = stack.pop()\n        output.appendleft(node)\n        if node not in children:\n            continue\n        for child in children[node]:\n            stack.append(child)\n    return output\n\ndef Traverse(traversal, parents):\n    values = defaultdict(list)\n    for node in traversal:\n        total = 1\n        if node in values:\n            r = sorted(values[node], reverse=True)\n            for (index, val) in enumerate(r):\n                total = total + (index + 1) * val\n        values[parents[node]].append(total)\n    return values[None][0]\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, X) = [int(y) for y in input().split()]\n        adjacencies = defaultdict(list)\n        for _ in range(N - 1):\n            (u, v) = [int(y) for y in input().split()]\n            adjacencies[u].append(v)\n            adjacencies[v].append(u)\n        (parents, children) = BuildTree(1, adjacencies)\n        traversal = PostOrderTraversal(children)\n        minSum = Traverse(traversal, parents)\n        print(X * minSum % PRIME)\nmain()", "t = int(input())\nimport sys\nsys.setrecursionlimit(500000)\nmod = 10 ** 9 + 7\nfor _ in range(t):\n    (n, x) = map(int, input().strip().split())\n    nodes = [list() for i in range(n)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().strip().split())\n        nodes[a - 1].append(b - 1)\n        nodes[b - 1].append(a - 1)\n    visited = set()\n\n    def recurse(ind):\n        visited.add(ind)\n        temp = []\n        for child in nodes[ind]:\n            if child not in visited:\n                temp.append(recurse(child))\n        temp.sort(reverse=True)\n        z = 1\n        i = 0\n        val = 0\n        while i < len(temp):\n            some = z * temp[i]\n            val = val + some\n            i += 1\n            z += 1\n        return val + 1\n    ans = recurse(0)\n    print(ans % mod * (x % mod) % mod)", "if 1 == 1:\n    import sys\n    sys.setrecursionlimit(10 ** 9)\n\n    class trees:\n        k = 0\n        visited = 0\n        vals = 0\n        muls = 0\n\n    def DFS(node, tree, first=-1):\n        MOD = 10 ** 9 + 7\n        for i in range(len(tree[node])):\n            if tree[node][i] != first:\n                DFS(tree[node][i], tree, node)\n        a = list()\n        for i in range(len(tree[node])):\n            if tree[node][i] != first:\n                a.append(trees.vals[tree[node][i]])\n        a.sort(reverse=True)\n        for k in range(len(a)):\n            trees.vals[node] = trees.vals[node] + (k + 1) * a[k]\n        a.clear()\n    for _ in range(int(input())):\n        MOD = 10 ** 9 + 7\n        (n, x) = map(int, input().split())\n        tree = [[] for _ in range(n + 1)]\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            tree[u].append(v)\n            tree[v].append(u)\n        trees.visited = [True for _ in range(n + 1)]\n        trees.vals = [x for _ in range(n + 1)]\n        DFS(1, tree)\n        print(trees.vals[1] % MOD)", "from collections import deque\nimport time\n\ndef modular_exponentiation(x, y, p):\n    res = 1\n    x = x % p\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef transverse(child, n, x, count_child, parent, level):\n    p = 10 ** 9 + 7\n    value = [0] * (n + 1)\n    visit = [False] * (n + 1)\n    queue = deque()\n    queue.append((1, 1))\n    value[1] = x\n    while queue:\n        s = queue.popleft()\n        x = value[s[0]]\n        visit[s[0]] == True\n        i = 1\n        for vertice in sorted(child[s[0]], key=lambda x: (count_child[x], n + 1 - level[x]), reverse=True):\n            if visit[vertice] == False and vertice != s[1]:\n                value[vertice] = x * i\n                i += 1\n                visit[vertice] = True\n                queue.append((vertice, s[0]))\n    print(sum(value) % p)\n\ndef bfs(node, tree, n):\n    count_child = [0] * (n + 1)\n    count_child[1] = -1\n    ans = [0] * (n + 1)\n    vis = [0] * (n + 1)\n    qu = deque()\n    qu.append((node, 1))\n    while qu:\n        p = qu.popleft()\n        ans[p[0]] = p[1]\n        count_child[p[1]] += 1\n        vis[p[0]] = True\n        for child in tree[p[0]]:\n            if not vis[child]:\n                qu.append((child, p[0]))\n    return (count_child, ans)\n\ndef dfs(node, par):\n    for x in child[node]:\n        if x == par:\n            continue\n        dfs(x, node)\n    c = []\n    for x in child[node]:\n        if x != par:\n            c.append((sub_val[x], x))\n    c.sort(reverse=True)\n    k = 1\n    for (m, n) in c:\n        value[n] += k\n        k += 1\n    for x in child[node]:\n        if x != par:\n            sub_val[node] += value[x] * sub_val[x]\ntry:\n    start = time.time()\n    t = int(input())\n    p = 10 ** 9 + 7\n    while t:\n        t -= 1\n        child = [[] for i in range(4)]\n        (n, x) = map(int, input().split())\n        child = [[] for i in range(n + 1)]\n        sub_val = [1] * (n + 1)\n        value = [0] * (n + 1)\n        level = [1] * (n + 1)\n        for i in range(n - 1):\n            (u, v) = map(int, input().split())\n            child[u].append(v)\n            child[v].append(u)\n        all_children = [0] * (n + 1)\n        all_children[1] = n - 1\n        (immed_child, parent) = bfs(1, child, n)\n        if immed_child.count(1) >= n // 2:\n            all_child = [0] * (n + 1)\n            for i in range(n, 1, -1):\n                level[parent[i]] = max(level[parent[i]], level[i] + 1)\n                if immed_child[i] == 0:\n                    all_child[parent[i]] = all_child[parent[i]] + immed_child[i] + 1\n                else:\n                    all_child[parent[i]] = all_child[parent[i]] + all_child[i] + 1\n            transverse(child, n, x, all_child, parent, level)\n        else:\n            dfs(1, 1)\n            print(sub_val[1] % p * x % p)\n    end = time.time()\nexcept:\n    pass", "mod = 10 ** 9 + 7\nimport sys\nsys.setrecursionlimit(300000)\n\nclass Tree:\n\n    def __init__(self, n):\n        self.nodes = []\n        for i in range(n + 1):\n            self.nodes.append([])\n\ndef checkUtil(t, x, parent):\n    k = []\n    sum = 1\n    for i in t.nodes[x]:\n        if i != parent:\n            if len(t.nodes[i]) > 1:\n                k.append(checkUtil(t, i, x))\n            else:\n                k.append(1)\n    k.sort(reverse=True)\n    for i in range(1, len(k) + 1):\n        sum += i * k[i - 1]\n    return sum\n\ndef check(t, x):\n    k = []\n    sum = 1\n    for i in t.nodes[x]:\n        if len(t.nodes[i]) > 1:\n            k.append(checkUtil(t, i, x))\n        else:\n            k.append(1)\n    k.sort(reverse=True)\n    for i in range(1, len(k) + 1):\n        sum += i * k[i - 1]\n    return sum\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    t = Tree(n)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        t.nodes[u].append(v)\n        t.nodes[v].append(u)\n    y = check(t, 1) % mod\n    res = x * y % mod\n    print(res)", "import sys\nsys.setrecursionlimit(pow(10, 6))\nvis = set()\n\ndef dfs(c):\n    ans = 1\n    nans = []\n    vis.add(c)\n    for i in g[c]:\n        if i in vis:\n            continue\n        nans.append(dfs(i))\n    k = sorted(nans, reverse=True)\n    for (i, j) in enumerate(k):\n        ans += j * (i + 1)\n    return ans\n    print(k)\nm = 1000000007\nfor _ in range(int(input())):\n    vis = set()\n    (n, x) = map(int, input().split(' '))\n    g = list(([] for i in range(n + 1)))\n    for i in range(n - 1):\n        (u, v) = map(int, input().split(' '))\n        g[u].append(v)\n        g[v].append(u)\n    print(dfs(1) * x % m)", "try:\n    from collections import defaultdict\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n\n    def sol(r):\n        (ans, m) = (1, len(r))\n        for kk in range(m - 1, -1, -1):\n            ans = ans + (m - kk) * r[kk]\n        return ans\n\n    def trav(g, a, b, l):\n        for jj in g[a]:\n            if b != jj:\n                l.append(trav(g, jj, a, []))\n        return sol(sorted(l))\n    for ii in range(int(input())):\n        (n, x) = map(int, input().split())\n        t = defaultdict(list)\n        for jj in range(n - 1):\n            (u, v) = map(int, input().split())\n            t[u].append(v)\n            t[v].append(u)\n        res = x * (trav(t, 1, -1, []) % (10 ** 9 + 7)) % (10 ** 9 + 7)\n        print(res)\nexcept:\n    pass", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef solve():\n    (n, m) = map(int, input().split())\n    answer = [1] * (n + 1)\n    multiplier = [0] * (n + 1)\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(root, t=-1):\n        for node in adj[root]:\n            if node == t:\n                continue\n            dfs(node, root)\n        ch = []\n        for node in adj[root]:\n            if node != t:\n                ch.append((answer[node], node))\n        ch.sort(reverse=True)\n        temp = 1\n        for (a, b) in ch:\n            multiplier[b] = temp\n            temp += 1\n        for node in adj[root]:\n            if node != t:\n                answer[root] += multiplier[node] * answer[node]\n    dfs(1)\n    print(answer[1] * m % (10 ** 9 + 7))\nfor _ in range(int(input())):\n    solve()", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(110000)\nM = 10 ** 9 + 7\n\nclass Edge:\n\n    def __init__(self, u, v):\n        self.u = u\n        self.v = v\n\nclass Graph:\n\n    def __init__(self, V, val):\n        self.V = V\n        self.nodes = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.nodes[u].append(Edge(u, v))\n\n    def adj(self, u):\n        return self.nodes[u]\n\ndef calculateChild(graph, u, visited):\n    visited.add(u)\n    if len(graph.adj(u)) == 0:\n        return 1\n    l = []\n    for edge in graph.adj(u):\n        if edge.v not in visited:\n            l.append(calculateChild(graph, edge.v, visited))\n    summ = 0\n    l.sort(reverse=True)\n    for (count, i) in enumerate(l, 1):\n        summ = summ + i * count\n    summ += 1\n    return summ\nt = int(input())\nfor i in range(t):\n    (n, x) = list(map(int, input().split()))\n    graph = Graph(n, x)\n    for i in range(n - 1):\n        (u, v) = list(map(int, input().split()))\n        graph.addEdge(u, v)\n        graph.addEdge(v, u)\n    visited = set()\n    ans = calculateChild(graph, 1, visited)\n    print(ans * x % M)", "import sys\n\ndef input():\n    return sys.stdin.readline().strip()\n\ndef iinput():\n    return int(input())\n\ndef rinput():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_list():\n    return list(map(int, sys.stdin.readline().strip().split()))\nmod = 10 ** 9 + 7\nsys.setrecursionlimit(10 ** 6)\n\ndef func(present, parent):\n    for i in d[present]:\n        if i != parent:\n            func(i, present)\n    li = [[l1[x], x] for x in d[present] if x != parent]\n    li.sort(reverse=True)\n    count = 1\n    for item in li:\n        (l2i, xi) = item\n        l2[xi] = count\n        count += 1\n    for i in d[present]:\n        if i != parent:\n            l1[present] += l2[i] * l1[i]\nt = iinput()\nwhile t > 0:\n    (n, x) = rinput()\n    d = {}\n    for i in range(1, n + 1):\n        d[i] = []\n    for _ in range(n - 1):\n        (a, b) = rinput()\n        d[a].append(b)\n        d[b].append(a)\n    for i in d:\n        d[i].sort()\n    l1 = [1] * (n + 1)\n    l2 = [0] * (n + 1)\n    func(1, -1)\n    s = l1[1] % mod * x % mod\n    print(s % mod)\n    t -= 1", "import sys\nimport bisect\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\nmod = 10 ** 9 + 7\n\ndef calcSum(adj, s, l=-1):\n    temp = []\n    for z in adj[s]:\n        if z != l:\n            bisect.insort(temp, calcSum(adj, z, s))\n    length = len(temp)\n    return 1 + sum([i * temp[length - i] for i in range(1, length + 1)])\nfor _ in range(int(sys.stdin.readline())):\n    (n, x) = map(int, sys.stdin.readline().split())\n    adj = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, sys.stdin.readline().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    print(calcSum(adj, 1) * x % mod)", "import sys\nsys.setrecursionlimit(400000)\n\ndef _recursion(Adj, lens, Nodes, node):\n    for i in range(lens[node]):\n        Nodes[node].add_child(Nodes[Adj[node][i]])\n        Adj[Adj[node][i]].remove(node)\n        lens[Adj[node][i]] -= 1\n        _recursion(Adj, lens, Nodes, Adj[node][i])\n\ndef recursion(node):\n    if node.isleaf:\n        return 1\n    Sums = []\n    for child in node.children:\n        Sums.append(recursion(child))\n    Sums.sort(reverse=True)\n    Sum = 1\n    for i in range(node.length):\n        Sum += Sums[i] * (i + 1)\n    return Sum\n\nclass Node:\n\n    def __init__(self):\n        self.children = []\n        self.length = 0\n        self.isleaf = True\n\n    def add_child(self, node):\n        self.children.append(node)\n        self.length += 1\n        self.isleaf = False\nt = int(input())\nassert 1 <= t <= 15\nfor _ in range(t):\n    (n, x) = tuple(map(int, input().split()))\n    assert 2 <= n <= 300000\n    assert 1 <= x <= 1000000000\n    Nodes = [Node() for i in range(n)]\n    Adj = [[] for i in range(n)]\n    lens = [0 for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = tuple(map(int, input().split()))\n        assert 1 <= u <= n and 1 <= v <= n and (u != v)\n        Adj[u - 1].append(v - 1)\n        lens[u - 1] += 1\n        Adj[v - 1].append(u - 1)\n        lens[v - 1] += 1\n    _recursion(Adj, lens, Nodes, 0)\n    print(recursion(Nodes[0]) * x % 1000000007)", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(300005)\nM = 10 ** 9 + 7\nt = int(input())\nfor _ in range(t):\n    (n, x) = [int(ele) for ele in input().split()]\n    dic = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = [int(ele) for ele in input().split()]\n        dic[u].append(v)\n        dic[v].append(u)\n    values = [0] * (n + 1)\n    values[1] = x\n    nodes = [0] * (n + 1)\n\n    def tmp(s):\n        ans = 0\n        for child in dic[s]:\n            ans += tmp(child)\n        nodes[s] = ans + 1\n        return nodes[s]\n\n    def rec(s, x):\n        values[s] = x\n        tmp = 0\n        for child in sorted(dic[s], key=lambda x: -nodes[x]):\n            tmp = (tmp + x) % M\n            rec(child, tmp)\n\n    def f(s, last=-1):\n        child_ans_list = []\n        for child in dic[s]:\n            if child == last:\n                continue\n            child_ans_list.append(f(child, s))\n        child_ans_list.sort(reverse=True)\n        tmp = 0\n        res = 1\n        for ch in child_ans_list:\n            tmp = (tmp + 1) % M\n            res = res + ch * tmp\n        return res\n    print(x * f(1) % M)", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nmod = 1000000007\nsys.setrecursionlimit(depth)\n\ndef dfs(u, p):\n    vals = []\n    for v in adj[u]:\n        if v != p:\n            vals.append(dfs(v, u))\n    (res, i) = (1, 1)\n    vals.sort(reverse=True)\n    for e in vals:\n        res += e * i\n        i += 1\n    return res\nfor _ in range(int(input())):\n    (n, x) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    ans = dfs(1, 1) % mod\n    ans = ans * x % mod\n    print(ans)", "from sys import stdin, setrecursionlimit as srl\nip = stdin.readline\nsrl(int(1000000.0))\nfor _ in range(int(ip())):\n    (n, x) = map(int, ip().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, ip().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def ans(root, last):\n        rank = [ans(child, root) for child in graph[root] if not child == last]\n        rank.sort(reverse=True)\n        return sum(((i + 1) * rank[i] for i in range(len(rank)))) + 1\n    print(ans(1, -1) * x % (int(1000000000.0) + 7))"]