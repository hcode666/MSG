["import sys\nsys.setrecursionlimit(10000)\n\ndef solve(arr, N, Z):\n    if Z == 0:\n        return 0\n    cur = best = sum(arr[-Z:])\n    for i in range(1, N - Z + 1):\n        cur -= i * (arr[-i] - arr[-i - 1])\n        cur += arr[-i - Z]\n        if cur < best:\n            best = cur\n    if Z > 1:\n        alternative = arr[0] * N + solve([x - arr[0] for x in arr[1:]], N - 1, Z - 1)\n        if alternative < best:\n            best = alternative\n    return best\nfor _ in range(int(input())):\n    (N, Z) = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    print(solve(A, N, Z))", "import sys\nsys.setrecursionlimit(10000)\n\ndef solve(arr, N, Z):\n    if Z == 0:\n        return 0\n    cur = best = sum(arr[-Z:])\n    for i in range(1, N - Z + 1):\n        cur -= i * (arr[-i] - arr[-i - 1])\n        cur += arr[-i - Z]\n        if cur < best:\n            best = cur\n    if Z > 1:\n        alternative = arr[0] * N + solve([x - arr[0] for x in arr[1:]], N - 1, Z - 1)\n        if alternative < best:\n            best = alternative\n    return best\nfor _ in range(int(input())):\n    (N, Z) = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    print(solve(A, N, Z))", "import sys\nsys.setrecursionlimit(10000)\n\ndef solve(arr, N, Z):\n    if Z == 0:\n        return 0\n    cur = best = sum(arr[-Z:])\n    for i in range(1, N - Z + 1):\n        cur -= i * (arr[-i] - arr[-i - 1])\n        cur += arr[-i - Z]\n        if cur < best:\n            best = cur\n    if Z > 1:\n        alternative = arr[0] * N + solve([x - arr[0] for x in arr[1:]], N - 1, Z - 1)\n        if alternative < best:\n            best = alternative\n    return best\nfor _ in range(int(input())):\n    (N, Z) = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    print(solve(A, N, Z))", "import sys\nsys.setrecursionlimit(10000)\n\ndef solve(arr, N, Z):\n    if Z == 0:\n        return 0\n    cur = best = sum(arr[-Z:])\n    for i in range(1, N - Z + 1):\n        cur -= i * (arr[-i] - arr[-i - 1])\n        cur += arr[-i - Z]\n        if cur < best:\n            best = cur\n    if Z > 1:\n        alternative = arr[0] * N + solve([x - arr[0] for x in arr[1:]], N - 1, Z - 1)\n        if alternative < best:\n            best = alternative\n    return best\nfor _ in range(int(input())):\n    (N, Z) = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    print(solve(A, N, Z))", "from sys import stdin, stdout\ninf = 1000000000000007\n\ndef solve(n, z):\n    dp = [[inf for j in range(n)] for i in range(z + 1)]\n    a = []\n    a = [int(i) for i in stdin.readline().split()]\n    a.sort(reverse=True)\n    cv_hullx = [[] for j in range(z + 1)]\n    cv_hully = [[] for j in range(z + 1)]\n    for i in range(n):\n        for j in range(1, z + 1):\n            if j == 1:\n                dp[j][i] = (i + 1) * a[i]\n            elif i >= j - 1:\n                k = len(cv_hullx[j - 1])\n                while k >= 2 and cv_hully[j - 1][k - 1] - cv_hully[j - 1][k - 2] >= (cv_hullx[j - 1][k - 1] - cv_hullx[j - 1][k - 2]) * a[i]:\n                    k -= 1\n                    cv_hullx[j - 1].pop()\n                    cv_hully[j - 1].pop()\n                dp[j][i] = cv_hully[j - 1][k - 1] + (i - cv_hullx[j - 1][k - 1]) * a[i]\n        for j in range(1, z + 1):\n            if i >= j - 1:\n                k = len(cv_hullx[j])\n                while k >= 2 and (cv_hully[j][k - 1] - cv_hully[j][k - 2]) * (i - cv_hullx[j][k - 1]) >= (dp[j][i] - cv_hully[j][k - 1]) * (cv_hullx[j][k - 1] - cv_hullx[j][k - 2]):\n                    k -= 1\n                    cv_hullx[j].pop()\n                    cv_hully[j].pop()\n                cv_hullx[j].append(i)\n                cv_hully[j].append(dp[j][i])\n    return min(dp[z])\nfor t in range(int(stdin.readline())):\n    (n, z) = [int(i) for i in stdin.readline().split()]\n    print(solve(n, z))", "def solve(line1, line2):\n    (m1, c1) = line1\n    (m2, c2) = line2\n    return (c2 - c1) / (m1 - m2)\n\ndef find(A, Z):\n    N = len(A)\n    A = [10 ** 10] + sorted(A)[::-1]\n    dp = [[10 ** 10 for j in range(Z + 1)] for k in range(N + 1)]\n    for i in range(1, N + 1):\n        dp[i][1] = i * A[i]\n    from collections import deque\n    for z in range(2, Z + 1):\n        temp = 10 ** 10\n        intersections = [0]\n        lines = [(-(z - 1), dp[z - 1][z - 1])]\n        for k in range(z, N + 1):\n            line = (-k, dp[k][z - 1])\n            while intersections:\n                if intersections[-1] > A[k]:\n                    intersections.pop()\n                    lines.pop()\n                else:\n                    break\n            (m0, c0) = lines[-1]\n            ans = m0 * A[k] + c0\n            dp[k][z] = ans + k * A[k]\n            if line[0] * A[k] + line[1] >= ans:\n                continue\n            while lines:\n                inter = solve(lines[-1], line)\n                (m, c) = line\n                (m0, c0) = lines[-1]\n                pos = intersections[-1]\n                if inter < pos and m * pos + c < m0 * pos + c0:\n                    lines.pop()\n                    intersections.pop()\n                else:\n                    break\n            lines += [line]\n            intersections += [max(inter, 0)]\n    return min([dp[i][Z] for i in range(1, N + 1)])\nfor _ in range(int(input())):\n    (N, Z) = list(map(int, input().strip().split(' ')))\n    A = list(map(int, input().strip().split(' ')))\n    print(find(A, Z))", "for _ in range(int(input())):\n    (n, z) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    l1 = []\n    c = 0\n    q = l[:]\n    for j in range(z, 0, -1):\n        temp = []\n        for i in range(len(q) - j + 1):\n            temp.append((i + 1) * q[i] + sum(q[i + 1:i + j]))\n        l1.append(min(temp) + c)\n        c += len(q) * q[-1]\n        q = [x - q[-1] for x in q]\n        j = -1\n        del q[-1]\n    print(min(l1))", "for _ in range(int(input())):\n    (n, z) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    l1 = []\n    c = 0\n    q = l[:]\n    for j in range(z, 0, -1):\n        temp = []\n        for i in range(len(q) - j + 1):\n            temp.append((i + 1) * q[i] + sum(q[i + 1:i + j]))\n        l1.append(min(temp) + c)\n        c += len(q) * q[-1]\n        q = [x - q[-1] for x in q]\n        j = -1\n        del q[-1]\n    print(min(l1))", "for t in range(int(input())):\n    (n, z) = list(map(int, input().split()))\n    a = list(map(int, input().split()))\n    a.sort()\n    b = []\n    for x in a:\n        b.append(x)\n    for i in range(1, n):\n        b[i] += b[i - 1]\n    if z == n:\n        print(b[n - 1])\n        continue\n    c = [-1] * n\n    i = n - z\n    while i > 0:\n        c[i] = b[i + z - 1] - b[i - 1] + (n - z - i) * a[i + z - 1]\n        i -= 1\n    c[0] = b[z - 1] + (n - z) * a[z - 1]\n    min_v = c[0]\n    for x in c:\n        if min_v > x and x != -1:\n            min_v = x\n    sum_v = 0\n    for j in range(1, z + 1):\n        c = [-1] * n\n        sum_v += b[j - 1] * (n + 1 - j)\n        i = j\n        k = 2\n        while i < n:\n            b[i] -= k * b[j - 1]\n            a[i] -= b[j - 1]\n            i += 1\n            k += 1\n        a[j - 1] = 0\n        b[j - 1] = 0\n        i = n - z + j\n        while i > 0:\n            if i < n:\n                c[i] = b[i + z - j - 1] - b[i - 1] + (n - z + j - i) * a[i + z - j - 1]\n            i -= 1\n        i = j\n        while i < n:\n            if min_v > c[i] + sum_v and c[i] != -1:\n                min_v = c[i] + sum_v\n            i += 1\n    print(min_v)", "t = int(input())\nmaxi = 10 ** 18\nimport sys\nsys.setrecursionlimit(10000)\n\ndef cal(low, high):\n    score = maxi\n    index = -maxi\n    num = -maxi\n    for i in range(low, high + 1):\n        temp = l[i] * (high - (i - 1))\n        if temp < score:\n            index = i\n            score = temp\n            num = high - i\n    return [score, index, num]\n\ndef find():\n    index = 0\n    num = 0\n    score = maxi\n    for i in range(len(mat)):\n        if mat[i][0] == score and mat[i][2] > num:\n            num = mat[i][2]\n            index = i\n        elif mat[i][0] < score:\n            num = mat[i][2]\n            score = mat[i][0]\n            index = i\n    return index\n\ndef altans(low, high, z):\n    if z == 0:\n        return maxi\n    else:\n        la = 0\n        s = sum(rev_l[:z])\n        out = s\n        for i in range(low, high - z + 1):\n            s += rev_l[(i + z) % n]\n            s -= rev_l[i % n]\n            la += 1\n            score = s + rev_l[(i + 1) % n] * la\n            out = min(out, score)\n        for i in range(low, high):\n            rev_l[i] -= rev_l[high]\n        ans = min(out, rev_l[high] * (high - low + 1) + altans(low, high - 1, z - 1))\n        return ans\nfor tcases in range(t):\n    (n, z) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort()\n    rev_l = l[::-1]\n    v = [[0, n - 1]]\n    h = 0\n    for zz in range(z):\n        mat = []\n        for i in range(len(v)):\n            temp = cal(v[i][0], v[i][1])\n            temp.append(i)\n            mat.append(temp)\n        k = find()\n        if mat[k][0] == maxi:\n            mat[k][0] = 0\n            break\n        else:\n            h += mat[k][0]\n            l1 = v[mat[k][3]][0]\n            l2 = mat[k][1] + 1\n            h1 = mat[k][1] - 1\n            h2 = v[mat[k][3]][1]\n            del v[mat[k][3]]\n            if h1 >= l1:\n                v.append([l1, h1])\n            if h2 >= l2:\n                v.append([l2, h2])\n                for i in range(l2, h2 + 1):\n                    l[i] -= l[mat[k][1]]\n    alth = altans(0, n - 1, z)\n    fans = min(h, alth)\n    print(fans)", "def get_input_line():\n    return input()\n\ndef solve_small(numbers, n, _):\n    sorted_numbers = sorted(numbers)\n    factors = [i for i in range(n, 0, -1)]\n    return min([n * f for (n, f) in zip(sorted_numbers, factors)])\n\ndef solve_med(numbers, n, z):\n    if z == n:\n        return sum(numbers)\n    sorted_numbers = sorted(numbers)\n    partial_sums = [sum(sorted_numbers[:z])]\n    for i in range(1, n - z + 1):\n        prev_sum = partial_sums[-1]\n        curr_sum = prev_sum - sorted_numbers[i - 1] + sorted_numbers[i + z - 1]\n        partial_sums.append(curr_sum)\n    min_sum = 0\n    for i in range(n - z + 1):\n        total_sum = partial_sums[i] + sorted_numbers[i + z - 1] * (n - z - i)\n        if not min_sum or total_sum < min_sum:\n            min_sum = total_sum\n    for n_ in range(n, z - 1, -1):\n        for i in range(z, -1, -1):\n            left = i\n            right = z - i\n            between = n_ - z\n            if left == 0:\n                between = 0\n            left_sum = sum(sorted_numbers[:left])\n            right_sum = sum(sorted_numbers[n_ - right:n_])\n            between_sum = between * sorted_numbers[i - 1]\n            extra_sum = (n - n_) * sorted_numbers[n_ - 1]\n            total_sum = left_sum + between_sum + right_sum + extra_sum\n            min_sum = min(min_sum, total_sum)\n    return min_sum\n\ndef solve_big(numbers, n, z):\n    sorted_numbers = sorted(numbers)\n    min_sum = 0\n    prev_partial_sum = sum(sorted_numbers[:z])\n    curr_partial_sum = prev_partial_sum\n    for i in range(n - z + 1):\n        right = sorted_numbers[i + z - 1]\n        multiplier = n - z - i\n        if i > 0:\n            prev_partial_sum = curr_partial_sum\n            curr_partial_sum = prev_partial_sum - sorted_numbers[i - 1] + sorted_numbers[i + z - 1]\n        curr_sum = curr_partial_sum + right * multiplier\n        if not min_sum or curr_sum < min_sum:\n            min_sum = curr_sum\n    reverse_partial_sum = [0] * n\n    for i in range(n - 1, -1, -1):\n        reverse_partial_sum[i] = sorted_numbers[i]\n        if i < n - 1:\n            reverse_partial_sum[i] += reverse_partial_sum[i + 1]\n    for n_ in range(z, n + 1):\n        for i in range(z, -1, -1):\n            left = i\n            right = z - i\n            between = n_ - z\n            if left == 0:\n                between = 0\n            left_sum = reverse_partial_sum[0]\n            if left < n:\n                left_sum -= reverse_partial_sum[left]\n            right_sum = 0\n            if n_ - right < n:\n                right_sum = reverse_partial_sum[n_ - right]\n                if n_ < n:\n                    right_sum -= reverse_partial_sum[n_]\n            between_sum = between * sorted_numbers[i - 1]\n            extra_sum = (n - n_) * sorted_numbers[n_ - 1]\n            total_sum = left_sum + between_sum + right_sum + extra_sum\n            min_sum = min(min_sum, total_sum)\n    return min_sum\n\ndef main():\n    t = int(get_input_line())\n    for i in range(t):\n        (n, z) = map(int, get_input_line().split())\n        numbers = list(map(int, get_input_line().split()))\n        result = solve_big(numbers, n, z)\n        print(result)\n\ndef _check_differences(n, z, tests=1000):\n    import random\n    for i in range(tests):\n        numbers = [random.randint(1, 10) for _ in range(n)]\n        rs = solve_big(numbers, n, z)\n        rb = solve_med(numbers, n, z)\n        if rs != rb:\n            print(n, z)\n            print(sorted(numbers), rs, rb)\n            exit()\n\ndef _check_performance(n, z, tests=1000):\n    import random\n    import time\n    all_numbers = []\n    for i in range(tests):\n        numbers = [random.randint(1, 10) for _ in range(n)]\n        all_numbers.append(numbers)\n    t1 = time.time()\n    all_rs = []\n    for i in range(tests):\n        rs = solve_big(all_numbers[i], n, z)\n        all_rs.append(rs)\n    t2 = time.time()\n    all_rb = []\n    for i in range(tests):\n        rb = solve_med(all_numbers[i], n, z)\n        all_rb.append(rb)\n    t3 = time.time()\n    for (numbers, rs, rb) in zip(all_numbers, all_rs, all_rb):\n        if rs != rb:\n            print(sorted(numbers), rs, rb)\n            exit()\n    print('rs: {}, rb: {}'.format(t2 - t1, t3 - t2))\nmain()", "T = int(input())\nwhile T > 0:\n    T -= 1\n    (N, Z) = map(int, input().split())\n    S = list(map(int, input().split()))\n    S.sort(reverse=True)\n    answer = []\n    steps = 0\n    Q = S[:]\n    for j in range(Z, 0, -1):\n        TempSubAns = []\n        for i in range(len(Q) - j + 1):\n            TempSubAns.append((i + 1) * Q[i] + sum(Q[i + 1:i + j]))\n        answer.append(min(TempSubAns) + steps)\n        steps += len(Q) * Q[-1]\n        Q = [x - Q[-1] for x in Q]\n        j = -1\n        del Q[-1]\n    print(min(answer))", "def solve(line1, line2):\n    (m1, c1) = line1\n    (m2, c2) = line2\n    return (c2 - c1) / (m1 - m2)\n\ndef find(A, Z):\n    N = len(A)\n    A = [10 ** 10] + sorted(A)[::-1]\n    dp = [[10 ** 10 for j in range(Z + 1)] for k in range(N + 1)]\n    for i in range(1, N + 1):\n        dp[i][1] = i * A[i]\n    from collections import deque\n    for z in range(2, Z + 1):\n        temp = 10 ** 10\n        intersections = [0]\n        lines = [(-(z - 1), dp[z - 1][z - 1])]\n        for k in range(z, N + 1):\n            line = (-k, dp[k][z - 1])\n            while intersections:\n                if intersections[-1] > A[k]:\n                    intersections.pop()\n                    lines.pop()\n                else:\n                    break\n            (m0, c0) = lines[-1]\n            ans = m0 * A[k] + c0\n            dp[k][z] = ans + k * A[k]\n            if line[0] * A[k] + line[1] >= ans:\n                continue\n            while lines:\n                inter = solve(lines[-1], line)\n                (m, c) = line\n                (m0, c0) = lines[-1]\n                pos = intersections[-1]\n                if inter < pos and m * pos + c < m0 * pos + c0:\n                    lines.pop()\n                    intersections.pop()\n                else:\n                    break\n            lines += [line]\n            intersections += [max(inter, 0)]\n    return min([dp[i][Z] for i in range(1, N + 1)])\nfor _ in range(int(input())):\n    (N, Z) = list(map(int, input().strip().split(' ')))\n    A = list(map(int, input().strip().split(' ')))\n    print(find(A, Z))", "t = int(input())\nfor _ in range(t):\n    (n, z) = map(int, input().split())\n    a = list(map(int, input().split()))\n    a = sorted(a)\n    ans = 1 << 64\n    p = [0] * (n + 1)\n    for i in range(1, n + 1):\n        p[i] = p[i - 1] + a[i - 1]\n    ans1 = 1 << 64\n    i = 0\n    while i + z - 1 < n:\n        ending = i + z - 1\n        currAns = 0\n        currAns += p[ending + 1] - p[i]\n        currAns += a[ending] * (n - ending - 1)\n        ans1 = min(ans1, currAns)\n        i += 1\n    ans = min(ans, ans1)\n    ans1 = 1 << 64\n    for i in range(z - 1, n):\n        x = 1\n        y = z - 1\n        while y > 0 and x < z:\n            currAns = 0\n            currAns += p[x]\n            currAns += a[x - 1] * (i - y + 1 - x)\n            currAns += p[i + 1] - p[i - y + 1]\n            currAns += a[i] * (n - i - 1)\n            ans1 = min(currAns, ans1)\n            x = x + 1\n            y = y - 1\n    ans = min(ans, ans1)\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef rec(arr, z, score, ans):\n    if z == 0:\n        return ans\n    summ = 0\n    for i in range(z):\n        summ += arr[i]\n    minTemp = summ + score\n    for i in range(z, len(arr)):\n        summ = summ - arr[i - z] + arr[i]\n        temp = score + summ + arr[i - z + 1] * (i - z + 1)\n        if temp < minTemp:\n            minTemp = temp\n    length = len(arr)\n    a = arr.pop(length - 1)\n    for i in range(len(arr)):\n        arr[i] -= a\n    z -= 1\n    if minTemp < ans:\n        ans = minTemp\n    return rec(arr, z, a * length + score, ans)\nt = int(input())\nfor r in range(t):\n    (n, z) = map(int, input().split())\n    l = list(map(int, input().split()))\n    l.sort(reverse=True)\n    print(rec(l, z, 0, 99999999999999999))", "import sys\nsys.setrecursionlimit(10000)\n\ndef solve(arr, N, Z):\n    if Z == 0:\n        return 0\n    cur = best = sum(arr[-Z:])\n    for i in range(1, N - Z + 1):\n        cur -= i * (arr[-i] - arr[-i - 1])\n        cur += arr[-i - Z]\n        if cur < best:\n            best = cur\n    if Z > 1:\n        alternative = arr[0] * N + solve([x - arr[0] for x in arr[1:]], N - 1, Z - 1)\n        if alternative < best:\n            best = alternative\n    return best\nfor _ in range(int(input())):\n    (N, Z) = map(int, input().split())\n    A = sorted(map(int, input().split()))\n    print(solve(A, N, Z))"]