["import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef main():\n    test_cases = int(sys.stdin.readline())\n    for _ in range(test_cases):\n        (board_dim, marked_count) = (int(i) for i in sys.stdin.readline().split())\n        marked = dict()\n        adj = [[] for _ in range(2 * (board_dim + 1))]\n        root = 0\n        for i in range(1, marked_count + 1):\n            (row, col) = (int(i) for i in sys.stdin.readline().split())\n            marked[row, col] = i\n            col = col + board_dim\n            adj[row].append(col)\n            adj[col].append(row)\n            root = max(root, row)\n        for (node, neighbors) in enumerate(adj):\n            if len(neighbors) % 2:\n                root = node\n        path = eulerian_path(root, adj)\n        soln = []\n        for (row, col) in zip(path[:-1], path[1:]):\n            if row > board_dim:\n                row = row - board_dim\n                (row, col) = (col, row)\n            else:\n                col = col - board_dim\n            soln.append(marked[row, col])\n        print(' '.join((str(i) for i in soln)))\nmain()", "import sys\nfrom collections import deque\n\ndef eulerian_path(root, adj):\n    path = []\n    stack = [root]\n    while stack:\n        u = stack[-1]\n        if len(adj[u]) == 0:\n            path.append(u)\n            stack.pop()\n        else:\n            v = adj[u][-1]\n            adj[u].pop()\n            adj[v] = [w for w in adj[v] if w != u]\n            stack.append(v)\n    return path\n\ndef main():\n    test_cases = int(sys.stdin.readline())\n    for _ in range(test_cases):\n        (board_dim, marked_count) = (int(i) for i in sys.stdin.readline().split())\n        marked = dict()\n        adj = [[] for _ in range(2 * (board_dim + 1))]\n        root = 0\n        for i in range(1, marked_count + 1):\n            (row, col) = (int(i) for i in sys.stdin.readline().split())\n            marked[row, col] = i\n            col = col + board_dim\n            adj[row].append(col)\n            adj[col].append(row)\n            root = max(root, row)\n        for (node, neighbors) in enumerate(adj):\n            if len(neighbors) % 2:\n                root = node\n        path = eulerian_path(root, adj)\n        soln = []\n        for (row, col) in zip(path[:-1], path[1:]):\n            if row > board_dim:\n                row = row - board_dim\n                (row, col) = (col, row)\n            else:\n                col = col - board_dim\n            soln.append(marked[row, col])\n        print(' '.join((str(i) for i in soln)))\nmain()"]