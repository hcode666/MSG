["n = int(input())\n(x, y) = ([0] * n, [0] * n)\ns = set()\nfor i in range(n):\n    (x[i], y[i]) = map(int, input().split())\n    s.add((x[i], y[i]))\nans = max(4 - n, 2)\nfor c in range(n):\n    for b in range(c):\n        (dx, dy) = (x[c] - x[b], y[c] - y[b])\n        c2 = 2\n        if (x[b] - dy, y[b] + dx) in s:\n            c2 -= 1\n        if (x[c] - dy, y[c] + dx) in s:\n            c2 -= 1\n        ans = min(ans, c2)\nprint(ans)", "import sys\nimport math\n\ndef main(arr):\n    ans = 2\n    if len(arr) < 2:\n        return 4 - len(arr)\n    set_arr = set(arr)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            need = 2\n            (x1, y1) = arr[i]\n            (x2, y2) = arr[j]\n            xc = (x1 + x2) / 2\n            yc = (y1 + y2) / 2\n            xd = (x1 - x2) / 2\n            yd = (y1 - y2) / 2\n            x3 = xc - yd\n            y3 = yc + xd\n            x4 = xc + yd\n            y4 = yc - xd\n            if (x3, y3) in set_arr:\n                need -= 1\n            if (x4, y4) in set_arr:\n                need -= 1\n            ans = min(ans, need)\n    return ans\narr = []\nfor i in range(int(input())):\n    arr.append(tuple(map(int, input().split())))\nprint(main(arr))", "import sys\nimport math\n\ndef main(arr):\n    ans = 2\n    if len(arr) < 2:\n        return 4 - len(arr)\n    set_arr = set(arr)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            need = 2\n            (x1, y1) = arr[i]\n            (x2, y2) = arr[j]\n            xc = (x1 + x2) / 2\n            yc = (y1 + y2) / 2\n            xd = (x1 - x2) / 2\n            yd = (y1 - y2) / 2\n            x3 = xc - yd\n            y3 = yc + xd\n            x4 = xc + yd\n            y4 = yc - xd\n            if (x3, y3) in set_arr:\n                need -= 1\n            if (x4, y4) in set_arr:\n                need -= 1\n            ans = min(ans, need)\n    return ans\narr = []\nfor i in range(int(input())):\n    arr.append(tuple(map(int, input().split())))\nprint(main(arr))", "import sys\nimport math\n\ndef main(arr):\n    ans = 2\n    if len(arr) < 2:\n        return 4 - len(arr)\n    set_arr = set(arr)\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            need = 2\n            (x1, y1) = arr[i]\n            (x2, y2) = arr[j]\n            xc = (x1 + x2) / 2\n            yc = (y1 + y2) / 2\n            xd = (x1 - x2) / 2\n            yd = (y1 - y2) / 2\n            x3 = xc - yd\n            y3 = yc + xd\n            x4 = xc + yd\n            y4 = yc - xd\n            if (x3, y3) in set_arr:\n                need -= 1\n            if (x4, y4) in set_arr:\n                need -= 1\n            ans = min(ans, need)\n    return ans\narr = []\nfor i in range(int(input())):\n    arr.append(tuple(map(int, input().split())))\nprint(main(arr))", "def chefsqua():\n    import sys\n\n    def gcd(a, b):\n        while b > 0:\n            (a, b) = (b, a % b)\n        return a\n    n = int(sys.stdin.readline().strip())\n    coords = []\n    cset = set()\n    (orgx, orgy) = (0, 0)\n    (basex, basey) = (1, 1)\n    colinear = True\n    for i in range(n):\n        (x, y) = tuple(map(int, sys.stdin.readline().strip().split(' ')))\n        if i == 0:\n            (orgx, orgy) = (x, y)\n        (x, y) = (x - orgx, y - orgy)\n        coords.append((x, y))\n        cset.add((x, y))\n        if i == 1:\n            g = gcd(x, y)\n            (basex, basey) = (x // g, y // g)\n        if colinear and i >= 2:\n            g = gcd(x, y)\n            colinear &= x // g == basex and y // g == basey\n    if n == 0:\n        print(4)\n        return\n    if n == 1:\n        print(3)\n        return\n    elif n == 2 or colinear:\n        print(2)\n        return\n    best = 2\n    for i in range(n - 1):\n        (xi, yi) = (coords[i][0], coords[i][1])\n        for j in range(i + 1, n):\n            (xj, yj) = (coords[j][0], coords[j][1])\n            (dx, dy) = (xj - xi, yj - yi)\n            if (xi - dy, yi + dx) in cset:\n                best = 1\n                if (xj - dy, yj + dx) in cset:\n                    print(0)\n                    return\n            if (xi + dy, yi - dx) in cset:\n                best = 1\n                if (xj + dy, yj - dx) in cset:\n                    print(0)\n                    return\n            if (xj - dy, yj + dx) in cset:\n                best = 1\n            if (xj + dy, yj - dx) in cset:\n                best = 1\n    print(best)\n    return\nchefsqua()", "def give_other_cord(x1, y1, x2, y2):\n    cx1 = (x1 + x2 + y1 - y2) / 2\n    cy1 = (y1 + y2 + x2 - x1) / 2\n    cx2 = (x1 + x2 + y2 - y1) / 2\n    cy2 = (y1 + y2 + x1 - x2) / 2\n    if all((cx1.is_integer(), cx2.is_integer(), cy1.is_integer(), cy2.is_integer())):\n        return (True, (cx1, cy1), (cx2, cy2))\n    else:\n        return (False, (0, 0), (0, 0))\n\ndef answer():\n    N = int(input())\n    d = {}\n    X = []\n    Y = []\n    found_three = False\n    found_four = False\n    if N == 0:\n        print(4)\n        return\n    elif N == 1:\n        print(3)\n        return\n    elif N == 2:\n        print(2)\n        return\n    else:\n        for i in range(N):\n            (x, y) = [int(x) for x in input().split()]\n            d[x, y] = 1\n            X.append(x)\n            Y.append(y)\n        is_break = False\n        for i in range(N):\n            if is_break:\n                break\n            for j in range(i + 1, N):\n                (x1, y1) = (X[i], Y[i])\n                (x2, y2) = (X[j], Y[j])\n                count = 0\n                (flag, (cx1, cy1), (cx2, cy2)) = give_other_cord(x1, y1, x2, y2)\n                if flag:\n                    try:\n                        d[cx1, cy1]\n                        count += 1\n                    except KeyError:\n                        pass\n                    try:\n                        d[cx2, cy2]\n                        count += 1\n                    except KeyError:\n                        pass\n                else:\n                    pass\n                if count == 0:\n                    pass\n                elif count == 1:\n                    found_three = True\n                    pass\n                elif count == 2:\n                    print(0)\n                    found_four = True\n                    is_break = True\n                    return\n    if found_three:\n        print(1)\n    else:\n        print(2)\n    return\nanswer()", "import itertools\nN = int(input())\nif N <= 2:\n    print(4 - N)\n    exit()\ncoords = {tuple([int(x) for x in input().split()]) for coord in range(N)}\ndel N\ncoordinatesNeeded = 2\nfor (a, b) in itertools.combinations(coords, 2):\n    (a_x, a_y) = a\n    (b_x, b_y) = b\n    (a, b) = ((a_x, a_y), (b_x, b_y))\n    del a_x, a_y, b_x, b_y\n    A = (a[0] - b[0], a[1] - b[1])\n    B = (a[1] - b[1], -a[0] + b[0])\n    newSquarePoints_Positive = [(a[0] + B[0], a[1] + B[1]), (b[0] + B[0], b[1] + B[1])]\n    newSquarePoints_Negative = [(a[0] - B[0], a[1] - B[1]), (b[0] - B[0], b[1] - B[1])]\n    newSquarePoints_Positive_Matches = len([x for x in newSquarePoints_Positive if x in coords])\n    newSquarePoints_Negative_Matches = len([x for x in newSquarePoints_Negative if x in coords])\n    coordinatesNeeded = min(coordinatesNeeded, 2 - newSquarePoints_Positive_Matches, 2 - newSquarePoints_Negative_Matches)\n    if coordinatesNeeded == 0:\n        break\nprint(coordinatesNeeded)", "n = int(input())\npoints = []\nfor _ in range(n):\n    points += [tuple(list(map(int, input().split())))]\nset_points = set(points)\nanswered = False\nresult = 0\nif n == 0:\n    result = 4\n    answered = True\nif not answered and n >= 4:\n    for i in range(n):\n        for j in range(i + 1, n):\n            (p_a, p_b) = (points[i], points[j])\n            (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n            if (p_b[0] - dy, p_b[1] + dx) in set_points and (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points or ((p_b[0] + dy, p_b[1] - dx) in set_points and (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                result = 0\n                answered = True\nif not answered and n >= 3:\n    for i in range(n):\n        for j in range(i + 1, n):\n            (p_a, p_b) = (points[i], points[j])\n            (dx, dy) = (p_a[0] - p_b[0], p_a[1] - p_b[1])\n            if ((p_b[0] - dy, p_b[1] + dx) in set_points or (p_b[0] + dx - dy, p_b[1] + dx + dy) in set_points) or ((p_b[0] + dy, p_b[1] - dx) in set_points or (p_b[0] + dx + dy, p_b[1] - dx + dy) in set_points):\n                result = 1\n                answered = True\nif not answered and n >= 2:\n    result = 2\n    answered = True\nif not answered:\n    result = 3\nprint(result)"]