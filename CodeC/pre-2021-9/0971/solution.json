["M = 10 ** 9 + 7\n\ndef lps_compute(s):\n    n = len(s)\n    lps = [0] * n\n    curr = 0\n    lps[0] = 0\n    i = 1\n    while i < n:\n        if s[i] == s[curr]:\n            curr += 1\n            lps[i] = curr\n            i += 1\n        elif curr != 0:\n            curr = lps[curr - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\ndef kmp(s1, s2):\n    (n, m) = (len(s1), len(s2))\n    lps = lps_compute(s2)\n    ans = [0] * n\n    (i, j) = (0, 0)\n    while i < n:\n        if s1[i] == s2[j]:\n            i += 1\n            j += 1\n        elif j == 0:\n            i += 1\n        else:\n            j = lps[j - 1]\n        if j == m:\n            ans[i - 1] = 1\n            j = lps[j - 1]\n    return ans\nfor _ in range(int(input())):\n    s1 = input().strip()\n    s2 = input().strip()\n    (n, m) = (len(s1), len(s2))\n    arr = kmp(s1, s2)\n    dp = [0] * n\n    if arr[0] == 1:\n        dp[0] = 1\n    for i in range(1, n):\n        if arr[i] == 1:\n            if i == m - 1:\n                dp[i] = 1\n            else:\n                dp[i] = (1 + dp[i - m]) % M\n        dp[i] = (dp[i - 1] + dp[i]) % M\n    print(dp[-1])", "M = 10 ** 9 + 7\n\ndef lps_compute(s):\n    n = len(s)\n    lps = [0] * n\n    curr = 0\n    lps[0] = 0\n    i = 1\n    while i < n:\n        if s[i] == s[curr]:\n            curr += 1\n            lps[i] = curr\n            i += 1\n        elif curr != 0:\n            curr = lps[curr - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\ndef kmp(s1, s2):\n    (n, m) = (len(s1), len(s2))\n    lps = lps_compute(s2)\n    ans = [0] * n\n    (i, j) = (0, 0)\n    while i < n:\n        if s1[i] == s2[j]:\n            i += 1\n            j += 1\n        elif j == 0:\n            i += 1\n        else:\n            j = lps[j - 1]\n        if j == m:\n            ans[i - 1] = 1\n            j = lps[j - 1]\n    return ans\nfor _ in range(int(input())):\n    s1 = input().strip()\n    s2 = input().strip()\n    (n, m) = (len(s1), len(s2))\n    arr = kmp(s1, s2)\n    dp = [0] * n\n    if arr[0] == 1:\n        dp[0] = 1\n    for i in range(1, n):\n        if arr[i] == 1:\n            if i == m - 1:\n                dp[i] = 1\n            else:\n                dp[i] = (1 + dp[i - m]) % M\n        dp[i] = (dp[i - 1] + dp[i]) % M\n    print(dp[-1])", "def KnuthMorrisPratt(text, pattern):\n    pattern = list(pattern)\n    shifts = [1] * (len(pattern) + 1)\n    shift = 1\n    for pos in range(len(pattern)):\n        while shift <= pos and pattern[pos] != pattern[pos - shift]:\n            shift += shifts[pos - shift]\n        shifts[pos + 1] = shift\n    ans = [0] * len(text)\n    startPos = 0\n    matchLen = 0\n    for c in text:\n        while matchLen == len(pattern) or (matchLen >= 0 and pattern[matchLen] != c):\n            startPos += shifts[matchLen]\n            matchLen -= shifts[matchLen]\n        matchLen += 1\n        if matchLen == len(pattern):\n            ans[startPos] = 1\n    return ans\n\ndef KMPSearch(pat, txt):\n    M = len(pat)\n    N = len(txt)\n    ans = [0] * (N + 1)\n    lps = [0] * M\n    j = 0\n    computeLPSArray(pat, M, lps)\n    i = 0\n    while i < N:\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        if j == M:\n            ans[i - j + M] = 1\n            j = lps[j - 1]\n        elif i < N and pat[j] != txt[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return ans\n\ndef computeLPSArray(pat, M, lps):\n    len = 0\n    lps[0]\n    i = 1\n    while i < M:\n        if pat[i] == pat[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        elif len != 0:\n            len = lps[len - 1]\n        else:\n            lps[i] = 0\n            i += 1\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    s = input().strip()\n    f = input().strip()\n    (n, m) = (len(s), len(f))\n    arr = KMPSearch(f, s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        if arr[i] == 1:\n            dp[i] = (dp[i] + dp[i - m]) % MOD\n        dp[i] = (dp[i] + dp[i - 1]) % MOD\n    print((dp[n] - 1 + MOD) % MOD)", "def KnuthMorrisPratt(text, pattern):\n    pattern = list(pattern)\n    shifts = [1] * (len(pattern) + 1)\n    shift = 1\n    for pos in range(len(pattern)):\n        while shift <= pos and pattern[pos] != pattern[pos - shift]:\n            shift += shifts[pos - shift]\n        shifts[pos + 1] = shift\n    ans = [0] * len(text)\n    startPos = 0\n    matchLen = 0\n    for c in text:\n        while matchLen == len(pattern) or (matchLen >= 0 and pattern[matchLen] != c):\n            startPos += shifts[matchLen]\n            matchLen -= shifts[matchLen]\n        matchLen += 1\n        if matchLen == len(pattern):\n            ans[startPos] = 1\n    return ans\n\ndef KMPSearch(pat, txt):\n    M = len(pat)\n    N = len(txt)\n    ans = [0] * (N + 1)\n    lps = [0] * M\n    j = 0\n    computeLPSArray(pat, M, lps)\n    i = 0\n    while i < N:\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        if j == M:\n            ans[i - j + M] = 1\n            j = lps[j - 1]\n        elif i < N and pat[j] != txt[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return ans\n\ndef computeLPSArray(pat, M, lps):\n    len = 0\n    lps[0]\n    i = 1\n    while i < M:\n        if pat[i] == pat[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        elif len != 0:\n            len = lps[len - 1]\n        else:\n            lps[i] = 0\n            i += 1\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    s = input().strip()\n    f = input().strip()\n    (n, m) = (len(s), len(f))\n    arr = KMPSearch(f, s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        if arr[i] == 1:\n            dp[i] = (dp[i] + dp[i - m]) % MOD\n        dp[i] = (dp[i] + dp[i - 1]) % MOD\n    print((dp[n] - 1 + MOD) % MOD)", "M = 10 ** 9 + 7\n\ndef lps_compute(s):\n    n = len(s)\n    lps = [0] * n\n    curr = 0\n    lps[0] = 0\n    i = 1\n    while i < n:\n        if s[i] == s[curr]:\n            curr += 1\n            lps[i] = curr\n            i += 1\n        elif curr != 0:\n            curr = lps[curr - 1]\n        else:\n            lps[i] = 0\n            i += 1\n    return lps\n\ndef kmp(s1, s2):\n    (n, m) = (len(s1), len(s2))\n    lps = lps_compute(s2)\n    ans = [0] * n\n    (i, j) = (0, 0)\n    while i < n:\n        if s1[i] == s2[j]:\n            i += 1\n            j += 1\n        elif j == 0:\n            i += 1\n        else:\n            j = lps[j - 1]\n        if j == m:\n            ans[i - 1] = 1\n            j = lps[j - 1]\n    return ans\nfor _ in range(int(input())):\n    s1 = input().strip()\n    s2 = input().strip()\n    (n, m) = (len(s1), len(s2))\n    arr = kmp(s1, s2)\n    dp = [0] * n\n    if arr[0] == 1:\n        dp[0] = 1\n    for i in range(1, n):\n        if arr[i] == 1:\n            if i == m - 1:\n                dp[i] = 1\n            else:\n                dp[i] = (1 + dp[i - m]) % M\n        dp[i] = (dp[i - 1] + dp[i]) % M\n    print(dp[-1])", "def KnuthMorrisPratt(text, pattern):\n    pattern = list(pattern)\n    shifts = [1] * (len(pattern) + 1)\n    shift = 1\n    for pos in range(len(pattern)):\n        while shift <= pos and pattern[pos] != pattern[pos - shift]:\n            shift += shifts[pos - shift]\n        shifts[pos + 1] = shift\n    ans = [0] * len(text)\n    startPos = 0\n    matchLen = 0\n    for c in text:\n        while matchLen == len(pattern) or (matchLen >= 0 and pattern[matchLen] != c):\n            startPos += shifts[matchLen]\n            matchLen -= shifts[matchLen]\n        matchLen += 1\n        if matchLen == len(pattern):\n            ans[startPos] = 1\n    return ans\n\ndef KMPSearch(pat, txt):\n    M = len(pat)\n    N = len(txt)\n    ans = [0] * (N + 1)\n    lps = [0] * M\n    j = 0\n    computeLPSArray(pat, M, lps)\n    i = 0\n    while i < N:\n        if pat[j] == txt[i]:\n            i += 1\n            j += 1\n        if j == M:\n            ans[i - j + M] = 1\n            j = lps[j - 1]\n        elif i < N and pat[j] != txt[i]:\n            if j != 0:\n                j = lps[j - 1]\n            else:\n                i += 1\n    return ans\n\ndef computeLPSArray(pat, M, lps):\n    len = 0\n    lps[0]\n    i = 1\n    while i < M:\n        if pat[i] == pat[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        elif len != 0:\n            len = lps[len - 1]\n        else:\n            lps[i] = 0\n            i += 1\nMOD = 10 ** 9 + 7\nfor _ in range(int(input())):\n    s = input().strip()\n    f = input().strip()\n    (n, m) = (len(s), len(f))\n    arr = KMPSearch(f, s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        if arr[i] == 1:\n            dp[i] = (dp[i] + dp[i - m]) % MOD\n        dp[i] = (dp[i] + dp[i - 1]) % MOD\n    print((dp[n] - 1 + MOD) % MOD)", "import re\nfrom collections import Counter\nM = int(1000000000.0) + 7\n\ndef brute(S, F, st):\n    st0 = st\n    tot = 0\n    while True:\n        p = S.find(F, st)\n        if p == -1:\n            break\n        tot += brute(S, F, p + len(F)) + 1\n        st = p + 1\n    return tot % M\nfor t in range(int(input())):\n    S = input().strip()\n    F = input().strip()\n    m = len(F)\n    (mc, cnt) = Counter(F).most_common(1)[0]\n    if m > 1 and cnt == m:\n        ans = 0\n        subs = [len(match.group()) for match in re.finditer('({0})\\\\1*'.format(mc), S) if len(match.group()) >= m]\n        if subs:\n            dpsum = [i + 1 for i in range(max(subs) + 1)]\n            for n in range(m, len(dpsum)):\n                dpsum[n] = (1 + dpsum[n - m] + dpsum[n - 1]) % M\n            ans = 1\n            for n in subs:\n                v = dpsum[n] - dpsum[n - 1] + M\n                ans = ans * v % M\n            ans -= 1\n    elif len(S) <= 30:\n        ans = brute(S, F, 0)\n    else:\n        ans = (pow(2, S.count(F), M) - 1 + M) % M\n    print(ans)"]