["import numpy as np\nMOD = 998244353\n\ndef mpow(x, k):\n    ret = 1\n    x %= MOD\n    while k:\n        if k & 1:\n            ret = ret * x % MOD\n        x = x * x % MOD\n        k >>= 1\n    return ret\n\ndef minv(x):\n    return mpow(x, MOD - 2)\n\ndef mm(a, b):\n    n = a.shape[0]\n    ret = np.zeros(n, dtype=int)\n    for i in range(n):\n        ret += b[i] * a[:, i] % MOD\n    return ret % MOD\nFACT = [1]\nIFACT = [1]\n\ndef ch(a, b):\n    return FACT[a] * IFACT[a - b] % MOD * IFACT[b] % MOD\nfor i in range(1, 3000):\n    x = FACT[-1] * i % MOD\n    FACT += [x]\n    IFACT += [minv(x)]\n\ndef getEig(n):\n    evals = 1 + np.arange(n) * 2 - n\n    evecs = np.zeros((n, n), dtype=np.int64)\n    evecs[0, :] = 1\n    evecs[1, :] = evals\n    for i in range(2, n):\n        (a, b) = (evecs[i - 2], evecs[i - 1])\n        (x, y) = (n - i + 1, i)\n        c = (b * evals - x * a) % MOD\n        c = c * minv(y) % MOD\n        evecs[i, :] = c\n    return (evals, evecs)\n\ndef getInit(n):\n    ret = np.array([ch(n - 1, i) for i in range(n)], dtype=np.int64)\n    ret *= minv(mpow(2, n - 1))\n    return ret % MOD\n\ndef getWays(n, k):\n    (x, y) = getEig(n)\n    z = getInit(n) * mpow(x, k) % MOD\n    return mm(y, z)\n\ndef getPairs(n, m, z):\n    ret = []\n    for i in range(n + 1):\n        den = n - 2 * i\n        if den == 0:\n            if i * m == z:\n                ret += [(i, j) for j in range(m + 1)]\n        else:\n            j = (z - i * m) // den\n            if i * (m - j) + j * (n - i) == z:\n                if j >= 0 and j <= m:\n                    ret += [(i, j)]\n    return ret\n\ndef solve(n, m, q, z):\n    nways = getWays(n + 1, q)\n    mways = getWays(m + 1, q)\n    ret = 0\n    for (a, b) in getPairs(n, m, z):\n        ret += nways[a] * mways[b] % MOD\n    return ret % MOD\nimport sys\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    (n, m, q, z) = map(int, f.readline().split())\n    print(solve(n, m, q, z))", "import numpy as np\nMOD = 998244353\n\ndef mpow(x, k):\n    ret = 1\n    x %= MOD\n    while k:\n        if k & 1:\n            ret = ret * x % MOD\n        x = x * x % MOD\n        k >>= 1\n    return ret\n\ndef minv(x):\n    return mpow(x, MOD - 2)\n\ndef mm(a, b):\n    n = a.shape[0]\n    ret = np.zeros(n, dtype=int)\n    for i in range(n):\n        ret += b[i] * a[:, i] % MOD\n    return ret % MOD\nFACT = [1]\nIFACT = [1]\n\ndef ch(a, b):\n    return FACT[a] * IFACT[a - b] % MOD * IFACT[b] % MOD\nfor i in range(1, 3000):\n    x = FACT[-1] * i % MOD\n    FACT += [x]\n    IFACT += [minv(x)]\n\ndef getEig(n):\n    evals = 1 + np.arange(n) * 2 - n\n    evecs = np.zeros((n, n), dtype=np.int64)\n    evecs[0, :] = 1\n    evecs[1, :] = evals\n    for i in range(2, n):\n        (a, b) = (evecs[i - 2], evecs[i - 1])\n        (x, y) = (n - i + 1, i)\n        c = (b * evals - x * a) % MOD\n        c = c * minv(y) % MOD\n        evecs[i, :] = c\n    return (evals, evecs)\n\ndef getInit(n):\n    ret = np.array([ch(n - 1, i) for i in range(n)], dtype=np.int64)\n    ret *= minv(mpow(2, n - 1))\n    return ret % MOD\n\ndef getWays(n, k):\n    (x, y) = getEig(n)\n    z = getInit(n) * mpow(x, k) % MOD\n    return mm(y, z)\n\ndef getPairs(n, m, z):\n    ret = []\n    for i in range(n + 1):\n        den = n - 2 * i\n        if den == 0:\n            if i * m == z:\n                ret += [(i, j) for j in range(m + 1)]\n        else:\n            j = (z - i * m) // den\n            if i * (m - j) + j * (n - i) == z:\n                if j >= 0 and j <= m:\n                    ret += [(i, j)]\n    return ret\n\ndef solve(n, m, q, z):\n    nways = getWays(n + 1, q)\n    mways = getWays(m + 1, q)\n    ret = 0\n    for (a, b) in getPairs(n, m, z):\n        ret += nways[a] * mways[b] % MOD\n    return ret % MOD\nimport sys\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    (n, m, q, z) = map(int, f.readline().split())\n    print(solve(n, m, q, z))"]