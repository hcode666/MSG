["for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    most = m * (m + 1)\n    if n1 >= most / 2 and n2 >= most / 2:\n        print(n1 + n2 - most)\n    else:\n        spile = min(n1, n2)\n        print(n1 + n2 - spile * 2)", "for _ in range(int(input())):\n    (a, b, m) = map(int, input().split())\n    max_remove = m * (m + 1) // 2\n    if a >= max_remove and b >= max_remove:\n        print(a + b - 2 * max_remove)\n    else:\n        print(a + b - 2 * min(a, b))", "for _ in range(int(input())):\n    (n1, n2, m) = list(map(int, input().split()))\n    m_max = m * (m + 1) // 2\n    sub = min(n1, n2, m_max)\n    ans = n1 + n2 - 2 * sub\n    print(ans)", "for _ in range(int(input())):\n    (n1, n2, m) = list(map(int, input().split()))\n    m_max = m * (m + 1) // 2\n    sub = min(n1, n2, m_max)\n    ans = n1 + n2 - 2 * sub\n    print(ans)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    most = m * (m + 1)\n    if n1 >= most / 2 and n2 >= most / 2:\n        print(n1 + n2 - most)\n    else:\n        spile = min(n1, n2)\n        print(n1 + n2 - spile * 2)", "from functools import lru_cache\nimport atexit, io\nimport sys\nfrom math import log2\nimport math\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_left, bisect_right, insort\nfrom math import gcd\nfrom math import sqrt\nfrom collections import Counter, defaultdict\nfrom heapq import heappush, heappop, heapify\nimport heapq\n\nclass FenwickTree:\n\n    def __init__(self, n):\n        self.farr = [0] * (n + 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\n    def find(self, k):\n        curr = 0\n        ans = 0\n        prevSum = 0\n        for i in range(log2(n), -1, -1):\n            if self.farr[curr + (i << i)] + prevSum < k:\n                curr += 1 << i\n                prevSum += self.farr[curr]\n        return curr + 1\n\nclass Trie(object):\n\n    def __init__(self):\n        self.trie = {}\n\n    def insert(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                t[c] = {}\n            t = t[c]\n        t['-'] = True\n\n    def search(self, word):\n        t = self.trie\n        for c in word:\n            if c not in t:\n                return False\n            t = t[c]\n        return '-' in t\n\n    def startsWith(self, prefix):\n        t = self.trie\n        for c in prefix:\n            if c not in t:\n                return False\n            t = t[c]\n        return True\n\n    def query(self, word):\n        ans = 0\n        t = self.trie\n        for i in word:\n            if i not in t:\n                break\n            ans += 1\n            t = t[i]\n        return ans\n\nclass FenvTree:\n\n    def __init__(self, arr):\n        arr.insert(0, 0)\n        self.farr = [0]\n        prefix = [0]\n        for i in arr[1:]:\n            prefix.append(prefix[-1] + i)\n        for i in range(1, len(arr)):\n            idash = i - (i & -i)\n            self.farr.append(prefix[i] - prefix[idash])\n\n    def query(self, l, r):\n        return self.prefixSum(r) - self.prefixSum(l - 1)\n\n    def prefixSum(self, idx):\n        s = 0\n        while idx > 0:\n            s += self.farr[idx]\n            idx -= idx & -idx\n        return s\n\n    def update(self, idx, val):\n        while idx < len(self.farr):\n            self.farr[idx] += val\n            idx += idx & -idx\n\nclass DSU:\n\n    def __init__(self, n):\n        self.parent = []\n        self.size = []\n        for i in range(n + 1):\n            self.parent.append(i)\n            self.size.append(1)\n\n    def union(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.size[pu] < self.size[pv]:\n            self.parent[pu] = pv\n            self.size[pv] += self.size[pu]\n        else:\n            self.parent[pv] = pu\n            self.size[pu] += self.size[pv]\n\n    def unionByRank(self, u, v):\n        pu = self.findPar(u)\n        pv = self.findPar(v)\n        if pu == pv:\n            return\n        if self.rank[pu] < self.rank[pv]:\n            self.parent[pu] = pv\n        elif self.rank[pv] < self.rank[pu]:\n            self.parent[pv] = pu\n        else:\n            self.parent[pu] = pv\n            self.rank[pv] += 1\n\n    def findPar(self, node):\n        if self.parent[node] == node:\n            return node\n        self.parent[node] = self.findPar(self.parent[node])\n        return self.parent[node]\n\nclass info:\n\n    def __init__(self, _open=0, _close=0, _full=0):\n        self.open = _open\n        self.close = _close\n        self.full = _full\n\nclass SGTree:\n\n    def __init__(self, n):\n        self.seg = [0 for _ in range(4 * n)]\n\n    def build(self, ind, low, high, arr):\n        if low == high:\n            self.seg[ind] = arr[low]\n            return\n        mid = (low + high) // 2\n        self.build(2 * ind + 1, low, mid, arr)\n        self.build(2 * ind + 2, mid + 1, high, arr)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\n    def query(self, ind, low, high, l, r):\n        if r < low or l > high:\n            return sys.maxsize\n        if low <= l and r >= high:\n            return self.seg[ind]\n        mid = low + high >> 1\n        left = self.query(2 * ind + 1, 0, mid, l, r)\n        right = self.query(2 * ind + 2, mid + 1, high, l, r)\n        return min(left, right)\n\n    def update(self, ind, low, high, i, val):\n        if low == high:\n            self.seg = val\n            return\n        mid = low + high >> 1\n        if i <= mid:\n            self.update(2 * ind + 1, low, mid, i, val)\n        else:\n            self.update(2 * ind + 1, mid + 1, high, i, val)\n        self.seg[ind] = min(self.seg[2 * ind + 1], self.seg[2 * ind + 2])\n\ndef isPalindrome(s):\n    i = 0\n    j = len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef IntList():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef getInts():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef getStrs():\n    return sys.stdin.readline().strip()\n\ndef StrList():\n    list(sys.stdin.readline().strip())\n\ndef FloatList():\n    lis = input().split()\n    lis = list(map(float, lis))\n    return lis\n\ndef SieveOfEratosthenes(n, isPrime):\n    isPrime[0] = isPrime[1] = False\n    for i in range(2, n + 1):\n        isPrime[i] = True\n    p = 2\n    while p * p <= n:\n        if isPrime[p]:\n            i = p * p\n            while i <= n:\n                isPrime[i] = False\n                i += p\n        p += 1\n\ndef findPrimePair(n):\n    isPrime = [0] * (n + 1)\n    SieveOfEratosthenes(n, isPrime)\n    for i in range(0, n):\n        if isPrime[i] and isPrime[n - i]:\n            print(i, n - i)\n            return\n\ndef query(ind, low, high, l, r, seg):\n    if r < low or l > high:\n        return info()\n    if low <= l and r >= high:\n        return self.seg[ind]\n    mid = low + high >> 1\n    left = self.query(2 * ind + 1, 0, mid, l, r, seg)\n    right = self.query(2 * ind + 2, mid + 1, high, l, r, seg)\n    return merge(left, right)\n\ndef merge(left, right):\n    ans = info()\n    ans.full = left.full + right.full + min(left.open, right.close)\n    ans.open = left.open + right.open + min(left.open, right.close)\n    ans.close = left.close + right.close + min(left.open, right.close)\n    return ans\n\ndef build(ind, low, high, s, seg):\n    if low == high:\n        seg[ind] = info(s[low] == '(', s[low] == ')', 0)\n        return\n    mid = (low + high) // 2\n    build(2 * ind + 1, low, mid, s, seg)\n    build(2 * ind + 2, mid + 1, high, s, seg)\n    seg[ind] = merge(seg[2 * ind + 1], seg[2 * ind + 2])\n\ndef countN(lis):\n    ans = 0\n    cnt = 0\n    for i in range(len(lis) - 1, -1, -1):\n        if lis[i] == 0:\n            cnt += 1\n        else:\n            ans += cnt\n    return ans\n\nclass Pair:\n\n    def __init__(self, x, y, gcd):\n        self.x = x\n        self.y = y\n        self.gcd = gcd\n\ndef Euclidean(a, b):\n    if b == 0:\n        return Pair(1, 0, a)\n    dash = Euclidean(b, a % b)\n    return Pair(dash.y, dash.x - a // b * dash.y, dash.gcd)\n\ndef chineseRemainder(a1, n1, a2, n2):\n    p = Euclidean(n1, n2)\n    x = p.x\n    gcd = p.gcd\n    if (a1 - a2) % gcd:\n        return -1\n    k = (a1 - a2) // gcd\n    a = a1 - n1 * (k * x % n2 // gcd)\n    lcm = n1 * n2 // gcd\n    if a < 0:\n        a += lcm\n    return a\n\ndef ncr(n, k, md):\n    mod = 998244353\n    tab = [[0 for _ in range(k + 1)] for i in range(n + 1)]\n    for i in range(1, len(tab)):\n        tab[i][0] = 1\n    for i in range(1, len(tab)):\n        for j in range(1, min(i + 1, len(tab[0]))):\n            if i == 1 and j == 1:\n                tab[i][j] = 1\n            else:\n                tab[i][j] = (tab[i - 1][j] + tab[i - 1][j - 1]) % mod\n    return tab\n\ndef repeat(i, j, arr):\n    if i > j:\n        return\n    cnt1 = i\n    cnt2 = j\n    while cnt1 < cnt2:\n        (arr[cnt1], arr[cnt2]) = (arr[cnt2], arr[cnt1])\n        cnt1 += 1\n        cnt2 -= 1\n    if i - 1 >= 0:\n        ele = arr[i - 1]\n        if ele > 0:\n            s = int(sqrt(ele - 1)) + 1\n            first = s * s - ele\n            repeat(first, i - 1, arr)\n    return\nspf = []\n\ndef makeSeive(n):\n    for i in range(n + 1):\n        spf.append(i)\n\ndef seive(n):\n    s = int(sqrt(n + 1))\n    for i in range(2, s + 1):\n        if spf[i] == i:\n            for j in range(i * i, n + 1, i):\n                if spf[j] == j:\n                    spf[j] = i\n\ndef getFactorization(x):\n    ret = set()\n    while x != 1:\n        ret.add(spf[x])\n        x = x // spf[x]\n    return ret\n\ndef getLPS(s):\n    st = '@#' + '#'.join(s) + '#&'\n    c = 0\n    r = 0\n    lps = [0] * len(st)\n    for i in range(1, len(st) - 1):\n        mirror = c - (i - c)\n        if i < r and mirror >= 0:\n            lps[i] = min(lps[mirror], r - i)\n        while st[i + lps[i] + 1] == st[i - lps[i] - 1]:\n            lps[i] += 1\n        if i + lps[i] > r:\n            r = i + lps[i]\n            c = i\n    return max(lps)\nfact = [1 for _ in range(100002)]\nmod = 10 ** 9 + 7\n\ndef getFact(n):\n    for i in range(1, n + 1):\n        fact[i] = fact[i - 1] * i % mod\n\ndef getInv(word):\n    num = math.factorial(len(word))\n    for v in Counter(word).values():\n        num = num * pow(math.factorial(v), mod - 2, mod) % mod\n    return int(num) % (10 ** 9 + 7)\n\ndef subarrayXor(arr, n, m):\n    HashTable = defaultdict(bool)\n    HashTable[0] = 1\n    count = 0\n    curSum = 0\n    for i in arr:\n        curSum ^= i\n        if HashTable[curSum ^ m]:\n            count += HashTable[curSum ^ m]\n        HashTable[curSum] += 1\n    return count\n\ndef get2dPrefixSum(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef get2dPrefixSumCnt(matrix, mid=0):\n    n = len(matrix)\n    m = len(matrix[0])\n    prefix = [[0 for _ in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n    return prefix\n\ndef getSumRange(r1, c1, r2, c2, prefix):\n    cnt = prefix[r2][c2] - prefix[r2][c1 - 1] - prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1]\n    return cnt\n\ndef getPrefix(arr):\n    prefix = [0]\n    for i in arr:\n        prefix.append(prefix[-1] + i)\n    return prefix\n\ndef getInv(arr):\n    cnt = 0\n    ans = []\n    for i in arr:\n        ind = bisect_right(ans, i)\n        cnt += len(ans) - ind\n        insort(ans, i)\n    return cnt\nM = 10 ** 5\n\ndef getFactors(x):\n    temp = []\n    k = 1\n    while k * k <= x:\n        if x % k == 0:\n            temp.append(k)\n            if k * k != x:\n                temp.append(x // k)\n        k += 1\n    return temp\n\ndef grayCode(n):\n    if not n:\n        return [0]\n    res = [0, 1]\n    for i in range(2, n + 1):\n        for j in range(len(res) - 1, -1, -1):\n            res.append(res[j] | 1 << i - 1)\n    return res\n\ndef threeSum(nums, target):\n    ans = -1\n    d = dict()\n    for (i, j) in enumerate(nums):\n        d[j] = i + 1\n    nums.sort()\n    for i in range(len(nums) - 2):\n        low = i + 1\n        high = len(nums) - 1\n        while low < high:\n            s = nums[i] + nums[low] + nums[high]\n            if s == target:\n                print(d[nums[low]], d[nums[high]], d[nums[i]])\n                return\n                low += 1\n                high -= 1\n            elif s < 0:\n                low = low + 1\n            else:\n                high -= 1\n    print('IMPOSSIBLE')\n    return\n\ndef medianSlidingWindow(nums, k):\n    (low, high) = ([], [])\n    for i in range(k):\n        heapq.heappush(high, (nums[i], i))\n    for _ in range(k >> 1):\n        convert(high, low)\n    ans = {high[0][0] if k & 1 else min(high[0][0], low[0][0])}\n    for i in range(len(nums[k:])):\n        if nums[i + k] >= high[0][0]:\n            heapq.heappush(high, (nums[i + k], i + k))\n            if nums[i] <= high[0][0]:\n                convert(high, low)\n        else:\n            heapq.heappush(low, (-nums[i + k], i + k))\n            if nums[i] >= high[0][0]:\n                convert(low, high)\n        while low and low[0][1] <= i:\n            heapq.heappop(low)\n        while high and high[0][1] <= i:\n            heapq.heappop(high)\n        ans.append(high[0][0] if k & 1 else min(high[0][0], low[0][0]))\n    return [abs(i) for i in ans]\n\ndef convert(heap1, heap2):\n    (element, index) = heapq.heappop(heap1)\n    heapq.heappush(heap2, (-element, index))\n\ndef PrateekGoel(s, x):\n    A = (s - x) // 2\n    first = 0\n    second = 0\n    for i in range(32):\n        Xi = 1 << i & x\n        Ai = 1 << i & A\n        if Xi == 0 and Ai == 0:\n            continue\n        elif Xi == 0 and Ai > 0:\n            first |= 1 << i\n            second |= 1 << i\n        elif Xi > 0 and Ai == 0:\n            first |= 1 << i\n        else:\n            return [-1]\n    return [first, second]\n\ndef FUCKCF():\n    (n1, n2, m) = getInts()\n    val = m * (m + 1) // 2\n    mn = min(n1, n2)\n    mnn = min(mn, val)\n    print(n1 + n2 - 2 * mnn)\nt = 1\nt = int(input())\nfor i in range(t):\n    FUCKCF()", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    total = m * (m + 1) // 2\n    p = min(total, min(n1, n2))\n    print(abs(n1 + n2 - 2 * p))", "for t in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    sum = m * (m + 1) // 2\n    if sum > min(n1, n2):\n        print(abs(n1 - n2))\n    else:\n        print(int(n1 + n2 - sum * 2))", "for t in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    sum = m * (m + 1) // 2\n    if sum > min(n1, n2):\n        print(abs(n1 - n2))\n    else:\n        print(int(n1 + n2 - sum * 2))", "for t in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    sum = m * (m + 1) // 2\n    if sum > min(n1, n2):\n        print(abs(n1 - n2))\n    else:\n        print(int(n1 + n2 - sum * 2))", "for t in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    sum = m * (m + 1) / 2\n    if m * (m + 1) / 2 > min(n1, n2):\n        print(abs(n1 - n2))\n    else:\n        print(int(n1 + n2 - m * (m + 1)))", "t = input()\nfor c in range(0, int(t)):\n    (n1, n2, m) = map(int, input().split())\n    if m * (m + 1) / 2 > min(n1, n2):\n        print(abs(n1 - n2))\n    else:\n        print(n1 + n2 - m * (m + 1))", "t = input()\nfor c in range(0, int(t)):\n    (n1, n2, m) = map(int, input().split())\n    if m * (m + 1) / 2 > min(n1, n2):\n        print(abs(n1 - n2))\n    else:\n        print(n1 + n2 - m * (m + 1))", "t = int(input())\nfor i in range(t):\n    (n1, n2, m) = map(int, input().split())\n    if m * (m + 1) / 2 > min(n1, n2):\n        print(abs(n1 - n2))\n    else:\n        print(n1 + n2 - m * (m + 1))", "for _ in range(int(input())):\n    (a, b, c) = map(int, input().split())\n    n = c\n    x = 0\n    ans = 0\n    if a < b:\n        x = a\n    else:\n        x = b\n    summ = c * (c + 1)\n    summ = summ // 2\n    subt_val = min(x, summ)\n    print(a - subt_val + (b - subt_val))", "for _ in range(int(input())):\n    (a, b, c) = map(int, input().split())\n    n = c\n    x = 0\n    ans = 0\n    if a < b:\n        x = a\n    else:\n        x = b\n    summ = c * (c + 1)\n    summ = summ // 2\n    subt_val = min(x, summ)\n    print(a - subt_val + (b - subt_val))", "for _ in range(int(input())):\n    (a, b, c) = list(map(int, input().split()))\n    n = c\n    x = 0\n    ans = 0\n    if a < b:\n        x = a\n    else:\n        x = b\n    summ = c * (c + 1)\n    summ = summ // 2\n    subt_val = min(x, summ)\n    print(a - subt_val + (b - subt_val))", "for _ in range(int(input())):\n    mone = input()\n    lst = mone.split()\n    n1 = int(lst[0])\n    n2 = int(lst[1])\n    m = int(lst[2])\n    if m * (m + 1) / 2 > n1 and m * (m + 1) / 2 > n2:\n        print(abs(n1 - n2))\n    elif m * (m + 1) / 2 > n1:\n        print(n2 - n1)\n    elif m * (m + 1) / 2 > n2:\n        print(n1 - n2)\n    else:\n        print(n1 + n2 - m * (m + 1))", "from collections import Counter, UserString\nmod = lambda n: n % (10 ** 9 + 7)\nfc_ = [1]\nfor i in range(1, 1000001):\n    fc_.append(i * fc_[i - 1])\n    fc_[i] = mod(fc_[i])\n\ndef fact(n):\n    return fc_[n]\n\ndef printm(n):\n    print(mod(n))\n\ndef isPrime(n):\n    if n > 1:\n        for i in range(2, int(n ** 0.5) + 1):\n            if not n % i:\n                return False\n        else:\n            return True\n    return True\n\nclass mutableStr(UserString):\n\n    def ins(self, n, s):\n        if n < 0:\n            self.data = self.data = ''.join(list(self.data)[:n + 1]) + s + ''.join(list(self.data)[n + 1:])\n        else:\n            self.data = ''.join(list(self.data)[:n]) + s + ''.join(list(self.data)[n:])\n\n    def rem(self, s):\n        self.data = self.data.replace(s, '')\nalphabetOrd = [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]\nalphabet = list('abcdefghijklmnopqrstuvwxyz')\nr1 = lambda n: range(n)\nr2 = lambda n: range(1, n + 1)\nalph = lambda s: s.isalpha()\nsl = lambda l: list(set(l))\ninf = float('inf')\nsoi = lambda : sorted(input())\nii = lambda : int(input())\nli = lambda : list(map(int, input().split()))\nsi = lambda : mutableStr(input())\nlsi = lambda : list(input())\nsepi = lambda : map(int, input().split())\nseti = lambda : set(map(int, input().split()))\nfor t in range(int(input())):\n    (n1, n2, m) = sepi()\n    j = m * (m + 1) // 2\n    if j >= n1 or j >= n2:\n        print(abs(n1 - n2))\n    else:\n        print(n1 + n2 - 2 * j)", "from collections import Counter, UserString\nmod = lambda n: n % (10 ** 9 + 7)\nfc_ = [1]\nfor i in range(1, 1000001):\n    fc_.append(i * fc_[i - 1])\n    fc_[i] = mod(fc_[i])\n\ndef fact(n):\n    return fc_[n]\n\ndef printm(n):\n    print(mod(n))\n\ndef isPrime(n):\n    if n > 1:\n        for i in range(2, int(n ** 0.5) + 1):\n            if not n % i:\n                return False\n        else:\n            return True\n    return True\n\nclass mutableStr(UserString):\n\n    def ins(self, n, s):\n        if n < 0:\n            self.data = self.data = ''.join(list(self.data)[:n + 1]) + s + ''.join(list(self.data)[n + 1:])\n        else:\n            self.data = ''.join(list(self.data)[:n]) + s + ''.join(list(self.data)[n:])\n\n    def rem(self, s):\n        self.data = self.data.replace(s, '')\nalphabetOrd = [97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122]\nalphabet = list('abcdefghijklmnopqrstuvwxyz')\nr1 = lambda n: range(n)\nr2 = lambda n: range(1, n + 1)\nalph = lambda s: s.isalpha()\nsl = lambda l: list(set(l))\ninf = float('inf')\nsoi = lambda : sorted(input())\nii = lambda : int(input())\nli = lambda : list(map(int, input().split()))\nsi = lambda : mutableStr(input())\nlsi = lambda : list(input())\nsepi = lambda : map(int, input().split())\nseti = lambda : set(map(int, input().split()))\nfor t in range(int(input())):\n    (n1, n2, m) = sepi()\n    j = m * (m + 1) // 2\n    if j >= n1 or j >= n2:\n        print(abs(n1 - n2))\n    else:\n        print(n1 + n2 - 2 * j)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    total = m * (m + 1) // 2\n    possible = min(total, min(n1, n2))\n    print(abs(n1 + n2 - 2 * possible))", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    total = m * (m + 1) // 2\n    possible = min(total, min(n1, n2))\n    print(abs(n1 + n2 - 2 * possible))", "t = int(input())\nfor i in range(t):\n    (n1, n2, m) = map(int, input().split(' '))\n    total = m * (m + 1) // 2\n    if total >= min(n1, n2):\n        print(max(n1, n2) - min(n1, n2))\n    else:\n        p1 = n1 - total\n        p2 = n2 - total\n        sum = p1 + p2\n        print(sum)", "t = int(input())\nfor i in range(t):\n    (n1, n2, m) = map(int, input().split(' '))\n    total = m * (m + 1) // 2\n    if total >= min(n1, n2):\n        print(max(n1, n2) - min(n1, n2))\n    else:\n        p1 = n1 - total\n        p2 = n2 - total\n        sum = p1 + p2\n        print(sum)", "for t in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    n = m * (m + 1) // 2\n    a = min(n1, n2, n)\n    print(n1 + n2 - 2 * a)", "t = int(input())\nfor z in range(t):\n    (n, m, a) = map(int, input().split())\n    s = a * (a + 1) // 2\n    l = min(n, m, s)\n    la = n + m - l - l\n    print(la)", "T = int(input())\nfor i in range(T):\n    (n1, n2, m) = map(int, input().split())\n    j = m * (m + 1) // 2\n    if j >= n1 or j >= n2:\n        print(abs(n1 - n2))\n    else:\n        print(n1 + n2 - 2 * j)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    m_tot = m * (m + 1) // 2\n    low = min(n1, n2)\n    if m_tot > low:\n        v = low\n    else:\n        v = m_tot\n    print(n1 + n2 - v * 2)", "tests = int(input())\nfor i in range(tests):\n    (a, b, m) = map(int, input().split())\n    max_removed = m * (m + 1) // 2\n    minimum = min(a, b, max_removed)\n    print(a + b - 2 * minimum)", "tests = int(input())\nfor i in range(tests):\n    (a, b, m) = map(int, input().split())\n    max_removed = m * (m + 1) // 2\n    minimum = min(a, b, max_removed)\n    print(a - minimum + b - minimum)", "t = int(input())\nfor z in range(t):\n    (n, m, a) = map(int, input().split())\n    s = a * (a + 1) // 2\n    l = min(n, m, s)\n    la = n + m - l - l\n    print(la)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    max_val = m * (m + 1) // 2\n    min_val = min(n1, n2, max_val)\n    print(n1 - min_val + (n2 - min_val))", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    mini = min(n1, n2)\n    maxi = max(n1, n2)\n    del n2\n    if mini <= m:\n        maxi -= mini\n        mini = 0\n        print(mini + maxi)\n    else:\n        n1 = m * (m + 1) // 2\n        if n1 >= mini:\n            maxi -= mini\n            mini = 0\n        else:\n            mini -= n1\n            maxi -= n1\n        print(mini + maxi)", "for _ in range(int(input())):\n    (a, b, m) = map(int, input().split())\n    n = min(a, b)\n    m = m * (m + 1) // 2\n    if m <= n:\n        c = a + b - 2 * m\n    else:\n        c = a + b - n - n\n    print(c)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    a = m * (m + 1) // 2\n    b = min(n1, n2)\n    if b >= a:\n        print(n1 + n2 - 2 * a)\n    else:\n        print(n1 + n2 - 2 * b)", "a = int(input())\ninputbag = []\nfor i in range(0, a):\n    temp = list(map(int, input().split(' ')))\n    inputbag.append(temp)\n    (a, b, c) = temp\n    temp1 = max(a + b - c * (c + 1), a - b, b - a)\n    print(int(temp1))", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    a = m * (m + 1) // 2\n    b = min(n1, n2)\n    if b >= a:\n        print(n1 + n2 - 2 * a)\n    else:\n        print(n1 + n2 - 2 * b)", "for xxxxxxxx in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    print(max(n1 + n2 - m * (m + 1), n1 - n2, n2 - n1))", "for _ in range(int(input())):\n    (a, b, m) = [int(s) for s in input().split()]\n    mc2 = m * (m + 1) // 2\n    if min(a, b) > mc2:\n        print(a + b - (mc2 << 1))\n    else:\n        print(abs(a - b))", "t = int(input())\nfor i in range(t):\n    (n1, n2, m) = map(int, input().split())\n    z = m * (m + 1) // 2\n    if z > min(n1, n2):\n        print(n1 + n2 - 2 * min(n1, n2))\n    else:\n        print(n1 + n2 - 2 * z)", "t = int(input())\nfor i in range(t):\n    (n1, n2, m) = map(int, input().split())\n    z = m * (m + 1) // 2\n    if z > min(n1, n2):\n        print(n1 + n2 - 2 * min(n1, n2))\n    else:\n        print(n1 + n2 - 2 * z)", "tc = int(input())\nfor _ in range(1, 1 + tc):\n    (n1, n2, m) = map(int, input().split())\n    x = min(m * (m + 1) // 2, n1, n2)\n    ans = n1 + n2 - 2 * x\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n1, n2, m) = map(int, input().split())\n    maxi = m * (m + 1)\n    if n1 >= maxi // 2 and n2 >= maxi // 2:\n        ans = n1 + n2 - maxi\n    else:\n        ans = abs(n1 - n2)\n    print(ans)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    max_val = m * (m + 1) // 2\n    min_val = min(n1, n2, max_val)\n    print(n1 - min_val + (n2 - min_val))", "t = int(input())\nfor _ in range(t):\n    (n1, n2, m) = map(int, input().split())\n    maxi = m * (m + 1)\n    if n1 >= maxi // 2 and n2 >= maxi // 2:\n        ans = n1 + n2 - maxi\n    else:\n        ans = abs(n1 - n2)\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    (n1, n2, m) = map(int, input().split())\n    res = max(n1 + n2 - m * (m + 1), abs(n1 - n2))\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    max_val = m * (m + 1) // 2\n    min_val = min(n1, n2, max_val)\n    print(n1 - min_val + (n2 - min_val))", "for i in range(int(input())):\n    (pile1, pile2, m) = map(int, input().split(' '))\n    min_ = min(pile1, pile2)\n    max_ = m * (m + 1) // 2\n    if min_ <= max_:\n        print(pile1 + pile2 - 2 * min_)\n    else:\n        print(pile1 + pile2 - 2 * max_)", "for i in range(int(input())):\n    (pile1, pile2, m) = map(int, input().split(' '))\n    min_ = min(pile1, pile2)\n    max_ = m * (m + 1) // 2\n    if min_ <= max_:\n        print(pile1 + pile2 - 2 * min_)\n    else:\n        print(pile1 + pile2 - 2 * max_)", "for i in range(int(input())):\n    (pile1, pile2, m) = map(int, input().split(' '))\n    min_ = min(pile1, pile2)\n    max_ = m * (m + 1) // 2\n    if min_ <= max_:\n        print(pile1 + pile2 - 2 * min_)\n    else:\n        print(pile1 + pile2 - 2 * max_)", "for i in range(int(input())):\n    (pile1, pile2, m) = map(int, input().split(' '))\n    min_ = min(pile1, pile2)\n    max_ = m * (m + 1) // 2\n    if min_ <= max_:\n        print(pile1 + pile2 - 2 * min_)\n    else:\n        print(pile1 + pile2 - 2 * max_)", "n = int(input())\nfor i in range(n):\n    (n1, n2, n3) = map(int, input().split())\n    n4 = min(n1, n2)\n    n5 = n3 * (n3 + 1) // 2\n    n6 = n1 + n2\n    if n4 > n5:\n        print(n6 - 2 * n5)\n    else:\n        print(max(n1, n2) - min(n1, n2))", "test = int(input())\nfor _ in range(test):\n    (p, q, m) = list(map(int, input().split()))\n    t = min(p, q)\n    s = m * (m + 1) // 2\n    if t > s:\n        print(p + q - 2 * s)\n    else:\n        print(max(p, q) - min(p, q))", "test = int(input())\nfor _ in range(test):\n    (p, q, m) = list(map(int, input().split()))\n    t = min(p, q)\n    s = m * (m + 1) // 2\n    if t > s:\n        print(p + q - 2 * s)\n    else:\n        print(max(p, q) - min(p, q))", "test = int(input())\nfor _ in range(test):\n    (p, q, m) = list(map(int, input().split()))\n    t = min(p, q)\n    s = m * (m + 1) // 2\n    if t > s:\n        print(p + q - 2 * s)\n    else:\n        print(max(p, q) - min(p, q))", "tc = int(input())\nfor i in range(tc):\n    (x, y, m) = map(int, input().split())\n    min_ = min(x, y)\n    m = m * (m + 1) // 2\n    if m <= min_:\n        res = x + y - 2 * m\n    else:\n        res = x + y - 2 * min_\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    mini = min(n1, n2)\n    s = m * (m + 1) // 2\n    if s >= mini:\n        print(abs(n2 - n1))\n    else:\n        print(n2 + n1 - 2 * s)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    mini = min(n1, n2)\n    s = m * (m + 1) // 2\n    if s >= mini:\n        print(abs(n2 - n1))\n    else:\n        print(n2 + n1 - 2 * s)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    mini = min(n1, n2)\n    s = m * (m + 1) // 2\n    if s >= mini:\n        print(abs(n2 - n1))\n    else:\n        print(n2 + n1 - 2 * s)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    mini = min(n1, n2)\n    s = m * (m + 1) // 2\n    if s >= mini:\n        print(abs(n2 - n1))\n    else:\n        print(n2 + n1 - 2 * s)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    mini = min(n1, n2)\n    s = m * (m + 1) // 2\n    if s >= mini:\n        print(abs(n2 - n1))\n    else:\n        print(n2 + n1 - 2 * s)", "for i in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    k = min(n1, n2, m * (m + 1) // 2)\n    print(n1 + n2 - 2 * k)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        res = n1 + n2 - val - val\n    else:\n        res = n1 + n2 - mn - mn\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    ap = m * (1 + m) // 2\n    if n1 >= ap and n2 >= ap:\n        print(n1 + n2 - 2 * ap)\n    else:\n        print(abs(n1 - n2))", "for _ in range(int(input())):\n    (stonesInPileOne, stonesInPileTwo, m) = map(int, input().split())\n    smallestPile = min(stonesInPileOne, stonesInPileTwo)\n    maxPossibleStoneRemovable = 0\n    if smallestPile > m:\n        maxPossibleStoneRemovable = min(m * (m + 1) // 2, smallestPile)\n    else:\n        maxPossibleStoneRemovable = smallestPile\n    print(stonesInPileOne + stonesInPileTwo - 2 * maxPossibleStoneRemovable)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    a = m * (m + 1) // 2\n    if a < n1 and a < n2:\n        print(n1 + n2 - 2 * a)\n    else:\n        print(abs(n1 - n2))", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    ap = m * (1 + m) // 2\n    if n1 >= ap and n2 >= ap:\n        print(n1 + n2 - 2 * ap)\n    else:\n        print(abs(n1 - n2))", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    ap = m * (1 + m) // 2\n    if n1 >= ap and n2 >= ap:\n        print(n1 + n2 - 2 * ap)\n    else:\n        print(abs(n1 - n2))", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    ap = m * (1 + m) // 2\n    if n1 >= ap and n2 >= ap:\n        print(n1 + n2 - 2 * ap)\n    else:\n        print(abs(n1 - n2))", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        res = n1 + n2 - val - val\n    else:\n        res = n1 + n2 - mn - mn\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        res = n1 + n2 - val - val\n    else:\n        res = n1 + n2 - mn - mn\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        res = n1 + n2 - val - val\n    else:\n        res = n1 + n2 - mn - mn\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        res = n1 + n2 - val - val\n    else:\n        res = n1 + n2 - mn - mn\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        res = n1 + n2 - val - val\n    else:\n        res = n1 + n2 - mn - mn\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        res = n1 + n2 - val - val\n    else:\n        res = n1 + n2 - mn - mn\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        ans = n1 + n2 - val - val\n    else:\n        ans = n1 + n2 - mn - mn\n    print(ans)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        ans = n1 + n2 - val - val\n    else:\n        ans = n1 + n2 - mn - mn\n    print(ans)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        res = n1 + n2 - val - val\n    else:\n        res = n1 + n2 - mn - mn\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        res = n1 + n2 - val - val\n    else:\n        res = n1 + n2 - mn - mn\n    print(res)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        ans = n1 + n2 - val - val\n    else:\n        ans = n1 + n2 - mn - mn\n    print(ans)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        ans = n1 + n2 - val - val\n    else:\n        ans = n1 + n2 - mn - mn\n    print(ans)", "t = int(input())\nfor i in range(t):\n    (x, y, m) = map(int, input().split())\n    n = min(x, y)\n    if m * (m + 1) / 2 > n:\n        print(x + y - 2 * n)\n    else:\n        print(x + y - m * (m + 1))", "t = int(input())\nfor i in range(t):\n    (x, y, m) = map(int, input().split())\n    n = min(x, y)\n    if m * (m + 1) / 2 > n:\n        print(x + y - 2 * n)\n    else:\n        print(x + y - m * (m + 1))", "T = int(input())\nwhile T > 0:\n    (n1, n2, M) = map(int, input().split())\n    maxRemoval = M * (M + 1) // 2\n    currentRemoval = min(n1, n2)\n    if currentRemoval < maxRemoval:\n        print(n1 + n2 - 2 * currentRemoval)\n    else:\n        print(n1 + n2 - 2 * maxRemoval)\n    T -= 1", "t = int(input())\nfor i in range(t):\n    (x, y, m) = map(int, input().split())\n    n = min(x, y)\n    if m * (m + 1) / 2 > n:\n        print(x + y - 2 * n)\n    else:\n        print(x + y - m * (m + 1))", "try:\n    for _ in range(int(input())):\n        (a, b, m) = map(int, input().split())\n        (a, b) = (min(a, b), max(a, b))\n        m = m * (m + 1) // 2\n        if a > m:\n            print(a + b - 2 * m)\n        else:\n            print(b - a)\nexcept:\n    pass", "numTest = int(input())\nfor _ in range(numTest):\n    (n1, n2, m) = tuple(map(int, input().split()))\n    mn = min(n1, n2)\n    m = int(m * (m + 1) // 2)\n    if mn >= m:\n        print(n1 + n2 - 2 * m)\n    else:\n        print(n1 + n2 - 2 * mn)", "for _ in range(int(input())):\n    (a, b, m) = map(int, input().split())\n    (a, b) = (min(a, b), max(a, b))\n    m = m * (m + 1) // 2\n    if a > m:\n        print(a + b - 2 * m)\n    else:\n        print(b - a)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        ans = n1 + n2 - val - val\n    else:\n        ans = n1 + n2 - mn - mn\n    print(ans)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        ans = n1 + n2 - val - val\n    else:\n        ans = n1 + n2 - mn - mn\n    print(ans)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        ans = n1 + n2 - val - val\n    else:\n        ans = n1 + n2 - mn - mn\n    print(ans)", "for _ in range(int(input())):\n    (n1, n2, val) = map(int, input().split())\n    mn = min(n1, n2)\n    val = val * (val + 1) // 2\n    if val <= mn:\n        ans = n1 + n2 - val - val\n    else:\n        ans = n1 + n2 - mn - mn\n    print(ans)", "for t in range(0, int(input())):\n    (n1, n2, m) = map(int, input().split())\n    total = 0\n    mini = min(n1, n2)\n    total = m * (m + 1) // 2\n    if total >= mini:\n        if n1 == mini:\n            print(n2 - mini)\n        else:\n            print(n1 - mini)\n    else:\n        print(n1 - total + n2 - total)", "for t in range(0, int(input())):\n    (n1, n2, m) = map(int, input().split())\n    total = 0\n    mini = min(n1, n2)\n    if m >= mini:\n        if n1 == mini:\n            print(n2 - mini)\n        else:\n            print(n1 - mini)\n    else:\n        total = m * (m + 1) // 2\n        if total >= mini:\n            if n1 == mini:\n                print(n2 - mini)\n            else:\n                print(n1 - mini)\n        else:\n            print(n1 - total + n2 - total)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    nMin = min(n1, n2)\n    m = m * (m + 1) // 2\n    if nMin < m:\n        print(abs(n1 - n2))\n    else:\n        print(n1 + n2 - m * 2)", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    m = m * (m + 1) // 2\n    if min(n1, n2) > m:\n        print(n1 + n2 - 2 * m)\n    else:\n        print(abs(n1 - n2))", "for _ in range(int(input())):\n    (n1, n2, m) = map(int, input().split())\n    m = m * (m + 1) // 2\n    if min(n1, n2) > m:\n        print(n1 + n2 - 2 * m)\n    else:\n        print(abs(n1 - n2))", "import numpy as np\nT = int(input())\noutput = []\nfor t in range(T):\n    (n1, n2, m) = [int(x) for x in input().split()]\n    n_min = min(n1, n2)\n    n_max = max(n1, n2)\n    diff = n_max - n_min\n    tmp = m * (m + 1) // 2\n    if tmp <= n_min:\n        stones_left = n_min - tmp\n        output.append(2 * stones_left + diff)\n    else:\n        k = int(np.sqrt(2 * n_min))\n        while k * (k + 1) / 2 > n_min:\n            k -= 1\n        initial_sum = k * (k + 1) // 2\n        if initial_sum == n_min:\n            output.append(diff)\n        else:\n            max_gain = m - 1\n            if n_min - initial_sum <= max_gain:\n                output.append(diff)\n            else:\n                output.append(2 * (n_min - initial_sum - max_gain) + diff)\nfor o in output:\n    print(o)", "t = int(input())\nfor _ in range(t):\n    (x, y, m) = map(int, input().split())\n    m = m * (m + 1) // 2\n    if min(x, y) <= m:\n        print(abs(x - y))\n    else:\n        print(x + y - 2 * m)"]