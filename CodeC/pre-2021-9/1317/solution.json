["from sys import stdin\nfrom sys import stdout\n\nclass BITree:\n    nodes = []\n    n = 0\n\n    def __init__(self, n):\n        self.nodes = [0] * (n + 1)\n        self.n = n + 1\n\n    def add(self, idx, val):\n        idx += 1\n        while idx < self.n:\n            self.nodes[idx] += val\n            idx += idx & -idx\n\n    def sum(self, idx):\n        r = 0\n        idx += 1\n        while idx > 0:\n            r += self.nodes[idx]\n            idx -= idx & -idx\n        return r\nT = int(input())\nfor t in range(0, T):\n    tree = BITree(2000000)\n    (n, q) = map(lambda x: int(x), input().split(' '))\n    points = []\n    for i in range(0, n):\n        xy = input().split(' ')\n        x = int(xy[0])\n        y = int(xy[1])\n        points.append((y - x, x + y))\n    points.sort(key=lambda p: p[0])\n    queries = []\n    for i in range(0, q):\n        lr = input().split(' ')\n        l = int(lr[0])\n        r = int(lr[1])\n        queries.append((-l, r, i))\n    queries.sort(key=lambda p: p[0])\n    solution = [0] * q\n    idx = 0\n    for i in range(0, q):\n        li = queries[i][0]\n        ri = queries[i][1]\n        query_idx = queries[i][2]\n        while idx < n and points[idx][0] <= li:\n            tree.add(points[idx][1], 1)\n            idx += 1\n        solution[query_idx] = str(tree.sum(ri))\n    print(' '.join(solution))", "from sys import stdin\nfrom sys import stdout\n\nclass BITree:\n    nodes = []\n    n = 0\n\n    def __init__(self, n):\n        self.nodes = [0] * (n + 1)\n        self.n = n + 1\n\n    def add(self, idx, val):\n        idx += 1\n        while idx < self.n:\n            self.nodes[idx] += val\n            idx += idx & -idx\n\n    def sum(self, idx):\n        r = 0\n        idx += 1\n        while idx > 0:\n            r += self.nodes[idx]\n            idx -= idx & -idx\n        return r\nT = int(stdin.readline())\nfor t in range(0, T):\n    tree = BITree(2000000)\n    (n, q) = map(lambda x: int(x), stdin.readline().split(' '))\n    points = []\n    for i in range(0, n):\n        xy = stdin.readline().split(' ')\n        x = int(xy[0])\n        y = int(xy[1])\n        points.append((y - x, x + y))\n    points.sort(key=lambda p: p[0])\n    queries = []\n    for i in range(0, q):\n        lr = stdin.readline().split(' ')\n        l = int(lr[0])\n        r = int(lr[1])\n        queries.append((-l, r, i))\n    queries.sort(key=lambda p: p[0])\n    solution = [0] * q\n    idx = 0\n    for i in range(0, q):\n        li = queries[i][0]\n        ri = queries[i][1]\n        query_idx = queries[i][2]\n        while idx < n and points[idx][0] <= li:\n            tree.add(points[idx][1], 1)\n            idx += 1\n        solution[query_idx] = str(tree.sum(ri))\n    print(' '.join(solution))"]