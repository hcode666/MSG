["(n, q) = map(int, input().split())\nglobal segment_tree, arr\narr = list(map(int, input().split()))\nsegment_tree = [0] * (4 * n)\n\nclass Node:\n\n    def __init__(self):\n        self.xory = 0\n        self.min_val = 10 ** 9\n\ndef build_tree(start, end, treenode=0):\n    global segment_tree, arr\n    if start == end:\n        node = Node()\n        node.min_val = arr[start]\n        node.xory = arr[start]\n        segment_tree[treenode] = node\n        return\n    mid = (start + end) // 2\n    build_tree(start, mid, 2 * treenode + 1)\n    build_tree(mid + 1, end, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    node = Node()\n    node.min_val = min(n1.min_val, n2.min_val)\n    node.xory = n1.xory | n2.xory\n    segment_tree[treenode] = node\n\ndef update_query(start, end, left, right, value, treenode=0):\n    global segment_tree\n    if left > end or right < start:\n        return\n    elif start == end and left <= start and (right >= end):\n        segment_tree[treenode].min_val = segment_tree[treenode].min_val & value\n        segment_tree[treenode].xory = segment_tree[treenode].min_val\n        return\n    else:\n        call = False\n        for bit_count in range(32):\n            if not value >> bit_count & 1 and segment_tree[treenode].xory >> bit_count & 1:\n                call = True\n                break\n        if not call:\n            return\n        mid = (start + end) // 2\n        update_query(start, mid, left, right, value, 2 * treenode + 1)\n        update_query(mid + 1, end, left, right, value, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    segment_tree[treenode].min_val = min(n1.min_val, n2.min_val)\n    segment_tree[treenode].xory = n1.xory | n2.xory\n\ndef retrieve_query(start, end, left, right, treenode=0):\n    if left > end or right < start:\n        return 10 ** 9\n    elif left <= start and right >= end:\n        return segment_tree[treenode].min_val\n    else:\n        mid = (start + end) // 2\n        ans1 = retrieve_query(start, mid, left, right, 2 * treenode + 1)\n        ans2 = retrieve_query(mid + 1, end, left, right, 2 * treenode + 2)\n        return min(ans1, ans2)\nbuild_tree(0, len(arr) - 1)\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        print(retrieve_query(0, len(arr) - 1, query[1] - 1, query[2] - 1))\n    else:\n        update_query(0, len(arr) - 1, query[1] - 1, query[2] - 1, query[3])", "(n, q) = map(int, input().split())\nglobal segment_tree, arr\narr = list(map(int, input().split()))\nsegment_tree = [0] * (4 * n)\n\nclass Node:\n\n    def __init__(self):\n        self.xory = 0\n        self.min_val = 10 ** 9\n\ndef build_tree(start, end, treenode=0):\n    global segment_tree, arr\n    if start == end:\n        node = Node()\n        node.min_val = arr[start]\n        node.xory = arr[start]\n        segment_tree[treenode] = node\n        return\n    mid = (start + end) // 2\n    build_tree(start, mid, 2 * treenode + 1)\n    build_tree(mid + 1, end, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    node = Node()\n    node.min_val = min(n1.min_val, n2.min_val)\n    node.xory = n1.xory | n2.xory\n    segment_tree[treenode] = node\n\ndef update_query(start, end, left, right, value, treenode=0):\n    global segment_tree\n    if left > end or right < start:\n        return\n    elif start == end and left <= start and (right >= end):\n        segment_tree[treenode].min_val = segment_tree[treenode].min_val & value\n        segment_tree[treenode].xory = segment_tree[treenode].min_val\n        return\n    else:\n        call = False\n        for bit_count in range(32):\n            if not value >> bit_count & 1 and segment_tree[treenode].xory >> bit_count & 1:\n                call = True\n                break\n        if not call:\n            return\n        mid = (start + end) // 2\n        update_query(start, mid, left, right, value, 2 * treenode + 1)\n        update_query(mid + 1, end, left, right, value, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    segment_tree[treenode].min_val = min(n1.min_val, n2.min_val)\n    segment_tree[treenode].xory = n1.xory | n2.xory\n\ndef retrieve_query(start, end, left, right, treenode=0):\n    if left > end or right < start:\n        return 10 ** 9\n    elif left <= start and right >= end:\n        return segment_tree[treenode].min_val\n    else:\n        mid = (start + end) // 2\n        ans1 = retrieve_query(start, mid, left, right, 2 * treenode + 1)\n        ans2 = retrieve_query(mid + 1, end, left, right, 2 * treenode + 2)\n        return min(ans1, ans2)\nbuild_tree(0, len(arr) - 1)\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        print(retrieve_query(0, len(arr) - 1, query[1] - 1, query[2] - 1))\n    else:\n        update_query(0, len(arr) - 1, query[1] - 1, query[2] - 1, query[3])", "(n, q) = map(int, input().split())\nglobal segment_tree, arr\narr = list(map(int, input().split()))\nsegment_tree = [0] * (4 * n)\n\nclass Node:\n\n    def __init__(self):\n        self.xory = 0\n        self.min_val = 10 ** 9\n\ndef build_tree(start, end, treenode=0):\n    global segment_tree, arr\n    if start == end:\n        node = Node()\n        node.min_val = arr[start]\n        node.xory = arr[start]\n        segment_tree[treenode] = node\n        return\n    mid = (start + end) // 2\n    build_tree(start, mid, 2 * treenode + 1)\n    build_tree(mid + 1, end, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    node = Node()\n    node.min_val = min(n1.min_val, n2.min_val)\n    node.xory = n1.xory | n2.xory\n    segment_tree[treenode] = node\n\ndef update_query(start, end, left, right, value, treenode=0):\n    global segment_tree\n    if left > end or right < start:\n        return\n    elif start == end and left <= start and (right >= end):\n        segment_tree[treenode].min_val = segment_tree[treenode].min_val & value\n        segment_tree[treenode].xory = segment_tree[treenode].min_val\n        return\n    else:\n        call = False\n        for bit_count in range(32):\n            if not value >> bit_count & 1 and segment_tree[treenode].xory >> bit_count & 1:\n                call = True\n                break\n        if not call:\n            return\n        mid = (start + end) // 2\n        update_query(start, mid, left, right, value, 2 * treenode + 1)\n        update_query(mid + 1, end, left, right, value, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    segment_tree[treenode].min_val = min(n1.min_val, n2.min_val)\n    segment_tree[treenode].xory = n1.xory | n2.xory\n\ndef retrieve_query(start, end, left, right, treenode=0):\n    if left > end or right < start:\n        return 10 ** 9\n    elif left <= start and right >= end:\n        return segment_tree[treenode].min_val\n    else:\n        mid = (start + end) // 2\n        ans1 = retrieve_query(start, mid, left, right, 2 * treenode + 1)\n        ans2 = retrieve_query(mid + 1, end, left, right, 2 * treenode + 2)\n        return min(ans1, ans2)\nbuild_tree(0, len(arr) - 1)\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        print(retrieve_query(0, len(arr) - 1, query[1] - 1, query[2] - 1))\n    else:\n        update_query(0, len(arr) - 1, query[1] - 1, query[2] - 1, query[3])", "(n, q) = map(int, input().split())\nglobal segment_tree, arr\narr = list(map(int, input().split()))\nsegment_tree = [0] * (4 * n)\n\nclass Node:\n\n    def __init__(self):\n        self.xory = 0\n        self.min_val = 10 ** 9\n\ndef build_tree(start, end, treenode=0):\n    global segment_tree, arr\n    if start == end:\n        node = Node()\n        node.min_val = arr[start]\n        node.xory = arr[start]\n        segment_tree[treenode] = node\n        return\n    mid = (start + end) // 2\n    build_tree(start, mid, 2 * treenode + 1)\n    build_tree(mid + 1, end, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    node = Node()\n    node.min_val = min(n1.min_val, n2.min_val)\n    node.xory = n1.xory | n2.xory\n    segment_tree[treenode] = node\n\ndef update_query(start, end, left, right, value, treenode=0):\n    global segment_tree\n    if left > end or right < start:\n        return\n    elif start == end and left <= start and (right >= end):\n        segment_tree[treenode].min_val = segment_tree[treenode].min_val & value\n        segment_tree[treenode].xory = segment_tree[treenode].min_val\n        return\n    else:\n        call = False\n        for bit_count in range(32):\n            if not value >> bit_count & 1 and segment_tree[treenode].xory >> bit_count & 1:\n                call = True\n                break\n        if not call:\n            return\n        mid = (start + end) // 2\n        update_query(start, mid, left, right, value, 2 * treenode + 1)\n        update_query(mid + 1, end, left, right, value, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    segment_tree[treenode].min_val = min(n1.min_val, n2.min_val)\n    segment_tree[treenode].xory = n1.xory | n2.xory\n\ndef retrieve_query(start, end, left, right, treenode=0):\n    if left > end or right < start:\n        return 10 ** 9\n    elif left <= start and right >= end:\n        return segment_tree[treenode].min_val\n    else:\n        mid = (start + end) // 2\n        ans1 = retrieve_query(start, mid, left, right, 2 * treenode + 1)\n        ans2 = retrieve_query(mid + 1, end, left, right, 2 * treenode + 2)\n        return min(ans1, ans2)\nbuild_tree(0, len(arr) - 1)\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        print(retrieve_query(0, len(arr) - 1, query[1] - 1, query[2] - 1))\n    else:\n        update_query(0, len(arr) - 1, query[1] - 1, query[2] - 1, query[3])", "(n, q) = map(int, input().split())\nglobal segment_tree, arr\narr = list(map(int, input().split()))\nsegment_tree = [0] * (4 * n)\n\nclass Node:\n\n    def __init__(self):\n        self.xory = 0\n        self.min_val = 10 ** 9\n\ndef build_tree(start, end, treenode=0):\n    global segment_tree, arr\n    if start == end:\n        node = Node()\n        node.min_val = arr[start]\n        node.xory = arr[start]\n        segment_tree[treenode] = node\n        return\n    mid = (start + end) // 2\n    build_tree(start, mid, 2 * treenode + 1)\n    build_tree(mid + 1, end, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    node = Node()\n    node.min_val = min(n1.min_val, n2.min_val)\n    node.xory = n1.xory | n2.xory\n    segment_tree[treenode] = node\n\ndef update_query(start, end, left, right, value, treenode=0):\n    global segment_tree\n    if left > end or right < start:\n        return\n    elif start == end and left <= start and (right >= end):\n        segment_tree[treenode].min_val = segment_tree[treenode].min_val & value\n        segment_tree[treenode].xory = segment_tree[treenode].min_val\n        return\n    else:\n        call = False\n        for bit_count in range(32):\n            if not value >> bit_count & 1 and segment_tree[treenode].xory >> bit_count & 1:\n                call = True\n                break\n        if not call:\n            return\n        mid = (start + end) // 2\n        update_query(start, mid, left, right, value, 2 * treenode + 1)\n        update_query(mid + 1, end, left, right, value, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    segment_tree[treenode].min_val = min(n1.min_val, n2.min_val)\n    segment_tree[treenode].xory = n1.xory | n2.xory\n\ndef retrieve_query(start, end, left, right, treenode=0):\n    if left > end or right < start:\n        return 10 ** 9\n    elif left <= start and right >= end:\n        return segment_tree[treenode].min_val\n    else:\n        mid = (start + end) // 2\n        ans1 = retrieve_query(start, mid, left, right, 2 * treenode + 1)\n        ans2 = retrieve_query(mid + 1, end, left, right, 2 * treenode + 2)\n        return min(ans1, ans2)\nbuild_tree(0, len(arr) - 1)\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        print(retrieve_query(0, len(arr) - 1, query[1] - 1, query[2] - 1))\n    else:\n        update_query(0, len(arr) - 1, query[1] - 1, query[2] - 1, query[3])", "(n, q) = map(int, input().split())\nglobal segment_tree, arr\narr = list(map(int, input().split()))\nsegment_tree = [0] * (4 * n)\n\nclass Node:\n\n    def __init__(self):\n        self.xory = 0\n        self.min_val = 10 ** 9\n\ndef build_tree(start, end, treenode=0):\n    global segment_tree, arr\n    if start == end:\n        node = Node()\n        node.min_val = arr[start]\n        node.xory = arr[start]\n        segment_tree[treenode] = node\n        return\n    mid = (start + end) // 2\n    build_tree(start, mid, 2 * treenode + 1)\n    build_tree(mid + 1, end, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    node = Node()\n    node.min_val = min(n1.min_val, n2.min_val)\n    node.xory = n1.xory | n2.xory\n    segment_tree[treenode] = node\n\ndef update_query(start, end, left, right, value, treenode=0):\n    global segment_tree\n    if left > end or right < start:\n        return\n    elif start == end and left <= start and (right >= end):\n        segment_tree[treenode].min_val = segment_tree[treenode].min_val & value\n        segment_tree[treenode].xory = segment_tree[treenode].min_val\n        return\n    else:\n        call = False\n        for bit_count in range(32):\n            if not value >> bit_count & 1 and segment_tree[treenode].xory >> bit_count & 1:\n                call = True\n                break\n        if not call:\n            return\n        mid = (start + end) // 2\n        update_query(start, mid, left, right, value, 2 * treenode + 1)\n        update_query(mid + 1, end, left, right, value, 2 * treenode + 2)\n    n1 = segment_tree[2 * treenode + 1]\n    n2 = segment_tree[2 * treenode + 2]\n    segment_tree[treenode].min_val = min(n1.min_val, n2.min_val)\n    segment_tree[treenode].xory = n1.xory | n2.xory\n\ndef retrieve_query(start, end, left, right, treenode=0):\n    if left > end or right < start:\n        return 10 ** 9\n    elif left <= start and right >= end:\n        return segment_tree[treenode].min_val\n    else:\n        mid = (start + end) // 2\n        ans1 = retrieve_query(start, mid, left, right, 2 * treenode + 1)\n        ans2 = retrieve_query(mid + 1, end, left, right, 2 * treenode + 2)\n        return min(ans1, ans2)\nbuild_tree(0, len(arr) - 1)\nfor _ in range(q):\n    query = list(map(int, input().split()))\n    if query[0] == 0:\n        print(retrieve_query(0, len(arr) - 1, query[1] - 1, query[2] - 1))\n    else:\n        update_query(0, len(arr) - 1, query[1] - 1, query[2] - 1, query[3])", "import numpy\n(n, q) = map(int, input().split())\na = list(map(int, input().split()))\na = numpy.array(a)\nfor _ in range(q):\n    aa = list(map(int, input().split()))\n    if aa[0] == 1:\n        a[aa[1] - 1:aa[2]] &= aa[3]\n    else:\n        print(numpy.amin(a[aa[1] - 1:aa[2]]))"]