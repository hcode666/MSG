["import sys\nfrom collections import deque\nmod = 10 ** 9 + 7\n\ndef invert(k):\n    return pow(k, mod - 2, mod)\nfact = [1] * 500001\nifact = [1] * 500001\nfor i in range(2, 500001):\n    fact[i] = i * fact[i - 1]\n    ifact[i] = invert(i) * ifact[i - 1]\n    fact[i] %= mod\n    ifact[i] %= mod\n\ndef ncr(k, l):\n    return fact[k] * ifact[l] % mod * ifact[k - l] % mod\nfor _ in range(int(sys.stdin.readline())):\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    d = {}\n    for i in a:\n        d[i] = d.get(i, 0) + 1\n    st = list(d.keys())\n    st.sort(reverse=True)\n    sum_till_now = [0] * (n + 1)\n    final_count = [0] * (n + 1)\n    times = [0] * (n + 1)\n    for i in st:\n        sum_till_now[i] = 1\n    st_length = len(st)\n    st = deque(st)\n    ans = 1\n    while st_length > 0:\n        b = st.popleft()\n        st_length -= 1\n        x = ncr(d[b], times[b] + 1)\n        ans *= invert(sum_till_now[b])\n        ans %= mod\n        sum_till_now[b] += x\n        sum_till_now[b] %= mod\n        final_count[b] += ans * x\n        final_count[b] %= mod\n        ans *= sum_till_now[b]\n        ans %= mod\n        times[b] += 1\n        if times[b] != d[b]:\n            st.append(b)\n            st_length += 1\n    print(*final_count[1:])", "N = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef ncr(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef addMod(a, b):\n    mod = 10 ** 9 + 7\n    return (a % mod + b % mod) % mod\n\ndef multiMod(a, b):\n    mod = 10 ** 9 + 7\n    return a % mod * (b % mod) % mod\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = {}\n    a = sorted(a)\n    maxFreq = -1\n    for i in a:\n        if i not in f:\n            f[i] = 1\n        else:\n            f[i] += 1\n        maxFreq = max(maxFreq, f[i])\n    distict = []\n    for i in f:\n        distict.append(i)\n    distict = sorted(distict)\n    ncrPRE = {}\n    for number in distict:\n        temp = [1]\n        for rep in range(1, f[number] + 1):\n            temp.append(addMod(ncr(f[number], rep, p), temp[-1]))\n        ncrPRE[number] = temp\n    ans = {}\n    for i in range(1, n + 1):\n        ans[i] = 0\n    tempAns = {}\n    extraFactorRight = {}\n    for i in distict:\n        extraFactorRight[i] = 1\n    extraFactorLeft = {}\n    for i in distict:\n        extraFactorLeft[i] = 1\n    distictBackWards = distict[::-1]\n    for possibleFreq in range(1, maxFreq + 1):\n        temp = ncrPRE[distictBackWards[0]][possibleFreq]\n        tempAns[distictBackWards[0]] = multiMod(ncr(f[distictBackWards[0]], possibleFreq, p), extraFactorLeft[distictBackWards[0]])\n        for number in distictBackWards[1:]:\n            tempAns[number] = 1\n            tempAns[number] = multiMod(tempAns[number], ncr(f[number], possibleFreq, p))\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorLeft[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq])\n        temp = ncrPRE[distict[0]][possibleFreq - 1]\n        tempAns[distict[0]] = multiMod(tempAns[distict[0]], extraFactorRight[distict[0]])\n        for number in distict[1:]:\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorRight[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq - 1])\n        for i in distict:\n            ans[i] = addMod(tempAns[i], ans[i])\n        tempHadHogi = []\n        for i in distict:\n            if f[i] == possibleFreq:\n                extraFactorRight[i] = ncrPRE[i][-1]\n                extraFactorLeft[i] = ncrPRE[i][-1]\n                tempHadHogi.append(ncrPRE[i][-1])\n            else:\n                tempHadHogi.append(1)\n        preHadHogi = [tempHadHogi[0]]\n        for ii in range(1, len(distict)):\n            preHadHogi.append(multiMod(preHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = [tempHadHogi[len(distict) - 1]]\n        for ii in range(len(tempHadHogi) - 2, -1, -1):\n            postHadHogi.append(multiMod(postHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = postHadHogi[::-1]\n        for ii in range(len(distict)):\n            extraFactorLeft[distict[ii]] = multiMod(extraFactorLeft[distict[ii]], postHadHogi[ii])\n        for ii in range(len(distict)):\n            extraFactorRight[distict[ii]] = multiMod(extraFactorRight[distict[ii]], preHadHogi[ii])\n        delIndex = []\n        for i in range(len(distict)):\n            if f[distict[i]] == possibleFreq:\n                delIndex.append(i)\n        delIndex = delIndex[::-1]\n        for i in delIndex:\n            del distict[i]\n        distictBackWards = distict[::-1]\n    for i in range(1, n + 1):\n        print(ans[i], end=' ')\n    print('')", "N = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef ncr(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef addMod(a, b):\n    mod = 10 ** 9 + 7\n    return (a % mod + b % mod) % mod\n\ndef multiMod(a, b):\n    mod = 10 ** 9 + 7\n    return a % mod * (b % mod) % mod\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = {}\n    a = sorted(a)\n    maxFreq = -1\n    for i in a:\n        if i not in f:\n            f[i] = 1\n        else:\n            f[i] += 1\n        maxFreq = max(maxFreq, f[i])\n    distict = []\n    for i in f:\n        distict.append(i)\n    distict = sorted(distict)\n    ncrPRE = {}\n    for number in distict:\n        temp = [1]\n        for rep in range(1, f[number] + 1):\n            temp.append(addMod(ncr(f[number], rep, p), temp[-1]))\n        ncrPRE[number] = temp\n    ans = {}\n    for i in range(1, n + 1):\n        ans[i] = 0\n    tempAns = {}\n    extraFactorRight = {}\n    for i in distict:\n        extraFactorRight[i] = 1\n    extraFactorLeft = {}\n    for i in distict:\n        extraFactorLeft[i] = 1\n    distictBackWards = distict[::-1]\n    for possibleFreq in range(1, maxFreq + 1):\n        temp = ncrPRE[distictBackWards[0]][possibleFreq]\n        tempAns[distictBackWards[0]] = multiMod(ncr(f[distictBackWards[0]], possibleFreq, p), extraFactorLeft[distictBackWards[0]])\n        for number in distictBackWards[1:]:\n            tempAns[number] = 1\n            tempAns[number] = multiMod(tempAns[number], ncr(f[number], possibleFreq, p))\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorLeft[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq])\n        temp = ncrPRE[distict[0]][possibleFreq - 1]\n        tempAns[distict[0]] = multiMod(tempAns[distict[0]], extraFactorRight[distict[0]])\n        for number in distict[1:]:\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorRight[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq - 1])\n        for i in distict:\n            ans[i] = addMod(tempAns[i], ans[i])\n        tempHadHogi = []\n        for i in distict:\n            if f[i] == possibleFreq:\n                extraFactorRight[i] = ncrPRE[i][-1]\n                extraFactorLeft[i] = ncrPRE[i][-1]\n                tempHadHogi.append(ncrPRE[i][-1])\n            else:\n                tempHadHogi.append(1)\n        preHadHogi = [tempHadHogi[0]]\n        for ii in range(1, len(distict)):\n            preHadHogi.append(multiMod(preHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = [tempHadHogi[len(distict) - 1]]\n        for ii in range(len(tempHadHogi) - 2, -1, -1):\n            postHadHogi.append(multiMod(postHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = postHadHogi[::-1]\n        for ii in range(len(distict)):\n            extraFactorLeft[distict[ii]] = multiMod(extraFactorLeft[distict[ii]], postHadHogi[ii])\n        for ii in range(len(distict)):\n            extraFactorRight[distict[ii]] = multiMod(extraFactorRight[distict[ii]], preHadHogi[ii])\n        delIndex = []\n        for i in range(len(distict)):\n            if f[distict[i]] == possibleFreq:\n                delIndex.append(i)\n        delIndex = delIndex[::-1]\n        for i in delIndex:\n            del distict[i]\n        distictBackWards = distict[::-1]\n    for i in range(1, n + 1):\n        print(ans[i], end=' ')\n    print('')", "def printf(a):\n    print(a)\n\ndef take_int():\n    return int(input())\n\ndef del_int(list_, index):\n    list_.remove(list_[index])\n    return list_\nN = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef ncr(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef addMod(a, b):\n    mod = 10 ** 9 + 7\n    return (a % mod + b % mod) % mod\n\ndef multiMod(a, b):\n    mod = 10 ** 9 + 7\n    return a % mod * (b % mod) % mod\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor _ in range(take_int()):\n    n = take_int()\n    a = list(map(int, input().split()))\n    f = {}\n    a = sorted(a)\n    maxFreq = -1\n    for i in a:\n        if i not in f:\n            f[i] = 1\n        else:\n            f[i] += 1\n        maxFreq = max(maxFreq, f[i])\n    distict = []\n    for i in f:\n        distict.append(i)\n    distict = sorted(distict)\n    ncrPRE = {}\n    for number in distict:\n        temp = [1]\n        for rep in range(1, f[number] + 1):\n            temp.append(addMod(ncr(f[number], rep, p), temp[-1]))\n        ncrPRE[number] = temp\n    ans = {}\n    for i in range(1, n + 1):\n        ans[i] = 0\n    tempAns = {}\n    extraFactorRight = {}\n    for i in distict:\n        extraFactorRight[i] = 1\n    extraFactorLeft = {}\n    for i in distict:\n        extraFactorLeft[i] = 1\n    distictBackWards = distict[::-1]\n    for possibleFreq in range(1, maxFreq + 1):\n        temp = ncrPRE[distictBackWards[0]][possibleFreq]\n        tempAns[distictBackWards[0]] = multiMod(ncr(f[distictBackWards[0]], possibleFreq, p), extraFactorLeft[distictBackWards[0]])\n        for number in distictBackWards[1:]:\n            tempAns[number] = 1\n            tempAns[number] = multiMod(tempAns[number], ncr(f[number], possibleFreq, p))\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorLeft[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq])\n        temp = ncrPRE[distict[0]][possibleFreq - 1]\n        tempAns[distict[0]] = multiMod(tempAns[distict[0]], extraFactorRight[distict[0]])\n        for number in distict[1:]:\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorRight[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq - 1])\n        for i in distict:\n            ans[i] = addMod(tempAns[i], ans[i])\n        tempHadHogi = []\n        for i in distict:\n            if f[i] == possibleFreq:\n                extraFactorRight[i] = ncrPRE[i][-1]\n                extraFactorLeft[i] = ncrPRE[i][-1]\n                tempHadHogi.append(ncrPRE[i][-1])\n            else:\n                tempHadHogi.append(1)\n        preHadHogi = [tempHadHogi[0]]\n        for ii in range(1, len(distict)):\n            preHadHogi.append(multiMod(preHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = [tempHadHogi[len(distict) - 1]]\n        for ii in range(len(tempHadHogi) - 2, -1, -1):\n            postHadHogi.append(multiMod(postHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = postHadHogi[::-1]\n        for ii in range(len(distict)):\n            extraFactorLeft[distict[ii]] = multiMod(extraFactorLeft[distict[ii]], postHadHogi[ii])\n        for ii in range(len(distict)):\n            extraFactorRight[distict[ii]] = multiMod(extraFactorRight[distict[ii]], preHadHogi[ii])\n        delIndex = []\n        for i in range(len(distict)):\n            if f[distict[i]] == possibleFreq:\n                delIndex.append(i)\n        delIndex = delIndex[::-1]\n        for i in delIndex:\n            del distict[i]\n        distictBackWards = distict[::-1]\n    for i in range(1, n + 1):\n        print(ans[i], end=' ')\n    print('')", "N = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef ncr(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef addMod(a, b):\n    mod = 10 ** 9 + 7\n    return (a % mod + b % mod) % mod\n\ndef multiMod(a, b):\n    mod = 10 ** 9 + 7\n    return a % mod * (b % mod) % mod\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = {}\n    a = sorted(a)\n    maxFreq = -1\n    for i in a:\n        if i not in f:\n            f[i] = 1\n        else:\n            f[i] += 1\n        maxFreq = max(maxFreq, f[i])\n    distict = []\n    for i in f:\n        distict.append(i)\n    distict = sorted(distict)\n    ncrPRE = {}\n    for number in distict:\n        temp = [1]\n        for rep in range(1, f[number] + 1):\n            temp.append(addMod(ncr(f[number], rep, p), temp[-1]))\n        ncrPRE[number] = temp\n    ans = {}\n    for i in range(1, n + 1):\n        ans[i] = 0\n    tempAns = {}\n    extraFactorRight = {}\n    for i in distict:\n        extraFactorRight[i] = 1\n    extraFactorLeft = {}\n    for i in distict:\n        extraFactorLeft[i] = 1\n    distictBackWards = distict[::-1]\n    for possibleFreq in range(1, maxFreq + 1):\n        temp = ncrPRE[distictBackWards[0]][possibleFreq]\n        tempAns[distictBackWards[0]] = multiMod(ncr(f[distictBackWards[0]], possibleFreq, p), extraFactorLeft[distictBackWards[0]])\n        for number in distictBackWards[1:]:\n            tempAns[number] = 1\n            tempAns[number] = multiMod(tempAns[number], ncr(f[number], possibleFreq, p))\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorLeft[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq])\n        temp = ncrPRE[distict[0]][possibleFreq - 1]\n        tempAns[distict[0]] = multiMod(tempAns[distict[0]], extraFactorRight[distict[0]])\n        for number in distict[1:]:\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorRight[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq - 1])\n        for i in distict:\n            ans[i] = addMod(tempAns[i], ans[i])\n        tempHadHogi = []\n        for i in distict:\n            if f[i] == possibleFreq:\n                extraFactorRight[i] = ncrPRE[i][-1]\n                extraFactorLeft[i] = ncrPRE[i][-1]\n                tempHadHogi.append(ncrPRE[i][-1])\n            else:\n                tempHadHogi.append(1)\n        preHadHogi = [tempHadHogi[0]]\n        for ii in range(1, len(distict)):\n            preHadHogi.append(multiMod(preHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = [tempHadHogi[len(distict) - 1]]\n        for ii in range(len(tempHadHogi) - 2, -1, -1):\n            postHadHogi.append(multiMod(postHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = postHadHogi[::-1]\n        for ii in range(len(distict)):\n            extraFactorLeft[distict[ii]] = multiMod(extraFactorLeft[distict[ii]], postHadHogi[ii])\n        for ii in range(len(distict)):\n            extraFactorRight[distict[ii]] = multiMod(extraFactorRight[distict[ii]], preHadHogi[ii])\n        delIndex = []\n        for i in range(len(distict)):\n            if f[distict[i]] == possibleFreq:\n                delIndex.append(i)\n        delIndex = delIndex[::-1]\n        for i in delIndex:\n            del distict[i]\n        distictBackWards = distict[::-1]\n    for i in range(1, n + 1):\n        print(ans[i], end=' ')\n    print('')", "N = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef ncr(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef addMod(a, b):\n    mod = 10 ** 9 + 7\n    return (a % mod + b % mod) % mod\n\ndef multiMod(a, b):\n    mod = 10 ** 9 + 7\n    return a % mod * (b % mod) % mod\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = {}\n    a = sorted(a)\n    maxFreq = -1\n    for i in a:\n        if i not in f:\n            f[i] = 1\n        else:\n            f[i] += 1\n        maxFreq = max(maxFreq, f[i])\n    distict = []\n    for i in f:\n        distict.append(i)\n    distict = sorted(distict)\n    ncrPRE = {}\n    for number in distict:\n        temp = [1]\n        for rep in range(1, f[number] + 1):\n            temp.append(addMod(ncr(f[number], rep, p), temp[-1]))\n        ncrPRE[number] = temp\n    ans = {}\n    for i in range(1, n + 1):\n        ans[i] = 0\n    tempAns = {}\n    extraFactorRight = {}\n    for i in distict:\n        extraFactorRight[i] = 1\n    extraFactorLeft = {}\n    for i in distict:\n        extraFactorLeft[i] = 1\n    distictBackWards = distict[::-1]\n    for possibleFreq in range(1, maxFreq + 1):\n        temp = ncrPRE[distictBackWards[0]][possibleFreq]\n        tempAns[distictBackWards[0]] = multiMod(ncr(f[distictBackWards[0]], possibleFreq, p), extraFactorLeft[distictBackWards[0]])\n        for number in distictBackWards[1:]:\n            tempAns[number] = 1\n            tempAns[number] = multiMod(tempAns[number], ncr(f[number], possibleFreq, p))\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorLeft[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq])\n        temp = ncrPRE[distict[0]][possibleFreq - 1]\n        tempAns[distict[0]] = multiMod(tempAns[distict[0]], extraFactorRight[distict[0]])\n        for number in distict[1:]:\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorRight[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq - 1])\n        for i in distict:\n            ans[i] = addMod(tempAns[i], ans[i])\n        tempHadHogi = []\n        for i in distict:\n            if f[i] == possibleFreq:\n                extraFactorRight[i] = ncrPRE[i][-1]\n                extraFactorLeft[i] = ncrPRE[i][-1]\n                tempHadHogi.append(ncrPRE[i][-1])\n            else:\n                tempHadHogi.append(1)\n        preHadHogi = [tempHadHogi[0]]\n        for ii in range(1, len(distict)):\n            preHadHogi.append(multiMod(preHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = [tempHadHogi[len(distict) - 1]]\n        for ii in range(len(tempHadHogi) - 2, -1, -1):\n            postHadHogi.append(multiMod(postHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = postHadHogi[::-1]\n        for ii in range(len(distict)):\n            extraFactorLeft[distict[ii]] = multiMod(extraFactorLeft[distict[ii]], postHadHogi[ii])\n        for ii in range(len(distict)):\n            extraFactorRight[distict[ii]] = multiMod(extraFactorRight[distict[ii]], preHadHogi[ii])\n        delIndex = []\n        for i in range(len(distict)):\n            if f[distict[i]] == possibleFreq:\n                delIndex.append(i)\n        delIndex = delIndex[::-1]\n        for i in delIndex:\n            del distict[i]\n        distictBackWards = distict[::-1]\n    for i in range(1, n + 1):\n        print(ans[i], end=' ')\n    print('')", "N = 1000001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\n\ndef InverseofNumber(p):\n    naturalNumInverse[0] = naturalNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        naturalNumInverse[i] = naturalNumInverse[p % i] * (p - int(p / i)) % p\n\ndef InverseofFactorial(p):\n    factorialNumInverse[0] = factorialNumInverse[1] = 1\n    for i in range(2, N + 1, 1):\n        factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % p\n\ndef factorial(p):\n    fact[0] = 1\n    for i in range(1, N + 1):\n        fact[i] = fact[i - 1] * i % p\n\ndef ncr(N, R, p):\n    ans = fact[N] * factorialNumInverse[R] % p * factorialNumInverse[N - R] % p\n    return ans\n\ndef addMod(a, b):\n    mod = 10 ** 9 + 7\n    return (a % mod + b % mod) % mod\n\ndef multiMod(a, b):\n    mod = 10 ** 9 + 7\n    return a % mod * (b % mod) % mod\np = 1000000007\nInverseofNumber(p)\nInverseofFactorial(p)\nfactorial(p)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    f = {}\n    a = sorted(a)\n    maxFreq = -1\n    for i in a:\n        if i not in f:\n            f[i] = 1\n        else:\n            f[i] += 1\n        maxFreq = max(maxFreq, f[i])\n    distict = []\n    for i in f:\n        distict.append(i)\n    distict = sorted(distict)\n    ncrPRE = {}\n    for number in distict:\n        temp = [1]\n        for rep in range(1, f[number] + 1):\n            temp.append(addMod(ncr(f[number], rep, p), temp[-1]))\n        ncrPRE[number] = temp\n    ans = {}\n    for i in range(1, n + 1):\n        ans[i] = 0\n    tempAns = {}\n    extraFactorRight = {}\n    for i in distict:\n        extraFactorRight[i] = 1\n    extraFactorLeft = {}\n    for i in distict:\n        extraFactorLeft[i] = 1\n    distictBackWards = distict[::-1]\n    for possibleFreq in range(1, maxFreq + 1):\n        temp = ncrPRE[distictBackWards[0]][possibleFreq]\n        tempAns[distictBackWards[0]] = multiMod(ncr(f[distictBackWards[0]], possibleFreq, p), extraFactorLeft[distictBackWards[0]])\n        for number in distictBackWards[1:]:\n            tempAns[number] = 1\n            tempAns[number] = multiMod(tempAns[number], ncr(f[number], possibleFreq, p))\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorLeft[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq])\n        temp = ncrPRE[distict[0]][possibleFreq - 1]\n        tempAns[distict[0]] = multiMod(tempAns[distict[0]], extraFactorRight[distict[0]])\n        for number in distict[1:]:\n            tempAns[number] = multiMod(tempAns[number], temp)\n            tempAns[number] = multiMod(tempAns[number], extraFactorRight[number])\n            temp = multiMod(temp, ncrPRE[number][possibleFreq - 1])\n        for i in distict:\n            ans[i] = addMod(tempAns[i], ans[i])\n        tempHadHogi = []\n        for i in distict:\n            if f[i] == possibleFreq:\n                extraFactorRight[i] = ncrPRE[i][-1]\n                extraFactorLeft[i] = ncrPRE[i][-1]\n                tempHadHogi.append(ncrPRE[i][-1])\n            else:\n                tempHadHogi.append(1)\n        preHadHogi = [tempHadHogi[0]]\n        for ii in range(1, len(distict)):\n            preHadHogi.append(multiMod(preHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = [tempHadHogi[len(distict) - 1]]\n        for ii in range(len(tempHadHogi) - 2, -1, -1):\n            postHadHogi.append(multiMod(postHadHogi[-1], tempHadHogi[ii]))\n        postHadHogi = postHadHogi[::-1]\n        for ii in range(len(distict)):\n            extraFactorLeft[distict[ii]] = multiMod(extraFactorLeft[distict[ii]], postHadHogi[ii])\n        for ii in range(len(distict)):\n            extraFactorRight[distict[ii]] = multiMod(extraFactorRight[distict[ii]], preHadHogi[ii])\n        delIndex = []\n        for i in range(len(distict)):\n            if f[distict[i]] == possibleFreq:\n                delIndex.append(i)\n        delIndex = delIndex[::-1]\n        for i in delIndex:\n            del distict[i]\n        distictBackWards = distict[::-1]\n    for i in range(1, n + 1):\n        print(ans[i], end=' ')\n    print('')", "def mul(a, b, c):\n    for i in range(min(len(a), len(b))):\n        a[i] = a[i] * b[i] % 1000000007\n    for i in range(len(a), len(b)):\n        a.append(b[i])\n    return a[:c]\n\ndef preProcess():\n    fac = [1, 1]\n    for i in range(2, 500001):\n        fac.append(i * fac[i - 1] % 1000000007)\n    return fac\n\ndef solve(n, arr, fac, modInverse):\n    m = 1000000007\n    ans = [0] * n\n    cntArr = [0] * (n + 1)\n    for i in arr:\n        cntArr[i] += 1\n    nArr = []\n    for i in cntArr:\n        if i == 0:\n            continue\n        nArr.append(i)\n    lessC = [0 for _ in range(max(nArr) + 1)]\n    for i in nArr:\n        lessC[i] += 1\n    for i in range(len(lessC)):\n        lessC[i] = i * lessC[i]\n    for i in range(1, len(lessC)):\n        lessC[i] = lessC[i - 1] + lessC[i]\n    for i in range(len(lessC)):\n        lessC[i] = pow(2, lessC[i], m)\n    ncr = [[] for _ in range(len(nArr))]\n    for i in range(len(nArr)):\n        for j in range(nArr[i] + 1):\n            modInverse[j] = modInverse[j] if modInverse[j] else pow(fac[j], m - 2, m)\n            modInverse[nArr[i] - j] = modInverse[nArr[i] - j] if modInverse[nArr[i] - j] else pow(fac[nArr[i] - j], m - 2, m)\n            ncr[i].append(fac[nArr[i]] * modInverse[j] * modInverse[nArr[i] - j] % m)\n    preArr = [[1] for _ in range(len(nArr))]\n    for i in range(len(ncr)):\n        for j in range(1, len(ncr[i])):\n            preArr[i].append(preArr[i][j - 1] + ncr[i][j] if j < len(ncr[i]) else preArr[i][j - 1])\n    nArrL = [False for _ in range(len(nArr))]\n    nArrR = [False for _ in range(len(nArr))]\n    currL = []\n    currR = []\n    for i in range(1, len(preArr)):\n        nArrL[i] = mul(currL, preArr[i - 1][:-1], len(preArr[i]))\n        nArrR[-1 - i] = mul(currR, preArr[-i], len(preArr[-1 - i]))\n    cArr = []\n    for i in range(len(ncr)):\n        sm = 0\n        for j in range(1, len(ncr[i])):\n            pro = ncr[i][j]\n            if nArrL[i] is not False and j - 1 < len(nArrL[i]):\n                pro = pro * nArrL[i][j - 1] % m\n            if nArrR[i] is not False and j < len(nArrR[i]):\n                pro = pro * nArrR[i][j] % m\n            pro = pro * lessC[j - 1] % m\n            sm = (sm + pro) % m\n        cArr.append(sm)\n    ans = []\n    j = 0\n    for i in cntArr[1:]:\n        if i == 0:\n            ans.append(0)\n        else:\n            ans.append(cArr[j])\n            j += 1\n    print(' '.join(list(map(str, ans))))\n\ndef main():\n    fac = preProcess()\n    modInv = [False for _ in range(len(fac))]\n    for _ in range(int(input())):\n        n = int(input())\n        arr = list(map(int, input().split()))\n        solve(n, arr, fac, modInv)\nmain()", "from collections import Counter\n\ndef main():\n    MOD = 1000000007\n    f = [0] * 500005\n\n    def nCr(n, r):\n        if r == 0:\n            return 1\n        else:\n            return f[n] * pow(f[n - r], MOD - 2, MOD) % MOD * pow(f[r], MOD - 2, MOD) % MOD\n\n    def solve():\n        f[0] = 1\n        f[1] = 1\n        for i in range(2, 500005):\n            f[i] = f[i - 1] * i % MOD\n        _ = int(input())\n        for __ in range(_):\n            n = int(input())\n            arr = list(map(int, input().split()))\n            hashMap = dict(Counter(arr))\n            k = [0] * (n + 3)\n            u = [0] * (n + 2)\n            for i in range(n + 2):\n                k[i] = 1\n                u[i] = 1\n            for (key, value) in hashMap.items():\n                s = 1\n                for j in range(1, value + 1):\n                    s += nCr(value, j)\n                    s %= MOD\n                    k[j] *= s\n                    k[j] %= MOD\n                u[value + 1] *= s\n                u[value + 1] %= MOD\n            m = 1\n            for i in range(1, n + 1):\n                m *= u[i]\n                m %= MOD\n                k[i] *= m\n                k[i] %= MOD\n            for i in range(1, n + 1):\n                a = 0\n                ta = 0\n                s = 1\n                if i in hashMap:\n                    for j in range(1, hashMap[i] + 1):\n                        ta = nCr(hashMap[i], j)\n                        tmp = ta\n                        s += ta\n                        s %= MOD\n                        k[j] = k[j] * pow(s, MOD - 2, MOD) % MOD\n                        ta *= k[j]\n                        ta %= MOD\n                        k[j] = k[j] * (s - tmp + MOD) % MOD % MOD\n                        a += ta\n                        a %= MOD\n                print(a % MOD, end=' ')\n            print()\n    solve()\nmain()", "import math\nimport sys\nfrom collections import defaultdict, Counter, deque\ninput = sys.stdin.readline\n\ndef rais(a, b, c):\n    num = 0\n    if b == 0:\n        return 1\n    x = rais(a, b // 2, c) % c\n    x = x * x % c\n    if b % 2 == 0:\n        return x\n    else:\n        return a * x % c\ntest = int(input())\nmod = int(pow(10, 9)) + 7\nfor num in range(test):\n    n = int(input())\n    a = list(map(int, input().split()))\n    fset = {}\n    dat = 0\n    maxf = 1\n    for k in range(1, n + 1):\n        fset[a[k - 1]] = fset.get(a[k - 1], 0) + 1\n        maxf = max(maxf, fset[a[k - 1]])\n    if maxf == 1:\n        for j in range(1, n + 1):\n            print(pow(2, n - j, mod), end=' ')\n        print()\n        continue\n    while False:\n        break\n    fset = sorted(fset.items())\n    fset2 = len(fset)\n    left = {}\n    right = {}\n    for k in range(fset2):\n        right[fset[k][1]] = right.get(fset[k][1], 0) + 1\n    factoril = list()\n    factoril.append(1)\n    opp = list()\n    opp.append(1)\n    for j in range(1, maxf + 1):\n        factoril.append(factoril[j - 1] * j % mod)\n        opp.append(pow(factoril[j], mod - 2, mod))\n    while False:\n        break\n    mul = defaultdict(list)\n    for j in right:\n        mul[j].append(opp[j])\n        for k in range(1, j + 1):\n            mul[j].append(mul[j][k - 1])\n            mul[j][k] = (mul[j][k] + opp[k] * opp[j - k] % mod) % mod\n    if n * len(right) < maxf * fset2:\n        listans = [0] * (n + 1)\n        for j in range(fset2):\n            right[fset[j][1]] -= 1\n            p = 1\n            while False:\n                break\n            while p <= fset[j][1]:\n                curr = factoril[fset[j][1]] * (opp[p] * opp[fset[j][1] - p]) % mod % mod\n                for k in right:\n                    dat = 0\n                    curr = curr * pow(factoril[k] * mul[k][min(p, k)] % mod, right[k], mod) % mod\n                for k in left:\n                    curr = curr * pow(factoril[k] * mul[k][min(p - 1, k)] % mod, left[k], mod) % mod\n                listans[fset[j][0]] = (listans[fset[j][0]] + curr) % mod\n                p += 1\n            left[fset[j][1]] = left.get(fset[j][1], 0) + 1\n        print(*listans[1:])\n        continue\n    dat = 0\n    ans1 = defaultdict(list)\n    ans2 = defaultdict(deque)\n    for j in range(maxf + 1):\n        ans1[j].append(mul[fset[0][1]][min(j, fset[0][1])])\n        for k in range(1, fset2):\n            ans1[j].append(ans1[j][k - 1])\n            ans1[j][k] = ans1[j][k] * mul[fset[k][1]][min(j, fset[k][1])] % mod\n        ans1[j].append(1)\n        while False:\n            break\n        ans2[j].append(1)\n        ans2[j].appendleft(mul[fset[-1][1]][min(j, fset[-1][1])])\n        for k in range(fset2 - 2, -1, -1):\n            ans2[j].appendleft(ans2[j][0])\n            ans2[j][0] = ans2[j][0] * mul[fset[k][1]][min(j, fset[k][1])] % mod\n    listans = [0] * (n + 1)\n    eve = 1\n    for j in range(fset2):\n        eve = eve * factoril[fset[j][1]] % mod\n        p = 1\n        while p <= fset[j][1]:\n            while False:\n                break\n            val = opp[p] * opp[fset[j][1] - p] % mod\n            val = val * ans2[p][j + 1] % mod * ans1[p - 1][j - 1] % mod\n            dat = 0\n            listans[fset[j][0]] = (listans[fset[j][0]] + val) % mod\n            p += 1\n    for j in range(1, n + 1):\n        print(eve * listans[j] % mod, end=' ')\n    print()", "data_ad = {}\n\ndef ncr(n, data_ad):\n    arr = [1]\n    num = den = 1\n    for i in range(n // 2):\n        num = num * (n - i) % 1000000007\n        den = den * (i + 1) % 1000000007\n        if den not in data_ad:\n            data_ad[den] = pow(den, 1000000005, 1000000007)\n        arr.append(num * data_ad[den] % 1000000007)\n    return arr\ndata_com = {}\nfor _ in range(int(input())):\n    n = int(input())\n    l = [int(x) for x in input().split()]\n    l.sort(reverse=True)\n    ques = []\n    last = l[0]\n    cnt = 0\n    ini_count_2 = {}\n    com = {}\n    ad = {}\n    count = {}\n    for j in range(len(l)):\n        if l[j] == last:\n            cnt += 1\n            if len(ques) >= cnt:\n                ques[cnt - 1].append(l[j])\n            else:\n                ques.append([l[j]])\n        else:\n            if cnt not in data_com:\n                data_com[cnt] = ncr(cnt, data_ad)\n            cnt = 1\n            last = l[j]\n            if len(ques) >= cnt:\n                ques[cnt - 1].append(l[j])\n            else:\n                ques.append([l[j]])\n        if l[j] not in ad:\n            count[l[j]] = 1\n            ad[l[j]] = 1\n            ini_count_2[l[j]] = 0\n        else:\n            count[l[j]] += 1\n    if cnt not in data_com:\n        data_com[cnt] = ncr(cnt, data_ad)\n    ans = []\n    mul = 1\n    mu_1 = 1\n    for j in range(len(l)):\n        ans.append(0)\n    for i in range(len(ques)):\n        for j in range(len(ques[i])):\n            temp = ques[i][j]\n            ind = ini_count_2[temp]\n            if ad[temp] not in data_ad:\n                data_ad[ad[temp]] = pow(ad[temp], 1000000005, 1000000007)\n                mul = mul * data_ad[ad[temp]] % 1000000007\n            else:\n                mul = mul * data_ad[ad[temp]] % 1000000007\n            mul_1 = mul\n            if count[temp] // 2 >= ind + 1:\n                ad[temp] = (ad[temp] + data_com[count[temp]][ind + 1]) % 1000000007\n                mul_1 = mul_1 * data_com[count[temp]][ind + 1] % 1000000007\n            else:\n                ad[temp] = (ad[temp] + data_com[count[temp]][count[temp] - (ind + 1)]) % 1000000007\n                mul_1 = mul_1 * data_com[count[temp]][count[temp] - (ind + 1)] % 1000000007\n            mul = mul * ad[temp] % 1000000007\n            ans[temp - 1] = (ans[temp - 1] + mul_1) % 1000000007\n            ini_count_2[temp] += 1\n    print(*ans)", "mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    dic = {}\n    maxg = 0\n    for i in range(N):\n        if A[i] in dic:\n            dic[A[i]] += 1\n        else:\n            dic[A[i]] = 1\n        maxg = max(maxg, dic[A[i]])\n    if len(dic.keys()) == 1:\n        x = pow(2, N, mod) - 1\n        j = A[0]\n        for i in range(N):\n            if i == A[0] - 1:\n                print(x, end=' ')\n            else:\n                print(0, end=' ')\n    else:\n        length = [0 for i in range(maxg)]\n        for i in dic.keys():\n            for j in range(dic[i]):\n                length[j] += 1\n        index_length = [0 for i in range(maxg)]\n        precompute = [[0 for j in range(length[i])] for i in range(maxg)]\n        y = [0 for i in range(len(dic.keys()))]\n        io = 0\n        for i in range(1, N + 1):\n            if i in dic:\n                y[io] = i\n                io += 1\n        NCRsum = [[] for i in range(N + 1)]\n        precomputetill = [[] for i in range(N + 1)]\n        ifdone = [False for i in range(N + 1)]\n        ifdonepos = [0 for i in range(N + 1)]\n        for i in y:\n            w = dic[i]\n            if ifdone[w]:\n                NCRsum[i] = NCRsum[ifdonepos[w]].copy()\n                precomputetill[i] = precomputetill[ifdonepos[w]].copy()\n                for j in range(w):\n                    precompute[j][index_length[j]] = i\n                    index_length[j] += 1\n            else:\n                x = w\n                NCRsum[i] = [0 for j in range(w)]\n                precomputetill[i] = [1 for j in range(w)]\n                NCRsum[i][0] = x\n                precomputetill[i][0] = x + 1\n                precompute[0][index_length[0]] = i\n                index_length[0] += 1\n                for j in range(1, w // 2):\n                    x = x * (w - j) // (j + 1)\n                    NCRsum[i][j] = x % mod\n                    precompute[j][index_length[j]] = i\n                    index_length[j] += 1\n                for j in range(w // 2, w - 1):\n                    NCRsum[i][j] = NCRsum[i][w - j - 2]\n                    precompute[j][index_length[j]] = i\n                    index_length[j] += 1\n                NCRsum[i][-1] = 1\n                if w > 1:\n                    precompute[w - 1][index_length[w - 1]] = i\n                    index_length[w - 1] += 1\n                for j in range(1, w):\n                    precomputetill[i][j] = (precomputetill[i][j - 1] + NCRsum[i][j]) % mod\n                ifdone[w] = True\n                ifdonepos[w] = i\n        finalans = [0 for i in range(N + 1)]\n        prefprod = [[] for i in range(len(precompute))]\n        suffixprod = [[] for i in range(len(precompute))]\n        for i in range(maxg):\n            if i != 0:\n                ki = precompute[i]\n                prefprod[i] = [1 for i in range(len(ki))]\n                suffixprod[i] = [1 for i in range(len(ki))]\n                for j in range(1, len(ki)):\n                    prefprod[i][j] = prefprod[i][j - 1] * precomputetill[ki[j - 1]][i - 1] % mod\n                    prefprod[i][j] %= mod\n                suffixprod[i][len(ki) - 1] = 1\n                for j in range(len(ki) - 2, -1, -1):\n                    suffixprod[i][j] = suffixprod[i][j + 1] * precomputetill[ki[j + 1]][i] % mod\n                    suffixprod[i][j] %= mod\n        producttill = 1\n        curr = 1\n        stable = [[] for i in range(N + 1)]\n        for i in y:\n            stable[i] = [0 for j in range(dic[i])]\n        ans = 1\n        for i in range(maxg):\n            ki = precompute[i]\n            curr = producttill\n            pi = prefprod[i]\n            si = suffixprod[i]\n            for j in range(len(ki) - 1, -1, -1):\n                if i == 0:\n                    if j == len(ki) - 1:\n                        stable[ki[j]][i] = 1\n                    else:\n                        ans *= precomputetill[ki[j + 1]][i] % mod\n                        ans %= mod\n                        stable[ki[j]][i] = ans\n                    if dic[ki[j]] == i + 1:\n                        producttill *= precomputetill[ki[j]][i]\n                else:\n                    ans = pi[j] * si[j] % mod * curr % mod\n                    stable[ki[j]][i] = ans\n                    if dic[ki[j]] == i + 1:\n                        producttill = producttill * precomputetill[ki[j]][i] % mod\n                        producttill %= mod\n        for i in range(1, N + 1):\n            for j in range(len(stable[i])):\n                finalans[i] += stable[i][j] * NCRsum[i][j] % mod\n                finalans[i] %= mod\n        for i in range(1, N + 1):\n            print(finalans[i], end=' ')\n        print()", "import math\nimport sys\nfrom collections import defaultdict, Counter, deque\ninput = sys.stdin.readline\n\ndef rais(a, b, c):\n    num = 0\n    if b == 0:\n        return 1\n    x = rais(a, b // 2, c) % c\n    x = x * x % c\n    if b % 2 == 0:\n        return x\n    else:\n        return a * x % c\ntest = int(input())\nmod = int(pow(10, 9)) + 7\nfor num in range(test):\n    n = int(input())\n    a = list(map(int, input().split()))\n    fset = {}\n    dat = 0\n    maxf = 1\n    for k in range(1, n + 1):\n        fset[a[k - 1]] = fset.get(a[k - 1], 0) + 1\n        maxf = max(maxf, fset[a[k - 1]])\n    if maxf == 1:\n        for j in range(1, n + 1):\n            print(pow(2, n - j, mod), end=' ')\n        print()\n        continue\n    while False:\n        break\n    fset = sorted(fset.items())\n    fset2 = len(fset)\n    left = {}\n    right = {}\n    for k in range(fset2):\n        right[fset[k][1]] = right.get(fset[k][1], 0) + 1\n    factoril = list()\n    factoril.append(1)\n    opp = list()\n    opp.append(1)\n    for j in range(1, maxf + 1):\n        factoril.append(factoril[j - 1] * j % mod)\n        opp.append(rais(factoril[j], mod - 2, mod))\n    while False:\n        break\n    mul = defaultdict(list)\n    for j in right:\n        mul[j].append(opp[j])\n        for k in range(1, j + 1):\n            mul[j].append(mul[j][k - 1])\n            mul[j][k] = (mul[j][k] + opp[k] * opp[j - k] % mod) % mod\n    if n * len(right) < maxf * fset2:\n        listans = [0] * (n + 1)\n        for j in range(fset2):\n            right[fset[j][1]] -= 1\n            p = 1\n            while False:\n                break\n            while p <= fset[j][1]:\n                curr = factoril[fset[j][1]] * (opp[p] * opp[fset[j][1] - p]) % mod % mod\n                for k in right:\n                    dat = 0\n                    curr = curr * pow(factoril[k] * mul[k][min(p, k)] % mod, right[k], mod) % mod\n                for k in left:\n                    curr = curr * pow(factoril[k] * mul[k][min(p - 1, k)] % mod, left[k], mod) % mod\n                listans[fset[j][0]] = (listans[fset[j][0]] + curr) % mod\n                p += 1\n            left[fset[j][1]] = left.get(fset[j][1], 0) + 1\n        print(*listans[1:])\n        continue\n    dat = 0\n    ans1 = defaultdict(list)\n    ans2 = defaultdict(deque)\n    for j in range(maxf + 1):\n        ans1[j].append(mul[fset[0][1]][min(j, fset[0][1])])\n        for k in range(1, fset2):\n            ans1[j].append(ans1[j][k - 1])\n            ans1[j][k] = ans1[j][k] * mul[fset[k][1]][min(j, fset[k][1])] % mod\n        ans1[j].append(1)\n        while False:\n            break\n        ans2[j].append(1)\n        ans2[j].appendleft(mul[fset[-1][1]][min(j, fset[-1][1])])\n        for k in range(fset2 - 2, -1, -1):\n            ans2[j].appendleft(ans2[j][0])\n            ans2[j][0] = ans2[j][0] * mul[fset[k][1]][min(j, fset[k][1])] % mod\n    listans = [0] * (n + 1)\n    eve = 1\n    for j in range(fset2):\n        eve = eve * factoril[fset[j][1]] % mod\n        p = 1\n        while p <= fset[j][1]:\n            while False:\n                break\n            val = opp[p] * opp[fset[j][1] - p] % mod\n            val = val * ans2[p][j + 1] % mod * ans1[p - 1][j - 1] % mod\n            dat = 0\n            listans[fset[j][0]] = (listans[fset[j][0]] + val) % mod\n            p += 1\n    for j in range(1, n + 1):\n        print(eve * listans[j] % mod, end=' ')\n    print()", "M = 1000000007\nN = 500005\nfact = [0 for i in range(N)]\nfact[0] = 1\nfor i in range(1, N):\n    fact[i] = fact[i - 1] * i % M\ninv_fact = [0 for i in range(N)]\ninv_fact[N - 1] = pow(fact[N - 1], M - 2, M)\nfor i in range(N - 2, -1, -1):\n    inv_fact[i] = (i + 1) * inv_fact[i + 1] % M\n\ndef ncr(n1, r1):\n    return fact[n1] * inv_fact[r1] % M * inv_fact[n1 - r1] % M\n\ndef inv(v):\n    return pow(v, M - 2, M)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    cnt = [0 for i in range(n + 1)]\n    for x in a:\n        cnt[x] += 1\n    st = sorted(list(set(a)))\n    mul_arr_small = [1 for i in range(n + 5)]\n    prefix_small = [1 for i in range(n + 5)]\n    mul_arr_small[0] = 0\n    final_add = []\n    for x in st:\n        l = [0 for i in range(cnt[x])]\n        for i in range(cnt[x]):\n            l[i] = ncr(cnt[x], i + 1)\n        final_add.append(l)\n    for index in range(len(st)):\n        x = st[index]\n        temp = 1\n        for i in range(cnt[x]):\n            temp = temp * prefix_small[i + 1] % M\n            final_add[index][i] = final_add[index][i] * (temp * mul_arr_small[i + 1]) % M % M\n        temp = 0\n        for i in range(cnt[x]):\n            temp = (temp + ncr(cnt[x], i)) % M\n            mul_arr_small[i + 1] = mul_arr_small[i + 1] * temp % M\n        temp = (temp + 1) % M\n        prefix_small[cnt[x] + 1] = prefix_small[cnt[x] + 1] * temp % M\n    mul_arr_big = [1 for i in range(n + 5)]\n    prefix_big = [1 for i in range(n + 5)]\n    for index in range(len(st) - 1, -1, -1):\n        x = st[index]\n        temp = 1\n        for i in range(cnt[x]):\n            temp = temp * prefix_big[i + 1] % M\n            final_add[index][i] = final_add[index][i] * (temp * mul_arr_big[i + 1]) % M % M\n        temp = 1\n        for i in range(cnt[x]):\n            temp = (temp + ncr(cnt[x], i + 1)) % M\n            mul_arr_big[i + 1] = mul_arr_big[i + 1] * temp % M\n        prefix_big[cnt[x] + 1] = prefix_big[cnt[x] + 1] * temp % M\n    ans = {}\n    for index in range(len(st)):\n        a = 0\n        for i in range(cnt[st[index]]):\n            a = (a + final_add[index][i]) % M\n        ans[st[index]] = a\n    for i in range(1, n + 1):\n        if i in ans:\n            print(ans[i], end=' ')\n        else:\n            print(0, end=' ')\n    print()", "import math\nfrom collections import OrderedDict\n\ndef modInverse(b, m):\n    g = math.gcd(b, m)\n    if g != 1:\n        return -1\n    return pow(b, m - 2, m)\n\ndef modDivide(a, b, m):\n    a = a % m\n    inv = modInverse(b, m)\n    if inv == -1:\n        return inv\n    else:\n        return inv * a % m\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    count = []\n    z = 10 ** 9 + 7\n    for j in range(n):\n        count.append([0, j + 1])\n    for j in range(n):\n        count[arr[j] - 1][0] += 1\n    num = 0\n    for j in range(n):\n        if count[j][0] == 1:\n            num += 1\n    if num == n:\n        x = 10 ** 9 + 7\n        lis = [0] * n\n        lis[-1] = 1\n        for j in range(2, n + 1):\n            lis[-j] = lis[-j + 1] * 2 % x\n        print(' '.join((str(x) for x in lis)))\n    else:\n        realCount = []\n        for j in range(n):\n            if count[j][0] != 0:\n                realCount.append(count[j])\n        len1 = len(realCount)\n        matrix = []\n        for j in range(len1):\n            lis = [1]\n            s = 1\n            for k in range(realCount[j][0]):\n                x = realCount[j][0] - k\n                y = k + 1\n                temp = modDivide(s * x, y, z)\n                if temp == -1:\n                    s = s * x // y\n                else:\n                    s = temp\n                lis.append(s % z)\n            matrix.append(lis)\n        box = []\n        for j in range(len1):\n            lis = [1]\n            for k in range(1, realCount[j][0] + 1):\n                s = lis[-1] + matrix[j][k]\n                s %= z\n                lis.append(s)\n            box.append(lis)\n        impBox = []\n        for j in range(1, len1 + 1):\n            lis = []\n            for l in range(realCount[-j][0] + 1):\n                lis.append(box[-j][l])\n            impBox.append(lis)\n        dict1 = OrderedDict()\n        for j in range(len1):\n            dict1[j] = box[j]\n        freq = 0\n        while dict1:\n            s = 1\n            for key in list(dict1.keys()):\n                if freq == matrix[key][1]:\n                    del dict1[key]\n                else:\n                    s = s * dict1[key][freq]\n                    s %= z\n                    box[key][freq] = s\n            freq += 1\n        dict2 = OrderedDict()\n        for j in range(len1):\n            dict2[j] = impBox[j]\n        freq = 0\n        while dict2:\n            s = 1\n            for key in list(dict2.keys()):\n                s = s * dict2[key][freq]\n                s %= z\n                impBox[key][freq] = s\n                if freq == matrix[len1 - 1 - key][1]:\n                    del dict2[key]\n            freq += 1\n        impMatrix = []\n        for j in range(len1):\n            lis = [1]\n            for k in range(1, realCount[j][0] + 1):\n                s = lis[-1] + matrix[j][k]\n                s %= z\n                lis.append(s)\n            impMatrix.append(lis)\n        dict3 = OrderedDict()\n        for j in range(len1):\n            dict3[j] = impMatrix[j]\n        lis = [1]\n        ans = [0] * n\n        freq = 1\n        while dict3:\n            s = 0\n            p = 0\n            len2 = len(dict3)\n            prev = -1\n            array = OrderedDict()\n            for key in list(dict3.keys()):\n                if p != 0:\n                    array[prev] = key\n                p += 1\n                prev = key\n            prev = -1\n            num1 = []\n            for key in list(dict3.keys()):\n                temp = matrix[key][freq]\n                if len2 == 1:\n                    temp = temp * lis[-1] % z\n                elif s == 0:\n                    temp = temp * impBox[len1 - 1 - array[key]][freq] % z\n                    temp = temp * lis[-1] % z\n                elif s == len2 - 1:\n                    temp = temp * box[prev][freq - 1] % z\n                    temp = temp * lis[-1] % z\n                else:\n                    temp = temp * box[prev][freq - 1] % z\n                    temp = temp * impBox[len1 - 1 - array[key]][freq] % z\n                    temp = temp * lis[-1] % z\n                prev = key\n                s += 1\n                p += 1\n                ans[realCount[key][1] - 1] = (ans[realCount[key][1] - 1] + temp) % z\n                if freq == matrix[key][1]:\n                    num1.append(dict3[key][-1])\n                    del dict3[key]\n                    p -= 1\n            len3 = len(num1)\n            num = 1\n            for j in range(len3):\n                num = num * num1[j] % z\n            lis.append(lis[-1] * num % z)\n            freq += 1\n        print(' '.join((str(x) for x in ans)))", "import sys\nimport math\nfrom collections import defaultdict, Counter, deque\ninput = sys.stdin.readline\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\nm = 10 ** 9 + 7\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    v = {}\n    ma = 1\n    for j in range(1, n + 1):\n        v[a[j - 1]] = v.get(a[j - 1], 0) + 1\n        ma = max(ma, v[a[j - 1]])\n    if ma == 1:\n        for j in range(1, n + 1):\n            print(pow(2, n - j, m), end=' ')\n        print()\n        continue\n    v = sorted(v.items())\n    v1 = len(v)\n    pre = {}\n    suf = {}\n    for j in range(v1):\n        suf[v[j][1]] = suf.get(v[j][1], 0) + 1\n    fact = [1]\n    inverse = [1]\n    for j in range(1, ma + 1):\n        fact.append(fact[j - 1] * j % m)\n        inverse.append(power(fact[j], m - 2, m))\n    mul = defaultdict(list)\n    for j in suf:\n        mul[j].append(inverse[j])\n        for k in range(1, j + 1):\n            mul[j].append(mul[j][k - 1])\n            mul[j][k] = (mul[j][k] + inverse[k] * inverse[j - k] % m) % m\n    if n * len(suf) < ma * v1:\n        ans = [0] * (n + 1)\n        for j in range(v1):\n            suf[v[j][1]] -= 1\n            p = 1\n            while p <= v[j][1]:\n                curr = fact[v[j][1]] * (inverse[p] * inverse[v[j][1] - p]) % m % m\n                for k in suf:\n                    curr = curr * pow(fact[k] * mul[k][min(p, k)] % m, suf[k], m) % m\n                for k in pre:\n                    curr = curr * pow(fact[k] * mul[k][min(p - 1, k)] % m, pre[k], m) % m\n                ans[v[j][0]] = (ans[v[j][0]] + curr) % m\n                p += 1\n            pre[v[j][1]] = pre.get(v[j][1], 0) + 1\n        print(*ans[1:])\n        continue\n    final = defaultdict(list)\n    final2 = defaultdict(deque)\n    for j in range(ma + 1):\n        final[j].append(mul[v[0][1]][min(j, v[0][1])])\n        for k in range(1, v1):\n            final[j].append(final[j][k - 1])\n            final[j][k] = final[j][k] * mul[v[k][1]][min(j, v[k][1])] % m\n        final[j].append(1)\n        final2[j].append(1)\n        final2[j].appendleft(mul[v[-1][1]][min(j, v[-1][1])])\n        for k in range(v1 - 2, -1, -1):\n            final2[j].appendleft(final2[j][0])\n            final2[j][0] = final2[j][0] * mul[v[k][1]][min(j, v[k][1])] % m\n    ans = [0] * (n + 1)\n    all = 1\n    for j in range(v1):\n        all = all * fact[v[j][1]] % m\n        p = 1\n        while p <= v[j][1]:\n            curr = inverse[p] * inverse[v[j][1] - p] % m\n            curr = curr * final2[p][j + 1] % m * final[p - 1][j - 1] % m\n            ans[v[j][0]] = (ans[v[j][0]] + curr) % m\n            p += 1\n    for j in range(1, n + 1):\n        print(all * ans[j] % m, end=' ')\n    print()", "from collections import Counter\nmod = 10 ** 9 + 7\n(hash1, hashn) = ({}, {})\n\ndef power(x, y):\n    res = 1\n    x = x % mod\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % mod\n        y = y >> 1\n        x = x * x % mod\n    return res\n\ndef nCr(n, r):\n    r = min(r, n - r)\n    num = reduce(op.mul, range(n, n - r, -1), 1)\n    den = reduce(op.mul, range(1, r + 1), 1)\n    return num // den % mod\n\ndef helper2(curr, t):\n    result = 1\n    while t:\n        if t & 1:\n            result = result * curr % mod\n        curr = curr * curr % mod\n        t = t >> 1\n    return result % mod\n\ndef helper(curr):\n    return helper2(curr, mod - 2)\n\ndef NCR(n, r):\n    if r == 0:\n        return 1\n    else:\n        if factorial[n - r] in hash1:\n            temp = hash1[factorial[n - r]]\n        else:\n            temp = helper(factorial[n - r])\n            hash1[factorial[n - r]] = temp\n        if factorial[r] in hash1:\n            temp2 = hash1[factorial[r]]\n        else:\n            temp2 = helper(factorial[r])\n            hash1[factorial[r]] = temp2\n        return factorial[n] * temp % mod * temp2 % mod\nt = int(input())\nfactorial = [1, 1]\nfor i in range(2, 500001):\n    factorial.append(i * factorial[-1] % mod)\n\ndef func(A, n):\n    if len(set(A)) == 1:\n        final = [0] * n\n        k = A[0]\n        final[k - 1] = power(2, n) - 1\n        return final\n    mapper = Counter(A)\n    final = [0] * n\n    A.sort()\n    (C, R) = ([1] * (n + 1), [1] * (n + 1))\n    C.extend([0, 0])\n    for i in mapper:\n        curr = 1\n        for j in range(1, mapper[i] + 1):\n            if (mapper[i], j) in hashn:\n                temp = hashn[mapper[i], j]\n            else:\n                temp = NCR(mapper[i], j)\n                hashn[mapper[i], j] = temp\n            curr = (curr + temp) % mod\n            C[j] = C[j] * curr % mod\n        R[mapper[i] + 1] = R[mapper[i] + 1] * curr % mod\n    curr2 = 1\n    for i in range(1, n + 1):\n        curr2 = curr2 * R[i] % mod\n        C[i] = C[i] * curr2 % mod\n    for i in range(1, n + 1):\n        answer = 0\n        curr = 1\n        for j in range(1, mapper[i] + 1):\n            if (mapper[i], j) in hashn:\n                curr3 = hashn[mapper[i], j]\n            else:\n                curr3 = NCR(mapper[i], j)\n                hashn[mapper[i], j] = curr3\n            curr = (curr + curr3) % mod\n            C[j] = C[j] * helper(curr) % mod\n            curr2 = curr3\n            curr3 = curr3 * C[j] % mod\n            C[j] = C[j] * (curr - curr2 + mod) % mod % mod\n            answer = (answer + curr3) % mod\n        final[i - 1] = answer % mod\n    return final\nfor i in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    final = func(A, n)\n    for l in final:\n        print(l, end=' ')\n    print()", "from collections import Counter\nmod = 10 ** 9 + 7\n(hash1, hashn) = ({}, {})\n\ndef power(x, y):\n    res = 1\n    x = x % mod\n    if x == 0:\n        return 0\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % mod\n        y = y >> 1\n        x = x * x % mod\n    return res\n\ndef nCr(n, r):\n    r = min(r, n - r)\n    num = reduce(op.mul, range(n, n - r, -1), 1)\n    den = reduce(op.mul, range(1, r + 1), 1)\n    return num // den % mod\n\ndef helper2(curr, t):\n    result = 1\n    while t:\n        if t & 1:\n            result = result * curr % mod\n        curr = curr * curr % mod\n        t = t >> 1\n    return result % mod\n\ndef helper(curr):\n    return helper2(curr, mod - 2)\n\ndef NCR(n, r):\n    if r == 0:\n        return 1\n    else:\n        if factorial[n - r] in hash1:\n            temp = hash1[factorial[n - r]]\n        else:\n            temp = helper(factorial[n - r])\n            hash1[factorial[n - r]] = temp\n        if factorial[r] in hash1:\n            temp2 = hash1[factorial[r]]\n        else:\n            temp2 = helper(factorial[r])\n            hash1[factorial[r]] = temp2\n        return factorial[n] * temp % mod * temp2 % mod\nt = int(input())\nfactorial = [1, 1]\nfor i in range(2, 500010):\n    factorial.append(i * factorial[-1] % mod)\n\ndef func(A, n):\n    if len(set(A)) == 1:\n        final = [0] * n\n        k = A[0]\n        final[k - 1] = power(2, n) - 1\n        return final\n    mapper = Counter(A)\n    final = [0] * n\n    A.sort()\n    (C, R) = ([1] * (n + 1), [1] * (n + 1))\n    C.extend([0, 0])\n    for i in mapper:\n        curr = 1\n        for j in range(1, mapper[i] + 1):\n            if (mapper[i], j) in hashn:\n                temp = hashn[mapper[i], j]\n            else:\n                temp = NCR(mapper[i], j)\n                hashn[mapper[i], j] = temp\n            curr = (curr + temp) % mod\n            C[j] = C[j] * curr % mod\n        R[mapper[i] + 1] = R[mapper[i] + 1] * curr % mod\n    curr2 = 1\n    for i in range(1, n + 1):\n        curr2 = curr2 * R[i] % mod\n        C[i] = C[i] * curr2 % mod\n    for i in range(1, n + 1):\n        answer = 0\n        curr = 1\n        for j in range(1, mapper[i] + 1):\n            if (mapper[i], j) in hashn:\n                curr3 = hashn[mapper[i], j]\n            else:\n                curr3 = NCR(mapper[i], j)\n                hashn[mapper[i], j] = curr3\n            curr = (curr + curr3) % mod\n            C[j] = C[j] * helper(curr) % mod\n            curr2 = curr3\n            curr3 = curr3 * C[j] % mod\n            C[j] = C[j] * (curr - curr2 + mod) % mod % mod\n            answer = (answer + curr3) % mod\n        final[i - 1] = answer % mod\n    return final\nfor i in range(t):\n    n = int(input())\n    A = list(map(int, input().split()))\n    final = func(A, n)\n    for l in final:\n        print(l, end=' ')\n    print()", "from math import ceil, sqrt\nMOD = int(1000000000.0 + 7)\n\ndef mult(a, b):\n    return a * b % MOD\n\ndef add(a, b):\n    return (a + b) % MOD\n\nclass Combination:\n    kfact = []\n    invkfact = []\n    memo = {}\n    c_memo = {}\n\n    def __init__(self, max_n):\n        self.kfact = [0 for i in range(max_n + 1)]\n        self.invkfact = [0 for i in range(max_n + 1)]\n        self.buildkfact(max_n)\n        self.buildinvkfact(max_n)\n\n    def mod_inv(self, a):\n        return pow(a, MOD - 2, MOD)\n\n    def buildkfact(self, max_n):\n        self.kfact[0] = 1\n        for i in range(1, max_n + 1):\n            self.kfact[i] = mult(self.kfact[i - 1], i)\n\n    def buildinvkfact(self, max_n):\n        self.invkfact[max_n] = self.mod_inv(self.kfact[max_n])\n        for i in range(max_n - 1, 0, -1):\n            self.invkfact[i] = mult(self.invkfact[i + 1], i + 1)\n        self.invkfact[0] = 1\n\n    def C(self, n, r):\n        return mult(self.kfact[n], mult(self.invkfact[n - r], self.invkfact[r]))\n\n    def set_freq(self, freq):\n        self.prebuild(freq)\n\n    def prebuild(self, freq):\n        for elem in freq:\n            S = []\n            n = freq[elem]\n            for i in range(n + 1):\n                S.append(self.C(n, i))\n            p = pow(2, n, MOD)\n            for i in range(1, n + 1):\n                S[i] = add(S[i], S[i - 1])\n            for i in range(n + 1):\n                S[i] = mult(S[i], self.mod_inv(p))\n            self.memo[n] = S\n\ndef freq(a):\n    m = {}\n    for e in a:\n        if e in m:\n            m[e] += 1\n        else:\n            m[e] = 1\n    return m\ncomb = Combination(500001)\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    freq_arr = freq(a)\n    comb.set_freq(freq_arr)\n    ans = [0 for i in range(n + 1)]\n    res_back_memo = [1 for i in range(n + 1)]\n    res_front_memo = [1 for i in range(n + 1)]\n    backward = {}\n    forward = {}\n    back_mult = [1 for i in range(n + 1)]\n    for i in range(1, n + 1):\n        if i in freq_arr:\n            back_mult[i] = mult(back_mult[i - 1], pow(2, freq_arr[i], MOD))\n        else:\n            back_mult[i] = back_mult[i - 1]\n    front_mult = [1 for i in range(n + 2)]\n    for i in range(n, 0, -1):\n        if i in freq_arr:\n            front_mult[i] = mult(front_mult[i + 1], pow(2, freq_arr[i], MOD))\n        else:\n            front_mult[i] = front_mult[i + 1]\n    for e in range(1, n + 1):\n        if e in freq_arr:\n            freq_e = freq_arr[e]\n            for i in range(1, freq_e + 1):\n                res = mult(res_back_memo[i], back_mult[e - 1])\n                backward[e, i] = res\n            for i in range(1, freq_e + 1):\n                res_back_memo[i] = mult(res_back_memo[i], comb.memo[freq_arr[e]][i - 1])\n    for e in range(n, 0, -1):\n        if e in freq_arr:\n            freq_e = freq_arr[e]\n            for i in range(1, freq_e + 1):\n                res = mult(res_front_memo[i], front_mult[e + 1])\n                forward[e, i] = res\n            for i in range(1, freq_e + 1):\n                res_front_memo[i] = mult(res_front_memo[i], comb.memo[freq_arr[e]][i])\n    for e in range(1, n + 1):\n        if e in freq_arr:\n            for i in range(1, freq_arr[e] + 1):\n                ans[e] = add(ans[e], mult(comb.C(freq_arr[e], i), mult(forward[e, i], backward[e, i])))\n    for i in range(1, n + 1):\n        print(ans[i], end=' ')\n    print()", "N = 500001\nfactorialNumInverse = [None] * (N + 1)\nnaturalNumInverse = [None] * (N + 1)\nfact = [None] * (N + 1)\nnaturalNumInverse[0] = naturalNumInverse[1] = 1\nfor i in range(2, N + 1, 1):\n    naturalNumInverse[i] = naturalNumInverse[1000000007 % i] * (1000000007 - 1000000007 // i) % 1000000007\nfactorialNumInverse[0] = factorialNumInverse[1] = 1\nfor i in range(2, N + 1, 1):\n    factorialNumInverse[i] = naturalNumInverse[i] * factorialNumInverse[i - 1] % 1000000007\nfact[0] = 1\nfor i in range(1, N + 1):\n    fact[i] = fact[i - 1] * i % 1000000007\n\ndef Binomial(N, R):\n    return fact[N] * factorialNumInverse[R] % 1000000007 * factorialNumInverse[N - R] % 1000000007\n\ndef modInverse(a, m):\n    m0 = m\n    y = 0\n    x = 1\n    if m == 1:\n        return 0\n    while a > 1:\n        q = a // m\n        t = m\n        m = a % m\n        a = t\n        t = y\n        y = x - q * y\n        x = t\n    if x < 0:\n        x = x + m0\n    return x\nfor _ in range(int(input())):\n    n = int(input())\n    a = list(map(int, input().split()))\n    cts = {}\n    rc = {}\n    ans = [0 for _ in range(n)]\n    acts = [0 for _ in range(n)]\n    for x in a:\n        acts[x - 1] += 1\n    myarray = []\n    for x in range(n, 0, -1):\n        if acts[x - 1] > 0:\n            cts[x] = acts[x - 1]\n            myarray.append(x)\n            rc[x] = 1\n    nl = []\n    nextlist = []\n    for y in range(1, max(acts) + 1):\n        justlist = []\n        nextlist = []\n        for x in myarray:\n            justlist.append(x)\n            if acts[x - 1] > y:\n                nextlist.append(x)\n        nl.append(justlist)\n        myarray = nextlist\n    p = 1\n    for (g, x) in enumerate(nl):\n        for i in x:\n            c = Binomial(cts[i], g + 1)\n            p = p * modInverse(rc[i], 1000000007) % 1000000007\n            ans[i - 1] = (ans[i - 1] + p * c % 1000000007) % 1000000007\n            rc[i] = (rc[i] + c) % 1000000007\n            p = rc[i] * p % 1000000007\n    for i in ans:\n        print(i, end=' ')\n    print()", "comb_sum = [[1].copy() for _ in range(500001)]\ncombination_hash = {}\ncom_num = [[].copy() for _ in range(500001)]\ncom_den = [[].copy() for _ in range(500001)]\nMOD_VAL = 1000000007\n\ndef combinations(n, r):\n    r = min(n - r, r)\n    if r == 0:\n        return 1\n    if combination_hash.get((n, r)) is not None:\n        return combination_hash[n, r]\n    p = 1000000007\n    num = den = 1\n    if len(com_num[n]) != 0:\n        num = com_num[n][-1]\n        den = com_den[n][-1]\n    for i in range(len(com_num[n]), r):\n        num = num * (n - i) % p\n        den = den * (i + 1) % p\n        com_num[n].append(num)\n        com_den[n].append(den)\n    answer = num * pow(den, p - 2, p) % p\n    combination_hash[n, r] = answer\n    return answer\n\ndef pre_compute_comb_sum(freqs):\n    for freq in freqs:\n        cache = comb_sum[freq]\n        if len(cache) > freq:\n            continue\n        local_possible = 1\n        for i in range(1, freq + 1):\n            local_possible += combinations(freq, i)\n            local_possible %= MOD_VAL\n            cache.append(local_possible)\n\ndef pre_compute_sum_for(count_dict, n):\n    global pre_mul_for\n    prefix_mul = [[]]\n    c_psum = [0]\n    for i in range(1, n + 1):\n        if i not in count_dict:\n            c_psum.append(c_psum[-1])\n            continue\n        c_psum.append(c_psum[-1] + count_dict[i])\n    recents = [-1] * 500001\n    for key in range(1, n + 1):\n        if key not in count_dict:\n            prefix_mul.append(prefix_mul[-1])\n            continue\n        prefix = []\n        for i in range(1, count_dict[key] + 1):\n            cur_comb_sum = comb_sum[count_dict[key]][i]\n            if recents[i] == -1:\n                prev_prefix_mul = pow(2, c_psum[key - 1], MOD_VAL)\n                prefix.append((prev_prefix_mul % MOD_VAL, prev_prefix_mul * cur_comb_sum % MOD_VAL))\n            else:\n                pow_2 = c_psum[key - 1] - c_psum[recents[i]]\n                pow_2 = pow(2, pow_2, MOD_VAL)\n                recent_prefix_sum = prefix_mul[recents[i]][i - 1][1]\n                prefix.append((pow_2 * recent_prefix_sum % MOD_VAL, pow_2 * recent_prefix_sum * cur_comb_sum % MOD_VAL))\n            recents[i] = key\n        prefix_mul.append(prefix)\n    pre_mul_for = prefix_mul\n\ndef pre_compute_sum_rev(count_dict, n):\n    global pre_mul_rev\n    prefix_mul = [[]]\n    c_psum = [0]\n    for i in range(n, 0, -1):\n        if i not in count_dict:\n            c_psum.append(c_psum[-1])\n            continue\n        c_psum.append(c_psum[-1] + count_dict[i])\n    c_psum.append(0)\n    c_psum.reverse()\n    recents = [-1] * 500001\n    for key in range(n, 0, -1):\n        if key not in count_dict:\n            prefix_mul.append(prefix_mul[-1])\n            continue\n        prefix = []\n        for i in range(1, count_dict[key] + 1):\n            cur_comb_sum = comb_sum[count_dict[key]][i]\n            if recents[i] == -1:\n                prev_prefix_mul = pow(2, c_psum[key + 1], MOD_VAL)\n                prefix.append((prev_prefix_mul % MOD_VAL, prev_prefix_mul * cur_comb_sum % MOD_VAL))\n            else:\n                pow_2 = c_psum[key + 1] - c_psum[recents[i]]\n                pow_2 = pow(2, pow_2, MOD_VAL)\n                recent_prefix_sum = prefix_mul[n - recents[i] + 1][i - 1][1]\n                prefix.append((pow_2 * recent_prefix_sum % MOD_VAL, pow_2 * recent_prefix_sum * cur_comb_sum % MOD_VAL))\n            recents[i] = key\n        prefix_mul.append(prefix)\n    prefix_mul.append([])\n    prefix_mul.reverse()\n    del prefix_mul[-1]\n    pre_mul_rev = prefix_mul\n\ndef get_subsequence_count(num, count):\n    if count == 1:\n        return pre_mul_rev[num][count - 1][0]\n    else:\n        return pre_mul_for[num][count - 2][0] * pre_mul_rev[num][count - 1][0] % MOD_VAL\n\ndef solution(n, nums):\n    global prefix_sums_for, prefix_sums_rev\n    count_dict = {}\n    for num in nums:\n        count_dict[num] = count_dict.get(num, 0) + 1\n    nums_present = list(count_dict.keys())\n    nums_present.sort()\n    pre_compute_comb_sum(set(count_dict.values()))\n    pre_compute_sum_for(count_dict, n)\n    pre_compute_sum_rev(count_dict, n)\n    answers = []\n    for num in range(1, n + 1):\n        if num not in count_dict:\n            answers.append('0')\n            continue\n        answer = 0\n        for int_count in range(1, count_dict[num] + 1):\n            answer += combinations(count_dict[num], int_count) % 1000000007 * (get_subsequence_count(num, int_count) % 1000000007)\n        answers.append(str(answer % 1000000007))\n    return ' '.join(answers)\nT = int(input())\nwhile T != 0:\n    n = int(input())\n    nums = [int(a) for a in input().split(' ')]\n    print(solution(n, nums))\n    T -= 1", "mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    dic = {}\n    mxn = 0\n    for i in range(N):\n        if A[i] in dic:\n            dic[A[i]] += 1\n        else:\n            dic[A[i]] = 1\n        mxn = max(mxn, dic[A[i]])\n    if len(dic.keys()) == 1:\n        x = pow(2, N, mod) - 1\n        j = A[0]\n        for i in range(N):\n            if i == A[0] - 1:\n                print(x, end=' ')\n            else:\n                print(0, end=' ')\n    else:\n        kaunlen = [0 for i in range(mxn)]\n        for i in dic.keys():\n            for j in range(dic[i]):\n                kaunlen[j] += 1\n        kaunlenindex = [0 for i in range(mxn)]\n        kaun = [[0 for j in range(kaunlen[i])] for i in range(mxn)]\n        y = [0 for i in range(len(dic.keys()))]\n        io = 0\n        for i in range(1, N + 1):\n            if i in dic:\n                y[io] = i\n                io += 1\n        K = [[] for i in range(N + 1)]\n        sumtill = [[] for i in range(N + 1)]\n        ifdone = [False for i in range(N + 1)]\n        ifdonepos = [0 for i in range(N + 1)]\n        for i in y:\n            w = dic[i]\n            if ifdone[w]:\n                K[i] = K[ifdonepos[w]].copy()\n                sumtill[i] = sumtill[ifdonepos[w]].copy()\n                for j in range(w):\n                    kaun[j][kaunlenindex[j]] = i\n                    kaunlenindex[j] += 1\n            else:\n                x = w\n                K[i] = [0 for j in range(w)]\n                sumtill[i] = [1 for j in range(w)]\n                K[i][0] = x\n                sumtill[i][0] = x + 1\n                kaun[0][kaunlenindex[0]] = i\n                kaunlenindex[0] += 1\n                for j in range(1, w // 2):\n                    x = x * (w - j) // (j + 1)\n                    K[i][j] = x % mod\n                    kaun[j][kaunlenindex[j]] = i\n                    kaunlenindex[j] += 1\n                for j in range(w // 2, w - 1):\n                    K[i][j] = K[i][w - j - 2]\n                    kaun[j][kaunlenindex[j]] = i\n                    kaunlenindex[j] += 1\n                K[i][-1] = 1\n                if w > 1:\n                    kaun[w - 1][kaunlenindex[w - 1]] = i\n                    kaunlenindex[w - 1] += 1\n                for j in range(1, w):\n                    sumtill[i][j] = (sumtill[i][j - 1] + K[i][j]) % mod\n                ifdone[w] = True\n                ifdonepos[w] = i\n        finans = [0 for i in range(N + 1)]\n        preprod = [[] for i in range(len(kaun))]\n        sufprod = [[] for i in range(len(kaun))]\n        for i in range(mxn):\n            if i != 0:\n                ki = kaun[i]\n                preprod[i] = [1 for i in range(len(ki))]\n                sufprod[i] = [1 for i in range(len(ki))]\n                for j in range(1, len(ki)):\n                    preprod[i][j] = preprod[i][j - 1] * sumtill[ki[j - 1]][i - 1] % mod\n                    preprod[i][j] %= mod\n                sufprod[i][len(ki) - 1] = 1\n                for j in range(len(ki) - 2, -1, -1):\n                    sufprod[i][j] = sufprod[i][j + 1] * sumtill[ki[j + 1]][i] % mod\n                    sufprod[i][j] %= mod\n        prodtill = 1\n        curr = 1\n        finanstable = [[] for i in range(N + 1)]\n        for i in y:\n            finanstable[i] = [0 for j in range(dic[i])]\n        ans = 1\n        for i in range(mxn):\n            ki = kaun[i]\n            curr = prodtill\n            pi = preprod[i]\n            si = sufprod[i]\n            for j in range(len(ki) - 1, -1, -1):\n                if i == 0:\n                    if j == len(ki) - 1:\n                        finanstable[ki[j]][i] = 1\n                    else:\n                        ans *= sumtill[ki[j + 1]][i] % mod\n                        ans %= mod\n                        finanstable[ki[j]][i] = ans\n                    if dic[ki[j]] == i + 1:\n                        prodtill *= sumtill[ki[j]][i]\n                else:\n                    ans = pi[j] * si[j] % mod * curr % mod\n                    finanstable[ki[j]][i] = ans\n                    if dic[ki[j]] == i + 1:\n                        prodtill = prodtill * sumtill[ki[j]][i] % mod\n                        prodtill %= mod\n        for i in range(1, N + 1):\n            for j in range(len(finanstable[i])):\n                finans[i] += finanstable[i][j] * K[i][j] % mod\n                finans[i] %= mod\n        for i in range(1, N + 1):\n            print(finans[i], end=' ')\n        print()", "mod = 10 ** 9 + 7\nfor _ in range(int(input())):\n    N = int(input())\n    A = list(map(int, input().split()))\n    dic = {}\n    mxn = 0\n    for i in range(N):\n        if A[i] in dic:\n            dic[A[i]] += 1\n        else:\n            dic[A[i]] = 1\n        mxn = max(mxn, dic[A[i]])\n    if len(dic.keys()) == 1:\n        x = pow(2, N, mod) - 1\n        j = A[0]\n        for i in range(N):\n            if i == A[0] - 1:\n                print(x, end=' ')\n            else:\n                print(0, end=' ')\n    else:\n        kaunlen = [0 for i in range(mxn)]\n        for i in dic.keys():\n            for j in range(dic[i]):\n                kaunlen[j] += 1\n        kaunlenindex = [0 for i in range(mxn)]\n        kaun = [[0 for j in range(kaunlen[i])] for i in range(mxn)]\n        y = [0 for i in range(len(dic.keys()))]\n        io = 0\n        for i in range(1, N + 1):\n            if i in dic:\n                y[io] = i\n                io += 1\n        K = [[] for i in range(N + 1)]\n        sumtill = [[] for i in range(N + 1)]\n        ifdone = [False for i in range(N + 1)]\n        ifdonepos = [0 for i in range(N + 1)]\n        for i in y:\n            w = dic[i]\n            if ifdone[w]:\n                K[i] = K[ifdonepos[w]].copy()\n                sumtill[i] = sumtill[ifdonepos[w]].copy()\n                for j in range(w):\n                    kaun[j][kaunlenindex[j]] = i\n                    kaunlenindex[j] += 1\n            else:\n                x = w\n                K[i] = [0 for j in range(w)]\n                sumtill[i] = [1 for j in range(w)]\n                K[i][0] = x\n                sumtill[i][0] = x + 1\n                kaun[0][kaunlenindex[0]] = i\n                kaunlenindex[0] += 1\n                for j in range(1, w // 2):\n                    x = x * (w - j) // (j + 1)\n                    K[i][j] = x % mod\n                    kaun[j][kaunlenindex[j]] = i\n                    kaunlenindex[j] += 1\n                for j in range(w // 2, w - 1):\n                    K[i][j] = K[i][w - j - 2]\n                    kaun[j][kaunlenindex[j]] = i\n                    kaunlenindex[j] += 1\n                K[i][-1] = 1\n                if w > 1:\n                    kaun[w - 1][kaunlenindex[w - 1]] = i\n                    kaunlenindex[w - 1] += 1\n                for j in range(1, w):\n                    sumtill[i][j] = (sumtill[i][j - 1] + K[i][j]) % mod\n                ifdone[w] = True\n                ifdonepos[w] = i\n        finans = [0 for i in range(N + 1)]\n        preprod = [[] for i in range(len(kaun))]\n        sufprod = [[] for i in range(len(kaun))]\n        for i in range(mxn):\n            if i != 0:\n                ki = kaun[i]\n                preprod[i] = [1 for i in range(len(ki))]\n                sufprod[i] = [1 for i in range(len(ki))]\n                for j in range(1, len(ki)):\n                    preprod[i][j] = preprod[i][j - 1] * sumtill[ki[j - 1]][i - 1] % mod\n                    preprod[i][j] %= mod\n                sufprod[i][len(ki) - 1] = 1\n                for j in range(len(ki) - 2, -1, -1):\n                    sufprod[i][j] = sufprod[i][j + 1] * sumtill[ki[j + 1]][i] % mod\n                    sufprod[i][j] %= mod\n        prodtill = 1\n        curr = 1\n        finanstable = [[] for i in range(N + 1)]\n        for i in y:\n            finanstable[i] = [0 for j in range(dic[i])]\n        ans = 1\n        for i in range(mxn):\n            ki = kaun[i]\n            curr = prodtill\n            pi = preprod[i]\n            si = sufprod[i]\n            for j in range(len(ki) - 1, -1, -1):\n                if i == 0:\n                    if j == len(ki) - 1:\n                        finanstable[ki[j]][i] = 1\n                    else:\n                        ans *= sumtill[ki[j + 1]][i] % mod\n                        ans %= mod\n                        finanstable[ki[j]][i] = ans\n                    if dic[ki[j]] == i + 1:\n                        prodtill *= sumtill[ki[j]][i]\n                else:\n                    ans = pi[j] * si[j] % mod * curr % mod\n                    finanstable[ki[j]][i] = ans\n                    if dic[ki[j]] == i + 1:\n                        prodtill = prodtill * sumtill[ki[j]][i] % mod\n                        prodtill %= mod\n        for i in range(1, N + 1):\n            for j in range(len(finanstable[i])):\n                finans[i] += finanstable[i][j] * K[i][j] % mod\n                finans[i] %= mod\n        for i in range(1, N + 1):\n            print(finans[i], end=' ')\n        print()"]