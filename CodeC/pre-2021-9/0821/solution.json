["from collections import defaultdict\nfrom collections import Counter\nimport sys, threading\nsys.setrecursionlimit(5 * 10 ** 5)\nthreading.stack_size(10 ** 8)\nMAX = 1000000007\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n + 1)]\n        self.size = [0] * (n + 1)\n\n    def start(self):\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def treeinput(self, m):\n        for i in range(m):\n            (u, v) = map(int, input().split())\n            self.union(u, v)\n\n    def printt(self):\n        print(self.parent)\n\ndef main():\n    (n, m) = map(int, input().split())\n    d = dsu(n)\n    galaxy = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        d.union(u, v)\n    arr = [-999]\n    for i in range(n):\n        arr.append(int(input()))\n    for i in range(1, n + 1):\n        galaxy[d.find(i)].append(i)\n    res = []\n    f = 1\n    for num in galaxy:\n        mn = MAX\n        for i in galaxy[num]:\n            if arr[i] >= 0:\n                mn = min(mn, arr[i])\n        if mn == MAX:\n            f = 0\n            break\n        res.append(mn)\n    if len(galaxy) == 1:\n        print(0)\n    elif not f:\n        print(-1)\n    else:\n        (cnt, mn, sm) = (-2, MAX, 0)\n        for i in res:\n            mn = min(mn, i)\n            cnt += 1\n            sm += i\n        print(mn * cnt + sm)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import defaultdict\nfrom collections import Counter\nimport sys, threading\nsys.setrecursionlimit(5 * 10 ** 5)\nthreading.stack_size(10 ** 8)\nMAX = 1000000007\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n + 1)]\n        self.size = [0] * (n + 1)\n\n    def start(self):\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def treeinput(self, m):\n        for i in range(m):\n            (u, v) = map(int, input().split())\n            self.union(u, v)\n\n    def printt(self):\n        print(self.parent)\n\ndef main():\n    (n, m) = map(int, input().split())\n    d = dsu(n)\n    galaxy = defaultdict(list)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        d.union(u, v)\n    arr = [-999]\n    for i in range(n):\n        arr.append(int(input()))\n    for i in range(1, n + 1):\n        galaxy[d.find(i)].append(i)\n    res = []\n    f = 1\n    for num in galaxy:\n        mn = MAX\n        for i in galaxy[num]:\n            if arr[i] >= 0:\n                mn = min(mn, arr[i])\n        if mn == MAX:\n            f = 0\n            break\n        res.append(mn)\n    if len(galaxy) == 1:\n        print(0)\n    elif not f:\n        print(-1)\n    else:\n        (cnt, mn, sm) = (-2, MAX, 0)\n        for i in res:\n            mn = min(mn, i)\n            cnt += 1\n            sm += i\n        print(mn * cnt + sm)\nt = threading.Thread(target=main)\nt.start()\nt.join()", "from collections import defaultdict\nfrom collections import Counter\nimport math\nimport bisect\n\nclass dsu:\n\n    def __init__(self, n):\n        self.parent = [i for i in range(n + 1)]\n        self.size = [0] * (n + 1)\n\n    def start(self):\n        for i in range(1, n + 1):\n            self.parent[i] = i\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, u, v):\n        (u, v) = (self.find(u), self.find(v))\n        if u != v:\n            self.parent[v] = u\n\n    def treeinput(self, m):\n        for i in range(m):\n            (u, v) = map(int, input().split())\n            self.union(u, v)\n\n    def printt(self):\n        print(self.parent)\nMAX = 1000000007\n(n, m) = map(int, input().split())\nd = dsu(n)\ngalaxy = defaultdict(list)\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    d.union(u, v)\narr = [-999]\nfor i in range(n):\n    arr.append(int(input()))\nfor i in range(1, n + 1):\n    galaxy[d.find(i)].append(i)\nres = []\nf = 1\nfor num in galaxy:\n    mn = MAX\n    for i in galaxy[num]:\n        if arr[i] >= 0:\n            mn = min(mn, arr[i])\n    if mn == MAX:\n        f = 0\n        break\n    res.append(mn)\nif len(galaxy) == 1:\n    print(0)\nelif not f:\n    print(-1)\nelse:\n    (cnt, mn, sm) = (-2, MAX, 0)\n    for i in res:\n        mn = min(mn, i)\n        cnt += 1\n        sm += i\n    print(mn * cnt + sm)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(vi, n, ed, c, mi):\n    vi[n] = True\n    if c[n] >= 0:\n        mi[0] = min(mi[0], c[n])\n    for l in ed[n]:\n        if vi[l] == False:\n            dfs(vi, l, ed, c, mi)\n(n, m) = [int(a) for a in input().split()]\ned = []\nfor l in range(n + 1):\n    ed.append([])\nfor l in range(m):\n    (u, v) = [int(a) for a in input().split()]\n    ed[u].append(v)\n    ed[v].append(u)\nc = [0]\nfor l in range(n):\n    c.append(int(input()))\nans = []\nvi = []\nfor l in range(n + 1):\n    vi.append(False)\nco = 0\nfor v in range(1, n + 1):\n    mi = [float('inf')]\n    f = False\n    if vi[v] == False:\n        dfs(vi, v, ed, c, mi)\n        co = co + 1\n        if mi[0] == float('inf'):\n            if co >= 2:\n                f = True\n                print(-1)\n                break\n            else:\n                ans.append(0)\n        else:\n            ans.append(mi[0])\n    if f:\n        break\nif not f:\n    to = 0\n    ans.sort()\n    for l in range(1, len(ans)):\n        to = to + ans[l] + ans[0]\n    print(to)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(vi, n, ed, c, mi):\n    vi[n] = True\n    if c[n] >= 0:\n        mi[0] = min(mi[0], c[n])\n    for l in ed[n]:\n        if vi[l] == False:\n            dfs(vi, l, ed, c, mi)\n(n, m) = [int(a) for a in input().split()]\ned = []\nfor l in range(n + 1):\n    ed.append([])\nfor l in range(m):\n    (u, v) = [int(a) for a in input().split()]\n    ed[u].append(v)\n    ed[v].append(u)\nc = [0]\nfor l in range(n):\n    c.append(int(input()))\nans = []\nvi = []\nfor l in range(n + 1):\n    vi.append(False)\nco = 0\nfor v in range(1, n + 1):\n    mi = [float('inf')]\n    f = False\n    if vi[v] == False:\n        dfs(vi, v, ed, c, mi)\n        co = co + 1\n        if mi[0] == float('inf'):\n            if co >= 2:\n                f = True\n                print(-1)\n                break\n            else:\n                ans.append(0)\n        else:\n            ans.append(mi[0])\n    if f:\n        break\nif not f:\n    to = 0\n    ans.sort()\n    for l in range(1, len(ans)):\n        to = to + ans[l] + ans[0]\n    ans.clear()\n    print(to)", "from collections import defaultdict\n\ndef find(x):\n    to_compress = []\n    while parents[x] != x:\n        to_compress.append(x)\n        x = parents[x]\n    for i in to_compress:\n        parents[i] = x\n    return x\n\ndef merge(x, y):\n    if ranks[x] >= ranks[y]:\n        parents[find(y)] = find(x)\n        ranks[find(x)] += 1\n    elif ranks[x] < ranks[y]:\n        parents[find(x)] = find(y)\n        ranks[find(y)] += 1\n(n, m) = map(int, input().split())\nparents = [i for i in range(n)]\nranks = [0 for i in range(n)]\nfor _ in range(m):\n    (a, b) = map(int, input().split())\n    merge(a - 1, b - 1)\ncosts = []\nfor _ in range(n):\n    val = int(input())\n    costs.append(val)\ngroups = defaultdict(list)\nfor i in range(n):\n    root = find(i)\n    groups[root].append(costs[i])\nmin_costs_per_group = []\nfor i in groups.values():\n    useful_govts = [x for x in i if x >= 0]\n    if len(useful_govts) == 0:\n        min_costs_per_group.append(-1)\n        break\n    min_costs_per_group.append(min(useful_govts))\nif len(groups.keys()) == 1:\n    print(0)\nelif min_costs_per_group[-1] == -1:\n    print(-1)\nelse:\n    n_teleports = len(min_costs_per_group)\n    mn = min(min_costs_per_group)\n    print((n_teleports - 1) * mn + sum(min_costs_per_group) - mn)", "class DisjointSet:\n\n    def __init__(self, n, cost):\n        self.parent = [i for i in range(n + 1)]\n        self.rank = [1] * (n + 1)\n        self.cost = cost\n        self.visited = [0] * (n + 1)\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        x_repr = self.find(x)\n        y_repr = self.find(y)\n        if x_repr == y_repr:\n            return\n        elif self.rank[x_repr] < self.rank[y_repr]:\n            self.parent[x_repr] = y_repr\n        elif self.rank[y_repr] < self.rank[x_repr]:\n            self.parent[y_repr] = x_repr\n        else:\n            self.parent[x_repr] = y_repr\n            self.rank[y_repr] += 1\n\n    def populate_representatives(self, x):\n        root = self.find(x)\n        if 0 <= self.cost[x] < self.cost[root] or (self.cost[root] < 0 and self.cost[x] >= 0):\n            self.cost[root] = self.cost[x]\n(n, m) = map(int, input().strip().split())\nconnections = []\ncost = [0] * (n + 1)\nsumm = 0\nminimum = 100005\ncount = 0\nnot_possible = 0\nfor _ in range(m):\n    (x, y) = map(int, input().strip().split())\n    connections.append((x, y))\nfor _ in range(1, n + 1):\n    cost[_] = int(input())\nds = DisjointSet(n, cost)\nfor i in connections:\n    ds.union(i[0], i[1])\nfor _ in range(1, n + 1):\n    ds.populate_representatives(_)\nfor i in range(1, n + 1):\n    if not ds.visited[ds.parent[i]]:\n        ds.visited[ds.parent[i]] = 1\n        if ds.cost[ds.parent[i]] < 0:\n            not_possible = 1\n        summ += ds.cost[ds.parent[i]]\n        minimum = min(minimum, ds.cost[ds.parent[i]])\n        count += 1\nif count != 1:\n    if not_possible:\n        print(-1)\n    else:\n        count = (count - 2) * minimum\n        print(summ + count)\nelse:\n    print(0)", "class DisjointSet:\n\n    def __init__(self, n, cost):\n        self.parent = [i for i in range(n + 1)]\n        self.rank = [1] * (n + 1)\n        self.cost = cost\n        self.visited = [0] * (n + 1)\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, x, y):\n        x_repr = self.find(x)\n        y_repr = self.find(y)\n        if x_repr == y_repr:\n            return\n        elif self.rank[x_repr] < self.rank[y_repr]:\n            self.parent[x_repr] = y_repr\n        elif self.rank[y_repr] < self.rank[x_repr]:\n            self.parent[y_repr] = x_repr\n        else:\n            self.parent[x_repr] = y_repr\n            self.rank[y_repr] += 1\n\n    def populate_representatives(self, x):\n        root = self.find(x)\n        if 0 <= self.cost[x] < self.cost[root] or (self.cost[root] < 0 and self.cost[x] >= 0):\n            self.cost[root] = self.cost[x]\n(n, m) = map(int, input().strip().split())\nconnections = []\ncost = [0] * (n + 1)\nsumm = 0\nminimum = 100005\ncount = 0\nnot_possible = 0\nfor _ in range(m):\n    (x, y) = map(int, input().strip().split())\n    connections.append((x, y))\nfor _ in range(1, n + 1):\n    cost[_] = int(input())\nds = DisjointSet(n, cost)\nfor i in connections:\n    ds.union(i[0], i[1])\nfor _ in range(1, n + 1):\n    ds.populate_representatives(_)\nfor i in range(1, n + 1):\n    if not ds.visited[ds.parent[i]]:\n        ds.visited[ds.parent[i]] = 1\n        if ds.cost[ds.parent[i]] < 0:\n            not_possible = 1\n        summ += ds.cost[ds.parent[i]]\n        minimum = min(minimum, ds.cost[ds.parent[i]])\n        count += 1\nif count != 1:\n    if not_possible:\n        print(-1)\n    else:\n        count = (count - 2) * minimum\n        print(summ + count)\nelse:\n    print(0)", "from collections import defaultdict\nimport gc\ngc.disable()\n\ndef find(a):\n    if par[a] == a:\n        return a\n    else:\n        par[a] = find(par[a])\n        return par[a]\n\ndef union(a, b):\n    (a, b) = (find(a), find(b))\n    if a != b:\n        if rank[a] > rank[b]:\n            par[b] = a\n        elif rank[b] > rank[a]:\n            par[a] = b\n        else:\n            par[a] = b\n            rank[b] += 1\nchanged_big_value = 10 ** 10\n(n, m) = map(int, input().split())\npar = [i for i in range(n + 1)]\nrank = [0 for i in range(n + 1)]\ncost = [-1 for i in range(n + 1)]\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    union(u, v)\nup = set()\nfor i in range(1, n + 1):\n    c = int(input())\n    j = find(i)\n    up.add(j)\n    if c >= 0:\n        if cost[j] == -1:\n            cost[j] = c\n        else:\n            cost[j] = min(cost[j], c)\nif len(up) == 1:\n    print(0)\nelse:\n    flag = True\n    for i in up:\n        if cost[i] == -1:\n            print(-1)\n            flag = False\n            break\n    if flag:\n        t = [cost[x] for x in up]\n        t.sort()\n        print(sum(t) + (len(t) - 2) * t[0])", "def find(a):\n    if par[a] == a:\n        return a\n    else:\n        par[a] = find(par[a])\n        return par[a]\n\ndef union(a, b):\n    (a, b) = (find(a), find(b))\n    if a != b:\n        if rank[a] > rank[b]:\n            par[b] = a\n        elif rank[b] > rank[a]:\n            par[a] = b\n        else:\n            par[a] = b\n            rank[b] += 1\n(n, m) = map(int, input().split())\npar = [i for i in range(n + 1)]\nrank = [0 for i in range(n + 1)]\ncost = [-1 for i in range(n + 1)]\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    union(u, v)\nup = set()\nfor i in range(1, n + 1):\n    c = int(input())\n    up.add(find(i))\n    if c >= 0:\n        if cost[find(i)] == -1:\n            cost[find(i)] = c\n        else:\n            cost[find(i)] = min(cost[find(i)], c)\nif len(up) == 1:\n    print(0)\nelse:\n    flag = True\n    for i in up:\n        if cost[i] == -1:\n            print(-1)\n            flag = False\n            break\n    if flag:\n        t1 = [cost[x] for x in up]\n        t1.sort()\n        print(sum(t1) + (len(t1) - 2) * t1[0])", "def find(a):\n    if par[a] == a:\n        return a\n    else:\n        par[a] = find(par[a])\n        return par[a]\n\ndef union(a, b):\n    (a, b) = (find(a), find(b))\n    if a != b:\n        if rank[a] > rank[b]:\n            par[b] = a\n        elif rank[b] > rank[a]:\n            par[a] = b\n        else:\n            par[a] = b\n            rank[b] += 1\n(n, m) = map(int, input().split())\npar = [i for i in range(n + 1)]\nrank = [0 for i in range(n + 1)]\ncost = [-1 for i in range(n + 1)]\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    union(u, v)\nup = set()\nfor i in range(1, n + 1):\n    c = int(input())\n    up.add(find(i))\n    if c >= 0:\n        if cost[find(i)] == -1:\n            cost[find(i)] = c\n        else:\n            cost[find(i)] = min(cost[find(i)], c)\nif len(up) == 1:\n    print(0)\nelse:\n    flag = True\n    for i in up:\n        if cost[i] == -1:\n            print(-1)\n            flag = False\n            break\n    if flag:\n        t1 = [cost[x] for x in up]\n        t1.sort()\n        print(sum(t1) + (len(t1) - 2) * t1[0])", "from sys import stdin, stdout\n\ndef find(parent, n):\n    if parent[n] == n:\n        return n\n    else:\n        parent[n] = find(parent, parent[n])\n        return parent[n]\n\ndef union(parent, u, v):\n    (u, v) = (find(parent, u), find(parent, v))\n    if u != v:\n        if rank[u] > rank[v]:\n            parent[v] = u\n        elif rank[u] < rank[v]:\n            parent[u] = v\n        else:\n            parent[u] = v\n            rank[v] += 1\n(n, m) = stdin.readline().strip().split(' ')\n(n, m) = (int(n), int(m))\nparent = [i for i in range(n)]\nrank = [0] * n\nchoice = [-1 for i in range(n)]\nfor _ in range(m):\n    (u, v) = stdin.readline().strip().split(' ')\n    (u, v) = (int(u) - 1, int(v) - 1)\n    union(parent, u, v)\ns = set()\nfor i in range(n):\n    c = int(stdin.readline().strip())\n    s.add(find(parent, i))\n    if c >= 0:\n        if choice[find(parent, i)] == -1:\n            choice[find(parent, i)] = c\n        else:\n            choice[find(parent, i)] = min(choice[find(parent, i)], c)\nif len(s) == 1:\n    print(0)\nelse:\n    f = 0\n    for i in s:\n        if choice[i] == -1:\n            print(-1)\n            f = 1\n            break\n    if f == 0:\n        t = [choice[x] for x in s]\n        t.sort()\n        print(sum(t) + (len(t) - 2) * t[0])", "def find(a):\n    if par[a] == a:\n        return a\n    else:\n        par[a] = find(par[a])\n        return par[a]\n\ndef union(a, b):\n    (a, b) = (find(a), find(b))\n    if a != b:\n        if rank[a] > rank[b]:\n            par[b] = a\n        elif rank[b] > rank[a]:\n            par[a] = b\n        else:\n            par[a] = b\n            rank[b] += 1\n(n, m) = map(int, input().split())\npar = [i for i in range(n + 1)]\nrank = [0 for i in range(n + 1)]\ncost = [-1 for i in range(n + 1)]\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    union(u, v)\nup = set()\nfor i in range(1, n + 1):\n    c = int(input())\n    up.add(find(i))\n    if c >= 0:\n        if cost[find(i)] == -1:\n            cost[find(i)] = c\n        else:\n            cost[find(i)] = min(cost[find(i)], c)\nif len(up) == 1:\n    print(0)\nelse:\n    flag = True\n    for i in up:\n        if cost[i] == -1:\n            print(-1)\n            flag = False\n            break\n    if flag:\n        t1 = [cost[x] for x in up]\n        t1.sort()\n        print(sum(t1) + (len(t1) - 2) * t1[0])", "from sys import stdin, stdout\n\ndef find(a):\n    if par[a] == a:\n        return a\n    else:\n        par[a] = find(par[a])\n        return par[a]\n\ndef union(a, b):\n    (a, b) = (find(a), find(b))\n    if a != b:\n        if rank[a] > rank[b]:\n            par[b] = a\n        elif rank[b] > rank[a]:\n            par[a] = b\n        else:\n            par[a] = b\n            rank[b] += 1\n(n, m) = stdin.readline().strip().split(' ')\n(n, m) = (int(n), int(m))\npar = [i for i in range(n)]\nrank = [0 for i in range(n)]\ncost = [-1 for i in range(n)]\nfor i in range(m):\n    (u, v) = stdin.readline().strip().split(' ')\n    (u, v) = (int(u) - 1, int(v) - 1)\n    union(u, v)\nup = set()\nfor i in range(n):\n    c = int(stdin.readline().strip())\n    up.add(find(i))\n    if c >= 0:\n        if cost[find(i)] == -1:\n            cost[find(i)] = c\n        else:\n            cost[find(i)] = min(cost[find(i)], c)\nif len(up) == 1:\n    print(0)\nelse:\n    flag = True\n    for i in up:\n        if cost[i] == -1:\n            print(-1)\n            flag = False\n            break\n    if flag:\n        t1 = [cost[x] for x in up]\n        t1.sort()\n        print(sum(t1) + (len(t1) - 2) * t1[0])", "from sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(100000)\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.graph = [-1 for i in range(vertices + 1)]\n\n    def findParent(self, x):\n        if self.graph[x] < 0:\n            return x\n        else:\n            self.graph[x] = self.findParent(self.graph[x])\n            return self.graph[x]\n\n    def union(self, x, y):\n        if self.graph[x] <= self.graph[y]:\n            self.graph[x] += self.graph[y]\n            self.graph[y] = x\n        else:\n            self.graph[y] += self.graph[x]\n            self.graph[x] = y\n\n    def addEdge(self, x, y):\n        x = self.findParent(x)\n        y = self.findParent(y)\n        if x != y:\n            self.union(x, y)\n(n, m) = map(int, input().split())\nplanets = n\ng = Graph(n)\ncost = []\nfor _ in range(m):\n    (a, b) = map(int, input().split())\n    g.addEdge(a, b)\nfor i in range(n):\n    c = int(input())\n    index = i + 1\n    if c >= 0:\n        cost.append((c, index))\ncost.sort()\ntotal = 0\nn = len(cost)\nif n >= 2:\n    e1 = cost.pop(0)\n    for i in range(n - 1):\n        e2 = cost[i]\n        p1 = g.findParent(e1[1])\n        p2 = g.findParent(e2[1])\n        if p1 != p2:\n            total = total + (e2[0] + e1[0])\n            g.union(p1, p2)\ns = set()\nfor i in range(1, planets + 1):\n    p = g.findParent(i)\n    s.add(p)\nif len(s) == 1:\n    print(str(total))\nelse:\n    print('-1')", "from sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(100000)\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.graph = [-1 for i in range(vertices + 1)]\n\n    def findParent(self, x):\n        if self.graph[x] < 0:\n            return x\n        else:\n            self.graph[x] = self.findParent(self.graph[x])\n            return self.graph[x]\n\n    def union(self, x, y):\n        if self.graph[x] <= self.graph[y]:\n            self.graph[x] += self.graph[y]\n            self.graph[y] = x\n        else:\n            self.graph[y] += self.graph[x]\n            self.graph[x] = y\n\n    def addEdge(self, x, y):\n        x = self.findParent(x)\n        y = self.findParent(y)\n        if x != y:\n            self.union(x, y)\n(n, m) = map(int, input().split())\nplanets = n\ng = Graph(n)\ncost = []\nfor _ in range(m):\n    (a, b) = map(int, input().split())\n    g.addEdge(a, b)\nfor i in range(n):\n    c = int(input())\n    index = i + 1\n    if c >= 0:\n        cost.append((c, index))\ncost.sort()\ntotal = 0\nn = len(cost)\nif n >= 2:\n    e1 = cost.pop(0)\n    for i in range(n - 1):\n        e2 = cost[i]\n        p1 = g.findParent(e1[1])\n        p2 = g.findParent(e2[1])\n        if p1 != p2:\n            total = total + (e2[0] + e1[0])\n            g.union(p1, p2)\ns = set()\nfor i in range(1, planets + 1):\n    p = g.findParent(i)\n    s.add(p)\nif len(s) == 1:\n    print(str(total))\nelse:\n    print('-1')", "def find(l, ind):\n    if l[ind] < 0:\n        return (l[ind], ind)\n    else:\n        return find(l, l[ind])\n(n, m) = map(int, input().split())\nl = [-1] * (n + 1)\nfor x in range(m):\n    (a, b) = map(int, input().split())\n    a1 = find(l, a)\n    b1 = find(l, b)\n    if a1[1] != b1[1]:\n        if a1[0] == b1[0]:\n            l[a1[1]] += a1[0]\n            l[b1[1]] = a1[1]\n        elif a1[0] < b1[0]:\n            l[a1[1]] += b1[0]\n            l[b1[1]] = a1[1]\n        else:\n            l[b1[1]] += a1[0]\n            l[a1[1]] = b1[1]\n    else:\n        if a != a1[1]:\n            l[a] = a1[1]\n        if b != a1[1]:\n            l[b] = a1[1]\nl1 = [0] * n\nfor x in range(n):\n    l1[x] = int(input())\nd = dict()\nfor x in range(1, len(l)):\n    if l[x] < 0:\n        d[x] = [x]\nfor x in range(1, len(l)):\n    if l[x] > 0:\n        e = find(l, l[x])\n        d[e[1]].append(x)\nans = 0\nglobal_min = 100000\nif len(d) == 1:\n    print(0)\nelse:\n    for x in d:\n        min_cost = 100000\n        b = 0\n        for y in d[x]:\n            if l1[y - 1] < 0:\n                continue\n            if l1[y - 1] < global_min:\n                global_min = l1[y - 1]\n            if l1[y - 1] < min_cost:\n                min_cost = l1[y - 1]\n                b = 1\n        if b == 0:\n            ans = -1\n            break\n        else:\n            ans += min_cost\n    if b == 0:\n        print(-1)\n    else:\n        print(ans + (len(d) - 2) * global_min)", "from sys import stdin, stdout\n\ndef find(parent, n):\n    if parent[n] == n:\n        return n\n    else:\n        parent[n] = find(parent, parent[n])\n        return parent[n]\n\ndef union(parent, u, v):\n    (u, v) = (find(parent, u), find(parent, v))\n    if u != v:\n        if rank[u] > rank[v]:\n            parent[v] = u\n        elif rank[u] < rank[v]:\n            parent[u] = v\n        else:\n            parent[u] = v\n            rank[v] += 1\n(n, m) = stdin.readline().strip().split(' ')\n(n, m) = (int(n), int(m))\nparent = [i for i in range(n)]\nrank = [0] * n\nchoice = [-1 for i in range(n)]\nfor _ in range(m):\n    (u, v) = stdin.readline().strip().split(' ')\n    (u, v) = (int(u) - 1, int(v) - 1)\n    union(parent, u, v)\ns = set()\nfor i in range(n):\n    c = int(stdin.readline().strip())\n    s.add(find(parent, i))\n    if c >= 0:\n        if choice[find(parent, i)] == -1:\n            choice[find(parent, i)] = c\n        else:\n            choice[find(parent, i)] = min(choice[find(parent, i)], c)\nif len(s) == 1:\n    print(0)\nelse:\n    f = 0\n    for i in s:\n        if choice[i] == -1:\n            print(-1)\n            f = 1\n            break\n    if f == 0:\n        t = [choice[x] for x in s]\n        t.sort()\n        print(sum(t) + (len(t) - 2) * t[0])", "from sys import stdin, stdout\n\ndef find(a):\n    if par[a] == a:\n        return a\n    else:\n        par[a] = find(par[a])\n        return par[a]\n\ndef union(a, b):\n    (a, b) = (find(a), find(b))\n    if a != b:\n        if rank[a] > rank[b]:\n            par[b] = a\n        elif rank[b] > rank[a]:\n            par[a] = b\n        else:\n            par[a] = b\n            rank[b] += 1\n(n, m) = stdin.readline().strip().split(' ')\n(n, m) = (int(n), int(m))\npar = [i for i in range(n)]\nrank = [0 for i in range(n)]\ncost = [-1 for i in range(n)]\nfor i in range(m):\n    (u, v) = stdin.readline().strip().split(' ')\n    (u, v) = (int(u) - 1, int(v) - 1)\n    union(u, v)\nup = set()\nfor i in range(n):\n    c = int(stdin.readline().strip())\n    up.add(find(i))\n    if c >= 0:\n        if cost[find(i)] == -1:\n            cost[find(i)] = c\n        else:\n            cost[find(i)] = min(cost[find(i)], c)\nif len(up) == 1:\n    print(0)\nelse:\n    flag = True\n    for i in up:\n        if cost[i] == -1:\n            print(-1)\n            flag = False\n            break\n    if flag:\n        t1 = [cost[x] for x in up]\n        t1.sort()\n        print(sum(t1) + (len(t1) - 2) * t1[0])", "from sys import stdin\n\nclass Node:\n\n    def __init__(self, data, price):\n        self.data = data\n        self.rank = 0\n        self.networkPrice = price\n        self.parent = self\n\ndef find_root(node):\n    if node != node.parent:\n        node.parent = find_root(node.parent)\n        return node.parent\n    return node.parent\n\ndef calculate_price(parent_1, parent_2):\n    if parent_2.networkPrice < parent_1.networkPrice:\n        if parent_2.networkPrice >= 0:\n            return parent_2.networkPrice\n        else:\n            return parent_1.networkPrice\n    elif parent_1.networkPrice >= 0:\n        return parent_1.networkPrice\n    else:\n        return parent_2.networkPrice\n\ndef union(node_1, node_2):\n    (parent_1, parent_2) = (find_root(node_1), find_root(node_2))\n    min_price = calculate_price(parent_1, parent_2)\n    if parent_1 == parent_2:\n        return\n    if parent_1.rank > parent_2.rank:\n        parent_2.parent = parent_1\n        parent_1.networkPrice = min_price\n    else:\n        parent_1.parent = parent_2\n        parent_2.networkPrice = min_price\n        if parent_1.rank == parent_2.rank:\n            parent_2.rank += 1\n(N, M) = map(int, stdin.readline().strip().split(' '))\nqueries = []\nfor i in range(M):\n    queries.append(tuple(map(int, stdin.readline().strip().split(' '))))\nprices = []\nfor i in range(N):\n    prices.append(int(stdin.readline()))\nvertex = [Node(i, j) for (i, j) in zip(range(1, N + 1), prices)]\nfor i in queries:\n    union(vertex[i[0] - 1], vertex[i[1] - 1])\nusage_dict = {}\nfor i in range(1, N + 1):\n    usage_dict[i] = False\nsum = 0\npossible = True\nmin_cost = 10 ** 5\ncountDict = {}\nfor i in vertex:\n    networkRoot = find_root(i)\n    if networkRoot.data not in countDict:\n        countDict[networkRoot.data] = True\n    if networkRoot.networkPrice < 0:\n        possible = False\n        break\n    if usage_dict[networkRoot.data] == False and networkRoot.networkPrice >= 0:\n        if min_cost > networkRoot.networkPrice:\n            min_cost = networkRoot.networkPrice\n        sum += networkRoot.networkPrice\n        usage_dict[networkRoot.data] = True\ncount = 0\nfor i in countDict:\n    count += 1\nif count == 1:\n    print('0')\nelif not possible:\n    print('-1')\nelse:\n    print(sum + (count - 2) * min_cost)", "def find_root(arr, n):\n    while arr[n] != n:\n        n = arr[n]\n    return n\n\ndef union(arr, a, b, size):\n    root_a = find_root(arr, a)\n    root_b = find_root(arr, b)\n    if root_a == root_b:\n        return\n    if size[root_a] < size[root_b]:\n        arr[root_a] = arr[root_b]\n        size[root_b] += arr[root_a]\n    else:\n        arr[root_b] = arr[root_a]\n        size[root_a] += size[root_b]\n\ndef same_root(arr, i, cost):\n    root = find_root(arr, i)\n    if cost[i] < cost[root] and cost[i] > -1 or (cost[root] < 0 and cost[i] > -1):\n        cost[root] = cost[i]\n    arr[i] = root\n(N, M) = [int(x) for x in input().split()]\nsize = [1] * (N + 1)\narr = [x for x in range(N + 1)]\ncost = [0]\nwhile M > 0:\n    (a, b) = [int(x) for x in input().split()]\n    union(arr, a, b, size)\n    M -= 1\ntemp = N\nwhile temp > 0:\n    cost.append(int(input()))\n    temp -= 1\nfor i in range(1, N + 1):\n    same_root(arr, i, cost)\nroots_dict = {}\nsum = 0\ncnt = 0\nmin = 1000000\nflag = True\nfor i in range(1, N + 1):\n    if arr[i] not in roots_dict:\n        if cost[arr[i]] < 0:\n            flag = False\n        sum += cost[arr[i]]\n        if cost[arr[i]] < min:\n            min = cost[arr[i]]\n        roots_dict[arr[i]] = True\n        cnt += 1\nif cnt == 1:\n    print('0')\nelif flag:\n    print(sum + (cnt - 2) * min)\nelse:\n    print('-1')", "import sys\nimport bisect\nsys.setrecursionlimit(1000000)\n\ndef find(a):\n    while dsu[a] != a:\n        dsu[a] = dsu[dsu[a]]\n        a = dsu[a]\n    return a\n\ndef union(a, b):\n    s1 = find(a)\n    s2 = find(b)\n    if rank[s1] > rank[s2]:\n        dsu[s2] = s1\n    elif rank[s2] > rank[s1]:\n        dsu[s1] = s2\n    else:\n        rank[s1] += 1\n        dsu[s2] = s1\n(n, m) = map(int, input().split())\ndsu = [i for i in range(n)]\nrank = [0] * n\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    union(a - 1, b - 1)\narr = []\nfor i in range(n):\n    a = int(input())\n    if a >= 0:\n        bisect.insort(arr, [a, i])\ncost = 0\nfor i in range(1, len(arr)):\n    if find(arr[0][1]) != find(arr[i][1]):\n        union(arr[0][1], arr[i][1])\n        cost += arr[0][0] + arr[i][0]\ns = set()\nfor i in range(n):\n    s.add(find(i))\nif len(s) == 1:\n    print(cost)\nelse:\n    print('-1')", "def find(child):\n    if child == parents[child]:\n        return parents[child]\n    parents[child] = find(parents[child])\n    return parents[child]\n\ndef union(root1, root2):\n    (real_root1, real_root2) = (find(root1), find(root2))\n    if real_root1 == real_root2:\n        return\n    if rank[real_root1] <= rank[real_root2]:\n        parents[real_root1] = real_root2\n        if rank[real_root1] == rank[real_root2]:\n            rank[real_root2] += 1\n    else:\n        parents[real_root2] = real_root1\n(n, m) = map(int, input().strip().split())\nparents = list(range(n))\nrank = [0 for i in range(n)]\nfor i in range(m):\n    (root1, root2) = map(int, input().strip().split())\n    union(root1 - 1, root2 - 1)\ncost_dict = {}\nfor i in range(n):\n    if i == parents[i]:\n        cost_dict[i] = 10 ** 5\ncost = [10 ** 5 for i in range(n)]\nmin_cost = 10 ** 5\nfor i in range(n):\n    c = int(input().strip())\n    if c >= 0:\n        cost[i] = c\n        grand_parent = find(i)\n        cost_dict[grand_parent] = min(c, cost_dict[grand_parent])\n        min_cost = min(c, min_cost)\npossible = True\ntotal_cost = 0\nfor root in cost_dict:\n    cst = cost_dict[root]\n    if cst == 10 ** 5 or cst > 10 ** 4:\n        possible = False\n        break\n    else:\n        total_cost += cst\nif len(cost_dict) == 1:\n    print(0)\nelif not possible:\n    print(-1)\nelse:\n    total_cost = total_cost + (len(cost_dict) - 2) * min_cost\n    print(total_cost)", "def find(child):\n    if child == parents[child]:\n        return parents[child]\n    parents[child] = find(parents[child])\n    return parents[child]\n\ndef union(r1, r2):\n    (mr1, mr2) = (find(r1), find(r2))\n    if mr1 == mr2:\n        return\n    if rank[mr1] <= rank[mr2]:\n        parents[mr1] = mr2\n        if rank[mr1] == rank[mr2]:\n            rank[mr2] += 1\n    else:\n        parents[mr2] = mr1\n(n, m) = map(int, input().split())\nparents = list(range(n))\nrank = [0 for i in range(n)]\nfor i in range(m):\n    (r1, r2) = map(int, input().strip().split())\n    union(r1 - 1, r2 - 1)\ncost_dict = {}\nfor i in range(n):\n    if i == parents[i]:\n        cost_dict[i] = 10 ** 5\ncost = [10 ** 5 for i in range(n)]\nmin_cost = 10 ** 5\nfor i in range(n):\n    c = int(input().strip())\n    if c >= 0:\n        cost[i] = c\n        grand_parent = find(i)\n        cost_dict[grand_parent] = min(c, cost_dict[grand_parent])\n        min_cost = min(c, min_cost)\npossible = True\ntotal_cost = 0\nfor r in cost_dict:\n    cst = cost_dict[r]\n    if cst == 10 ** 5 or cst > 10 ** 4:\n        possible = False\n        break\n    else:\n        total_cost += cst\nif len(cost_dict) == 1:\n    print(0)\nelif not possible:\n    print(-1)\nelse:\n    total_cost = total_cost + (len(cost_dict) - 2) * min_cost\n    print(total_cost)", "def get_root(i, root):\n    if root[i] == i:\n        return i\n    return get_root(root[i], root)\n(n, m) = map(int, input().split())\n(edges, cost) = ([], [0])\nroot = list((i for i in range(n + 1)))\nfor i in range(m):\n    edges.append(tuple(map(int, input().split())))\nfor i in range(n):\n    cost.append(int(input()))\nfor edge in edges:\n    (x, y, xroot, yroot) = (edge[0], edge[1], get_root(edge[0], root), get_root(edge[1], root))\n    if xroot != yroot:\n        if cost[xroot] >= 0 and cost[yroot] >= 0:\n            if cost[xroot] <= cost[yroot]:\n                root[y] = xroot\n                root[yroot] = xroot\n            else:\n                root[x] = yroot\n                root[xroot] = yroot\n        elif cost[xroot] <= 0 and cost[yroot] <= 0:\n            root[y] = xroot\n            root[yroot] = xroot\n        elif cost[xroot] < 0:\n            root[x] = yroot\n            root[xroot] = yroot\n        else:\n            root[y] = xroot\n            root[yroot] = xroot\nfor i in range(1, n + 1):\n    root[i] = get_root(i, root)\nd = {}\nfor i in range(1, n + 1):\n    d[root[i]] = cost[root[i]]\nd = list(d.values())\nminn = min(d)\nif minn < 0 and len(d) > 1:\n    print(-1)\nelse:\n    print(sum(d) + (len(d) - 2) * min(d))", "def find(child):\n    if child == parents[child]:\n        return parents[child]\n    parents[child] = find(parents[child])\n    return parents[child]\n\ndef union(root1, root2):\n    (real_root1, real_root2) = (find(root1), find(root2))\n    if real_root1 == real_root2:\n        return\n    if rank[real_root1] <= rank[real_root2]:\n        parents[real_root1] = real_root2\n        if rank[real_root1] == rank[real_root2]:\n            rank[real_root2] += 1\n    else:\n        parents[real_root2] = real_root1\n(n, m) = map(int, input().strip().split())\nparents = list(range(n))\nrank = [0 for i in range(n)]\nfor i in range(m):\n    (root1, root2) = map(int, input().strip().split())\n    union(root1 - 1, root2 - 1)\ncost_dict = {}\nfor i in range(n):\n    if i == parents[i]:\n        cost_dict[i] = 10 ** 5\ncost = [10 ** 5 for i in range(n)]\nmin_cost = 10 ** 5\nfor i in range(n):\n    c = int(input().strip())\n    if c >= 0:\n        cost[i] = c\n        grand_parent = find(i)\n        cost_dict[grand_parent] = min(c, cost_dict[grand_parent])\n        min_cost = min(c, min_cost)\npossible = True\ntotal_cost = 0\nfor root in cost_dict:\n    cst = cost_dict[root]\n    if cst == 10 ** 5 or cst > 10 ** 4:\n        possible = False\n        break\n    else:\n        total_cost += cst\nif len(cost_dict) == 1:\n    print(0)\nelif not possible:\n    print(-1)\nelse:\n    total_cost = total_cost + (len(cost_dict) - 2) * min_cost\n    print(total_cost)", "from collections import defaultdict\nvisited = defaultdict(lambda : False)\n(n, m) = [int(x) for x in input().split()]\ncost = defaultdict()\n\nclass Graph:\n\n    def __init__(self):\n        self.neighbours = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.neighbours[u].append(v)\n        self.neighbours[v].append(u)\n\n    def BFS(self, s, n, visited):\n        queue = [s]\n        visited[s] = True\n        mini = 10 ** 7\n        while queue:\n            u = queue.pop()\n            mini = min(cost[u], mini)\n            for v in self.neighbours[u]:\n                if v not in visited:\n                    visited[v] = True\n                    queue.append(v)\n                    mini = min(cost[v], mini)\n        return mini\ng = Graph()\nfor i in range(m):\n    (u, v) = [int(x) for x in input().split()]\n    g.addEdge(u, v)\nfor i in range(1, n + 1):\n    value = int(input())\n    if value >= 0:\n        cost[i] = value\n    else:\n        cost[i] = 10 ** 7\nminimums = []\nfor i in range(1, n + 1):\n    if i not in visited:\n        m = g.BFS(i, n, visited)\n        minimums.append(m)\nl = len(minimums)\npossible = True\nfor i in minimums:\n    if i >= 10 ** 6:\n        possible = False\n        break\nif l == 1:\n    print(0)\nelif not possible:\n    print(-1)\nelse:\n    global_min = min(minimums)\n    ans = global_min * (l - 1) + sum(minimums) - global_min\n    print(ans)", "from collections import defaultdict\nvisited = defaultdict(lambda : False)\n(n, m) = [int(x) for x in input().split()]\ncost = defaultdict()\n\nclass Graph:\n\n    def __init__(self):\n        self.neighbours = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.neighbours[u].append(v)\n        self.neighbours[v].append(u)\n\n    def BFS(self, s, n, visited):\n        queue = [s]\n        visited[s] = True\n        mini = 10 ** 7\n        while queue:\n            u = queue.pop(0)\n            mini = min(cost[u], mini)\n            for v in self.neighbours[u]:\n                if v not in visited:\n                    visited[v] = True\n                    queue.append(v)\n                    mini = min(cost[v], mini)\n        return mini\ng = Graph()\nfor i in range(m):\n    (u, v) = [int(x) for x in input().split()]\n    g.addEdge(u, v)\nfor i in range(1, n + 1):\n    value = int(input())\n    if value >= 0:\n        cost[i] = value\n    else:\n        cost[i] = 10 ** 7\nminimums = []\nfor i in range(1, n + 1):\n    if i not in visited:\n        m = g.BFS(i, n, visited)\n        minimums.append(m)\nl = len(minimums)\npossible = True\nfor i in minimums:\n    if i >= 10 ** 6:\n        possible = False\n        break\nif l == 1:\n    print(0)\nelif not possible:\n    print(-1)\nelse:\n    global_min = min(minimums)\n    ans = global_min * (l - 1) + sum(minimums) - global_min\n    print(ans)", "from collections import defaultdict\nMAXINT = 1000000\n(n, m) = list(map(int, input().split()))\n(mincost, cost) = ([], [-1])\ngraph = defaultdict(list)\nfor i in range(m):\n    (a, b) = list(map(int, input().split()))\n    graph[a].append(b)\n    graph[b].append(a)\nfor i in range(n):\n    c = int(input())\n    if c < 0:\n        c = MAXINT\n    cost.append(c)\nans = 0\nvisited = [False] * (n + 1)\n\ndef dfs(i):\n    mcost = MAXINT\n    buffer = [i]\n    while buffer:\n        v = buffer.pop()\n        mcost = min(mcost, cost[v])\n        for nb in graph[v]:\n            if not visited[nb]:\n                visited[nb] = True\n                buffer.append(nb)\n    return mcost\nfor i in range(1, n + 1):\n    if not visited[i]:\n        visited[i] = True\n        mincost.append(dfs(i))\n(cmax, cmin) = (max(mincost), min(mincost))\nif len(mincost) == 1:\n    print(0)\nelif cmax == MAXINT:\n    print(-1)\nelse:\n    print(sum(mincost) + (len(mincost) - 2) * cmin)", "from collections import defaultdict\nMAXINT = 1000000\n(n, m) = list(map(int, input().split()))\n(mincost, cost) = ([], [-1])\ngraph = defaultdict(list)\nfor i in range(m):\n    (a, b) = list(map(int, input().split()))\n    graph[a].append(b)\n    graph[b].append(a)\nfor i in range(n):\n    c = int(input())\n    if c < 0:\n        c = MAXINT\n    cost.append(c)\nans = 0\nvisited = [False] * (n + 1)\n\ndef dfs(i):\n    mcost = MAXINT\n    buffer = [i]\n    while buffer:\n        v = buffer.pop()\n        mcost = min(mcost, cost[v])\n        for nb in graph[v]:\n            if not visited[nb]:\n                visited[nb] = True\n                buffer.append(nb)\n    return mcost\nfor i in range(1, n + 1):\n    if not visited[i]:\n        visited[i] = True\n        mincost.append(dfs(i))\n(cmax, cmin) = (max(mincost), min(mincost))\nif len(mincost) == 1:\n    print(0)\nelif cmax == MAXINT:\n    print(-1)\nelse:\n    print(sum(mincost) + (len(mincost) - 2) * cmin)"]