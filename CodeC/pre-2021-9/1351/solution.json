["def F():\n    MAX = 10 ** 9 + 1\n    for _ in range(int(input())):\n        (N, M, K) = [int(x) for x in input().split()]\n        S = [int(x) for x in input()]\n        XYW = [[int(x) for x in input().split()] for i in range(M)]\n        cost = [[MAX for i in range(10)] for j in range(10)]\n        for i in range(10):\n            cost[i][i] = 0\n        for [x, y, w] in XYW:\n            cost[x][y] = w\n        for p in range(10):\n            for i in range(10):\n                for j in range(10):\n                    cost[i][j] = min(cost[i][j], cost[i][p] + cost[p][j])\n        coins_used = [0] * (1 + N // 2)\n        for p in range(N // 2, 0, -1):\n            coins = MAX\n            for i in range(10):\n                coins = min(coins, cost[S[p - 1]][i] + cost[S[N - p]][i])\n            coins_used[p - 1] = coins_used[p] + coins\n        if coins_used[0] > K:\n            print(-1)\n            continue\n        ans = ''\n        extra_coins = K - coins_used[0]\n        for p in range(N // 2):\n            for i in range(9, -1, -1):\n                this_cost = cost[S[p]][i] + cost[S[N - p - 1]][i]\n                old_cost = coins_used[p] - coins_used[p + 1]\n                if this_cost <= extra_coins + old_cost:\n                    ans += str(i)\n                    extra_coins -= this_cost - old_cost\n                    break\n        if N % 2:\n            for i in range(9, -1, -1):\n                if extra_coins >= cost[S[N // 2]][i]:\n                    ans += str(i)\n                    break\n        for i in range(N // 2 - 1, -1, -1):\n            ans += ans[i]\n        print(ans)\nF()", "def F():\n    MAX = 10 ** 9 + 1\n    for _ in range(int(input())):\n        (N, M, K) = [int(x) for x in input().split()]\n        S = [int(x) for x in input()]\n        XYW = [[int(x) for x in input().split()] for i in range(M)]\n        cost = [[MAX for i in range(10)] for j in range(10)]\n        for i in range(10):\n            cost[i][i] = 0\n        for [x, y, w] in XYW:\n            cost[x][y] = w\n        for p in range(10):\n            for i in range(10):\n                for j in range(10):\n                    cost[i][j] = min(cost[i][j], cost[i][p] + cost[p][j])\n        coins_used = [0] * (1 + N // 2)\n        for p in range(N // 2, 0, -1):\n            coins = MAX\n            for i in range(10):\n                coins = min(coins, cost[S[p - 1]][i] + cost[S[N - p]][i])\n            coins_used[p - 1] = coins_used[p] + coins\n        if coins_used[0] > K:\n            print(-1)\n            continue\n        ans = ''\n        extra_coins = K - coins_used[0]\n        for p in range(N // 2):\n            for i in range(9, -1, -1):\n                this_cost = cost[S[p]][i] + cost[S[N - p - 1]][i]\n                old_cost = coins_used[p] - coins_used[p + 1]\n                if this_cost <= extra_coins + old_cost:\n                    ans += str(i)\n                    extra_coins -= this_cost - old_cost\n                    break\n        if N % 2:\n            for i in range(9, -1, -1):\n                if extra_coins >= cost[S[N // 2]][i]:\n                    ans += str(i)\n                    break\n        for i in range(N // 2 - 1, -1, -1):\n            ans += ans[i]\n        print(ans)\nF()", "def F():\n    MAX = 10 ** 9 + 1\n    for _ in range(int(input())):\n        (N, M, K) = [int(x) for x in input().split()]\n        S = [int(x) for x in input()]\n        XYW = [[int(x) for x in input().split()] for i in range(M)]\n        cost = [[MAX for i in range(10)] for j in range(10)]\n        for i in range(10):\n            cost[i][i] = 0\n        for [x, y, w] in XYW:\n            cost[x][y] = w\n        for p in range(10):\n            for i in range(10):\n                for j in range(10):\n                    cost[i][j] = min(cost[i][j], cost[i][p] + cost[p][j])\n        coins_used = [0] * (1 + N // 2)\n        for p in range(N // 2, 0, -1):\n            coins = MAX\n            for i in range(10):\n                coins = min(coins, cost[S[p - 1]][i] + cost[S[N - p]][i])\n            coins_used[p - 1] = coins_used[p] + coins\n        if coins_used[0] > K:\n            print(-1)\n            continue\n        ans = ''\n        extra_coins = K - coins_used[0]\n        for p in range(N // 2):\n            for i in range(9, -1, -1):\n                this_cost = cost[S[p]][i] + cost[S[N - p - 1]][i]\n                old_cost = coins_used[p] - coins_used[p + 1]\n                if this_cost <= extra_coins + old_cost:\n                    ans += str(i)\n                    extra_coins -= this_cost - old_cost\n                    break\n        if N % 2:\n            for i in range(9, -1, -1):\n                if extra_coins >= cost[S[N // 2]][i]:\n                    ans += str(i)\n                    break\n        for i in range(N // 2 - 1, -1, -1):\n            ans += ans[i]\n        print(ans)\nF()", "import sys\nimport math\n\ndef read(lst=False):\n    line = sys.stdin.readline().rstrip()\n    if ' ' in line or lst:\n        return map(int, line.split())\n    return line\n\ndef floydWarshall(n):\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])\n\ndef computeCost(n):\n    totalCost = 0\n    for i in range(N // 2):\n        minCost = 1e+21\n        for j in range(10):\n            cost[i][j] = dp[int(S[i])][j] + dp[int(S[n - 1 - i])][j]\n            if cost[i][j] < minCost:\n                palin[i] = j\n                minCost = cost[i][j]\n        totalCost += minCost\n    if n & 1:\n        minCost = 1e+21\n        for i in range(10):\n            cost[-1][i] = dp[int(S[n // 2])][i]\n            if cost[-1][i] < minCost:\n                palin[-1] = i\n                minCost = cost[-1][i]\n        totalCost += minCost\n    return totalCost\n\ndef solver(totalCost):\n    for i in range((N + 1) // 2):\n        for j in range(9, -1, -1):\n            if totalCost - cost[i][palin[i]] + cost[i][j] <= K:\n                totalCost += -cost[i][palin[i]] + cost[i][j]\n                palin[i] = j\n                break\nT = int(read())\nfor t in range(T):\n    (N, M, K) = read()\n    S = read()\n    dp = [[math.inf if i != j else 0 for i in range(10)] for j in range(10)]\n    cost = [[None] * 10 for _ in range((N + 1) // 2)]\n    palin = [None] * ((N + 1) // 2)\n    for m in range(M):\n        (X, Y, W) = read()\n        if X != Y:\n            dp[X][Y] = W\n    floydWarshall(10)\n    minCost = computeCost(N)\n    if minCost > K:\n        print(-1)\n        continue\n    solver(minCost)\n    print(''.join(map(str, palin[:N // 2] + palin[N // 2::-1])))\nsys.exit()", "def move(op, root, node, price=0, looked=[]):\n    if node != root:\n        op[root][node] = min(op[root].get(node, float('inf')), price)\n    for conn in list(op[node]):\n        if not conn in looked:\n            if conn in op[root] and op[root][conn] < price:\n                continue\n            move(op, root, conn, price + op[node][conn], looked + [conn])\nfor _ in range(int(input())):\n    (n, M, K) = map(int, input().split())\n    S = list(input())\n    _S = S.copy()\n    op = {str(i): {} for i in range(10)}\n    for i in range(M):\n        (x, y, w) = input().split()\n        op[x][y] = int(w)\n    for i in range(10):\n        move(op, str(i), str(i))\n    for i in range(10):\n        op[str(i)][str(i)] = 0\n    minC = 0\n    changes = {}\n    for i in range(n // 2):\n        j = n - 1 - i\n        if S[i] != S[j]:\n            (a, b) = (S[i], S[j])\n            (bo, bc) = (None, float('inf'))\n            for g in range(10):\n                g = str(g)\n                if g in op[a] and g in op[b]:\n                    c = op[a][g] + op[b][g]\n                    if c < bc:\n                        bo = g\n                        bc = c\n            if bo == None:\n                print(-1)\n                break\n            else:\n                minC += bc\n                if bo == 'a':\n                    S[i] = S[j]\n                else:\n                    S[j] = S[i]\n                changes[i] = bc\n    else:\n        if minC > K:\n            print(-1)\n        else:\n            for i in range(n // 2):\n                j = n - 1 - i\n                (a, b) = (_S[i], _S[j])\n                discount = changes.get(i, 0)\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a] and g in op[b]:\n                        c = op[a][g] + op[b][g] - discount\n                        if c + minC <= K:\n                            S[i] = g\n                            S[j] = g\n                            minC += c\n                            break\n            if n & 1:\n                i = n // 2\n                a = S[i]\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a]:\n                        c = op[a][g]\n                        if c + minC <= K:\n                            S[i] = g\n                            minC += c\n                            break\n            print(''.join(S))", "def move(op, root, node, price=0, looked=[]):\n    if node != root:\n        op[root][node] = min(op[root].get(node, float('inf')), price)\n    for conn in list(op[node]):\n        if not conn in looked:\n            if conn in op[root] and op[root][conn] < price:\n                continue\n            move(op, root, conn, price + op[node][conn], looked + [conn])\nfor _ in range(int(input())):\n    (n, M, K) = map(int, input().split())\n    S = list(input())\n    _S = S.copy()\n    op = {str(i): {} for i in range(10)}\n    for i in range(M):\n        (x, y, w) = input().split()\n        op[x][y] = int(w)\n    for i in range(10):\n        move(op, str(i), str(i))\n    for i in range(10):\n        op[str(i)][str(i)] = 0\n    minC = 0\n    changes = {}\n    for i in range(n // 2):\n        j = n - 1 - i\n        if S[i] != S[j]:\n            (a, b) = (S[i], S[j])\n            (bo, bc) = (None, float('inf'))\n            for g in range(10):\n                g = str(g)\n                if g in op[a] and g in op[b]:\n                    c = op[a][g] + op[b][g]\n                    if c < bc:\n                        bo = g\n                        bc = c\n            if bo == None:\n                print(-1)\n                break\n            else:\n                minC += bc\n                if bo == 'a':\n                    S[i] = S[j]\n                else:\n                    S[j] = S[i]\n                changes[i] = bc\n    else:\n        if minC > K:\n            print(-1)\n        else:\n            for i in range(n // 2):\n                j = n - 1 - i\n                (a, b) = (_S[i], _S[j])\n                discount = changes.get(i, 0)\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a] and g in op[b]:\n                        c = op[a][g] + op[b][g] - discount\n                        if c + minC <= K:\n                            S[i] = g\n                            S[j] = g\n                            minC += c\n                            break\n            if n & 1:\n                i = n // 2\n                a = S[i]\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a]:\n                        c = op[a][g]\n                        if c + minC <= K:\n                            S[i] = g\n                            minC += c\n                            break\n            print(''.join(S))", "def move(op, root, node, price=0, looked=[]):\n    if node != root:\n        op[root][node] = min(op[root].get(node, float('inf')), price)\n    for conn in list(op[node]):\n        if not conn in looked:\n            if conn in op[root] and op[root][conn] < price:\n                continue\n            move(op, root, conn, price + op[node][conn], looked + [conn])\nfor _ in range(int(input())):\n    (n, M, K) = map(int, input().split())\n    S = list(input())\n    _S = S.copy()\n    op = {str(i): {} for i in range(10)}\n    for i in range(M):\n        (x, y, w) = input().split()\n        op[x][y] = int(w)\n    for i in range(10):\n        move(op, str(i), str(i))\n    for i in range(10):\n        op[str(i)][str(i)] = 0\n    minC = 0\n    changes = {}\n    for i in range(n // 2):\n        j = n - 1 - i\n        if S[i] != S[j]:\n            (a, b) = (S[i], S[j])\n            (bo, bc) = (None, float('inf'))\n            for g in range(10):\n                g = str(g)\n                if g in op[a] and g in op[b]:\n                    c = op[a][g] + op[b][g]\n                    if c < bc:\n                        bo = g\n                        bc = c\n            if bo == None:\n                print(-1)\n                break\n            else:\n                minC += bc\n                if bo == 'a':\n                    S[i] = S[j]\n                else:\n                    S[j] = S[i]\n                changes[i] = bc\n    else:\n        if minC > K:\n            print(-1)\n        else:\n            for i in range(n // 2):\n                j = n - 1 - i\n                (a, b) = (_S[i], _S[j])\n                discount = changes.get(i, 0)\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a] and g in op[b]:\n                        c = op[a][g] + op[b][g] - discount\n                        if c + minC <= K:\n                            S[i] = g\n                            S[j] = g\n                            minC += c\n                            break\n            if n & 1:\n                i = n // 2\n                a = S[i]\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a]:\n                        c = op[a][g]\n                        if c + minC <= K:\n                            S[i] = g\n                            minC += c\n                            break\n            print(''.join(S))", "def move(op, root, node, price=0, looked=[]):\n    if node != root:\n        op[root][node] = min(op[root].get(node, float('inf')), price)\n    for conn in list(op[node]):\n        if not conn in looked:\n            if conn in op[root] and op[root][conn] < price:\n                continue\n            move(op, root, conn, price + op[node][conn], looked + [conn])\nfor _ in range(int(input())):\n    (n, M, K) = map(int, input().split())\n    S = list(input())\n    _S = S.copy()\n    op = {str(i): {} for i in range(10)}\n    for i in range(M):\n        (x, y, w) = input().split()\n        op[x][y] = int(w)\n    for i in range(10):\n        move(op, str(i), str(i))\n    for i in range(10):\n        op[str(i)][str(i)] = 0\n    minC = 0\n    changes = {}\n    for i in range(n // 2):\n        j = n - 1 - i\n        if S[i] != S[j]:\n            (a, b) = (S[i], S[j])\n            (bo, bc) = (None, float('inf'))\n            for g in range(10):\n                g = str(g)\n                if g in op[a] and g in op[b]:\n                    c = op[a][g] + op[b][g]\n                    if c < bc:\n                        bo = g\n                        bc = c\n            if bo == None:\n                print(-1)\n                break\n            else:\n                minC += bc\n                if bo == 'a':\n                    S[i] = S[j]\n                else:\n                    S[j] = S[i]\n                changes[i] = bc\n    else:\n        if minC > K:\n            print(-1)\n        else:\n            for i in range(n // 2):\n                j = n - 1 - i\n                (a, b) = (_S[i], _S[j])\n                discount = changes.get(i, 0)\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a] and g in op[b]:\n                        c = op[a][g] + op[b][g] - discount\n                        if c + minC <= K:\n                            S[i] = g\n                            S[j] = g\n                            minC += c\n                            break\n            if n & 1:\n                i = n // 2\n                a = S[i]\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a]:\n                        c = op[a][g]\n                        if c + minC <= K:\n                            S[i] = g\n                            minC += c\n                            break\n            print(''.join(S))", "def move(op, root, node, price=0, looked=[]):\n    if node != root:\n        op[root][node] = min(op[root].get(node, float('inf')), price)\n    for conn in list(op[node]):\n        if not conn in looked:\n            if conn in op[root] and op[root][conn] < price:\n                continue\n            move(op, root, conn, price + op[node][conn], looked + [conn])\nfor _ in range(int(input())):\n    (n, M, K) = map(int, input().split())\n    S = list(input())\n    _S = S.copy()\n    op = {str(i): {} for i in range(10)}\n    for i in range(M):\n        (x, y, w) = input().split()\n        op[x][y] = int(w)\n    for i in range(10):\n        move(op, str(i), str(i))\n    for i in range(10):\n        op[str(i)][str(i)] = 0\n    minC = 0\n    changes = {}\n    for i in range(n // 2):\n        j = n - 1 - i\n        if S[i] != S[j]:\n            (a, b) = (S[i], S[j])\n            (bo, bc) = (None, float('inf'))\n            for g in range(10):\n                g = str(g)\n                if g in op[a] and g in op[b]:\n                    c = op[a][g] + op[b][g]\n                    if c < bc:\n                        bo = g\n                        bc = c\n            if bo == None:\n                print(-1)\n                break\n            else:\n                minC += bc\n                if bo == 'a':\n                    S[i] = S[j]\n                else:\n                    S[j] = S[i]\n                changes[i] = bc\n    else:\n        if minC > K:\n            print(-1)\n        else:\n            for i in range(n // 2):\n                j = n - 1 - i\n                (a, b) = (_S[i], _S[j])\n                discount = changes.get(i, 0)\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a] and g in op[b]:\n                        c = op[a][g] + op[b][g] - discount\n                        if c + minC <= K:\n                            S[i] = g\n                            S[j] = g\n                            minC += c\n                            break\n            if n & 1:\n                i = n // 2\n                a = S[i]\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a]:\n                        c = op[a][g]\n                        if c + minC <= K:\n                            S[i] = g\n                            minC += c\n                            break\n            print(''.join(S))", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    s = list(input().strip())\n    s = list(map(int, s))\n    d = [[float('inf') for i in range(10)] for i in range(10)]\n    for i in range(m):\n        (x, y, w) = map(int, input().split())\n        d[x][y] = w\n    for i in range(10):\n        d[i][i] = 0\n    for l in range(10):\n        for i in range(10):\n            for j in range(10):\n                d[i][j] = min(d[i][j], d[i][l] + d[l][j])\n    suff = [float('inf') for i in range(n // 2)]\n    for i in range(n // 2):\n        for j in range(10):\n            x = d[s[i]][j]\n            y = d[s[n - i - 1]][j]\n            suff[i] = min(suff[i], x + y)\n    suff.append(0)\n    for i in range(n // 2 - 1, -1, -1):\n        suff[i] += suff[i + 1]\n    if suff[0] > k:\n        print(-1)\n        continue\n    ans = [0 for i in range(n)]\n    for i in range(n // 2):\n        for j in range(9, -1, -1):\n            x = d[s[i]][j]\n            y = d[s[n - i - 1]][j]\n            if suff[i + 1] + x + y <= k:\n                ans[i] = j\n                ans[n - i - 1] = j\n                k -= x + y\n                break\n    if n & 1:\n        for j in range(9, -1, -1):\n            x = d[s[n // 2]][j]\n            if x <= k:\n                ans[n // 2] = j\n                k -= x\n                break\n    print(''.join([str(i) for i in ans]))", "def move(op, root, node, price=0, looked=[]):\n    if node != root:\n        op[root][node] = min(op[root].get(node, float('inf')), price)\n    for conn in list(op[node]):\n        if not conn in looked:\n            if conn in op[root] and op[root][conn] < price:\n                continue\n            move(op, root, conn, price + op[node][conn], looked + [conn])\nfor _ in range(int(input())):\n    (n, M, K) = map(int, input().split())\n    S = list(input())\n    _S = S.copy()\n    op = {str(i): {} for i in range(10)}\n    for i in range(M):\n        (x, y, w) = input().split()\n        op[x][y] = int(w)\n    for i in range(10):\n        move(op, str(i), str(i))\n    for i in range(10):\n        op[str(i)][str(i)] = 0\n    minC = 0\n    changes = {}\n    for i in range(n // 2):\n        j = n - 1 - i\n        if S[i] != S[j]:\n            (a, b) = (S[i], S[j])\n            (bo, bc) = (None, float('inf'))\n            for g in range(10):\n                g = str(g)\n                if g in op[a] and g in op[b]:\n                    c = op[a][g] + op[b][g]\n                    if c < bc:\n                        bo = g\n                        bc = c\n            if bo == None:\n                print(-1)\n                break\n            else:\n                minC += bc\n                if bo == 'a':\n                    S[i] = S[j]\n                else:\n                    S[j] = S[i]\n                changes[i] = bc\n    else:\n        if minC > K:\n            print(-1)\n        else:\n            for i in range(n // 2):\n                j = n - 1 - i\n                (a, b) = (_S[i], _S[j])\n                discount = changes.get(i, 0)\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a] and g in op[b]:\n                        c = op[a][g] + op[b][g] - discount\n                        if c + minC <= K:\n                            S[i] = g\n                            S[j] = g\n                            minC += c\n                            break\n            if n & 1:\n                i = n // 2\n                a = S[i]\n                for g in range(9, -1, -1):\n                    g = str(g)\n                    if g in op[a]:\n                        c = op[a][g]\n                        if c + minC <= K:\n                            S[i] = g\n                            minC += c\n                            break\n            print(''.join(S))"]