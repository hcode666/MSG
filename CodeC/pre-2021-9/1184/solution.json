["def fun():\n    t = int(input())\n    for a0 in range(t):\n        (n, q) = map(int, input().strip().split())\n        arr = []\n        ans = []\n        flag = 0\n        for i in range(n + 1):\n            arr.append([])\n            ans.append(-1)\n        for i in range(q):\n            (a, b) = map(int, input().strip().split())\n            arr[a].append(b)\n            if a >= b:\n                flag = 1\n        if flag == 1:\n            print(-1)\n            continue\n        s = len(arr[0])\n        po = [i for i in range(1, s + 1)]\n        pok = tuple(po)\n        pos = [list(pok) for i in range(n)]\n        ans[0] = 0\n        for i in range(n):\n            arr[i].sort()\n            j = 0\n            if ans[i] == -1:\n                flag = 1\n                break\n            while j < len(arr[i]):\n                if ans[arr[i][j]] == -1:\n                    if len(pos[i]) == 0:\n                        flag = 1\n                        break\n                    else:\n                        ans[arr[i][j]] = pos[i][0]\n                        arr_remove = arr[i][j]\n                        pos_remove = pos[i][0]\n                        remove_till = arr[i][j]\n                        pos[i].pop(0)\n                        m = i + 1\n                        while m < remove_till:\n                            if arr_remove not in arr[m] or pos_remove not in pos[m]:\n                                flag = 1\n                                break\n                            arr[m].remove(arr_remove)\n                            pos[m].remove(pos_remove)\n                            m = m + 1\n                j = j + 1\n            if len(pos[i]) != 0:\n                ks = 0\n                ke = len(pos[i])\n                while ks != ke:\n                    ls = i + 1\n                    mc = pos[i][ks]\n                    while ls != n:\n                        pos[ls].remove(mc)\n                        ls = ls + 1\n                    ks = ks + 1\n        if ans[n] == -1:\n            flag = 1\n        if flag == 1:\n            print(-1)\n        else:\n            for i in range(1, n + 1):\n                print(ans[i], end=' ')\n            print()\nfun()", "def fun():\n    t = int(input())\n    for a0 in range(t):\n        (n, q) = map(int, input().strip().split())\n        arr = []\n        ans = []\n        flag = 0\n        for i in range(n + 1):\n            arr.append([])\n            ans.append(-1)\n        for i in range(q):\n            (a, b) = map(int, input().strip().split())\n            arr[a].append(b)\n            if a >= b:\n                flag = 1\n        if flag == 1:\n            print(-1)\n            continue\n        s = len(arr[0])\n        po = [i for i in range(1, s + 1)]\n        pok = tuple(po)\n        pos = [list(pok) for i in range(n)]\n        ans[0] = 0\n        for i in range(n):\n            arr[i].sort()\n            j = 0\n            if ans[i] == -1:\n                flag = 1\n                break\n            while j < len(arr[i]):\n                if ans[arr[i][j]] == -1:\n                    if len(pos[i]) == 0:\n                        flag = 1\n                        break\n                    else:\n                        ans[arr[i][j]] = pos[i][0]\n                        arr_remove = arr[i][j]\n                        pos_remove = pos[i][0]\n                        remove_till = arr[i][j]\n                        pos[i].pop(0)\n                        m = i + 1\n                        while m < remove_till:\n                            if arr_remove not in arr[m] or pos_remove not in pos[m]:\n                                flag = 1\n                                break\n                            arr[m].remove(arr_remove)\n                            pos[m].remove(pos_remove)\n                            m = m + 1\n                j = j + 1\n            if len(pos[i]) != 0:\n                ks = 0\n                ke = len(pos[i])\n                while ks != ke:\n                    ls = i + 1\n                    mc = pos[i][ks]\n                    while ls != n:\n                        pos[ls].remove(mc)\n                        ls = ls + 1\n                    ks = ks + 1\n        if ans[n] == -1:\n            flag = 1\n        if flag == 1:\n            print(-1)\n        else:\n            for i in range(1, n + 1):\n                print(ans[i], end=' ')\n            print()\nfun()", "from collections import defaultdict\nT = int(input())\nfor t in range(T):\n    G = defaultdict(set)\n    (N, M) = map(int, input().split())\n    edges = []\n    for m in range(M):\n        (u, v) = map(int, input().split())\n        G[v].add(u)\n        edges.append((u, v))\n    edges.sort()\n    answer = [0] * (N + 1)\n    counter = 0\n    for (u, v) in edges:\n        if u == 0:\n            counter += 1\n            answer[v] = counter\n        elif answer[v] == 0:\n            answer[v] = answer[u]\n    last_instance = {}\n    valid = True\n    for i in range(1, N + 1):\n        val = answer[i]\n        last = last_instance.get(val, 0)\n        last_instance[val] = i\n        if len(G[i]) != i - last:\n            valid = False\n            break\n    print(' '.join(map(str, answer[1:])) if valid else -1)", "from collections import defaultdict\n\ndef stringra(P, n):\n    if 0 in P or any((i not in P for i in range(1, n + 1))):\n        return [-1]\n    for i in range(1, len(P) + 1):\n        P[i].sort()\n    Q = defaultdict(list)\n    Q[1].append(0)\n    X = [0] * (n + 1)\n    k = 0\n    for i in range(1, len(P) + 1):\n        if P[i][0] == 0:\n            k += 1\n            X[i] = k\n        else:\n            X[i] = X[P[i][0]]\n    for i in range(2, len(P) + 1):\n        for j in range(i - 1, -1, -1):\n            if X[i] != X[j]:\n                Q[i].append(j)\n            else:\n                Q[i].append(j)\n                break\n        Q[i].reverse()\n    if any((Q[i] != P[i] for i in range(1, n + 1))):\n        return [-1]\n    return X[1:n + 1]\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    adjList = defaultdict(list)\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        adjList[y].append(x)\n    print(*stringra(adjList, n))", "from collections import defaultdict\n\ndef stringra(P, n):\n    if 0 in P or any((i not in P for i in range(1, n + 1))):\n        return [-1]\n    for i in range(1, len(P) + 1):\n        P[i].sort()\n    Q = defaultdict(list)\n    Q[1].append(0)\n    X = [0] * (n + 1)\n    k = 0\n    for i in range(1, len(P) + 1):\n        if P[i][0] == 0:\n            k += 1\n            X[i] = k\n        else:\n            X[i] = X[P[i][0]]\n    for i in range(2, n + 1):\n        for j in range(i - 1, -1, -1):\n            if X[i] != X[j]:\n                Q[i].append(j)\n            else:\n                Q[i].append(j)\n                break\n    for i in range(1, n + 1):\n        Q[i].reverse()\n    if any((Q[i] != P[i] for i in range(1, n + 1))):\n        return [-1]\n    return X[1:n + 1]\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    adjList = defaultdict(list)\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        adjList[y].append(x)\n    print(*stringra(adjList, n))", "from collections import defaultdict\n\ndef stringra(P, n):\n    if 0 in P or any((i not in P for i in range(1, n + 1))):\n        return [-1]\n    for i in range(1, n + 1):\n        P[i].sort()\n    Q = defaultdict(list)\n    Q[1].append(0)\n    X = [0] * (n + 1)\n    k = 0\n    for i in range(1, n + 1):\n        if P[i][0] == 0:\n            k += 1\n            X[i] = k\n        else:\n            X[i] = X[P[i][0]]\n    for i in range(2, n + 1):\n        for j in range(i - 1, -1, -1):\n            if X[i] != X[j]:\n                Q[i].append(j)\n            else:\n                Q[i].append(j)\n                break\n    for i in range(1, n + 1):\n        Q[i].reverse()\n    if any((Q[i] != P[i] for i in range(1, n + 1))):\n        return [-1]\n    return X[1:n + 1]\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    adjList = defaultdict(list)\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        adjList[y].append(x)\n    print(*stringra(adjList, n))", "from collections import defaultdict\n\ndef stringra(P, n):\n    if 0 in P or any((i not in P for i in range(1, n + 1))):\n        return [-1]\n    for i in range(1, n + 1):\n        P[i].sort()\n    Q = defaultdict(list)\n    Q[1].append(0)\n    X = [0] * (n + 1)\n    k = 0\n    for i in range(1, n + 1):\n        if P[i][0] == 0:\n            k += 1\n            X[i] = k\n        else:\n            X[i] = X[P[i][0]]\n    for i in range(2, n + 1):\n        for j in range(i - 1, -1, -1):\n            if X[i] != X[j]:\n                Q[i].append(j)\n            else:\n                Q[i].append(j)\n                break\n    for i in range(1, n + 1):\n        Q[i].sort()\n    if any((Q[i] != P[i] for i in range(1, n + 1))):\n        return [-1]\n    return X[1:n + 1]\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    adjList = defaultdict(list)\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        adjList[y].append(x)\n    print(*stringra(adjList, n))", "def getElist(ee):\n    ret = []\n    ee = sorted(ee)\n    for (a, b) in ee:\n        while a >= len(ret):\n            ret += [[]]\n        ret[a] += [b]\n    return ret\n\ndef checkElist(ee):\n    se = [set(x) for x in ee]\n    for (i, e) in enumerate(ee):\n        if e[0] != i:\n            return False\n        if i + 1 < len(ee):\n            s = se[i + 1]\n            for q in e[1:]:\n                if q not in s:\n                    return False\n    return True\n\ndef solve(n, ee):\n    ee = getElist(ee)\n    ret = [-1] * n\n    if not checkElist(ee):\n        return -1\n    for (i, e) in enumerate(ee[0]):\n        ret[e] = i + 1\n    ss = set(ee[0])\n    for (i, e) in enumerate(ee):\n        if i == 0:\n            continue\n        nn = []\n        for k in e:\n            if k not in ss:\n                ss.add(k)\n                nn += [k]\n        if len(nn) > 1:\n            return -1\n        elif len(nn) == 1:\n            ret[nn[0]] = ret[i - 1]\n    if any((x == -1 for x in ret)):\n        return -1\n    return ' '.join(map(str, ret))\nimport sys\nf = sys.stdin\nt = int(f.readline())\nfor i in range(t):\n    (n, m) = map(int, f.readline().split())\n    e = []\n    for j in range(m):\n        (a, b) = map(int, f.readline().split())\n        e += [(a, b - 1)]\n    print(solve(n, e))", "def gen(N, E):\n    G = [N + 1 for _ in range(N + 1)]\n    S = [set() for _ in range(N + 1)]\n    for (x, y) in E:\n        if x >= y or x in S[y]:\n            return -1\n        G[y] = min(G[y], x)\n        S[y].add(x)\n    C = []\n    cpt = 1\n    for i in range(1, N + 1):\n        if len(S[i]) == 0 or i - G[i] != len(S[i]):\n            return -1\n        if G[i] == 0:\n            C.append(cpt)\n            cpt += 1\n        else:\n            C.append(C[G[i] - 1])\n    E = set(E)\n    D = {}\n    m = 0\n    for i in range(N - 1, -1, -1):\n        D[C[i]] = i + 1\n        for x in D:\n            if not (i, D[x]) in E:\n                return -1\n            m += 1\n            if m > len(E):\n                return -1\n    if m != len(E):\n        return -1\n    return ' '.join(map(str, C))\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        (N, M) = map(int, input().split())\n        E = [tuple(map(int, input().split())) for _ in range(M)]\n        print(gen(N, E))\nmain()", "def rebuild(PG, PGS):\n    for pv in PG:\n        for (l, r) in zip(pv, pv[1:]):\n            if l == r:\n                return None\n    kinds = 0\n    locations = {}\n    res = []\n    for (idx, pv) in enumerate(PG[1:], start=1):\n        if len(pv) == idx:\n            kinds += 1\n            res.append(kinds)\n            locations[kinds] = [idx]\n        else:\n            matched = None\n            for kind in range(1, kinds + 1):\n                got = True\n                if len(pv) != idx - locations[kind][-1]:\n                    got = False\n                    continue\n                for (tidx, t) in enumerate(pv):\n                    if tidx + locations[kind][-1] != t:\n                        got = False\n                        break\n                if got:\n                    matched = kind\n                    break\n            if matched is None:\n                return None\n            res.append(matched)\n            locations[matched].append(idx)\n    return res\nT = int(input())\nfor _ in range(T):\n    (N, M) = map(int, input().split())\n    PG = [[] for _ in range(N + 1)]\n    PGS = [set() for _ in range(N + 1)]\n    for _ in range(M):\n        (f, t) = map(int, input().split())\n        if f > t:\n            (f, t) = (t, f)\n        PG[t].append(f)\n        PGS[t].add(f)\n    for pv in PG:\n        pv.sort()\n    ans = rebuild(PG, PGS)\n    if ans is None:\n        print(-1)\n    else:\n        print(' '.join((str(item) for item in ans)))", "import sys\n\ndef find():\n    (N, M) = list(map(int, input().strip().split(' ')))\n    edge = set()\n    edges = [[] for i in range(N + 1)]\n    index = 1\n    check = 1\n    for i in range(M):\n        (a, b) = list(map(int, input().strip().split(' ')))\n        if a >= b:\n            check = 0\n        elif (a, b) in edge:\n            check = 0\n        else:\n            edge.add((a, b))\n            edges[b] += [a]\n    if check == 0:\n        print(-1)\n        return 0\n    ans = [1] * N\n    count1 = 0\n    for i in range(1, N + 1):\n        edges[i] = sorted(edges[i])\n        if edges[i] == []:\n            print(-1)\n            return 0\n        begin = edges[i][0]\n        if i - begin != len(edges[i]):\n            print(-1)\n            return 0\n        if begin == 0:\n            ans[i - 1] = index\n            index += 1\n        else:\n            ans[i - 1] = ans[begin - 1]\n    X = max(ans)\n    counting = {}\n    for i in range(1, X + 1):\n        counting[i] = []\n    for i in range(len(ans)):\n        if ans[i] not in counting:\n            print(-1)\n            return 0\n        counting[ans[i]] += [i + 1]\n    for x in counting:\n        array = counting[x]\n        for i in range(len(array)):\n            if i == 0:\n                k = array[i]\n                if edges[k][0] != 0:\n                    print(-1)\n                    return 0\n            else:\n                k1 = array[i]\n                k2 = array[i - 1]\n                if edges[k1][0] != k2:\n                    print(-1)\n                    return 0\n    print(*ans)\n    return 0\nfor _ in range(int(input())):\n    find()", "from collections import deque\nfor t in range(int(input())):\n    (n, m) = map(int, input().split())\n    g = [[] for i in range(n + 1)]\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n    val = [None] * (n + 1)\n    nums = set()\n    g[0].sort()\n    for i in range(len(g[0])):\n        val[g[0][i]] = i + 1\n        nums.add(i + 1)\n    invalid = False\n    for u in range(1, n + 1):\n        if val[u] is None:\n            invalid = True\n            break\n        ss = set()\n        nxt = None\n        for v in g[u]:\n            ss.add(val[v])\n            if val[v] is None:\n                nxt = v\n        if len(g[u]) != len(ss) or (len(ss) != len(nums) and len(ss) != len(nums) - 1):\n            invalid = True\n            break\n        if None in ss:\n            ss.remove(None)\n            ss.add(val[u])\n            if ss != nums:\n                invalid = True\n                break\n            val[nxt] = val[u]\n        else:\n            nums.remove(val[u])\n            if ss != nums:\n                invalid = True\n                break\n    if invalid:\n        print(-1)\n    else:\n        print(*val[1:])"]