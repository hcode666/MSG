["def depth_dfs(u0=0):\n    S = [u0]\n    D = [-1] * N\n    D[u0] = 0\n    while S:\n        u = S.pop()\n        for v in G[u]:\n            if D[v] < 0:\n                D[v] = D[u] + 1\n                S.append(v)\n    return D\n\ndef one_value(X, t):\n    res = 0\n    for i in range(len(X)):\n        if i & t - 1 == 0:\n            res ^= X[i]\n\ndef dp_all_values(X, kmax):\n    C = [X[:] for _ in range(kmax + 1)]\n    for k in range(1, kmax + 1):\n        for i in range(len(X)):\n            C[k][i] = C[k - 1][i ^ 1 << k - 1]\n            if i >> k - 1 & 1 == 0:\n                C[k][i] ^= C[k - 1][i]\n    return C\n\ndef main():\n    global N, G\n    (N, Q) = map(int, input().split())\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u].append(v)\n        G[v].append(u)\n    X0 = list(map(int, input().split()))\n    D = depth_dfs()\n    MD = max(D)\n    X = [0] * (MD + 1)\n    for u in range(N):\n        X[D[u]] ^= X0[u]\n    k = 1\n    while 1 << k <= MD:\n        k += 1\n    period = 1 << k\n    while len(X) < period:\n        X.append(0)\n    C = dp_all_values(X, k)\n    for i in range(Q):\n        t = (int(input()) - 1) % period\n        print(C[k][t])\nmain()", "def depth_dfs(u0=0):\n    S = [u0]\n    D = [-1] * N\n    D[u0] = 0\n    while S:\n        u = S.pop()\n        for v in G[u]:\n            if D[v] < 0:\n                D[v] = D[u] + 1\n                S.append(v)\n    return D\n\ndef one_value(X, t):\n    res = 0\n    for i in range(len(X)):\n        if i & t - 1 == 0:\n            res ^= X[i]\n\ndef dp_all_values(X, kmax):\n    C = [X[:] for _ in range(kmax + 1)]\n    for k in range(1, kmax + 1):\n        for i in range(len(X)):\n            C[k][i] = C[k - 1][i ^ 1 << k - 1]\n            if i >> k - 1 & 1 == 0:\n                C[k][i] ^= C[k - 1][i]\n    return C\n\ndef main():\n    global N, G\n    (N, Q) = map(int, input().split())\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u].append(v)\n        G[v].append(u)\n    X0 = list(map(int, input().split()))\n    D = depth_dfs()\n    MD = max(D)\n    X = [0] * (MD + 1)\n    for u in range(N):\n        X[D[u]] ^= X0[u]\n    k = 1\n    while 1 << k <= MD:\n        k += 1\n    period = 1 << k\n    while len(X) < period:\n        X.append(0)\n    C = dp_all_values(X, k)\n    for i in range(Q):\n        t = (int(input()) - 1) % period\n        print(C[k][t])\nmain()", "def depth_dfs(u0=0):\n    S = [u0]\n    D = [-1] * N\n    D[u0] = 0\n    while S:\n        u = S.pop()\n        for v in G[u]:\n            if D[v] < 0:\n                D[v] = D[u] + 1\n                S.append(v)\n    return D\n\ndef one_value(X, t):\n    res = 0\n    for i in range(len(X)):\n        if i & t - 1 == 0:\n            res ^= X[i]\n\ndef dp_all_values(X, kmax):\n    C = [X[:] for _ in range(kmax + 1)]\n    for k in range(1, kmax + 1):\n        for i in range(len(X)):\n            C[k][i] = C[k - 1][i ^ 1 << k - 1]\n            if i >> k - 1 & 1 == 0:\n                C[k][i] ^= C[k - 1][i]\n    return C\n\ndef main():\n    global N, G\n    (N, Q) = map(int, input().split())\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u].append(v)\n        G[v].append(u)\n    X0 = list(map(int, input().split()))\n    D = depth_dfs()\n    MD = max(D)\n    X = [0] * (MD + 1)\n    for u in range(N):\n        X[D[u]] ^= X0[u]\n    k = 1\n    while 1 << k <= MD:\n        k += 1\n    period = 1 << k\n    while len(X) < period:\n        X.append(0)\n    C = dp_all_values(X, k)\n    for i in range(Q):\n        t = (int(input()) - 1) % period\n        print(C[k][t])\nmain()", "def depth_dfs(u0=0):\n    S = [u0]\n    D = [-1] * N\n    D[u0] = 0\n    while S:\n        u = S.pop()\n        for v in G[u]:\n            if D[v] < 0:\n                D[v] = D[u] + 1\n                S.append(v)\n    return D\n\ndef one_value(X, t):\n    res = 0\n    for i in range(len(X)):\n        if i & t - 1 == 0:\n            res ^= X[i]\n\ndef dp_all_values(X, kmax):\n    C = [X[:] for _ in range(kmax + 1)]\n    for k in range(1, kmax + 1):\n        for i in range(len(X)):\n            C[k][i] = C[k - 1][i ^ 1 << k - 1]\n            if i >> k - 1 & 1 == 0:\n                C[k][i] ^= C[k - 1][i]\n    return C\n\ndef main():\n    global N, G\n    (N, Q) = map(int, input().split())\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        G[u].append(v)\n        G[v].append(u)\n    X0 = list(map(int, input().split()))\n    D = depth_dfs()\n    MD = max(D)\n    X = [0] * (MD + 1)\n    for u in range(N):\n        X[D[u]] ^= X0[u]\n    k = 1\n    while 1 << k <= MD:\n        k += 1\n    period = 1 << k\n    while len(X) < period:\n        X.append(0)\n    C = dp_all_values(X, k)\n    for i in range(Q):\n        t = (int(input()) - 1) % period\n        print(C[k][t])\nmain()", "from collections import defaultdict\nfrom math import *\n\ndef getReducedGraph(G, N, XTable):\n    visited = [0 for i in range(N)]\n    Levels = [0 for i in range(N)]\n    maxLevel = 0\n    queue = [0]\n    while queue:\n        u = queue[0]\n        visited[u] = 1\n        queue.pop(0)\n        if maxLevel < Levels[u]:\n            maxLevel = Levels[u]\n        for v in G[u]:\n            if not visited[v]:\n                Levels[v] = Levels[u] + 1\n                queue.append(v)\n    MaxPower = int(ceil(log(maxLevel + 1, 2)))\n    Upto = 2 ** MaxPower\n    newXTable = [0 for y in range(Upto)]\n    for i in range(N):\n        newXTable[Levels[i]] ^= XTable[i]\n    for i in range(MaxPower):\n        SkipAndDo = 2 ** i\n        flag = 0\n        for q in range(0, Upto, SkipAndDo):\n            if flag == 0:\n                flag = 1\n                continue\n            else:\n                flag = 0\n                for z in range(q, q + SkipAndDo):\n                    newXTable[z] ^= newXTable[z - SkipAndDo]\n    revList = newXTable[1:]\n    revList.reverse()\n    return (newXTable[0:1] + revList, Upto)\n(N, Q) = map(int, input().split())\nG = defaultdict(list)\nfor i in range(N - 1):\n    (u, v) = map(int, input().split())\n    assert u < v\n    G[u].append(v)\n    G[v].append(u)\nXTable = list(map(int, input().split()))\n(newXTable, Upto) = getReducedGraph(G, N, XTable)\nfor i in range(Q):\n    q = int(input())\n    print(newXTable[q % Upto])", "from collections import deque\n(N, Q) = map(int, input().split())\ng = [[] for i in range(N)]\nfor i in range(N - 1):\n    (u, v) = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\nX0 = list(map(int, input().split()))\nA = [0] * N\nP = 0\nq = deque()\nq.append((0, -1, 0))\nwhile q:\n    (u, p, d) = q.popleft()\n    P = d\n    A[d] ^= X0[u]\n    for v in g[u]:\n        if v != p:\n            q.append((v, u, d + 1))\nP += 1\nB = P.bit_length()\nP = 1 << P.bit_length()\nA += [0] * (P - len(A))\nfor b in range(B):\n    j = 1 << b\n    j2 = j << 1\n    for i in range(0, P, j2):\n        L = A[i:i + j]\n        R = A[i + j:i + j2]\n        A[i:i + j] = [Lk ^ Rk for (Lk, Rk) in zip(L, R)]\n        A[i + j:i + j2] = L\nfor q in range(Q):\n    d = int(input())\n    d = (d - 1) % P\n    print(A[d])", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom collections import deque\n(N, Q) = map(int, input().split())\ng = [[] for i in range(N)]\nfor i in range(N - 1):\n    (u, v) = map(int, input().split())\n    g[u].append(v)\n    g[v].append(u)\nX0 = list(map(int, input().split()))\nA = [0] * N\nP = 0\nq = deque()\nq.append((0, -1, 0))\nwhile q:\n    (u, p, d) = q.popleft()\n    P = max(P, d)\n    A[d] ^= X0[u]\n    for v in g[u]:\n        if v != p:\n            q.append((v, u, d + 1))\nP += 1\nA = A[:P]\nP_ = 1 << P.bit_length()\nif P_ != P << 1:\n    P = P_\nA += [0] * (P - len(A))\nB = P.bit_length() - 1\nfor b in range(B):\n    j = 1 << b\n    j2 = j << 1\n    for i in range(0, P, j2):\n        L = A[i:i + j]\n        R = A[i + j:i + j2]\n        for k in range(j):\n            A[i + k] = L[k] ^ R[k]\n            A[i + k + j] = L[k]\nfor q in range(Q):\n    d = int(input())\n    d = (d - 1) % P\n    print(A[d])", "import math\nimport sys\nfrom sys import stdin\nfrom collections import deque\nBIG = 2 ** 18\nANS = []\n(N, Q) = list(map(int, sys.stdin.readline().strip().split(' ')))\ngraph = [[] for i in range(N)]\nfor _ in range(N - 1):\n    (a, b) = list(map(int, sys.stdin.readline().strip().split(' ')))\n    graph[a] += [b]\n    graph[b] += [a]\nvalue = list(map(int, sys.stdin.readline().strip().split(' ')))\nquery = []\nfor _ in range(Q):\n    query += [int(input())]\nparent = [-1] * N\nlevel = [0] * N\nq = deque([0])\nwhile q:\n    u = q.popleft()\n    for v in graph[u]:\n        if v != parent[u]:\n            q.append(v)\n            level[v] = level[u] + 1\n            parent[v] = u\nmaxlevel = max(level)\nLL = [[] for i in range(maxlevel + 1)]\nfor i in range(N):\n    LL[level[i]] += [value[i]]\nnewvalue = [0] * (maxlevel + 1)\n\ndef find(C):\n    temp = 0\n    for i in range(len(C)):\n        temp ^= C[i]\n    return temp\nfor i in range(maxlevel + 1):\n    newvalue[i] = find(LL[i])\nnewvalue = newvalue + [0] * (BIG - len(newvalue))\n\ndef findout(array):\n    if len(array) == 2:\n        return [array[0], array[1] ^ array[0]]\n    if len(array) == 1:\n        return [array[0]]\n    left = array[:len(array) // 2]\n    right = array[len(array) // 2:]\n    ans1 = findout(left)\n    ans2 = findout(right)\n    ans = [0] * len(array)\n    for i in range(len(array) // 2):\n        if i == 0:\n            ans[i] = ans1[i]\n        else:\n            ans[i] = ans1[i] ^ ans2[i]\n    for i in range(len(array) // 2, len(array)):\n        if i == len(array) // 2:\n            ans[i] = ans1[0] ^ ans2[0]\n        else:\n            ans[i] = ans1[i - len(array) // 2]\n    return ans\nanswers = findout(newvalue)\nANS = []\nfor i in range(len(query)):\n    need = query[i] % BIG\n    ANS += [answers[need]]\nprint('\\n'.join(list(map(str, ANS))))"]