["def issafe(r, c, r1, c1, graph):\n    if graph[r][c] and graph[r1][c1]:\n        return True\n    return False\nt = int(input())\nfor mmmmmm in range(t):\n    (n, m) = map(int, input().split())\n    (x, y) = map(int, input().split())\n    graph = [[False] * (m + 2) for _ in range(n + 2)]\n    cost_graph = [[[-1, -1, -1] for __ in range(m)] for _ in range(n)]\n    for i in range(n):\n        str1 = input()\n        for (j, val) in enumerate(str1):\n            graph[i][j] = val == '1'\n    x = x - 1\n    y = y - 1\n    set1 = set()\n    set1.add((x, y, 0))\n    cost_graph[x][y][0] = 0\n    while set1:\n        set2 = set()\n        while set1:\n            (r, c, p) = set1.pop()\n            new_cost = cost_graph[r][c][p] + 1\n            if p == 0:\n                if issafe(r, c + 1, r, c + 2, graph):\n                    if cost_graph[r][c + 1][1] == -1 or cost_graph[r][c + 1][1] > new_cost:\n                        cost_graph[r][c + 1][1] = new_cost\n                        set2.add((r, c + 1, 1))\n                if issafe(r + 1, c, r + 2, c, graph):\n                    if cost_graph[r + 1][c][2] == -1 or cost_graph[r + 1][c][2] > new_cost:\n                        cost_graph[r + 1][c][2] = new_cost\n                        set2.add((r + 1, c, 2))\n                if issafe(r, c - 2, r, c - 1, graph):\n                    if cost_graph[r][c - 2][1] == -1 or cost_graph[r][c - 2][1] > new_cost:\n                        cost_graph[r][c - 2][1] = new_cost\n                        set2.add((r, c - 2, 1))\n                if issafe(r - 2, c, r - 1, c, graph):\n                    if cost_graph[r - 2][c][2] == -1 or cost_graph[r - 2][c][2] > new_cost:\n                        cost_graph[r - 2][c][2] = new_cost\n                        set2.add((r - 2, c, 2))\n            elif p == 1:\n                if issafe(r, c + 2, r, c + 2, graph):\n                    if cost_graph[r][c + 2][0] == -1 or cost_graph[r][c + 2][0] > new_cost:\n                        cost_graph[r][c + 2][0] = new_cost\n                        set2.add((r, c + 2, 0))\n                if issafe(r + 1, c, r + 1, c + 1, graph):\n                    if cost_graph[r + 1][c][1] == -1 or cost_graph[r + 1][c][1] > new_cost:\n                        cost_graph[r + 1][c][1] = new_cost\n                        set2.add((r + 1, c, 1))\n                if issafe(r, c - 1, r, c - 1, graph):\n                    if cost_graph[r][c - 1][0] == -1 or cost_graph[r][c - 1][0] > new_cost:\n                        cost_graph[r][c - 1][0] = new_cost\n                        set2.add((r, c - 1, 0))\n                if issafe(r - 1, c, r - 1, c + 1, graph):\n                    if cost_graph[r - 1][c][1] == -1 or cost_graph[r - 1][c][1] > new_cost:\n                        cost_graph[r - 1][c][1] = new_cost\n                        set2.add((r - 1, c, 1))\n            elif p == 2:\n                if issafe(r, c + 1, r + 1, c + 1, graph):\n                    if cost_graph[r][c + 1][2] == -1 or cost_graph[r][c + 1][2] > new_cost:\n                        cost_graph[r][c + 1][2] = new_cost\n                        set2.add((r, c + 1, 2))\n                if issafe(r + 2, c, r + 2, c, graph):\n                    if cost_graph[r + 2][c][0] == -1 or cost_graph[r + 2][c][0] > new_cost:\n                        cost_graph[r + 2][c][0] = new_cost\n                        set2.add((r + 2, c, 0))\n                if issafe(r, c - 1, r + 1, c - 1, graph):\n                    if cost_graph[r][c - 1][2] == -1 or cost_graph[r][c - 1][2] > new_cost:\n                        cost_graph[r][c - 1][2] = new_cost\n                        set2.add((r, c - 1, 2))\n                if issafe(r - 1, c, r - 1, c, graph):\n                    if cost_graph[r - 1][c][0] == -1 or cost_graph[r - 1][c][0] > new_cost:\n                        cost_graph[r - 1][c][0] = new_cost\n                        set2.add((r - 1, c, 0))\n        set1 = set2\n    for _ in range(n):\n        for __ in range(m):\n            print(cost_graph[_][__][0], end=' ')\n        print()", "def issafe(r, c, r1, c1, graph):\n    if graph[r][c] and graph[r1][c1]:\n        return True\n    return False\nt = int(input())\nfor mmmmmm in range(t):\n    (n, m) = map(int, input().split())\n    (x, y) = map(int, input().split())\n    graph = [[False] * (m + 2) for _ in range(n + 2)]\n    cost_graph = [[[-1, -1, -1] for __ in range(m)] for _ in range(n)]\n    for i in range(n):\n        str1 = input()\n        for (j, val) in enumerate(str1):\n            graph[i][j] = val == '1'\n    x = x - 1\n    y = y - 1\n    set1 = set()\n    set1.add((x, y, 0))\n    cost_graph[x][y][0] = 0\n    while set1:\n        set2 = set()\n        while set1:\n            (r, c, p) = set1.pop()\n            new_cost = cost_graph[r][c][p] + 1\n            if p == 0:\n                if issafe(r, c + 1, r, c + 2, graph):\n                    if cost_graph[r][c + 1][1] == -1 or cost_graph[r][c + 1][1] > new_cost:\n                        cost_graph[r][c + 1][1] = new_cost\n                        set2.add((r, c + 1, 1))\n                if issafe(r + 1, c, r + 2, c, graph):\n                    if cost_graph[r + 1][c][2] == -1 or cost_graph[r + 1][c][2] > new_cost:\n                        cost_graph[r + 1][c][2] = new_cost\n                        set2.add((r + 1, c, 2))\n                if issafe(r, c - 2, r, c - 1, graph):\n                    if cost_graph[r][c - 2][1] == -1 or cost_graph[r][c - 2][1] > new_cost:\n                        cost_graph[r][c - 2][1] = new_cost\n                        set2.add((r, c - 2, 1))\n                if issafe(r - 2, c, r - 1, c, graph):\n                    if cost_graph[r - 2][c][2] == -1 or cost_graph[r - 2][c][2] > new_cost:\n                        cost_graph[r - 2][c][2] = new_cost\n                        set2.add((r - 2, c, 2))\n            elif p == 1:\n                if issafe(r, c + 2, r, c + 2, graph):\n                    if cost_graph[r][c + 2][0] == -1 or cost_graph[r][c + 2][0] > new_cost:\n                        cost_graph[r][c + 2][0] = new_cost\n                        set2.add((r, c + 2, 0))\n                if issafe(r + 1, c, r + 1, c + 1, graph):\n                    if cost_graph[r + 1][c][1] == -1 or cost_graph[r + 1][c][1] > new_cost:\n                        cost_graph[r + 1][c][1] = new_cost\n                        set2.add((r + 1, c, 1))\n                if issafe(r, c - 1, r, c - 1, graph):\n                    if cost_graph[r][c - 1][0] == -1 or cost_graph[r][c - 1][0] > new_cost:\n                        cost_graph[r][c - 1][0] = new_cost\n                        set2.add((r, c - 1, 0))\n                if issafe(r - 1, c, r - 1, c + 1, graph):\n                    if cost_graph[r - 1][c][1] == -1 or cost_graph[r - 1][c][1] > new_cost:\n                        cost_graph[r - 1][c][1] = new_cost\n                        set2.add((r - 1, c, 1))\n            elif p == 2:\n                if issafe(r, c + 1, r + 1, c + 1, graph):\n                    if cost_graph[r][c + 1][2] == -1 or cost_graph[r][c + 1][2] > new_cost:\n                        cost_graph[r][c + 1][2] = new_cost\n                        set2.add((r, c + 1, 2))\n                if issafe(r + 2, c, r + 2, c, graph):\n                    if cost_graph[r + 2][c][0] == -1 or cost_graph[r + 2][c][0] > new_cost:\n                        cost_graph[r + 2][c][0] = new_cost\n                        set2.add((r + 2, c, 0))\n                if issafe(r, c - 1, r + 1, c - 1, graph):\n                    if cost_graph[r][c - 1][2] == -1 or cost_graph[r][c - 1][2] > new_cost:\n                        cost_graph[r][c - 1][2] = new_cost\n                        set2.add((r, c - 1, 2))\n                if issafe(r - 1, c, r - 1, c, graph):\n                    if cost_graph[r - 1][c][0] == -1 or cost_graph[r - 1][c][0] > new_cost:\n                        cost_graph[r - 1][c][0] = new_cost\n                        set2.add((r - 1, c, 0))\n        set1 = set2\n    for _ in range(n):\n        for __ in range(m):\n            print(cost_graph[_][__][0], end=' ')\n        print()", "from math import inf\nT = int(input())\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    (r, c) = map(int, input().split())\n    grid = [[False] * (m + 2) for __ in range(n + 2)]\n    for i in range(n):\n        s = input()\n        for (j, x) in enumerate(s):\n            grid[i][j] = x == '1'\n    solution = [[[inf, inf, inf] for ___ in range(m)] for __ in range(n)]\n    r -= 1\n    c -= 1\n    solution[r][c][0] = 0\n    touched_set = set()\n    touched_set.add((r, c, 0))\n    while len(touched_set):\n        new_touched_set = set()\n        while len(touched_set):\n            (r, c, o) = touched_set.pop()\n            new_sol = 1 + solution[r][c][o]\n            if o == 0:\n                if grid[r][c + 1] and grid[r][c + 2] and (solution[r][c + 1][1] > new_sol):\n                    solution[r][c + 1][1] = new_sol\n                    new_touched_set.add((r, c + 1, 1))\n                if grid[r + 1][c] and grid[r + 2][c] and (solution[r + 1][c][2] > new_sol):\n                    solution[r + 1][c][2] = new_sol\n                    new_touched_set.add((r + 1, c, 2))\n                if grid[r][c - 2] and grid[r][c - 1] and (solution[r][c - 2][1] > new_sol):\n                    solution[r][c - 2][1] = new_sol\n                    new_touched_set.add((r, c - 2, 1))\n                if grid[r - 2][c] and grid[r - 1][c] and (solution[r - 2][c][2] > new_sol):\n                    solution[r - 2][c][2] = new_sol\n                    new_touched_set.add((r - 2, c, 2))\n            elif o == 1:\n                if grid[r][c + 2] and solution[r][c + 2][0] > new_sol:\n                    solution[r][c + 2][0] = new_sol\n                    new_touched_set.add((r, c + 2, 0))\n                if grid[r + 1][c] and grid[r + 1][c + 1] and (solution[r + 1][c][1] > new_sol):\n                    solution[r + 1][c][1] = new_sol\n                    new_touched_set.add((r + 1, c, 1))\n                if grid[r][c - 1] and solution[r][c - 1][0] > new_sol:\n                    solution[r][c - 1][0] = new_sol\n                    new_touched_set.add((r, c - 1, 0))\n                if grid[r - 1][c] and grid[r - 1][c + 1] and (solution[r - 1][c][1] > new_sol):\n                    solution[r - 1][c][1] = new_sol\n                    new_touched_set.add((r - 1, c, 1))\n            else:\n                if grid[r][c + 1] and grid[r + 1][c + 1] and (solution[r][c + 1][2] > new_sol):\n                    solution[r][c + 1][2] = new_sol\n                    new_touched_set.add((r, c + 1, 2))\n                if grid[r + 2][c] and solution[r + 2][c][0] > new_sol:\n                    solution[r + 2][c][0] = new_sol\n                    new_touched_set.add((r + 2, c, 0))\n                if grid[r][c - 1] and grid[r + 1][c - 1] and (solution[r][c - 1][2] > new_sol):\n                    solution[r][c - 1][2] = new_sol\n                    new_touched_set.add((r, c - 1, 2))\n                if grid[r - 1][c] and solution[r - 1][c][0] > new_sol:\n                    solution[r - 1][c][0] = new_sol\n                    new_touched_set.add((r - 1, c, 0))\n        touched_set = new_touched_set\n    for i in range(n):\n        for j in range(m):\n            print(solution[i][j][0] if solution[i][j][0] != inf else -1, end=' ')\n        print()", "from math import inf\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    (r, c) = map(int, input().split())\n    a = [[0] * (m + 2) for _ in range(n + 2)]\n    for i in range(n):\n        s = input()\n        for (j, x) in enumerate(s):\n            a[i][j] = x\n    r -= 1\n    c -= 1\n    ans = [[[inf, inf, inf] for i in range(m)] for j in range(n)]\n    ans[r][c][0] = 0\n    touched = set()\n    touched.add((r, c, 0))\n    while len(touched):\n        visited = set()\n        while len(touched):\n            (r, c, o) = touched.pop()\n            count = 1 + ans[r][c][o]\n            if o == 0:\n                if a[r][c + 1] == '1' and a[r][c + 2] == '1' and (ans[r][c + 1][1] > count):\n                    ans[r][c + 1][1] = count\n                    visited.add((r, c + 1, 1))\n                if a[r][c - 2] == '1' and a[r][c - 1] == '1' and (ans[r][c - 2][1] > count):\n                    ans[r][c - 2][1] = count\n                    visited.add((r, c - 2, 1))\n                if a[r + 1][c] == '1' and a[r + 2][c] == '1' and (ans[r + 1][c][2] > count):\n                    ans[r + 1][c][2] = count\n                    visited.add((r + 1, c, 2))\n                if a[r - 1][c] == '1' and a[r - 2][c] == '1' and (ans[r - 2][c][2] > count):\n                    ans[r - 2][c][2] = count\n                    visited.add((r - 2, c, 2))\n            elif o == 1:\n                if a[r][c + 2] == '1' and ans[r][c + 2][0] > count:\n                    ans[r][c + 2][0] = count\n                    visited.add((r, c + 2, 0))\n                if a[r][c - 1] == '1' and ans[r][c - 1][0] > count:\n                    ans[r][c - 1][0] = count\n                    visited.add((r, c - 1, 0))\n                if a[r + 1][c] == '1' and a[r + 1][c + 1] == '1' and (ans[r + 1][c][1] > count):\n                    ans[r + 1][c][1] = count\n                    visited.add((r + 1, c, 1))\n                if a[r - 1][c] == '1' and a[r - 1][c + 1] == '1' and (ans[r - 1][c][1] > count):\n                    ans[r - 1][c][1] = count\n                    visited.add((r - 1, c, 1))\n            else:\n                if a[r][c + 1] == '1' and a[r + 1][c + 1] == '1' and (ans[r][c + 1][2] > count):\n                    ans[r][c + 1][2] = count\n                    visited.add((r, c + 1, 2))\n                if a[r][c - 1] == '1' and a[r + 1][c - 1] == '1' and (ans[r][c - 1][2] > count):\n                    ans[r][c - 1][2] = count\n                    visited.add((r, c - 1, 2))\n                if a[r + 2][c] == '1' and ans[r + 2][c][0] > count:\n                    ans[r + 2][c][0] = count\n                    visited.add((r + 2, c, 0))\n                if a[r - 1][c] == '1' and ans[r - 1][c][0] > count:\n                    ans[r - 1][c][0] = count\n                    visited.add((r - 1, c, 0))\n        touched = visited\n    for i in range(n):\n        for j in range(m):\n            print(ans[i][j][0] if ans[i][j][0] != inf else -1, end=' ')\n        print()", "from math import inf\nT = int(input())\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    (r, c) = map(int, input().split())\n    grid = [[False] * (m + 2) for __ in range(n + 2)]\n    for i in range(n):\n        s = input()\n        for (j, x) in enumerate(s):\n            grid[i][j] = x == '1'\n    solution = [[[inf, inf, inf] for ___ in range(m)] for __ in range(n)]\n    r -= 1\n    c -= 1\n    solution[r][c][0] = 0\n    touched_set = set()\n    touched_set.add((r, c, 0))\n    while len(touched_set):\n        new_touched_set = set()\n        while len(touched_set):\n            (r, c, o) = touched_set.pop()\n            new_sol = 1 + solution[r][c][o]\n            if o == 0:\n                if grid[r][c + 1] and grid[r][c + 2] and (solution[r][c + 1][1] > new_sol):\n                    solution[r][c + 1][1] = new_sol\n                    new_touched_set.add((r, c + 1, 1))\n                if grid[r + 1][c] and grid[r + 2][c] and (solution[r + 1][c][2] > new_sol):\n                    solution[r + 1][c][2] = new_sol\n                    new_touched_set.add((r + 1, c, 2))\n                if grid[r][c - 2] and grid[r][c - 1] and (solution[r][c - 2][1] > new_sol):\n                    solution[r][c - 2][1] = new_sol\n                    new_touched_set.add((r, c - 2, 1))\n                if grid[r - 2][c] and grid[r - 1][c] and (solution[r - 2][c][2] > new_sol):\n                    solution[r - 2][c][2] = new_sol\n                    new_touched_set.add((r - 2, c, 2))\n            elif o == 1:\n                if grid[r][c + 2] and solution[r][c + 2][0] > new_sol:\n                    solution[r][c + 2][0] = new_sol\n                    new_touched_set.add((r, c + 2, 0))\n                if grid[r + 1][c] and grid[r + 1][c + 1] and (solution[r + 1][c][1] > new_sol):\n                    solution[r + 1][c][1] = new_sol\n                    new_touched_set.add((r + 1, c, 1))\n                if grid[r][c - 1] and solution[r][c - 1][0] > new_sol:\n                    solution[r][c - 1][0] = new_sol\n                    new_touched_set.add((r, c - 1, 0))\n                if grid[r - 1][c] and grid[r - 1][c + 1] and (solution[r - 1][c][1] > new_sol):\n                    solution[r - 1][c][1] = new_sol\n                    new_touched_set.add((r - 1, c, 1))\n            else:\n                if grid[r][c + 1] and grid[r + 1][c + 1] and (solution[r][c + 1][2] > new_sol):\n                    solution[r][c + 1][2] = new_sol\n                    new_touched_set.add((r, c + 1, 2))\n                if grid[r + 2][c] and solution[r + 2][c][0] > new_sol:\n                    solution[r + 2][c][0] = new_sol\n                    new_touched_set.add((r + 2, c, 0))\n                if grid[r][c - 1] and grid[r + 1][c - 1] and (solution[r][c - 1][2] > new_sol):\n                    solution[r][c - 1][2] = new_sol\n                    new_touched_set.add((r, c - 1, 2))\n                if grid[r - 1][c] and solution[r - 1][c][0] > new_sol:\n                    solution[r - 1][c][0] = new_sol\n                    new_touched_set.add((r - 1, c, 0))\n        touched_set = new_touched_set\n    for i in range(n):\n        for j in range(m):\n            print(solution[i][j][0] if solution[i][j][0] != inf else -1, end=' ')\n        print()"]