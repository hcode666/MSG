["import sys\nsys.setrecursionlimit(10 ** 9)\ntry:\n    t = int(input())\n\n    def dfs(graph, node, ans, v, anc):\n        v[node] = 1\n        ans[0] += 1\n        for child in graph[node]:\n            if child == anc:\n                continue\n            dfs(graph, child, ans, v, node)\n            ans[0] += int(v[node] * v[child] % (10 ** 9 + 7))\n            v[node] += int(2 * v[child] % (10 ** 9 + 7))\n            v[node] %= 10 ** 9 + 7\n            ans[0] %= 10 ** 9 + 7\n            v[node] = int(v[node])\n            ans[0] = int(ans[0])\n    while t > 0:\n        n = int(input())\n        if n == 1:\n            print(1)\n            t -= 1\n            continue\n        graph = dict()\n        for ind in range(n - 1):\n            (u, v) = tuple(map(int, input().split()))\n            if u not in graph:\n                graph[u] = [v]\n            else:\n                graph[u].append(v)\n            if v not in graph:\n                graph[v] = [u]\n            else:\n                graph[v].append(u)\n        ans = [0]\n        v1 = dict()\n        dfs(graph, 1, ans, v1, 1)\n        print(int(ans[0]))\n        t -= 1\nexcept EOFError as e:\n    print(e)", "import sys\nsys.setrecursionlimit(10 ** 9)\ntry:\n    t = int(input())\n\n    def dfs(graph, node, ans, v, anc):\n        v[node] = 1\n        ans[0] += 1\n        for child in graph[node]:\n            if child == anc:\n                continue\n            dfs(graph, child, ans, v, node)\n            ans[0] += int(v[node] * v[child] % (10 ** 9 + 7))\n            v[node] += int(2 * v[child] % (10 ** 9 + 7))\n            v[node] %= 10 ** 9 + 7\n            ans[0] %= 10 ** 9 + 7\n            v[node] = int(v[node])\n            ans[0] = int(ans[0])\n    while t > 0:\n        n = int(input())\n        if n == 1:\n            print(1)\n            t -= 1\n            continue\n        graph = dict()\n        for ind in range(n - 1):\n            (u, v) = tuple(map(int, input().split()))\n            if u not in graph:\n                graph[u] = [v]\n            else:\n                graph[u].append(v)\n            if v not in graph:\n                graph[v] = [u]\n            else:\n                graph[v].append(u)\n        ans = [0]\n        v1 = dict()\n        dfs(graph, 1, ans, v1, 1)\n        print(int(ans[0]))\n        t -= 1\nexcept EOFError as e:\n    print(e)", "import sys\nsys.setrecursionlimit(10 ** 9)\ntry:\n    t = int(input())\n\n    def dfs(graph, node, ans, v, anc):\n        v[node] = 1\n        ans[0] += 1\n        for child in graph[node]:\n            if child == anc:\n                continue\n            dfs(graph, child, ans, v, node)\n            ans[0] += int(v[node] * v[child] % (10 ** 9 + 7))\n            v[node] += int(2 * v[child] % (10 ** 9 + 7))\n            v[node] %= 10 ** 9 + 7\n            ans[0] %= 10 ** 9 + 7\n            v[node] = int(v[node])\n            ans[0] = int(ans[0])\n    while t > 0:\n        n = int(input())\n        if n == 1:\n            print(1)\n            t -= 1\n            continue\n        graph = dict()\n        for ind in range(n - 1):\n            (u, v) = tuple(map(int, input().split()))\n            if u not in graph:\n                graph[u] = [v]\n            else:\n                graph[u].append(v)\n            if v not in graph:\n                graph[v] = [u]\n            else:\n                graph[v].append(u)\n        ans = [0]\n        v1 = dict()\n        dfs(graph, 1, ans, v1, 1)\n        print(int(ans[0]))\n        t -= 1\nexcept EOFError as e:\n    print(e)", "import sys\nsys.setrecursionlimit(10 ** 9)\ntry:\n    t = int(input())\n\n    def dfs(graph, node, ans, v, anc):\n        v[node] = 1\n        ans[0] += 1\n        for child in graph[node]:\n            if child == anc:\n                continue\n            dfs(graph, child, ans, v, node)\n            ans[0] += int(v[node] * v[child] % (10 ** 9 + 7))\n            v[node] += int(2 * v[child] % (10 ** 9 + 7))\n            v[node] %= 10 ** 9 + 7\n            ans[0] %= 10 ** 9 + 7\n            v[node] = int(v[node])\n            ans[0] = int(ans[0])\n    while t > 0:\n        n = int(input())\n        if n == 1:\n            print(1)\n            t -= 1\n            continue\n        graph = dict()\n        for ind in range(n - 1):\n            (u, v) = tuple(map(int, input().split()))\n            if u not in graph:\n                graph[u] = [v]\n            else:\n                graph[u].append(v)\n            if v not in graph:\n                graph[v] = [u]\n            else:\n                graph[v].append(u)\n        ans = [0]\n        v1 = dict()\n        dfs(graph, 1, ans, v1, 1)\n        print(int(ans[0]))\n        t -= 1\nexcept EOFError as e:\n    print(e)", "import sys\nsys.setrecursionlimit(10 ** 9)\ntry:\n    t = int(input())\n\n    def dfs(graph, node, ans, v, anc):\n        v[node] = 1\n        ans[0] += 1\n        for child in graph[node]:\n            if child == anc:\n                continue\n            dfs(graph, child, ans, v, node)\n            ans[0] += int(v[node] * v[child] % (10 ** 9 + 7))\n            v[node] += int(2 * v[child] % (10 ** 9 + 7))\n            v[node] %= 10 ** 9 + 7\n            ans[0] %= 10 ** 9 + 7\n            v[node] = int(v[node])\n            ans[0] = int(ans[0])\n    while t > 0:\n        n = int(input())\n        if n == 1:\n            print(1)\n            t -= 1\n            continue\n        graph = dict()\n        for ind in range(n - 1):\n            (u, v) = tuple(map(int, input().split()))\n            if u not in graph:\n                graph[u] = [v]\n            else:\n                graph[u].append(v)\n            if v not in graph:\n                graph[v] = [u]\n            else:\n                graph[v].append(u)\n        ans = [0]\n        v1 = dict()\n        dfs(graph, 1, ans, v1, 1)\n        print(int(ans[0]))\n        t -= 1\nexcept EOFError as e:\n    print(e)", "import sys\nsys.setrecursionlimit(10 ** 9)\nt = int(input())\n\ndef dfs(graph, node, ans, v, anc):\n    v[node] = 1\n    ans[0] += 1\n    for child in graph[node]:\n        if child == anc:\n            continue\n        dfs(graph, child, ans, v, node)\n        ans[0] += int(v[node] * v[child] % (10 ** 9 + 7))\n        v[node] += int(2 * v[child] % (10 ** 9 + 7))\n        v[node] %= 10 ** 9 + 7\n        ans[0] %= 10 ** 9 + 7\n        v[node] = int(v[node])\n        ans[0] = int(ans[0])\nwhile t > 0:\n    n = int(input())\n    if n == 1:\n        print(1)\n        t -= 1\n        continue\n    graph = dict()\n    for ind in range(n - 1):\n        (u, v) = tuple(map(int, input().split()))\n        if u not in graph:\n            graph[u] = [v]\n        else:\n            graph[u].append(v)\n        if v not in graph:\n            graph[v] = [u]\n        else:\n            graph[v].append(u)\n    ans = [0]\n    v1 = dict()\n    dfs(graph, 1, ans, v1, 1)\n    print(int(ans[0]))\n    t -= 1", "import sys\nsys.setrecursionlimit(10 ** 9)\nt = int(input())\n\ndef dfs(graph, node, ans, v, anc):\n    v[node] = 1\n    ans[0] += 1\n    for child in graph[node]:\n        if child == anc:\n            continue\n        dfs(graph, child, ans, v, node)\n        ans[0] += int(v[node] * v[child] % (10 ** 9 + 7))\n        v[node] += int(2 * v[child] % (10 ** 9 + 7))\n        v[node] %= 10 ** 9 + 7\n        ans[0] %= 10 ** 9 + 7\n        v[node] = int(v[node])\n        ans[0] = int(ans[0])\nwhile t > 0:\n    n = int(input())\n    if n == 1:\n        print(1)\n        t -= 1\n        continue\n    graph = dict()\n    for ind in range(n - 1):\n        (u, v) = tuple(map(int, input().split()))\n        if u not in graph:\n            graph[u] = [v]\n        else:\n            graph[u].append(v)\n        if v not in graph:\n            graph[v] = [u]\n        else:\n            graph[v].append(u)\n    ans = [0]\n    v1 = dict()\n    dfs(graph, 1, ans, v1, 1)\n    print(int(ans[0]))\n    t -= 1", "import sys\nsys.setrecursionlimit(10 ** 9)\nt = int(input())\n\ndef dfs(graph, node, ans, v, anc):\n    v[node] = 1\n    ans[0] += 1\n    for child in graph[node]:\n        if child == anc:\n            continue\n        dfs(graph, child, ans, v, node)\n        ans[0] += int(v[node] * v[child] % (10 ** 9 + 7))\n        v[node] += int(2 * v[child] % (10 ** 9 + 7))\n        v[node] %= 10 ** 9 + 7\n        ans[0] %= 10 ** 9 + 7\n        v[node] = int(v[node])\n        ans[0] = int(ans[0])\nwhile t > 0:\n    n = int(input())\n    if n == 1:\n        print(1)\n        t -= 1\n        continue\n    graph = dict()\n    for ind in range(n - 1):\n        (u, v) = tuple(map(int, input().split()))\n        if u not in graph:\n            graph[u] = [v]\n        else:\n            graph[u].append(v)\n        if v not in graph:\n            graph[v] = [u]\n        else:\n            graph[v].append(u)\n    ans = [0]\n    v1 = dict()\n    dfs(graph, 1, ans, v1, 1)\n    print(int(ans[0]))\n    t -= 1", "import sys\nsys.setrecursionlimit(10 ** 6)\nmod = 1000000007\n\ndef dfs(node, tree, visited, final):\n    visited[node] = True\n    child = tree[node]\n    temp = []\n    ret = 0\n    for i in child:\n        if visited[i] == False:\n            ans = dfs(i, tree, visited, final)\n            temp.append(ans)\n            ret += 2 * ans\n    ret += 1\n    s = 0\n    for i in temp:\n        s += i\n    for i in temp:\n        s -= i\n        final[0] = (final[0] + 2 * s * i % mod) % mod\n    return ret\n\ndef solve(king, tree):\n    visited = [False for x in range(len(tree))]\n    visited[king] = True\n    child = tree[king]\n    temp = []\n    ret = 0\n    mat = [0]\n    for i in child:\n        ans = dfs(i, tree, visited, mat)\n        temp.append(ans)\n        ret += 2 * ans\n    ret += 1\n    final = mat[0]\n    s = 0\n    for i in temp:\n        s += i\n    for i in temp:\n        s -= i\n        final = (final + 2 * s * i % mod) % mod\n    final = (final + ret % mod) % mod\n    print(final)\nt = int(input())\nfor test in range(t):\n    n = int(input())\n    tree = [[] for x in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    solve(1, tree)", "import sys\nsys.setrecursionlimit(10 ** 6)\ntest = int(input())\nmex = 100001\nmod = 10 ** 9 + 7\nv = [[] for _ in range(mex)]\ndp = [[] for _ in range(mex)]\n\ndef dfs(n, p):\n    dp[n] = [1, 0]\n    sum1 = 0\n    childs = []\n    for child in v[n]:\n        if child != p:\n            dfs(child, n)\n            dp[n][0] += dp[child][0] * 2\n            dp[n][0] %= mod\n            sum1 += dp[child][0]\n            sum1 %= mod\n            childs.append(dp[child][0])\n    for val in childs:\n        dp[n][1] += (sum1 - val) * val % mod\n        dp[n][1] %= mod\nfor i in range(test):\n    n = int(input())\n    for i in range(1, n + 1):\n        v[i].clear()\n        dp[i].clear()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        v[a].append(b)\n        v[b].append(a)\n    dfs(1, 0)\n    ans = 0\n    for i in range(1, n + 1):\n        ans += dp[i][1]\n        ans %= mod\n    ans += dp[1][0]\n    ans %= mod\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\ntest = int(input())\nmex = 100001\nmod = 10 ** 9 + 7\nv = [[] for _ in range(mex)]\ndp = [[] for _ in range(mex)]\n\ndef dfs(n, p):\n    dp[n] = [1, 0]\n    sum1 = 0\n    childs = []\n    for child in v[n]:\n        if child != p:\n            dfs(child, n)\n            dp[n][0] += dp[child][0] * 2\n            dp[n][0] %= mod\n            sum1 += dp[child][0]\n            sum1 %= mod\n            childs.append(dp[child][0])\n    for val in childs:\n        dp[n][1] += (sum1 - val) * val % mod\n        dp[n][1] %= mod\nfor i in range(test):\n    n = int(input())\n    for i in range(1, n + 1):\n        v[i].clear()\n        dp[i].clear()\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        v[a].append(b)\n        v[b].append(a)\n    dfs(1, 0)\n    ans = 0\n    for i in range(1, n + 1):\n        ans += dp[i][1]\n        ans %= mod\n    ans += dp[1][0]\n    ans %= mod\n    print(ans)", "from math import *\nfrom collections import *\nimport sys\nsys.setrecursionlimit(10 ** 6)\nMOD = 1000000007\n\ndef dfs(now, x):\n    (l1[now], l2[now]) = (1, 1)\n    cnt = 0\n    for i in range(len(ajl[now])):\n        y = ajl[now][i]\n        if x != y:\n            dfs(y, now)\n            l1[now] += 2 * l1[y]\n            l2[now] += l2[y] + l1[y]\n            cnt += l1[y]\n    for i in range(len(ajl[now])):\n        y = ajl[now][i]\n        if x != y:\n            l2[now] += l1[y] * (cnt - l1[y])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ajl = [[] for i in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        ajl[u].append(v)\n        ajl[v].append(u)\n    l1 = [0] * (n + 1)\n    l2 = [0] * (n + 1)\n    dfs(1, 1)\n    print(l2[1] % MOD)", "ans = 0\nv = []\ndp = []\ntot = []\nmod = 10 ** 9 + 7\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(cur, par):\n    dp[cur] = 1\n    tot[cur] = 1\n    sum = 0\n    cnt = 0\n    for i in range(len(v[cur])):\n        node = v[cur][i]\n        if node != par:\n            dfs(node, cur)\n            dp[cur] += 2 * dp[node] % mod\n            dp[cur] %= mod\n            cnt += 1\n            tot[cur] += tot[node]\n            tot[cur] %= mod\n            tot[cur] += dp[node]\n            tot[cur] %= mod\n            sum += dp[node]\n    for i in range(len(v[cur])):\n        node = v[cur][i]\n        if node != par:\n            tot[cur] += dp[node] * (sum - dp[node] + mod) % mod\n            tot[cur] %= mod\nfor _ in range(int(input())):\n    ans = 0\n    n = int(input())\n    v = [[] for i in range(n + 1)]\n    dp = [0 for i in range(n + 1)]\n    tot = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (l, r) = [int(i) for i in input().split()]\n        v[l].append(r)\n        v[r].append(l)\n    dfs(1, 1)\n    ans = tot[1] % mod\n    print(ans)\n    dp = []\n    v = []\n    tot = []", "import sys\nsys.setrecursionlimit(1000000000)\ninput = sys.stdin.readline\nmod = 1000000007\n\ndef dfs(ind, rap):\n    (arr[ind], arr1[ind], s, flag) = (1, 1, 0, 0)\n    a = len(v[ind])\n    for i in range(a):\n        nd = v[ind][i]\n        if nd != rap:\n            dfs(nd, ind)\n            arr[ind] = (arr[ind] + 2 * arr[nd] % mod) % mod\n            flag += 1\n            arr1[ind] = ((arr1[ind] + arr1[nd]) % mod + arr[nd]) % mod\n            s += arr[nd]\n    for i in range(a):\n        nd = v[ind][i]\n        if nd != rap:\n            arr1[ind] += arr[nd] * (s - arr[nd] + mod) % mod % mod\n            arr1[ind] %= mod\nt = int(input())\nwhile t:\n    t -= 1\n    ans = 0\n    n = int(input())\n    v = [[] for x in range(n + 1)]\n    arr = [0] * (n + 1)\n    arr1 = [0] * (n + 1)\n    for i in range(1, n):\n        (l, r) = [int(x) for x in input().split()]\n        v[l].append(r)\n        v[r].append(l)\n    dfs(1, 1)\n    print(arr1[1] % mod)", "import sys\nsys.setrecursionlimit(1000000000)\nmod = 1000000007\n\ndef depth_first(c, p):\n    (s, dp_second[c], dp_first[c], cnt) = (0, 1, 1, 0)\n    l = len(val[c])\n    for i in range(l):\n        node = val[c][i]\n        if node != p:\n            depth_first(node, c)\n            dp_first[c] = (dp_first[c] + 2 * dp_first[node] % mod) % mod\n            cnt += 1\n            dp_second[c] += dp_second[node]\n            dp_second[c] %= mod\n            dp_second[c] += dp_first[node]\n            dp_second[c] %= mod\n            s += dp_first[node]\n    for i in range(len(val[c])):\n        node = val[c][i]\n        if node != p:\n            dp_second[c] += dp_first[node] * (s - dp_first[node] + mod) % mod % mod\n            dp_second[c] %= mod\nfor _ in range(int(input())):\n    ans = 0\n    n = int(input())\n    val = []\n    dp_first = [0] * (n + 1)\n    dp_second = [0] * (n + 1)\n    for i in range(n + 1):\n        val.append([])\n    for i in range(1, n):\n        (l, r) = [int(x) for x in input().split()]\n        val[l].append(r)\n        val[r].append(l)\n    depth_first(1, 1)\n    print(dp_second[1] % mod)", "from math import *\nfrom collections import *\nimport sys\nsys.setrecursionlimit(10 ** 6)\nMOD = 1000000007\n\ndef dfs(now, x):\n    (l1[now], l2[now]) = (1, 1)\n    cnt = 0\n    for i in range(len(ajl[now])):\n        y = ajl[now][i]\n        if x != y:\n            dfs(y, now)\n            l1[now] += 2 * l1[y]\n            l2[now] += l2[y] + l1[y]\n            cnt += l1[y]\n    for i in range(len(ajl[now])):\n        y = ajl[now][i]\n        if x != y:\n            l2[now] += l1[y] * (cnt - l1[y])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    ajl = [[] for i in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        ajl[u].append(v)\n        ajl[v].append(u)\n    l1 = [0] * (n + 1)\n    l2 = [0] * (n + 1)\n    dfs(1, 1)\n    print(l2[1] % MOD)", "import sys\nsys.setrecursionlimit(1000000000)\nmod = 1000000007\nv = [[]]\ndp = []\ndp1 = []\n\ndef dfs(cur, par):\n    dp[cur] = 1\n    dp1[cur] = 1\n    sum1 = 0\n    cnt = 0\n    for i in range(len(v[cur])):\n        node = v[cur][i]\n        if node != par:\n            dfs(node, cur)\n            dp[cur] += 2 * dp[node] % mod\n            dp[cur] %= mod\n            cnt += 1\n            dp1[cur] += dp1[node]\n            dp1[cur] %= mod\n            dp1[cur] += dp[node]\n            dp1[cur] %= mod\n            sum1 += dp[node]\n    for i in range(len(v[cur])):\n        node = v[cur][i]\n        if node != par:\n            dp1[cur] += dp[node] * (sum1 - dp[node] + mod) % mod % mod\n            dp1[cur] %= mod\nt = int(input())\nfor _ in range(t):\n    ans = 0\n    n = int(input())\n    v = []\n    dp = []\n    dp1 = []\n    for i in range(n + 1):\n        v.append([])\n        dp.append(0)\n        dp1.append(0)\n    for i in range(1, n):\n        (l, r) = [int(x) for x in input().split()]\n        v[l].append(r)\n        v[r].append(l)\n    dfs(1, 1)\n    print(dp1[1] % mod)", "import sys\nsys.setrecursionlimit(10 ** 7)\nmod = 10 ** 9 + 7\n\ndef add(a, b):\n    return (a % mod + b % mod) % mod\n\ndef mul(a, b):\n    return a % mod * b % mod % mod\n\ndef sub(a, b):\n    return (a % mod - b % mod + mod) % mod\n\ndef dfs(node, prev):\n    for adjacents in childs[node]:\n        if adjacents != prev:\n            dfs(adjacents, node)\n    temp = 0\n    for adjacents in childs[node]:\n        if adjacents != prev:\n            dp[node] = add(dp[node], 2 * dp[adjacents])\n            subtree_values[node] = add(add(subtree_values[adjacents], dp[adjacents]), subtree_values[node])\n            temp += dp[adjacents]\n    for adjacents in childs[node]:\n        if adjacents != prev:\n            subtree_values[node] += mul(dp[adjacents], sub(temp, dp[adjacents]))\n    subtree_values[node] %= mod\nfor _ in range(int(input())):\n    n = int(input())\n    childs = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (a, b) = map(int, input().strip().split())\n        childs[a].append(b)\n        childs[b].append(a)\n    dp = [1] * (n + 1)\n    subtree_values = [1] * (n + 1)\n    dfs(1, -1)\n    print(subtree_values[1] % mod)", "from collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\nmod = 10 ** 9 + 7\n\ndef findProductSum(A, n):\n    array_sum = 0\n    for i in range(0, n, 1):\n        array_sum = array_sum + A[i]\n    array_sum_square = array_sum * array_sum\n    individual_square_sum = 0\n    for i in range(0, n, 1):\n        individual_square_sum += A[i] * A[i]\n    return (array_sum_square - individual_square_sum) // 2 % mod\n\ndef traverse(par, node):\n    if len(adj[node]) == 1 and node != 1:\n        return 1\n    arr = []\n    for j in adj[node]:\n        if j == par:\n            continue\n        rn = traverse(node, j)\n        arr.append(rn)\n    if len(arr) > 1:\n        sidew.append(findProductSum(arr, len(arr)) * 2 % mod)\n    return (sum(arr) * 2 + 1) % mod\nfor t in range(int(input())):\n    N = int(input())\n    adj = defaultdict(list)\n    sidew = []\n    if N == 1:\n        print(1)\n    else:\n        for i in range(N - 1):\n            (a, b) = map(int, input().split())\n            adj[a].append(b)\n            adj[b].append(a)\n        ans = traverse(1, 1)\n        print((ans + sum(sidew)) % mod)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef solve():\n    n = int(input())\n    adj = [[] for _ in range(n + 1)]\n    aux = [1] * (n + 1)\n    answer = [1] * (n + 1)\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(root, t=-1):\n        count = 0\n        for node in adj[root]:\n            if node == t:\n                continue\n            dfs(node, root)\n            aux[root] += 2 * aux[node]\n            answer[root] += aux[node] + answer[node]\n            count += aux[node]\n        for node in adj[root]:\n            if node != t:\n                answer[root] += (count - aux[node]) * aux[node]\n    dfs(1)\n    print(answer[1] % (10 ** 9 + 7))\nfor _ in range(int(input())):\n    solve()", "import sys\nM = 10 ** 9 + 7\nsys.setrecursionlimit(100000000)\n\nclass Tree:\n\n    def __init__(self, n):\n        self.adj = [set() for _ in range(n + 1)]\n        self.val_root = [1 for _ in range(n + 1)]\n        self.val_final = [1 for _ in range(n + 1)]\n\n    def __dfs(self, cur, parent):\n        self.val_final[cur] = 1\n        s = 0\n        for (i, v) in enumerate(self.adj[cur]):\n            if v != parent:\n                self.__dfs(v, cur)\n                self.val_root[cur] += 2 * self.val_root[v] % M\n                self.val_root[cur] %= M\n                self.val_final[cur] += (self.val_final[v] + self.val_root[v]) % M\n                self.val_final[cur] %= M\n                s += self.val_root[v]\n                s %= M\n        for (i, v) in enumerate(self.adj[cur]):\n            if v != parent:\n                self.val_final[cur] += self.val_root[v] * ((s - self.val_root[v]) % M) % M\n                self.val_final[cur] %= M\n\n    def insertEdge(self, u, v):\n        self.adj[u].add(v)\n        self.adj[v].add(u)\n\n    def solve(self):\n        self.__dfs(1, 0)\n        return self.val_final[1]\nfor _ in range(int(input())):\n    n = int(input())\n    tree = Tree(n)\n    for i in range(1, n):\n        tree.insertEdge(*map(int, input().split()))\n    print(tree.solve())", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(5 * 10 ** 5)\nmod = 1000000007\n\ndef depth(current, p):\n    dpx[current] = 1\n    t[current] = 1\n    total = 0\n    cnt = 0\n    for i in range(len(graph[current])):\n        node = graph[current][i]\n        if node != p:\n            depth(node, current)\n            dpx[current] = dpx[current] + 2 * dpx[node] % 1000000007\n            dpx[current] %= 1000000007\n            cnt += 1\n            t[current] += t[node]\n            t[current] %= 1000000007\n            t[current] += dpx[node]\n            t[current] %= 1000000007\n            total += dpx[node]\n    for i in range(len(graph[current])):\n        node = graph[current][i]\n        if node != p:\n            t[current] += dpx[node] * ((total - dpx[node] + 1000000007) % 1000000007) % 1000000007\n            t[current] %= 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    graph = defaultdict(list)\n    (dpx, t) = ([0] * (n + 1), [0] * (n + 1))\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    depth(1, 1)\n    final = t[1]\n    sys.stdout.write(str(final))\n    sys.stdout.flush()\n    print()", "from sys import setrecursionlimit\nsetrecursionlimit(1000000)\nmod = 1000000007\n\ndef dfs(node, root, dp, dp1, g):\n    (dp[node], dp1[node]) = (1, 1)\n    (sum_, cnt) = (0, 0)\n    for curr in g[node]:\n        if curr != root:\n            dfs(curr, node, dp, dp1, g)\n            dp[node] += 2 * dp[curr] % mod\n            dp[node] = dp[node] % mod\n            cnt += 1\n            dp1[node] += dp1[curr]\n            dp1[node] = dp1[node] % mod\n            dp1[node] += dp[curr]\n            dp1[node] %= mod\n            sum_ += dp[curr]\n    for curr in g[node]:\n        if curr != root:\n            dp1[node] += dp[curr] * (sum_ - dp[curr] + mod) % mod % mod\n            dp1[node] %= mod\nfor _ in range(int(input())):\n    n = int(input())\n    g = [[] for _ in range(n + 1)]\n    dp = [[] for _ in range(n + 1)]\n    dp1 = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    dfs(1, 1, dp, dp1, g)\n    ans = dp1[1] % mod\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfor t in range(int(input())):\n    n = int(input())\n    adj = [[] for i in range(n + 10)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[v].append(u)\n        adj[u].append(v)\n    dp = [0] * (n + 10)\n    dp1 = [0] * (n + 10)\n\n    def dfs(curr, par):\n        dp[curr] = 1\n        dp1[curr] = 1\n        suma = 0\n        count = 0\n        for node in adj[curr]:\n            if node != par:\n                dfs(node, curr)\n                dp[curr] += 2 * dp[node]\n                count += 1\n                dp1[curr] += dp1[node]\n                dp1[curr] += dp[node]\n                suma += dp[node]\n        for node in adj[curr]:\n            if node != par:\n                dp1[curr] += dp[node] * (suma - dp[node])\n    dfs(1, 1)\n    mod = 10 ** 9 + 7\n    print(dp1[1] % mod)", "import sys\nsys.setrecursionlimit(1000000)\n\ndef mgc(t, p):\n    (dp[t], dp1[t]) = (1, 1)\n    (sm, cnt) = (0, 0)\n    for i in range(len(adj[t])):\n        node = adj[t][i]\n        if node != p:\n            mgc(node, t)\n            dp[t] += 2 * dp[node] % mod\n            dp[t] %= mod\n            cnt += 1\n            dp1[t] += dp1[node]\n            dp1[t] %= mod\n            dp1[t] += dp[node]\n            dp1[t] %= mod\n            sm += dp[node]\n    for i in range(len(adj[t])):\n        node = adj[t][i]\n        if node != p:\n            dp1[t] += dp[node] * (sm - dp[node] + mod) % mod % mod\n            dp1[t] %= mod\nmod = 1000000007\nfor _ in range(int(input())):\n    n = int(input())\n    dp = [0] * (n + 1)\n    adj = [[] for i in range(n + 1)]\n    dp1 = [0] * (n + 1)\n    for i in range(n - 1):\n        (l, r) = map(int, input().split())\n        adj[l].append(r)\n        adj[r].append(l)\n    mgc(1, 1)\n    ans = dp1[1] % mod\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 8)\niparr = []\ntemparr = []\narrtree = []\nAnswer = 0\nMOD = 1000000007\n\ndef DepthFirstSearch(kak, prac):\n    (temparr[kak], arrtree[kak]) = (1, 1)\n    loopsum = 0\n    for i in range(len(iparr[kak])):\n        TempValue = int(iparr[kak][i])\n        if TempValue != prac:\n            DepthFirstSearch(TempValue, kak)\n            temparr[kak] += 2 * temparr[TempValue] % MOD\n            temparr[kak] %= MOD\n            arrtree[kak] += arrtree[TempValue]\n            arrtree[kak] %= MOD\n            arrtree[kak] += temparr[TempValue]\n            arrtree[kak] %= MOD\n            loopsum += temparr[TempValue]\n    for i in range(len(iparr[kak])):\n        TempValue = iparr[kak][i]\n        if TempValue != prac:\n            arrtree[kak] += temparr[TempValue] * ((loopsum - temparr[TempValue] + MOD) % MOD) % MOD\n            arrtree[kak] %= MOD\nfor _ in range(int(sys.stdin.readline())):\n    Answer = 0\n    n = int(sys.stdin.readline())\n    for i in range(n + 1):\n        temparr.append(0)\n        arrtree.append(0)\n        iparr.append([])\n    for i in range(n - 1):\n        (x, y) = map(int, sys.stdin.readline().strip().split())\n        iparr[x].append(y)\n        iparr[y].append(x)\n    DepthFirstSearch(1, 1)\n    Answer = arrtree[1]\n    sys.stdout.write(str(Answer) + '\\n')\n    arrtree.clear()\n    iparr.clear()\n    temparr.clear()", "import sys\nsys.setrecursionlimit(10 ** 8)\niparr = []\ntemparr = []\narrtree = []\nAnswer = 0\nMOD = 1000000007\n\ndef DepthFirstSearch(kak, prac):\n    (temparr[kak], arrtree[kak]) = (1, 1)\n    (sum, count) = (0, 0)\n    for i in range(len(iparr[kak])):\n        TempValue = int(iparr[kak][i])\n        if TempValue != prac:\n            DepthFirstSearch(TempValue, kak)\n            temparr[kak] += 2 * temparr[TempValue] % MOD\n            temparr[kak] %= MOD\n            count += 1\n            arrtree[kak] += arrtree[TempValue]\n            arrtree[kak] %= MOD\n            arrtree[kak] += temparr[TempValue]\n            arrtree[kak] %= MOD\n            sum += temparr[TempValue]\n    for i in range(len(iparr[kak])):\n        TempValue = iparr[kak][i]\n        if TempValue != prac:\n            arrtree[kak] += temparr[TempValue] * ((sum - temparr[TempValue] + MOD) % MOD) % MOD\n            arrtree[kak] %= MOD\nfor _ in range(int(sys.stdin.readline())):\n    Answer = 0\n    n = int(sys.stdin.readline())\n    for i in range(n + 1):\n        temparr.append(0)\n        arrtree.append(0)\n        iparr.append([])\n    for i in range(n - 1):\n        (x, y) = map(int, sys.stdin.readline().strip().split())\n        iparr[x].append(y)\n        iparr[y].append(x)\n    DepthFirstSearch(1, 1)\n    Answer = arrtree[1]\n    sys.stdout.write(str(Answer) + '\\n')\n    arrtree.clear()\n    iparr.clear()\n    temparr.clear()", "from sys import stdin, setrecursionlimit as srl\nsrl(int(1000000.0))\nip = stdin.readline\nmod = int(1000000000.0) + 7\nfor _ in range(int(ip())):\n    n = int(ip())\n    graph = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, ip().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    total = [0]\n\n    def samepath(var, root, last):\n        total[0] = (total[0] + var) % mod\n        passon = 0\n        for a in graph[root]:\n            if a == last:\n                continue\n            varnext = 2 * (passon + var) % mod\n            p = samepath(varnext, a, root)\n            passon = (passon + 2 * p - 1) % mod\n        return passon + 1\n    samepath(1, 1, -1)\n    print(total[0])", "from sys import *\nfrom collections import defaultdict as dd\nfrom math import *\nfrom bisect import *\nsetrecursionlimit(10 ** 8)\n\ndef sinp():\n    return input()\n\ndef inp():\n    return int(sinp())\n\ndef minp():\n    return map(int, sinp().split())\n\ndef linp():\n    return list(minp())\n\ndef strl():\n    return list(sinp())\n\ndef pr(x):\n    print(x)\nmod = int(1000000000.0 + 7)\n\ndef dfs(x=1, y=1):\n    dp[x] = 1\n    ans[x] = 1\n    res = 0\n    for i in graph[x]:\n        if i != y:\n            dfs(i, x)\n            dp[x] = (dp[x] + 2 * dp[i] % mod) % mod\n            ans[x] = (ans[x] + ans[i]) % mod\n            ans[x] = (ans[x] + dp[i]) % mod\n            res += dp[i]\n    for i in graph[x]:\n        if i != y:\n            ans[x] = (ans[x] + dp[i] * ((res - dp[i] + mod) % mod) % mod) % mod\nfor _ in range(inp()):\n    n = inp()\n    graph = dd(list)\n    dp = [0 for i in range(n + 1)]\n    ans = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = minp()\n        graph[u].append(v)\n        graph[v].append(u)\n    dfs()\n    pr(ans[1] % mod)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom collections import defaultdict\n\ndef addEdge(graph, u, v):\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef method_1(current, parent):\n    summ = 0\n    for v in graph[current]:\n        if v == parent:\n            continue\n        method_1(v, current)\n        table[current] = table[current] + 2 * table[v]\n        val[current] = val[current] + val[v] + table[v]\n        summ = summ + table[v]\n    for v in graph[current]:\n        if v == parent:\n            continue\n        val[current] = val[current] + table[v] * abs(summ - table[v])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    graph = defaultdict(list)\n    table = [1] * n\n    val = [1] * n\n    for __ in range(n - 1):\n        (u, v) = map(int, input().split())\n        addEdge(graph, u - 1, v - 1)\n    method_1(0, -1)\n    print(val[0] % (10 ** 9 + 7))", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom collections import defaultdict\n\ndef addEdge(graph, u, v):\n    graph[u].append(v)\n    graph[v].append(u)\n\ndef method_1(current, parent):\n    summ = 0\n    for v in graph[current]:\n        if v == parent:\n            continue\n        method_1(v, current)\n        table[current] = table[current] + 2 * table[v]\n        val[current] = val[current] + val[v] + table[v]\n        summ = summ + table[v]\n    for v in graph[current]:\n        if v == parent:\n            continue\n        val[current] = val[current] + table[v] * abs(summ - table[v])\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    graph = defaultdict(list)\n    table = [1] * n\n    val = [1] * n\n    for __ in range(n - 1):\n        (u, v) = map(int, input().split())\n        addEdge(graph, u - 1, v - 1)\n    method_1(0, -1)\n    print(val[0] % (10 ** 9 + 7))", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(int(10000000.0))\n\ndef solve(root, graph, values, parent=None):\n    for c in graph[root]:\n        if c != parent:\n            solve(c, graph, values, root)\n    child_single_paths = sum((values[c][0] for c in graph[root] if c != parent))\n    single_paths = (child_single_paths % int(1000000000.0 + 7) * 2 + 1) % int(1000000000.0 + 7)\n    cross_paths = 0\n    carry = 0\n    running_sum = 0\n    for i in range(len(graph[root])):\n        c = graph[root][i]\n        if c != parent:\n            cross_paths += values[c][0] * (child_single_paths - values[c][0] - running_sum) % int(1000000000.0 + 7)\n            running_sum += values[c][0]\n    cross_paths = cross_paths % int(1000000000.0 + 7)\n    carry = sum((values[c][1] for c in graph[root] if c != parent))\n    values[root][0] = single_paths\n    values[root][1] = (cross_paths * 2 + carry) % int(1000000000.0 + 7)\nfor _ in range(int(input())):\n    N = int(input())\n    graph = defaultdict(list)\n    values = [[1, 0] for _ in range(N + 1)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    solve(1, graph, values)\n    print((values[1][0] + values[1][1]) % int(1000000000.0 + 7))", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(int(10000000.0))\n\ndef solve(root, graph, values, parent=None):\n    for c in graph[root]:\n        if c != parent:\n            solve(c, graph, values, root)\n    child_single_paths = sum((values[c][0] for c in graph[root] if c != parent))\n    single_paths = (child_single_paths % int(1000000000.0 + 7) * 2 + 1) % int(1000000000.0 + 7)\n    cross_paths = 0\n    carry = 0\n    running_sum = 0\n    for i in range(len(graph[root])):\n        c = graph[root][i]\n        if c != parent:\n            cross_paths += values[c][0] * (child_single_paths - values[c][0] - running_sum) % int(1000000000.0 + 7)\n            running_sum += values[c][0]\n    cross_paths = cross_paths % int(1000000000.0 + 7)\n    for c in graph[root]:\n        if c != parent:\n            carry += values[c][1]\n    values[root][0] = single_paths\n    values[root][1] = (cross_paths * 2 + carry) % int(1000000000.0 + 7)\nfor _ in range(int(input())):\n    N = int(input())\n    graph = defaultdict(list)\n    values = [[1, 0] for _ in range(N + 1)]\n    for _ in range(N - 1):\n        (u, v) = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n    solve(1, graph, values)\n    print((values[1][0] + values[1][1]) % int(1000000000.0 + 7))", "import sys\nsys.setrecursionlimit(10 ** 6)\n\nclass Scanner:\n\n    def __init__(self):\n        pass\n\n    def readInt(self):\n        return int(input())\n\n    def readFloat(self):\n        return map(float, input().split())\n\n    def readList(self):\n        return list(map(int, input().split()))\n\n    def readString(self):\n        return input()\nsc = Scanner()\nt = sc.readInt()\nMAX = 100005\ng = [[] for _ in range(MAX)]\nthrough = [0 for _ in range(MAX)]\nacross = [0 for _ in range(MAX)]\n\ndef ways(u, parent):\n    if parent != 0 and len(g[u]) == 1:\n        through[u] = 1\n        return\n    v = []\n    for child in g[u]:\n        if child == parent:\n            continue\n        ways(child, u)\n        through[u] += through[child] * 2\n        v.append(through[child])\n    sums = [0 for _ in range(len(v) + 1)]\n    for i in reversed(range(len(v))):\n        sums[i] = sums[i + 1] + v[i]\n    for i in range(len(v)):\n        across[u] += 2 * v[i] * sums[i + 1]\n    through[u] += 1\nfor _ in range(t):\n    n = sc.readInt()\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    ways(1, 0)\n    ans = through[1]\n    for i in range(1, n + 1):\n        ans += across[i]\n        g[i].clear()\n        through[i] = 0\n        across[i] = 0\n    print(ans % 1000000007)", "try:\n    from collections import defaultdict\n    import sys\n    sys.setrecursionlimit(10 ** 6)\n\n    def sol(g, l, i, res):\n        (l[i], val, ar) = (True, 1, [])\n        for jj in g[i]:\n            if not l[jj]:\n                (temp, res) = sol(g, l, jj, res)\n                ar.append(temp)\n                val = (val + temp * 2) % (10 ** 9 + 7)\n        res = (res + prod(ar) + sum(ar)) % (10 ** 9 + 7)\n        return (val, res)\n\n    def prod(s):\n        (sq, sq2) = (sum(s) ** 2, 0)\n        for kk in range(len(s)):\n            sq2 = (sq2 + s[kk] ** 2) % (10 ** 9 + 7)\n        return (sq - sq2) % (10 ** 9 + 7)\n    for ii in range(int(input())):\n        n = int(input())\n        (t, l, res, ans) = (defaultdict(list), defaultdict(bool), 0, n)\n        for jj in range(n - 1):\n            (u, v) = map(int, input().split())\n            t[u].append(v)\n            t[v].append(u)\n        (x, y) = sol(t, l, 1, res)\n        print((y + n) % (10 ** 9 + 7))\nexcept:\n    pass", "import sys\nimport os.path\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\ndepth = 1000005\nmod = 1000000007\nsys.setrecursionlimit(depth)\n\ndef dfs(u, p):\n    for v in adj[u]:\n        if v != p:\n            dfs(v, u)\n    s = 0\n    for v in adj[u]:\n        if v != p:\n            dp1[u] = (dp1[u] + 2 * dp1[v]) % mod\n            dp2[u] = (dp2[u] + dp2[v]) % mod\n            s = (s + dp1[v]) % mod\n    for v in adj[u]:\n        if v != p:\n            s = s - dp1[v]\n            while s < 0:\n                s += mod\n            s %= mod\n            dp2[u] = (dp2[u] + 2 * s * dp1[v] % mod) % mod\nfor _ in range(int(input())):\n    n = int(input())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        (u, v) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n    dp1 = [1 for _ in range(n + 1)]\n    dp2 = [0 for _ in range(n + 1)]\n    dfs(1, 1)\n    ans = (dp1[1] + dp2[1]) % mod\n    print(ans)", "import sys\nsys.setrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n\ndef solve(graph, j, sub, high, x, mini):\n    graph[j].sort(reverse=True, key=lambda x: (sub[x], -high[x]))\n    for k in range(len(graph[j])):\n        mini[graph[j][k]] = mini[j] * (k + 1)\n\ndef solve1(a, b, k):\n    f = 0\n    ans = 0\n    for i in range(k):\n        if a[i] == b[i]:\n            f = 1\n        elif f:\n            ans = ans + 2\n            f = 0\n    if a[1] != b[1]:\n        ans = ans - 1\n    return ans\n\ndef dfs(current, parent, g, dp, total):\n    dp[current] = 1\n    total[current] = dp[current]\n    s = 0\n    for i in range(len(g[current])):\n        node = g[current][i]\n        if node != parent:\n            dfs(node, current, g, dp, total)\n            dp[current] += 2 * dp[node] % mod\n            dp[current] %= mod\n            total[current] += total[node]\n            total[current] %= mod\n            total[current] += dp[node]\n            total[current] %= mod\n            s += dp[node]\n    for i in range(len(g[current])):\n        node = g[current][i]\n        if node != parent:\n            total[current] += dp[node] * ((s - dp[node] + mod) % mod) % mod\n            total[current] %= mod\n\ndef SieveOfEratosthenes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p] == True:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    prime[0] = False\n    prime[1] = False\n    return prime\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    combination = 0\n    n = int(input())\n    n += 1\n    dp = [0] * n\n    total = [0] * n\n    g = defaultdict(list)\n    for i in range(n - 2):\n        (u, v) = map(int, input().split())\n        g[u].append(v)\n        g[v].append(u)\n    dfs(1, 1, g, dp, total)\n    combination = total[1]\n    print(combination % mod)", "from collections import defaultdict as dd\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nmod = 1000000007\n\ndef dfs(cur, prev):\n    prefix = [0 for i in range(len(tree[cur]))]\n    j = 1\n    for i in range(len(tree[cur])):\n        if tree[cur][i] != prev:\n            dfs(tree[cur][i], cur)\n            dp[cur][1] += 2 * dp[tree[cur][i]][1]\n            dp[cur][1] %= mod\n            dp[cur][0] += dp[tree[cur][i]][1] + dp[tree[cur][i]][0]\n            prefix[j] = prefix[j - 1]\n            prefix[j] += dp[tree[cur][i]][1]\n            prefix[j] %= mod\n            j += 1\n    k = 1\n    for i in range(len(tree[cur])):\n        if tree[cur][i] != prev:\n            dp[cur][0] += 2 * dp[tree[cur][i]][1] * (prefix[j - 1] - prefix[k] + mod)\n            dp[cur][0] %= mod\n            k += 1\nfor _ in range(int(input())):\n    n = int(input())\n    tree = dd(list)\n    dp = [[1, 1] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    tree[0].append(1)\n    tree[1].append(0)\n    dfs(1, 0)\n    print(dp[1][0])", "from collections import defaultdict as dd\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\nmod = 1000000007\n\ndef dfs(cur, prev):\n    prefix = [0 for i in range(len(tree[cur]))]\n    j = 1\n    for i in range(len(tree[cur])):\n        if tree[cur][i] != prev:\n            dfs(tree[cur][i], cur)\n            dp[cur][1] += 2 * dp[tree[cur][i]][1]\n            dp[cur][1] %= mod\n            dp[cur][0] += dp[tree[cur][i]][1] + dp[tree[cur][i]][0]\n            prefix[j] = prefix[j - 1]\n            prefix[j] += dp[tree[cur][i]][1]\n            prefix[j] %= mod\n            j += 1\n    k = 1\n    for i in range(len(tree[cur])):\n        if tree[cur][i] != prev:\n            dp[cur][0] += 2 * dp[tree[cur][i]][1] * (prefix[j - 1] - prefix[k] + mod)\n            dp[cur][0] %= mod\n            k += 1\nmx = 3004\npower = [1 for i in range(mx)]\nfor i in range(1, mx):\n    power[i] = power[i - 1] * 2\n    power[i] %= mod\nfor _ in range(int(input())):\n    n = int(input())\n    tree = dd(list)\n    dp = [[1, 1] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    tree[0].append(1)\n    tree[1].append(0)\n    dfs(1, 0)\n    print(dp[1][0])", "import sys\nimport math\nsys.setrecursionlimit(1000000)\n\nclass Node:\n\n    def __init__(self):\n        self.adj = []\n        self.val = 1\n        self.visited = False\n\ndef dfs2(root):\n    root.visited = True\n    ch = []\n    for i in range(len(root.adj)):\n        if not root.adj[i].visited:\n            ch.append(root.adj[i].val)\n    temp = 0\n    if len(ch) == 0 or len(ch) == 1:\n        temp = 0\n    else:\n        s = 0\n        p = 0\n        for i in range(1, len(ch)):\n            s += ch[i - 1]\n            p = (p + ch[i] * s % 1000000007) % 1000000007\n        temp = p * 2 % 1000000007\n    ch1 = []\n    for i in range(len(root.adj)):\n        if not root.adj[i].visited:\n            ch1.append(dfs2(root.adj[i]))\n    return (temp + sum(ch1)) % 1000000007\n\ndef dfs(root):\n    root.visited = True\n    ch = []\n    for i in range(len(root.adj)):\n        if not root.adj[i].visited:\n            ch.append(dfs(root.adj[i]))\n    sm = sum(ch)\n    root.val = (2 * sm + 1) % 1000000007\n    return root.val\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    tr = []\n    for i in range(n):\n        tr.append(Node())\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        tr[u - 1].adj.append(tr[v - 1])\n        tr[v - 1].adj.append(tr[u - 1])\n    ans = dfs(tr[0]) % 1000000007\n    for i in range(n):\n        tr[i].visited = False\n    ans2 = dfs2(tr[0]) % 1000000007\n    print((ans + ans2) % 1000000007)", "import sys\nsys.setrecursionlimit(20000000)\nmod = 1000000007\ndp = []\ntotal = []\nv = []\n\ndef dfs(curr, par):\n    dp[curr] = 1\n    total[curr] = 1\n    sum = 0\n    for i in range(len(v[curr])):\n        node = v[curr][i]\n        if node != par:\n            dfs(node, curr)\n            dp[curr] += 2 * dp[node] % mod\n            dp[curr] %= mod\n            total[curr] += total[node]\n            total[curr] %= mod\n            total[curr] += dp[node]\n            total[curr] %= mod\n            sum += dp[node]\n    for i in range(len(v[curr])):\n        node = v[curr][i]\n        if node != par:\n            total[curr] += dp[node] * ((sum - dp[node] + mod) % mod) % mod\n            total[curr] %= mod\nfor _ in range(int(input())):\n    ans = 0\n    n = int(input())\n    v = [[] for i in range(n + 1)]\n    dp = [0 for i in range(n + 1)]\n    total = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (l, r) = map(int, input().split())\n        v[l].append(r)\n        v[r].append(l)\n    dfs(1, 1)\n    ans = total[1] % mod\n    print(ans)\n    dp.clear()\n    v.clear()\n    total.clear()", "from collections import defaultdict\nimport sys\nsys.setrecursionlimit(10 ** 6)\nmod = 10 ** 9 + 7\n\ndef dfs(cur, prev):\n    dp[cur] = 1\n    total[cur] = 1\n    s = 0\n    for data in graph[cur]:\n        if data != prev:\n            dfs(data, cur)\n            dp[cur] += 2 * dp[data]\n            total[cur] += total[data] + dp[data]\n            s += dp[data]\n    for data in graph[cur]:\n        if data != prev:\n            total[cur] += dp[data] * (s - dp[data])\nfor _ in range(int(input())):\n    n = int(input())\n    graph = defaultdict(list)\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    dp = [0] * (n + 5)\n    total = [0] * (n + 5)\n    dfs(0, -1)\n    print(total[0] % mod)", "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(3 * 10 ** 5)\n\ndef inp():\n    return int(input())\n\ndef st():\n    return input().rstrip('\\n')\n\ndef lis():\n    return list(map(int, input().split()))\n\ndef ma():\n    return map(int, input().split())\nglobal p, res\np = 10 ** 9 + 7\n\ndef dfs(cur, pa, deg, dp, val):\n    global p\n    loc = 0\n    for i in deg[cur]:\n        if i != pa:\n            dfs(i, cur, deg, dp, val)\n            dp[cur] += 2 * dp[i] % p\n            val[cur] += (val[i] + dp[i]) % p\n            loc += dp[i]\n            dp[cur] %= p\n            val[cur] %= p\n    for i in deg[cur]:\n        if i != pa:\n            val[cur] += dp[i] * (loc - dp[i]) % p\n            val[cur] %= p\nt = inp()\nwhile t:\n    t -= 1\n    n = inp()\n    res = pow(2, n, p) - 1\n    deg = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (x, y) = ma()\n        deg[x].append(y)\n        deg[y].append(x)\n    dp = [1 for i in range(n + 1)]\n    val = [1 for i in range(n + 1)]\n    dfs(1, 0, deg, dp, val)\n    print(val[1] % p)", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    a = [[] for i in range(n + 1)]\n    vis = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (p, q) = map(int, input().split())\n        a[p].append(q)\n        a[q].append(p)\n    p = [0 for i in range(n + 1)]\n    for i in a:\n        i.sort()\n    z = [1]\n    cc = []\n    b = [[] for i in range(n + 1)]\n    while len(z) != 0:\n        cc.append(z)\n        for i in z:\n            vis[i] = 1\n        zz = []\n        for i in z:\n            for j in a[i]:\n                if vis[j] == 0:\n                    b[i].append(j)\n                    zz.append(j)\n        z = zz\n    u = 10 ** 9 + 7\n    p = [0 for i in range(n + 1)]\n    q = [0 for i in range(n + 1)]\n    for i in range(len(cc) - 1, -1, -1):\n        for j in cc[i]:\n            if len(b[j]) == 0:\n                p[j] = 1\n                q[j] = 0\n            else:\n                gg = []\n                s = 0\n                for k in b[j]:\n                    s = s + p[k]\n                    gg.append(p[k])\n                s = 2 * s + 1\n                p[j] = s\n                s = 0\n                ff = []\n                for k in gg:\n                    s = s + k\n                    ff.append(s)\n                s = 0\n                for k in range(len(gg) - 1):\n                    s = s + 2 * gg[k] * (ff[-1] - ff[k])\n                q[j] = s\n    print((p[1] + sum(q)) % u)\n    t = t - 1", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    a = [[] for i in range(n + 1)]\n    vis = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (p, q) = map(int, input().split())\n        a[p].append(q)\n        a[q].append(p)\n    p = [0 for i in range(n + 1)]\n    for i in a:\n        i.sort()\n    z = [1]\n    cc = []\n    b = [[] for i in range(n + 1)]\n    while len(z) != 0:\n        cc.append(z)\n        for i in z:\n            vis[i] = 1\n        zz = []\n        for i in z:\n            for j in a[i]:\n                if vis[j] == 0:\n                    b[i].append(j)\n                    zz.append(j)\n        z = zz\n    u = 10 ** 9 + 7\n    p = [0 for i in range(n + 1)]\n    q = [0 for i in range(n + 1)]\n    for i in range(len(cc) - 1, -1, -1):\n        for j in cc[i]:\n            if len(b[j]) == 0:\n                p[j] = 1\n                q[j] = 0\n            else:\n                gg = []\n                s = 0\n                for k in b[j]:\n                    s = s + p[k]\n                    gg.append(p[k])\n                s = 2 * s + 1\n                p[j] = s\n                s = 0\n                ff = []\n                for k in gg:\n                    s = s + k\n                    ff.append(s)\n                s = 0\n                for k in range(len(gg) - 1):\n                    s = s + 2 * gg[k] * (ff[-1] - ff[k])\n                q[j] = s\n    print((p[1] + sum(q)) % u)\n    t = t - 1", "import sys\nsys.setrecursionlimit(int(1000000.0))\nm = int(1000000000.0) + 7\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    adja = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        u -= 1\n        v -= 1\n        adja[u].append(v)\n        adja[v].append(u)\n\n    def dfs(node, ances, mul):\n        const = mul\n        sm = const\n        path = 0\n        for v in adja[node]:\n            if v == ances:\n                continue\n            (a, b) = dfs(v, node, 2 * (path + const) % m)\n            sm = (sm + a) % m\n            path = (path + 2 * b - 1) % m\n        return (sm, path + 1)\n    (res, p) = dfs(0, -1, 1)\n    print(res % m)", "import sys\nsys.setrecursionlimit(10 ** 5 + 1)\nm = 10 ** 9 + 7\n\ndef cal_sum(arr):\n    cs = 0\n    ts = 0\n    for v in arr:\n        ts = (ts + cs * v) % m\n        cs = (cs + v) % m\n    return 2 * ts % m\n\ndef bfs(u, tree, vis):\n    vis[u] = True\n    sbt_nums = []\n    tsum = 0\n    for v in tree[u]:\n        if not vis[v]:\n            (sbtsum, sbtnum) = bfs(v, tree, vis)\n            tsum = (tsum + sbtsum) % m\n            sbt_nums.append(sbtnum)\n    tnum = (2 * sum(sbt_nums) + 1) % m\n    tsum = (tsum + cal_sum(sbt_nums)) % m\n    return (tsum, tnum)\n\ndef solve(tree, vis):\n    root = 1\n    (tsum, tnum) = bfs(root, tree, vis)\n    return (tsum + tnum) % m\nfor t in range(int(input())):\n    n = int(input())\n    tree = dict()\n    for i in range(1, n + 1):\n        tree[i] = []\n    for i in range(n - 1):\n        (u, v) = tuple(map(int, input().strip().split()))\n        tree[u].append(v)\n        tree[v].append(u)\n    vis = [False for i in range(n + 1)]\n    ans = solve(tree, vis)\n    print(ans)", "from collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\nmod = 10 ** 9 + 7\n\ndef findProductSum(A, n):\n    array_sum = 0\n    for i in range(0, n, 1):\n        array_sum = array_sum + A[i]\n    array_sum_square = array_sum * array_sum\n    individual_square_sum = 0\n    for i in range(0, n, 1):\n        individual_square_sum += A[i] * A[i]\n    return (array_sum_square - individual_square_sum) // 2 % mod\n\ndef traverse(par, node):\n    if len(adj[node]) == 1 and node != 1:\n        return 1\n    arr = []\n    for j in adj[node]:\n        if j == par:\n            continue\n        rn = traverse(node, j)\n        arr.append(rn)\n    if len(arr) > 1:\n        sidew.append(findProductSum(arr, len(arr)) * 2 % mod)\n    return (sum(arr) * 2 + 1) % mod\nfor t in range(int(input())):\n    N = int(input())\n    adj = defaultdict(list)\n    sidew = []\n    if N == 1:\n        print(1)\n    else:\n        for i in range(N - 1):\n            (a, b) = map(int, input().split())\n            adj[a].append(b)\n            adj[b].append(a)\n        ans = traverse(1, 1)\n        print((ans + sum(sidew)) % mod)", "from collections import defaultdict\nfrom sys import setrecursionlimit\nsetrecursionlimit(10 ** 8)\nmod = 10 ** 9 + 7\n\ndef findProductSum(A, n):\n    array_sum = 0\n    for i in range(0, n, 1):\n        array_sum = array_sum + A[i]\n    array_sum_square = array_sum * array_sum\n    individual_square_sum = 0\n    for i in range(0, n, 1):\n        individual_square_sum += A[i] * A[i]\n    return (array_sum_square - individual_square_sum) // 2 % mod\n\ndef traverse(par, node):\n    if len(adj[node]) == 1 and node != 1:\n        return (1, 0)\n    arr = []\n    ne = []\n    for j in adj[node]:\n        if j == par:\n            continue\n        (rn, sv) = traverse(node, j)\n        arr.append(rn)\n        ne.append(sv)\n    if len(arr) > 1:\n        ex = findProductSum(arr, len(arr)) * 2 % mod\n    else:\n        ex = 0\n    return ((sum(arr) * 2 + 1) % mod, (ex + sum(ne)) % mod)\nfor t in range(int(input())):\n    N = int(input())\n    adj = defaultdict(list)\n    if N == 1:\n        print(1)\n    else:\n        for i in range(N - 1):\n            (a, b) = map(int, input().split())\n            adj[a].append(b)\n            adj[b].append(a)\n        (ans, sidev) = traverse(1, 1)\n        print((ans + sidev) % mod)", "import sys\nsys.setrecursionlimit(int(100000.0) + 11)\nMOD = int(1000000000.0) + 7\n\ndef dfs(node, parent):\n    down = []\n    paths = []\n    for child in graph[node]:\n        if child != parent:\n            (d, p) = dfs(child, node)\n            down.append(d)\n            paths.append(p)\n    d_sum = sum(down) % MOD\n    d_pairs = 0\n    for d in down:\n        d_pairs = (d_pairs + d * (d_sum - d)) % MOD\n    valid_paths = (sum(paths) + d_sum + 1 + d_pairs) % MOD\n    down_paths = (d_sum * 2 + 1) % MOD\n    return (down_paths, valid_paths)\n\ndef solve():\n    (_, paths) = dfs(1, 1)\n    return paths\ntest_cases = int(input())\nfor test_case in range(test_cases):\n    N = int(input())\n    graph = [[] for i in range(N + 1)]\n    for i in range(N - 1):\n        (a, b) = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    print(solve())", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef rec(x, y, z):\n    if len(y[x]) == 1 and y[x][0] == z:\n        return (1, 1)\n    ans = 1\n    ans1 = 1\n    a = 0\n    for i in y[x]:\n        if i != z:\n            (temp1, temp2) = rec(i, y, x)\n            ans += temp1 + temp2\n            ans -= temp2 ** 2\n            ans1 += 2 * temp2\n            a += temp2\n    ans += a ** 2\n    return (ans % 1000000007, ans1 % 1000000007)\nfor t in range(int(input())):\n    n = int(input())\n    a1 = [[] for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        a1[u].append(v)\n        a1[v].append(u)\n    (ai, aj) = rec(1, a1, 0)\n    print(ai % 1000000007)", "import itertools\nimport sys\nsys.setrecursionlimit(3 * 10 ** 5)\nMODULUS = 10 ** 9 + 7\n\ndef number_of_valid_paths(tree, root, parent):\n    subtrees = [number_of_valid_paths(tree, node, root) for node in tree[root] if node != parent]\n    result = (sum((v + s for (v, s) in subtrees)) + 2 * sum((s * (a - s) for ((v, s), a) in zip(subtrees, itertools.accumulate((s for (_, s) in subtrees))))) + 1, 2 * sum((s for (_, s) in subtrees)) + 1)\n    return (result[0] % MODULUS, result[1] % MODULUS)\nfor _ in range(int(input())):\n    number_of_nodes = int(input())\n    tree = [[] for _ in range(number_of_nodes)]\n    for _ in range(number_of_nodes - 1):\n        (u, v) = [int(x) - 1 for x in input().split()]\n        tree[u].append(v)\n        tree[v].append(u)\n    print(number_of_valid_paths(tree, 0, None)[0])"]