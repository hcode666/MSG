["from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    if m == 0:\n        print(fact[n] % MOD)\n        continue\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    print(ans)", "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    if m == 0:\n        print(fact[n] % MOD)\n        continue\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    print(ans)", "from collections import defaultdict\nMOD = 1000000007\nMX = 100010\n(fact, inv_fact) = ([1] * MX, [1] * MX)\nfor i in range(2, MX):\n    fact[i] = fact[i - 1] * i % MOD\ninv_fact[MX - 1] = 549915853\nfor i in range(MX - 2, -1, -1):\n    inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n\ndef ncr(n, r):\n    if n < r:\n        return 0\n    return fact[n] * inv_fact[r] % MOD * inv_fact[n - r] % MOD\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    if m == 0:\n        print(fact[n] % MOD)\n        continue\n    faulty_nodes = []\n    discon = defaultdict(lambda : 0)\n    for i in range(m):\n        (u, v) = map(int, input().split())\n        discon[u, v] = 1\n        discon[v, u] = 1\n        if u not in faulty_nodes:\n            faulty_nodes.append(u)\n        if v not in faulty_nodes:\n            faulty_nodes.append(v)\n    k = len(faulty_nodes)\n    normal_nodes = n - k\n    normal_nodes_combinations = fact[normal_nodes]\n    ans = 0\n    dp = [[[0] * (k + 1) for _ in range(k + 1)] for _ in range(1 << k + 1)]\n    for i in range(k):\n        dp[1 << i][i][0] = 1\n    for mask in range(1, 1 << k):\n        for first_node in range(k):\n            for number_tied in range(k):\n                if dp[mask][first_node][number_tied] > 0:\n                    for new_first in range(k):\n                        if mask >> new_first & 1 == 0:\n                            new_mask = mask ^ 1 << new_first\n                            edge_missing = discon[faulty_nodes[first_node], faulty_nodes[new_first]]\n                            dp[new_mask][new_first][number_tied + edge_missing] += dp[mask][first_node][number_tied]\n                if mask == (1 << k) - 1:\n                    get_ways = ncr(n - number_tied, k) * dp[mask][first_node][number_tied] * normal_nodes_combinations % MOD\n                    ans = (ans + get_ways) % MOD\n    print(ans)", "from math import factorial\nroots = [i for i in range(100010)]\nMOD = 10 ** 9 + 7\nfactorials = [1] * 100010\nfor i in range(2, 100010):\n    factorials[i] = i * factorials[i - 1] % MOD\n\ndef root(x):\n    while x != roots[x]:\n        x = roots[x]\n    return x\n\ndef unite(x, y):\n    (p, q) = (root(x), root(y))\n    roots[p] = q\n\ndef find(x, y):\n    return roots[x] == roots[y]\n\ndef subset(i, s):\n    if i == len(arr):\n        subsets.append(s)\n        return\n    subset(i + 1, s)\n    temp = s[:] + [arr[i]]\n    subset(i + 1, temp)\n\ndef solve(v, ans):\n    nodes = set()\n    r = dict()\n    q = dict()\n    for (x, y) in v:\n        nodes.add(x)\n        nodes.add(y)\n        unite(x, y)\n    for node in nodes:\n        a = root(node)\n        if a in q:\n            q[a].append(node)\n        else:\n            q[a] = [node]\n        if a in r:\n            r[a] += 1\n        else:\n            r[a] = 1\n    for node in nodes:\n        roots[node] = node\n    for temp_arr in q.values():\n        d = dict()\n        (c1, c2) = (0, 0)\n        for (x, y) in v:\n            if x in temp_arr:\n                if x in d:\n                    d[x] += 1\n                else:\n                    d[x] = 1\n                if y in d:\n                    d[y] += 1\n                else:\n                    d[y] = 1\n        for value in d.values():\n            if value == 1:\n                c1 += 1\n            elif value == 2:\n                c2 += 1\n            else:\n                return ans\n        if c1 < 2:\n            return ans\n    p1 = len(r)\n    p2 = n - sum([value - 1 for value in r.values()])\n    q = factorials[p2] * (1 << p1)\n    if len(v) % 2 == 0:\n        ans += q\n    else:\n        ans -= q\n    return ans % (10 ** 9 + 7)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        if x < y:\n            arr.append((x, y))\n        else:\n            arr.append((y, x))\n    arr = list(set(arr))\n    arr.sort()\n    subsets = []\n    subset(0, [])\n    subsets.sort()\n    ans = factorials[n]\n    for v in subsets:\n        if len(v):\n            ans = solve(v, ans)\n    print(ans % (10 ** 9 + 7))", "from math import factorial\nroots = [i for i in range(100010)]\nMOD = 10 ** 9 + 7\nfactorials = [1] * 100010\nfor i in range(2, 100010):\n    factorials[i] = i * factorials[i - 1] % MOD\n\ndef nPr(n, r, MOD):\n    res = 1\n    for i in range(n - r + 1, n + 1):\n        res = res * i % MOD\n    return res\n\ndef root(x):\n    while x != roots[x]:\n        x = roots[x]\n    return x\n\ndef unite(x, y):\n    (p, q) = (root(x), root(y))\n    roots[p] = q\n\ndef find(x, y):\n    return roots[x] == roots[y]\n\ndef subset(i, s):\n    if i == len(arr):\n        subsets.append(s)\n        return\n    subset(i + 1, s)\n    temp = s[:] + [arr[i]]\n    subset(i + 1, temp)\n\ndef solve(v, ans):\n    nodes = set()\n    r = dict()\n    q = dict()\n    for (x, y) in v:\n        nodes.add(x)\n        nodes.add(y)\n        unite(x, y)\n    for node in nodes:\n        a = root(node)\n        if a in q:\n            q[a].append(node)\n        else:\n            q[a] = [node]\n        if a in r:\n            r[a] += 1\n        else:\n            r[a] = 1\n    for node in nodes:\n        roots[node] = node\n    for temp_arr in q.values():\n        d = dict()\n        (c1, c2) = (0, 0)\n        for (x, y) in v:\n            if x in temp_arr:\n                if x in d:\n                    d[x] += 1\n                else:\n                    d[x] = 1\n                if y in d:\n                    d[y] += 1\n                else:\n                    d[y] = 1\n        for value in d.values():\n            if value == 1:\n                c1 += 1\n            elif value == 2:\n                c2 += 1\n            else:\n                return ans\n        if c1 < 2:\n            return ans\n    p1 = len(r)\n    p2 = n - sum([value - 1 for value in r.values()])\n    q = nPr(p2, p1, MOD) * (1 << p1) * factorials[p2 - p1]\n    if len(v) % 2 == 0:\n        ans += q\n    else:\n        ans -= q\n    return ans % (10 ** 9 + 7)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        if x < y:\n            arr.append((x, y))\n        else:\n            arr.append((y, x))\n    arr = list(set(arr))\n    arr.sort()\n    subsets = []\n    subset(0, [])\n    subsets.sort()\n    ans = factorials[n]\n    for v in subsets:\n        if len(v):\n            ans = solve(v, ans)\n    print(ans % (10 ** 9 + 7))", "from math import factorial\nroots = [i for i in range(100010)]\nnPr = [[0 for _ in range(50)] for _ in range(100010)]\nMOD = 10 ** 9 + 7\nfactorials = [1] * 100010\nfor i in range(2, 100010):\n    factorials[i] = i * factorials[i - 1] % (10 ** 9 + 7)\n\ndef nPr(n, r, MOD):\n    res = 1\n    for i in range(n - r + 1, n + 1):\n        res = res * i % MOD\n    return res\n\ndef root(x):\n    while x != roots[x]:\n        x = roots[x]\n    return x\n\ndef unite(x, y):\n    (p, q) = (root(x), root(y))\n    roots[p] = q\n\ndef find(x, y):\n    return roots[x] == roots[y]\n\ndef subset(i, s):\n    if i == len(arr):\n        subsets.append(s)\n        return\n    subset(i + 1, s)\n    temp = s[:] + [arr[i]]\n    subset(i + 1, temp)\n\ndef solve(v, ans):\n    nodes = set()\n    r = dict()\n    q = dict()\n    for (x, y) in v:\n        nodes.add(x)\n        nodes.add(y)\n        unite(x, y)\n    for node in nodes:\n        a = root(node)\n        if a in q:\n            q[a].append(node)\n        else:\n            q[a] = [node]\n        if a in r:\n            r[a] += 1\n        else:\n            r[a] = 1\n    for node in nodes:\n        roots[node] = node\n    for temp_arr in q.values():\n        d = dict()\n        (c1, c2) = (0, 0)\n        for (x, y) in v:\n            if x in temp_arr:\n                if x in d:\n                    d[x] += 1\n                else:\n                    d[x] = 1\n                if y in d:\n                    d[y] += 1\n                else:\n                    d[y] = 1\n        for value in d.values():\n            if value == 1:\n                c1 += 1\n            elif value == 2:\n                c2 += 1\n            else:\n                return ans\n        if c1 < 2:\n            return ans\n    p1 = len(r)\n    p2 = n - sum([value - 1 for value in r.values()])\n    q = nPr(p2, p1, MOD) * (1 << p1) * factorials[p2 - p1]\n    if len(v) % 2 == 0:\n        ans += q\n    else:\n        ans -= q\n    return ans % (10 ** 9 + 7)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    arr = []\n    for _ in range(m):\n        (x, y) = map(int, input().split())\n        if x < y:\n            arr.append((x, y))\n        else:\n            arr.append((y, x))\n    arr = list(set(arr))\n    arr.sort()\n    subsets = []\n    subset(0, [])\n    subsets.sort()\n    ans = factorials[n]\n    for v in subsets:\n        if len(v):\n            ans = solve(v, ans)\n    print(ans % (10 ** 9 + 7))"]