["def square(m1, mod):\n    return mod_mul(m1, m1, mod)\n\ndef mod_mul(m1, m2, mod):\n    return [[(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod]]\n\ndef solve():\n    (n, mod) = map(int, input().split())\n    n = 2 * n - 1\n    ans = [[1, 1], [1, 0]]\n    tm = [[1, 1], [1, 0]]\n    exp = 1\n    up = 1\n    while 1:\n        if exp == n:\n            return ans\n        if exp + up > n:\n            tm = [[1, 1], [1, 0]]\n            up = 1\n        ans = mod_mul(ans, tm, mod)\n        tm = square(tm, mod)\n        exp += up\n        up *= 2\nfor _ in range(int(input())):\n    p = solve()\n    print('%d/%d' % (p[0][1], p[0][0]))", "def square(m1, mod):\n    return mod_mul(m1, m1, mod)\n\ndef mod_mul(m1, m2, mod):\n    return [[(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod]]\n\ndef solve():\n    (n, mod) = map(int, input().split())\n    n = 2 * n - 1\n    ans = [[1, 1], [1, 0]]\n    tm = [[1, 1], [1, 0]]\n    exp = 1\n    up = 1\n    while 1:\n        if exp == n:\n            return ans\n        if exp + up > n:\n            tm = [[1, 1], [1, 0]]\n            up = 1\n        ans = mod_mul(ans, tm, mod)\n        tm = square(tm, mod)\n        exp += up\n        up *= 2\nfor _ in range(int(input())):\n    p = solve()\n    print('%d/%d' % (p[0][1], p[0][0]))", "def mod_mul(m1, m2, mod):\n    return [[(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod]]\n\ndef solve():\n    (n, mod) = map(int, input().split())\n    n = 2 * n - 1\n    ans = [[1, 1], [1, 0]]\n    tm = [[1, 1], [1, 0]]\n    exp = 1\n    up = 1\n    while 1:\n        if exp == n:\n            return ans\n        if exp + up > n:\n            tm = [[1, 1], [1, 0]]\n            up = 1\n        ans = mod_mul(ans, tm, mod)\n        tm = mod_mul(tm, tm, mod)\n        exp += up\n        up *= 2\nfor _ in range(int(input())):\n    p = solve()\n    print('%d/%d' % (p[0][1], p[0][0]))", "def square(m1, mod):\n    return mod_mul(m1, m1, mod)\n\ndef mod_mul(m1, m2, mod):\n    return [[(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod]]\n\ndef solve():\n    (n, mod) = map(int, input().split())\n    n = 2 * n - 1\n    ans = [[1, 1], [1, 0]]\n    tm = [[1, 1], [1, 0]]\n    exp = 1\n    up = 1\n    while 1:\n        if exp == n:\n            return ans\n        if exp + up > n:\n            tm = [[1, 1], [1, 0]]\n            up = 1\n        ans = mod_mul(ans, tm, mod)\n        tm = square(tm, mod)\n        exp += up\n        up *= 2\nfor _ in range(int(input())):\n    p = solve()\n    print('%d/%d' % (p[0][1], p[0][0]))", "def li():\n    return list(map(int, input().split()))\n\ndef si():\n    return input().split()\n\ndef ii():\n    return int(input())\n\ndef ip():\n    return input()\nfor tastcas in range(int(input())):\n    (n, m) = li()\n    p = q = 1\n    nn = n - 1\n    for i in range(nn):\n        t = (p + q) % m\n        (p, q) = (t, (t + q) % m)\n    print(f'{p}/{q}')", "def li():\n    return list(map(int, input().split()))\n\ndef si():\n    return input().split()\n\ndef ii():\n    return int(input())\n\ndef ip():\n    return input()\nfor tastcas in range(int(input())):\n    (n, m) = li()\n    p = q = 1\n    nn = n - 1\n    for i in range(nn):\n        t = (p + q) % m\n        (p, q) = (t, (t + q) % m)\n    print(f'{p}/{q}')", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    (a, b) = (1, 1)\n    for j in range(1, n):\n        a += b\n        b += a\n        a %= m\n        b %= m\n    print(f'{a}/{b}')", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    (a, b) = (1, 1)\n    for j in range(1, n):\n        a += b\n        b += a\n        a %= m\n        b %= m\n    print(f'{a}/{b}')", "t = int(input())\nfor i in range(t):\n    (n, m) = map(int, input().split())\n    (a, b) = (1, 1)\n    for j in range(1, n):\n        a += b\n        b += a\n        a %= m\n        b %= m\n    print(f'{a}/{b}')", "t = int(input())\nfor _ in range(t):\n    (n, m) = [int(i) for i in input().split()]\n    (num, den) = (1, 1)\n    for i in range(1, n):\n        num = num + den\n        den = den + num\n        num = num % m\n        den = den % m\n    print(f'{num}/{den}')", "def gcd(a, b):\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\nfor _ in range(int(input())):\n    (n, m) = map(int, input().rstrip().split())\n    num = 1\n    den = 1\n    for i in range(2, n + 1):\n        num = (num + den) % m\n        den = (num + den) % m\n    print(str(num % m) + '/' + str(den % m))", "for tc in range(int(input().strip())):\n    (n, MOD) = [int(i) for i in input().split()]\n    (num, den) = (1, 1)\n    for i in range(n - 1):\n        num += den\n        den += num\n        num %= MOD\n        den %= MOD\n    print(str(num % MOD) + '/' + str(den % MOD))", "for tc in range(int(input().strip())):\n    (N, M) = map(int, input().strip().split())\n    (a, b) = (1, 1)\n    for i in range(1, N):\n        (a, b) = ((a + b) % M, (a + 2 * b) % M)\n    print(a, end='/')\n    print(b)", "def multiply(m1, m2, mod):\n    return [[(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod]]\n\ndef fibo(n, mod):\n    if n == 0:\n        return 1\n    res = [[1, 1], [1, 0]]\n    temp = [[1, 1], [1, 0]]\n    exp = factor = 1\n    while True:\n        if exp == n:\n            return res\n        if exp + factor > n:\n            temp = [[1, 1], [1, 0]]\n            factor = 1\n        res = multiply(res, temp, mod)\n        temp = multiply(temp, temp, mod)\n        exp += factor\n        factor *= 2\nfor t in range(0, int(input())):\n    (n, mod) = map(int, input().split())\n    mat = fibo(2 * n - 1, mod)\n    print('%d/%d' % (mat[0][1], mat[0][0]))", "def square(m1, mod):\n    return mul(m1, m1, mod)\n\ndef mul(m1, m2, mod):\n    return [[(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod]]\n\ndef fib(n, mod):\n    if n == 0:\n        return 1\n    ans = [[1, 1], [1, 0]]\n    tm = [[1, 1], [1, 0]]\n    exp = 1\n    up = 1\n    while 1:\n        if exp == n:\n            return ans\n        if exp + up > n:\n            tm = [[1, 1], [1, 0]]\n            up = 1\n        ans = mul(ans, tm, mod)\n        tm = square(tm, mod)\n        exp += up\n        up *= 2\nT = int(input())\nwhile T > 0:\n    T -= 1\n    data = input().split()\n    (n, m) = (int(data[0]), int(data[1]))\n    p = fib(2 * n - 1, m)\n    print('%d/%d' % (p[0][1], p[0][0]))", "def main():\n    T = eval(input())\n    for t in range(T):\n        (n, m) = tuple([int(x) for x in input().split()])\n        (a, b) = (0, 1)\n        for i in range(n):\n            (a, b) = ((a + b) % m, a)\n            (a, b) = ((a + b) % m, a)\n        num = str(b)\n        den = str(a)\n        print(num + '/' + den)\nmain()", "def main():\n    T = eval(input())\n    for t in range(T):\n        (n, m) = tuple([int(x) for x in input().split()])\n        a = [0, 1]\n        for i in range(2 * n + 10):\n            a.append((a[-1] + a[-2]) % m)\n        num = str(a[2 * n - 1])\n        den = str(a[2 * n])\n        print(num + '/' + den)\nmain()", "def main():\n    T = eval(input())\n    for t in range(T):\n        (n, m) = tuple([int(x) for x in input().split()])\n        a = [0, 1]\n        for i in range(2 * n + 10):\n            a.append((a[-1] + a[-2]) % m)\n        num = str(a[2 * n - 1])\n        den = str(a[2 * n])\n        print(num + '/' + den)\nmain()", "def square(m1, mod):\n    return mul(m1, m1, mod)\n\ndef mul(m1, m2, mod):\n    return [[(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod]]\n\ndef fib(n, mod):\n    if n == 0:\n        return 1\n    ans = [[1, 1], [1, 0]]\n    tm = [[1, 1], [1, 0]]\n    exp = 1\n    up = 1\n    while 1:\n        if exp == n:\n            return ans\n        if exp + up > n:\n            tm = [[1, 1], [1, 0]]\n            up = 1\n        ans = mul(ans, tm, mod)\n        tm = square(tm, mod)\n        exp += up\n        up *= 2\nT = int(input())\nwhile T > 0:\n    T -= 1\n    data = input().split()\n    (n, m) = (int(data[0]), int(data[1]))\n    p = fib(2 * n - 1, m)\n    print('%d/%d' % (p[0][1], p[0][0]))", "def square(m1, mod):\n    return mul(m1, m1, mod)\n\ndef mul(m1, m2, mod):\n    return [[(m1[0][0] * m2[0][0] + m1[0][1] * m2[1][0]) % mod, (m1[0][0] * m2[0][1] + m1[0][1] * m2[1][1]) % mod], [(m1[1][0] * m2[0][0] + m1[1][1] * m2[1][0]) % mod, (m1[1][0] * m2[0][1] + m1[1][1] * m2[1][1]) % mod]]\n\ndef fib(n, mod):\n    if n == 0:\n        return 1\n    ans = [[1, 1], [1, 0]]\n    tm = [[1, 1], [1, 0]]\n    exp = 1\n    up = 1\n    while 1:\n        if exp == n:\n            return ans[0][0]\n        if exp + up > n:\n            tm = [[1, 1], [1, 0]]\n            up = 1\n        ans = mul(ans, tm, mod)\n        tm = square(tm, mod)\n        exp += up\n        up *= 2\nT = int(input())\nwhile T > 0:\n    T -= 1\n    data = input().split()\n    (n, m) = (int(data[0]), int(data[1]))\n    p = fib(2 * (n - 1), m)\n    q = fib(2 * n - 1, m)\n    print('%d/%d' % (p, q))"]