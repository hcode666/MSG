["def main():\n    from sys import stdin, stderr\n    from collections import deque\n\n    def findout(graph):\n        if len(graph) <= 2:\n            return 2\n\n        def bfs(graph):\n            N = len(graph)\n            q = deque([0])\n            visit = []\n            parent = [-1] * N\n            while q:\n                v = q.popleft()\n                visit += [v]\n                for adj in graph[v]:\n                    if adj != parent[v]:\n                        q.append(adj)\n                        parent[adj] = v\n            return (parent, visit)\n        N = len(graph)\n        (parent, visit) = bfs(graph)\n        bfsvisit = visit[::-1]\n        can1 = [0] * N\n        can2 = [0] * N\n        coin = [0] * N\n        for x in bfsvisit:\n            if parent[x] != -1:\n                if len(graph[x]) == 1:\n                    coin[x] = 1\n                    can2[x] = 0\n                    can1[x] = 1\n                else:\n                    need = 0\n                    count = 0\n                    for y in graph[x]:\n                        if need == 1:\n                            break\n                        if y != parent[x]:\n                            if coin[y] == 0:\n                                if can2[y] == 0:\n                                    need = 1\n                                    break\n                                else:\n                                    for z in graph[y]:\n                                        if z != parent[y]:\n                                            if coin[z] == 1:\n                                                if can2[z] == 0:\n                                                    need = 1\n                                                    break\n                    if need == 1:\n                        coin[x] = 1\n                        count = 0\n                        for y in graph[x]:\n                            if y != parent[x]:\n                                if coin[y] == 1:\n                                    count = 1\n                                    break\n                        can2[x] = 1\n                    else:\n                        count = 0\n                        for y in graph[x]:\n                            if y != parent[x]:\n                                if coin[y] == 1:\n                                    count += 1\n                        if count == 1:\n                            coin[x] = 0\n                            can1[x] = 1\n                            can2[x] = 0\n                        elif count >= 2:\n                            coin[x] = 0\n                            can2[x] = 1\n                            can1[x] = 1\n                        else:\n                            coin[x] = 1\n                            can2[x] = 1\n                            can1[x] = 1\n            elif len(graph[x]) == 1:\n                coin[x] = 1\n                can2[x] = 0\n                can1[x] = 1\n            else:\n                need = 0\n                count = 0\n                for y in graph[x]:\n                    if need == 1:\n                        break\n                    if y != parent[x]:\n                        if coin[y] == 0:\n                            if can2[y] == 0:\n                                need = 1\n                                break\n                            else:\n                                for z in graph[y]:\n                                    if z != parent[y]:\n                                        if coin[z] == 1:\n                                            if can2[z] == 0:\n                                                need = 1\n                                                break\n                        elif can2[y] == 0:\n                            need = 1\n                if need == 1:\n                    coin[x] = 1\n                else:\n                    count = 0\n                    for y in graph[x]:\n                        if coin[y] == 1:\n                            count += 1\n                    if count > 1:\n                        coin[x] = 0\n                    else:\n                        coin[x] = 1\n        return sum(coin)\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        graph = [[] for i in range(N)]\n        for _ in range(N - 1):\n            (u, v) = map(int, stdin.readline().strip().split())\n            (u, v) = (u - 1, v - 1)\n            graph[u] += [v]\n            graph[v] += [u]\n        if N > 1:\n            print(findout(graph))\n        else:\n            print(-1)\nmain()", "def main():\n    from sys import stdin, stderr\n    from collections import deque\n\n    def findout(graph):\n        if len(graph) <= 2:\n            return 2\n\n        def bfs(graph):\n            N = len(graph)\n            q = deque([0])\n            visit = []\n            parent = [-1] * N\n            while q:\n                v = q.popleft()\n                visit += [v]\n                for adj in graph[v]:\n                    if adj != parent[v]:\n                        q.append(adj)\n                        parent[adj] = v\n            return (parent, visit)\n        N = len(graph)\n        (parent, visit) = bfs(graph)\n        bfsvisit = visit[::-1]\n        can1 = [0] * N\n        can2 = [0] * N\n        coin = [0] * N\n        for x in bfsvisit:\n            if parent[x] != -1:\n                if len(graph[x]) == 1:\n                    coin[x] = 1\n                    can2[x] = 0\n                    can1[x] = 1\n                else:\n                    need = 0\n                    count = 0\n                    for y in graph[x]:\n                        if need == 1:\n                            break\n                        if y != parent[x]:\n                            if coin[y] == 0:\n                                if can2[y] == 0:\n                                    need = 1\n                                    break\n                                else:\n                                    for z in graph[y]:\n                                        if z != parent[y]:\n                                            if coin[z] == 1:\n                                                if can2[z] == 0:\n                                                    need = 1\n                                                    break\n                    if need == 1:\n                        coin[x] = 1\n                        count = 0\n                        for y in graph[x]:\n                            if y != parent[x]:\n                                if coin[y] == 1:\n                                    count = 1\n                                    break\n                        can2[x] = 1\n                    else:\n                        count = 0\n                        for y in graph[x]:\n                            if y != parent[x]:\n                                if coin[y] == 1:\n                                    count += 1\n                        if count == 1:\n                            coin[x] = 0\n                            can1[x] = 1\n                            can2[x] = 0\n                        elif count >= 2:\n                            coin[x] = 0\n                            can2[x] = 1\n                            can1[x] = 1\n                        else:\n                            coin[x] = 1\n                            can2[x] = 1\n                            can1[x] = 1\n            elif len(graph[x]) == 1:\n                coin[x] = 1\n                can2[x] = 0\n                can1[x] = 1\n            else:\n                need = 0\n                count = 0\n                for y in graph[x]:\n                    if need == 1:\n                        break\n                    if y != parent[x]:\n                        if coin[y] == 0:\n                            if can2[y] == 0:\n                                need = 1\n                                break\n                            else:\n                                for z in graph[y]:\n                                    if z != parent[y]:\n                                        if coin[z] == 1:\n                                            if can2[z] == 0:\n                                                need = 1\n                                                break\n                        elif can2[y] == 0:\n                            need = 1\n                if need == 1:\n                    coin[x] = 1\n                else:\n                    count = 0\n                    for y in graph[x]:\n                        if coin[y] == 1:\n                            count += 1\n                    if count > 1:\n                        coin[x] = 0\n                    else:\n                        coin[x] = 1\n        return sum(coin)\n    T = int(input())\n    for _ in range(T):\n        N = int(input())\n        graph = [[] for i in range(N)]\n        for _ in range(N - 1):\n            (u, v) = map(int, stdin.readline().strip().split())\n            (u, v) = (u - 1, v - 1)\n            graph[u] += [v]\n            graph[v] += [u]\n        if N > 1:\n            print(findout(graph))\n        else:\n            print(-1)\nmain()"]