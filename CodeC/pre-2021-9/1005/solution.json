["class DisjointNode:\n    el: any\n    parent = None\n    opposite = None\n    rank: int = 0\n\n    def __init__(self, el) -> None:\n        self.el = el\n        self.parent = self\n\n    def add_element(self, el):\n        new_el = DisjointNode(el)\n        new_el.parent = self\n        return new_el\n\ndef find_parent(node: DisjointNode) -> DisjointNode:\n    if node.parent != node:\n        node.parent = find_parent(node=node.parent)\n    return node.parent\n\ndef merge_sets(node1: DisjointNode, node2: DisjointNode) -> DisjointNode:\n    (node1, node2) = (find_parent(node1), find_parent(node2))\n    if node1.rank > node2.rank:\n        node2.parent = node1\n    else:\n        node1.parent = node2\n        if node1.rank == node2.rank:\n            node2.rank += 1\n    return node1.parent\n\ndef answer_of_task(n: int, qs: list) -> str:\n    sets: list[DisjointNode] = [DisjointNode(el=i) for i in range(n + 1)]\n    for q in qs:\n        (i, j) = (q[0], q[1])\n        val = q[2]\n        if i == j:\n            if val != 0:\n                return 'no'\n            continue\n        sets[i] = find_parent(sets[i])\n        sets[j] = find_parent(sets[j])\n        sets[i].opposite = None if sets[i].opposite is None else find_parent(sets[i].opposite)\n        sets[j].opposite = None if sets[j].opposite is None else find_parent(sets[j].opposite)\n        if val == 0:\n            if sets[i].opposite == sets[j]:\n                return 'no'\n            merge_sets(sets[i], sets[j])\n        else:\n            if sets[i] == sets[j]:\n                return 'no'\n            sets[i].opposite = sets[j] if sets[i].opposite is None else merge_sets(sets[i].opposite, sets[j])\n            sets[j].opposite = sets[i] if sets[j].opposite is None else merge_sets(sets[j].opposite, sets[i])\n    return 'yes'\nT = int(input())\nfor k in range(T):\n    (N, Q) = [int(x) for x in input().split()]\n    qs = [[int(x) for x in input().split()] for i in range(Q)]\n    print(answer_of_task(n=N, qs=qs))", "class DisjointNode:\n    el: any\n    parent = None\n    opposite = None\n    rank: int = 0\n\n    def __init__(self, el) -> None:\n        self.el = el\n        self.parent = self\n\n    def add_element(self, el):\n        new_el = DisjointNode(el)\n        new_el.parent = self\n        return new_el\n\ndef find_parent(node: DisjointNode) -> DisjointNode:\n    if node.parent != node:\n        node.parent = find_parent(node=node.parent)\n    return node.parent\n\ndef merge_sets(node1: DisjointNode, node2: DisjointNode) -> DisjointNode:\n    (node1, node2) = (find_parent(node1), find_parent(node2))\n    if node1.rank > node2.rank:\n        node2.parent = node1\n    else:\n        node1.parent = node2\n        if node1.rank == node2.rank:\n            node2.rank += 1\n    return node1.parent\n\ndef answer_of_task(n: int, qs: list) -> str:\n    sets: list[DisjointNode] = [DisjointNode(el=i) for i in range(n + 1)]\n    for q in qs:\n        (i, j) = (q[0], q[1])\n        val = q[2]\n        if i == j:\n            if val != 0:\n                return 'no'\n            continue\n        sets[i] = find_parent(sets[i])\n        sets[j] = find_parent(sets[j])\n        sets[i].opposite = None if sets[i].opposite is None else find_parent(sets[i].opposite)\n        sets[j].opposite = None if sets[j].opposite is None else find_parent(sets[j].opposite)\n        if val == 0:\n            if sets[i].opposite == sets[j]:\n                return 'no'\n            merge_sets(sets[i], sets[j])\n        else:\n            if sets[i] == sets[j]:\n                return 'no'\n            sets[i].opposite = sets[j] if sets[i].opposite is None else merge_sets(sets[i].opposite, sets[j])\n            sets[j].opposite = sets[i] if sets[j].opposite is None else merge_sets(sets[j].opposite, sets[i])\n    return 'yes'\nT = int(input())\nfor k in range(T):\n    (N, Q) = [int(x) for x in input().split()]\n    qs = [[int(x) for x in input().split()] for i in range(Q)]\n    print(answer_of_task(n=N, qs=qs))", "class DisjointNode:\n    el: any\n    parent = None\n    opposite = None\n    rank: int = 0\n\n    def __init__(self, el) -> None:\n        self.el = el\n        self.parent = self\n\n    def add_element(self, el):\n        new_el = DisjointNode(el)\n        new_el.parent = self\n        return new_el\n\ndef find_parent(node: DisjointNode) -> DisjointNode:\n    if node.parent != node:\n        node.parent = find_parent(node=node.parent)\n    return node.parent\n\ndef merge_sets(node1: DisjointNode, node2: DisjointNode) -> DisjointNode:\n    (node1, node2) = (find_parent(node1), find_parent(node2))\n    if node1.rank > node2.rank:\n        node2.parent = node1\n    else:\n        node1.parent = node2\n        if node1.rank == node2.rank:\n            node2.rank += 1\n    return node1.parent\n\ndef answer_of_task(n: int, qs: list) -> str:\n    sets: list[DisjointNode] = [DisjointNode(el=i) for i in range(n + 1)]\n    for q in qs:\n        (i, j) = (q[0], q[1])\n        val = q[2]\n        if i == j:\n            if val != 0:\n                return 'no'\n            continue\n        sets[i] = find_parent(sets[i])\n        sets[j] = find_parent(sets[j])\n        sets[i].opposite = None if sets[i].opposite is None else find_parent(sets[i].opposite)\n        sets[j].opposite = None if sets[j].opposite is None else find_parent(sets[j].opposite)\n        if val == 0:\n            if sets[i].opposite == sets[j]:\n                return 'no'\n            merge_sets(sets[i], sets[j])\n        else:\n            if sets[i] == sets[j]:\n                return 'no'\n            sets[i].opposite = sets[j] if sets[i].opposite is None else merge_sets(sets[i].opposite, sets[j])\n            sets[j].opposite = sets[i] if sets[j].opposite is None else merge_sets(sets[j].opposite, sets[i])\n    return 'yes'\nT = int(input())\nfor k in range(T):\n    (N, Q) = [int(x) for x in input().split()]\n    qs = [[int(x) for x in input().split()] for i in range(Q)]\n    print(answer_of_task(n=N, qs=qs))", "import sys\nsys.setrecursionlimit(1000000)\nmod = 10 ** 9 + 7\nts = int(input())\nwhile ts > 0:\n    (n, q) = list(map(int, input().split()))\n    ncc = n - 1\n    par = [i for i in range(n)]\n    rank = [1] * n\n    xor = [0] * n\n    flag = 1\n\n    def find(a):\n        if par[a] == a:\n            return a\n        else:\n            temp = find(par[a])\n            xor[a] ^= xor[par[a]]\n            par[a] = temp\n            return temp\n\n    def union(a, b):\n        (a, b) = (find(a), find(b))\n        if a == b:\n            return\n        if rank[a] > rank[b]:\n            par[b] = a\n            rank[a] += rank[b]\n        elif rank[a] < rank[b]:\n            par[a] = b\n            rank[b] += rank[a]\n        else:\n            par[b] = a\n            rank[a] += rank[b]\n        par[b] = a\n    for _ in range(q):\n        (a, b, x) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        if flag == -1:\n            continue\n        para = find(a)\n        parb = find(b)\n        if para == parb and xor[a] ^ xor[b] != x:\n            flag = -1\n            continue\n        if para != parb:\n            if rank[para] < rank[parb]:\n                xor[para] = xor[a] ^ xor[b] ^ x\n                par[para] = parb\n                rank[parb] += rank[para]\n            else:\n                xor[parb] = xor[a] ^ xor[b] ^ x\n                par[parb] = para\n                rank[para] += rank[parb]\n            ncc -= 1\n    if flag != -1:\n        print('yes')\n    else:\n        print('no')\n    ts -= 1", "import sys\nsys.setrecursionlimit(1000000)\nmod = 10 ** 9 + 7\nts = int(input())\nwhile ts > 0:\n    (n, q) = list(map(int, input().split()))\n    ncc = n - 1\n    par = [i for i in range(n)]\n    rank = [1] * n\n    xor = [0] * n\n    flag = 1\n\n    def find(a):\n        if par[a] == a:\n            return a\n        else:\n            temp = find(par[a])\n            xor[a] ^= xor[par[a]]\n            par[a] = temp\n            return temp\n\n    def union(a, b):\n        (a, b) = (find(a), find(b))\n        if a == b:\n            return\n        if rank[a] > rank[b]:\n            par[b] = a\n            rank[a] += rank[b]\n        elif rank[a] < rank[b]:\n            par[a] = b\n            rank[b] += rank[a]\n        else:\n            par[b] = a\n            rank[a] += rank[b]\n        par[b] = a\n    for _ in range(q):\n        (a, b, x) = list(map(int, input().split()))\n        a -= 1\n        b -= 1\n        if flag == -1:\n            continue\n        para = find(a)\n        parb = find(b)\n        if para == parb and xor[a] ^ xor[b] != x:\n            flag = -1\n            continue\n        if para != parb:\n            if rank[para] < rank[parb]:\n                xor[para] = xor[a] ^ xor[b] ^ x\n                par[para] = parb\n                rank[parb] += rank[para]\n            else:\n                xor[parb] = xor[a] ^ xor[b] ^ x\n                par[parb] = para\n                rank[para] += rank[parb]\n            ncc -= 1\n    if flag != -1:\n        print('yes')\n    else:\n        print('no')\n    ts -= 1", "for _ in range(int(input())):\n    (N, Q) = map(int, input().split())\n    c = [-1] * N\n    b = []\n    flag = 0\n    for j in range(Q):\n        (p, q, r) = map(int, input().split())\n        b.append([p, q, r])\n    b.sort()\n    for i in range(Q):\n        (p, q, r) = b[i]\n        p -= 1\n        q -= 1\n        if p == q:\n            if r != 0:\n                flag = 1\n                break\n        elif c[p] != -1 and c[q] != -1:\n            if abs(c[p] - c[q]) != r:\n                flag = 1\n                break\n        elif c[p] == -1 and c[q] == -1:\n            c[q] = 0\n            c[p] = c[q] + r\n        elif c[p] == -1:\n            if c[q] == 1:\n                c[p] = c[q] - r\n            else:\n                c[p] = c[q] + r\n        elif c[p] == 1:\n            c[q] = c[p] - r\n        else:\n            c[q] = c[p] + r\n    if flag == 1:\n        print('no')\n    else:\n        print('yes')", "def union(a, b):\n    fa = find(a)\n    fb = find(b)\n    if rank[fa] > rank[fb]:\n        dsu[fb] = fa\n    elif rank[fb] > rank[fa]:\n        dsu[fa] = fb\n    else:\n        rank[fa] += 1\n        dsu[fb] = fa\n\ndef find(x):\n    while x != dsu[x]:\n        dsu[x] = dsu[dsu[x]]\n        x = dsu[x]\n    return x\nfor _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    dsu = [i for i in range(n)]\n    rank = [0] * n\n    ones = []\n    zeros = []\n    for i in range(q):\n        (a, b, c) = map(int, input().split())\n        if c == 1:\n            ones.append([a - 1, b - 1])\n        else:\n            zeros.append([a - 1, b - 1])\n    flag = 0\n    for i in zeros:\n        f1 = find(i[0])\n        f2 = find(i[1])\n        union(i[0], i[1])\n    color = [0] * n\n    for i in ones:\n        f1 = find(i[0])\n        f2 = find(i[1])\n        if f1 == f2:\n            flag = 1\n        elif color[f1] == 0 and color[f2] == 0:\n            color[f1] = -1\n            color[f2] = 1\n        elif color[f1] != 0 and color[f2] == 0:\n            color[f2] = -color[f1]\n        elif color[f2] != 0 and color[f1] == 0:\n            color[f1] = -color[f2]\n        elif color[f2] == color[f1]:\n            flag = 1\n    print('yes' if flag == 0 else 'no')", "store = dict()\n\nclass node:\n\n    def __init__(self, data):\n        self.data = data\n        self.parent = None\n        self.rank = 0\n        self.color = None\n\ndef makeset(data):\n    new_node = node(data)\n    new_node.parent = new_node\n    store[data] = new_node\n\ndef union(data1, data2):\n    node1 = store[data1]\n    node2 = store[data2]\n    parent1 = findset(node1)\n    parent2 = findset(node2)\n    if parent1.data == parent2.data:\n        return\n    if parent1.rank >= parent2.rank:\n        parent1.rank += int(parent1.rank == parent2.rank)\n        parent2.parent = parent1\n    else:\n        parent1.parent = parent2\n\ndef findset(new_node):\n    parent = new_node.parent\n    if new_node == parent:\n        return new_node\n    new_node.parent = findset(new_node.parent)\n    return new_node.parent\n\ndef repre(data):\n    return findset(store[data])\nfrom sys import stdin, stdout\nfor _ in range(int(stdin.readline())):\n    (n, q) = map(int, stdin.readline().split())\n    store = dict()\n    different = []\n    for i in range(1, n + 1):\n        makeset(i)\n    for i in range(q):\n        (a, b, c) = map(int, stdin.readline().split())\n        if c == 0:\n            union(a, b)\n        else:\n            different.append([a, b])\n    ans = True\n    for i in range(len(different)):\n        ob1 = repre(different[i][0])\n        ob2 = repre(different[i][1])\n        if ob1.data == ob2.data:\n            ans = 0\n            break\n        elif ob1.color == ob2.color and ob1.color != None:\n            ans = 0\n            break\n        elif ob1.color == None and ob2.color == None:\n            ob1.color = True\n            ob2.color = not ob1.color\n        elif ob1.color == None:\n            ob1.color = not ob2.color\n        elif ob2.color == None:\n            ob2.color = not ob1.color\n    if ans:\n        stdout.write('yes\\n')\n    else:\n        stdout.write('no\\n')", "for _ in range(int(input())):\n    (N, Q) = map(int, input().split())\n    c = [-1] * N\n    b = []\n    flag = 0\n    for j in range(Q):\n        (p, q, r) = map(int, input().split())\n        b.append([p, q, r])\n    b.sort()\n    for i in range(Q):\n        (p, q, r) = b[i]\n        p -= 1\n        q -= 1\n        if p == q:\n            if r != 0:\n                flag = 1\n                break\n        elif c[p] != -1 and c[q] != -1:\n            if abs(c[p] - c[q]) != r:\n                flag = 1\n                break\n        elif c[p] == -1 and c[q] == -1:\n            c[q] = 0\n            c[p] = c[q] + r\n        elif c[p] == -1:\n            if c[q] == 1:\n                c[p] = c[q] - r\n            else:\n                c[p] = c[q] + r\n        elif c[p] == 1:\n            c[q] = c[p] - r\n        else:\n            c[q] = c[p] + r\n    if flag == 1:\n        print('no')\n    else:\n        print('yes')", "import sys\nsys.setrecursionlimit(1000000)\nt = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    par = [i for i in range(2 * n)]\n\n    def get(u):\n        if u != par[u]:\n            par[u] = get(par[u])\n        return par[u]\n\n    def union(u, v):\n        par[get(u)] = get(v)\n    for i in range(q):\n        (i, j, val) = map(int, input().split())\n        i -= 1\n        j -= 1\n        if val == 0:\n            union(i, j)\n            union(i + n, j + n)\n        else:\n            union(i, j + n)\n            union(i + n, j)\n    if any((get(i) == get(i + n) for i in range(n))):\n        print('no')\n    else:\n        print('yes')", "def find(parent, i, distance):\n    root = i\n    while parent[root] != root:\n        root = parent[root]\n        distance[i] += distance[root]\n    return root\n\ndef find2(parent, i, distance):\n    root = i\n    while parent[root] != root:\n        root = parent[root]\n    return root\n\ndef update(parent, des, distance, dis, new_parent):\n    root = des\n    while parent[root] != new_parent:\n        root = parent[root]\n        temp = distance[root]\n        distance[root] = dis + distance[des]\n        dis = temp\n        des = root\n\ndef union(parent, size, x, y, cycle, distance, parent1, parent2):\n    parent_x = parent1\n    parent_y = parent2\n    if parent_x != parent_y:\n        if cycle[parent_x] == 1:\n            size[parent_x] += size[parent_y]\n            parent[parent_y] = parent_x\n        elif cycle[parent_y] == 1:\n            size[parent_y] += size[parent_x]\n            parent[parent_x] = parent_y\n        elif size[parent_x] < size[parent_y]:\n            size[parent_y] += size[parent_x]\n            parent[parent_x] = parent_y\n        else:\n            size[parent_x] += size[parent_y]\n            parent[parent_y] = parent_x\ntest = int(input())\ni = 1\nwhile i <= test:\n    c = 0\n    s1 = list(map(int, input().split()))\n    n = s1[0]\n    q = s1[1]\n    distance = []\n    cycle = []\n    edges = []\n    parent = []\n    size = []\n    for j in range(n + 1):\n        distance.append(0)\n        cycle.append(0)\n        edges.append([])\n        parent.append(j)\n        size.append(1)\n    j = 1\n    while j <= q:\n        s2 = list(map(int, input().split()))\n        src = s2[0]\n        des = s2[1]\n        weight = s2[2]\n        parent[src] = find(parent, src, distance)\n        parent[des] = find(parent, des, distance)\n        if src == des:\n            if weight != 0:\n                c = 1\n        elif src != des:\n            if parent[src] == parent[des]:\n                d1 = distance[des] - distance[src]\n                if d1 % 2 == 0 and weight % 2 != 0:\n                    c = 1\n                elif d1 % 2 != 0 and weight % 2 == 0:\n                    c = 1\n            else:\n                prev1 = parent[src]\n                prev2 = parent[des]\n                dis = distance[src]\n                dis1 = distance[des]\n                union(parent, size, src, des, cycle, distance, parent[src], parent[des])\n                new1 = find2(parent, src, distance)\n                new2 = find2(parent, des, distance)\n                if new1 == prev1:\n                    distance[des] = distance[src] + weight\n                    if prev2 != des:\n                        update(parent, des, distance, dis1, new1)\n                    parent[des] = find2(parent, des, distance)\n                else:\n                    distance[src] = distance[des] + weight\n                    if prev1 != src:\n                        update(parent, src, distance, dis, new1)\n                    parent[src] = find2(parent, src, distance)\n        j += 1\n    i += 1\n    if c == 1:\n        print('no')\n    else:\n        print('yes')", "from collections import defaultdict\nfor _ in range(int(input())):\n    (n, q) = list(map(int, input().split()))\n    graph = defaultdict(list)\n    pair = {}\n    ok = True\n    for x in range(q):\n        (i, j, val) = list(map(int, input().split()))\n        if not ok:\n            continue\n        if i == j and val:\n            ok = False\n        else:\n            if (i, j) in pair:\n                if val != pair[i, j]:\n                    ok = False\n                continue\n            graph[i].append(j)\n            graph[j].append(i)\n            (pair[i, j], pair[j, i]) = (val, val)\n    if not ok:\n        print('no')\n    else:\n        visited = [False] * (n + 1)\n        color = [0] * (n + 1)\n        for i in range(1, n + 1):\n            if not visited[i]:\n                visited[i] = True\n                color[i] = 1\n                st = [i]\n                while st:\n                    v = st.pop()\n                    for nb in graph[v]:\n                        if not visited[nb]:\n                            visited[nb] = True\n                            st.append(nb)\n                            if pair[v, nb] == 0:\n                                color[nb] = color[v]\n                            else:\n                                color[nb] = -1 * color[v]\n                        else:\n                            if pair[v, nb] == 0 and color[v] != color[nb]:\n                                ok = False\n                                break\n                            if pair[v, nb] == 1 and color[nb] != -1 * color[v]:\n                                ok = False\n                                break\n        if ok:\n            print('yes')\n        else:\n            print('no')", "class node:\n\n    def __init__(self, key):\n        self.data = key\n        self.parent = None\n        self.rank = 0\n        self.color = None\n\nclass disjoint:\n\n    def __init__(self, n):\n        self.mapp = [None] * n\n        for i in range(n):\n            self.mapp[i] = node(i)\n            self.mapp[i].parent = self.mapp[i]\n\n    def find(self, a):\n        node1 = self.mapp[a]\n        while 1:\n            if node1.parent == node1:\n                break\n            else:\n                node1 = node1.parent\n        if node1.rank >= 2:\n            self.mapp[a].parent = node1\n        return node1\n\n    def union(self, a, b):\n        rep1 = self.find(a)\n        rep2 = self.find(b)\n        if rep1.color == 0 and rep2.color == 1 or (rep2.color == 0 and rep1.color == 1):\n            return False\n        elif rep1.rank == rep2.rank:\n            rep1.rank += 1\n            rep2.rank = 0\n            rep2.parent = rep1\n        elif rep1.rank > rep2.rank:\n            rep1.rank += 1\n            rep2.rank = 0\n            rep2.parent = rep1\n        else:\n            rep2.rank += 1\n            rep1.rank = 0\n            rep1.parent = rep2\n        return True\n\n    def colored(self, a, b):\n        rep1 = self.find(a)\n        rep2 = self.find(b)\n        if rep1 == rep2:\n            return False\n        elif rep1.color == None and rep2.color == None:\n            rep1.color = 0\n            rep2.color = 1\n        elif rep2.color == None:\n            rep2.color = (rep1.color + 1) % 2\n        elif rep1.color == None:\n            rep1.color = (rep2.color + 1) % 2\n        elif rep1.color == rep2.color:\n            return False\n        return True\nt = int(input())\nfor i in range(t):\n    (n, q) = map(int, input().strip().split())\n    d = disjoint(n)\n    flag = 0\n    for j in range(q):\n        (s0, s1, s2) = map(int, input().strip().split())\n        if flag == 0:\n            if s0 == s1:\n                if s2 == 1:\n                    flag = 1\n            elif s2 == 1:\n                if d.colored(s0 - 1, s1 - 1) == False:\n                    flag = 1\n            elif s2 == 0:\n                if d.union(s0 - 1, s1 - 1) == False:\n                    flag = 1\n    if flag == 0:\n        print('yes')\n    else:\n        print('no')", "for i in range(int(input())):\n    state = 0\n    (n, q) = map(int, input().split())\n    d = []\n    k = 0\n    while k <= n:\n        d.append(-1)\n        k += 1\n    gg = []\n    k = 1\n    while k <= q:\n        (a, b, c) = map(int, input().split())\n        gg.append([a, b, c])\n        k += 1\n    gg.sort()\n    k = 0\n    while k < q:\n        if gg[k][0] == gg[k][1]:\n            if gg[k][2] == 1:\n                state = 1\n                break\n        elif d[gg[k][0]] == -1 and d[gg[k][1]] == -1:\n            d[gg[k][0]] = 0\n            if gg[k][2] == 0:\n                d[gg[k][1]] = 0\n            else:\n                d[gg[k][1]] = 1\n        elif d[gg[k][0]] != -1 and d[gg[k][1]] == -1:\n            d[gg[k][1]] = abs(gg[k][2] - d[gg[k][0]])\n        elif d[gg[k][0]] == -1 and d[gg[k][1]] != -1:\n            d[gg[k][0]] = abs(gg[k][2] - d[gg[k][1]])\n        elif d[gg[k][0]] != -1 and d[gg[k][1]] != -1:\n            if gg[k][2] == 0 and d[gg[k][0]] != d[gg[k][1]]:\n                state = 1\n                break\n            if gg[k][2] == 1 and d[gg[k][0]] == d[gg[k][1]]:\n                state = 1\n                break\n        k += 1\n    if state == 0:\n        print('yes')\n    else:\n        print('no')", "for i in range(int(input())):\n    state = 0\n    (n, q) = map(int, input().split())\n    d = []\n    k = 0\n    while k <= n:\n        d.append(-1)\n        k += 1\n    gg = []\n    k = 1\n    while k <= q:\n        (a, b, c) = map(int, input().split())\n        gg.append([a, b, c])\n        k += 1\n    gg.sort()\n    k = 0\n    while k < q:\n        if gg[k][0] == gg[k][1]:\n            if gg[k][2] == 1:\n                state = 1\n                break\n        elif d[gg[k][0]] == -1 and d[gg[k][1]] == -1:\n            d[gg[k][0]] = 0\n            if gg[k][2] == 0:\n                d[gg[k][1]] = 0\n            else:\n                d[gg[k][1]] = 1\n        elif d[gg[k][0]] != -1 and d[gg[k][1]] == -1:\n            d[gg[k][1]] = abs(gg[k][2] - d[gg[k][0]])\n        elif d[gg[k][0]] == -1 and d[gg[k][1]] != -1:\n            d[gg[k][0]] = abs(gg[k][2] - d[gg[k][1]])\n        elif d[gg[k][0]] != -1 and d[gg[k][1]] != -1:\n            if gg[k][2] == 0 and d[gg[k][0]] != d[gg[k][1]]:\n                state = 1\n                break\n            if gg[k][2] == 1 and d[gg[k][0]] == d[gg[k][1]]:\n                state = 1\n                break\n        k += 1\n    if state == 0:\n        print('yes')\n    else:\n        print('no')", "from collections import defaultdict\nfor _ in range(int(input())):\n    sames = defaultdict(list)\n    differents = defaultdict(list)\n    (n, q) = map(int, input().split())\n    ans = True\n    for query in range(q):\n        (i, j, diff) = map(int, input().split())\n        if diff:\n            if i == j:\n                ans = False\n            differents[i - 1].append(j - 1)\n            differents[j - 1].append(i - 1)\n        else:\n            sames[i - 1].append(j - 1)\n            sames[j - 1].append(i - 1)\n    a = [-1] * n\n    if ans:\n        for i in range(n):\n            if a[i] != -1:\n                continue\n            a[i] = 0\n            queue = [i]\n            while queue:\n                node = queue.pop(0)\n                for new_node in sames[node]:\n                    if a[new_node] == -1:\n                        a[new_node] = a[node]\n                        queue.append(new_node)\n                    elif a[new_node] != a[node]:\n                        ans = False\n                        break\n                if not ans:\n                    break\n                for new_node in differents[node]:\n                    if a[new_node] == -1:\n                        a[new_node] = (a[node] + 1) % 2\n                        queue.append(new_node)\n                    elif a[new_node] == a[node]:\n                        ans = False\n                        break\n                if not ans:\n                    break\n    print('yes') if ans else print('no')", "for i in range(int(input())):\n    state = 0\n    (n, q) = map(int, input().split())\n    d = []\n    k = 0\n    while k <= n:\n        d.append(-1)\n        k += 1\n    gg = []\n    k = 1\n    while k <= q:\n        (a, b, c) = map(int, input().split())\n        gg.append([a, b, c])\n        k += 1\n    gg.sort()\n    k = 0\n    while k < q:\n        if gg[k][0] == gg[k][1]:\n            if gg[k][2] == 1:\n                state = 1\n                break\n        elif d[gg[k][0]] == -1 and d[gg[k][1]] == -1:\n            d[gg[k][0]] = 0\n            if gg[k][2] == 0:\n                d[gg[k][1]] = 0\n            else:\n                d[gg[k][1]] = 1\n        elif d[gg[k][0]] != -1 and d[gg[k][1]] == -1:\n            if gg[k][2] == 0:\n                d[gg[k][1]] = d[gg[k][0]]\n            elif d[gg[k][0]] == 0:\n                d[gg[k][1]] = 1\n            else:\n                d[gg[k][1]] = 0\n        elif d[gg[k][0]] == -1 and d[gg[k][1]] != -1:\n            if gg[k][2] == 0:\n                d[gg[k][0]] = d[gg[k][1]]\n            elif d[gg[k][1]] == 0:\n                d[gg[k][0]] = 1\n            else:\n                d[gg[k][0]] = 0\n        elif d[gg[k][0]] != -1 and d[gg[k][1]] != -1:\n            if gg[k][2] == 0 and d[gg[k][0]] != d[gg[k][1]]:\n                state = 1\n                break\n            if gg[k][2] == 1 and d[gg[k][0]] == d[gg[k][1]]:\n                state = 1\n                break\n        k += 1\n    if state == 0:\n        print('yes')\n    else:\n        print('no')", "def func():\n    a = input().split()\n    (n, q) = (int(a[0]), int(a[1]))\n    arr = [-1 for i in range(n + 1)]\n    z = {}\n    dic2 = {}\n    g_data = []\n    for i in range(q):\n        a = input().split()\n        g_data.append([int(a[0]), int(a[1]), int(a[2])])\n    j = 0\n    for i in g_data:\n        if i[0] == i[1] and i[2] == 1:\n            print('no')\n            return\n        if i[0] not in z:\n            printeve(arr, z, dic2, 0)\n            if i[1] not in z:\n                printeve(arr, z, dic2, 1)\n                z[i[0]] = j\n                z[i[1]] = j\n                if i[0] != i[1]:\n                    dic2[j] = [i[0], i[1]]\n                else:\n                    dic2[j] = [i[0]]\n                if i[2] == 0:\n                    arr[i[0]] = 0\n                    arr[i[1]] = 0\n                else:\n                    arr[i[0]] = 0\n                    arr[i[1]] = 1\n                printeve(arr, z, dic2, 1)\n                j += 1\n            else:\n                printeve(arr, z, dic2, 2)\n                z[i[0]] = z[i[1]]\n                dic2[z[i[1]]].append(i[0])\n                arr[i[0]] = abs(arr[i[1]] - i[2])\n                printeve(arr, z, dic2, 2)\n            printeve(arr, z, dic2, 0)\n        elif i[0] in z:\n            printeve(arr, z, dic2, 3)\n            if i[1] not in z:\n                printeve(arr, z, dic2, 4)\n                z[i[1]] = z[i[0]]\n                dic2[z[i[0]]].append(i[1])\n                arr[i[1]] = abs(arr[i[0]] - i[2])\n                printeve(arr, z, dic2, 4)\n            else:\n                printeve(arr, z, dic2, 5)\n                if z[i[0]] == z[i[1]]:\n                    if i[2] == 0:\n                        if arr[i[0]] != arr[i[1]]:\n                            print('no')\n                            return\n                    elif i[2] == 1:\n                        if arr[i[0]] == arr[i[1]]:\n                            print('no')\n                            return\n                elif i[2] == 0:\n                    if arr[i[0]] == arr[i[1]]:\n                        if z[i[0]] > z[i[1]]:\n                            l = z[i[1]]\n                            h = z[i[0]]\n                        elif z[i[1]] > z[i[0]]:\n                            l = z[i[0]]\n                            h = z[i[1]]\n                        tempd = dic2[h]\n                        dic2[h] = []\n                        dic2[l] += tempd\n                        for ad in tempd:\n                            z[ad] = l\n                    elif arr[i[0]] != arr[i[1]]:\n                        if z[i[0]] > z[i[1]]:\n                            l = z[i[1]]\n                            h = z[i[0]]\n                        elif z[i[1]] > z[i[0]]:\n                            l = z[i[0]]\n                            h = z[i[1]]\n                        tempd = dic2[h]\n                        dic2[h] = []\n                        dic2[l] += tempd\n                        for ad in tempd:\n                            z[ad] = l\n                            arr[ad] = abs(arr[ad] - 1)\n                elif i[2] == 1:\n                    if arr[i[0]] != arr[i[1]]:\n                        if z[i[0]] > z[i[1]]:\n                            l = z[i[1]]\n                            h = z[i[0]]\n                        elif z[i[1]] > z[i[0]]:\n                            l = z[i[0]]\n                            h = z[i[1]]\n                        tempd = dic2[h]\n                        dic2[h] = []\n                        dic2[l] += tempd\n                        for ad in tempd:\n                            z[ad] = l\n                    elif arr[i[0]] == arr[i[1]]:\n                        if z[i[0]] > z[i[1]]:\n                            l = z[i[1]]\n                            h = z[i[0]]\n                        elif z[i[1]] > z[i[0]]:\n                            l = z[i[0]]\n                            h = z[i[1]]\n                        tempd = dic2[h]\n                        dic2[h] = []\n                        dic2[l] += tempd\n                        for ad in tempd:\n                            z[ad] = l\n                            arr[ad] = abs(arr[ad] - 1)\n                printeve(arr, z, dic2, 5)\n    print('yes')\n\ndef printeve(a, b, c, s):\n    pass\nt = int(input())\nfor i in range(t):\n    func()", "def func(qlist, N, Q):\n    keys = {}\n    values = {}\n    count = 1\n    A = []\n    for i in range(N):\n        A.append(0)\n    for y in range(Q):\n        [i, j, val] = qlist[y]\n        if i == j and val != 0:\n            print('no')\n            return\n        if i not in keys:\n            if j not in keys:\n                A[i - 1] = 0\n                A[j - 1] = (1 - val) * A[i - 1] + val * (1 - A[i - 1])\n                if i != j:\n                    values[count] = [i, j]\n                else:\n                    values[count] = [i]\n                keys[i] = count\n                keys[j] = count\n                count += 1\n            else:\n                keys[i] = keys[j]\n                values[keys[j]].append(i)\n                A[i - 1] = (1 - val) * A[j - 1] + val * (1 - A[j - 1])\n        elif j not in keys:\n            keys[j] = keys[i]\n            values[keys[i]].append(j)\n            A[j - 1] = (1 - val) * A[i - 1] + val * (1 - A[i - 1])\n        elif keys[i] == keys[j]:\n            if not (A[i - 1] - A[j - 1] == val or A[j - 1] - A[i - 1] == val):\n                print('no')\n                return\n        else:\n            if len(values[keys[i]]) >= len(values[keys[j]]):\n                new_ind = keys[i]\n                old_ind = keys[j]\n            else:\n                new_ind = keys[j]\n                old_ind = keys[i]\n            temp = values[old_ind]\n            values[old_ind] = []\n            values[new_ind] += temp\n            if A[i - 1] - A[j - 1] == val or A[j - 1] - A[i - 1] == val:\n                for t in temp:\n                    keys[t] = new_ind\n            else:\n                for t in temp:\n                    A[t - 1] = 1 - A[t - 1]\n                    keys[t] = new_ind\n    print('yes')\nT = int(input())\nfor x in range(T):\n    inp = input().split()\n    N = int(inp[0])\n    Q = int(inp[1])\n    qlist = []\n    for y in range(Q):\n        qlist.append([int(k) for k in input().split()])\n    func(qlist, N, Q)", "def func():\n    a = input().split()\n    (n, q) = (int(a[0]), int(a[1]))\n    arr = [-1 for i in range(n + 1)]\n    z = {}\n    dic2 = {}\n    g_data = []\n    for i in range(q):\n        a = input().split()\n        g_data.append([int(a[0]), int(a[1]), int(a[2])])\n    j = 0\n    for i in g_data:\n        if i[0] == i[1] and i[2] == 1:\n            print('no')\n            return\n        if i[0] not in z:\n            printeve(arr, z, dic2, 0)\n            if i[1] not in z:\n                printeve(arr, z, dic2, 1)\n                z[i[0]] = j\n                z[i[1]] = j\n                if i[0] != i[1]:\n                    dic2[j] = [i[0], i[1]]\n                else:\n                    dic2[j] = [i[0]]\n                if i[2] == 0:\n                    arr[i[0]] = 0\n                    arr[i[1]] = 0\n                else:\n                    arr[i[0]] = 0\n                    arr[i[1]] = 1\n                printeve(arr, z, dic2, 1)\n                j += 1\n            else:\n                printeve(arr, z, dic2, 2)\n                z[i[0]] = z[i[1]]\n                dic2[z[i[1]]].append(i[0])\n                arr[i[0]] = abs(arr[i[1]] - i[2])\n                printeve(arr, z, dic2, 2)\n            printeve(arr, z, dic2, 0)\n        elif i[0] in z:\n            printeve(arr, z, dic2, 3)\n            if i[1] not in z:\n                printeve(arr, z, dic2, 4)\n                z[i[1]] = z[i[0]]\n                dic2[z[i[0]]].append(i[1])\n                arr[i[1]] = abs(arr[i[0]] - i[2])\n                printeve(arr, z, dic2, 4)\n            else:\n                printeve(arr, z, dic2, 5)\n                if z[i[0]] == z[i[1]]:\n                    if i[2] == 0:\n                        if arr[i[0]] != arr[i[1]]:\n                            print('no')\n                            return\n                    elif i[2] == 1:\n                        if arr[i[0]] == arr[i[1]]:\n                            print('no')\n                            return\n                elif i[2] == 0:\n                    if arr[i[0]] == arr[i[1]]:\n                        if z[i[0]] > z[i[1]]:\n                            l = z[i[1]]\n                            h = z[i[0]]\n                        elif z[i[1]] > z[i[0]]:\n                            l = z[i[0]]\n                            h = z[i[1]]\n                        tempd = dic2[h]\n                        dic2[h] = []\n                        dic2[l] += tempd\n                        for ad in tempd:\n                            z[ad] = l\n                    elif arr[i[0]] != arr[i[1]]:\n                        if z[i[0]] > z[i[1]]:\n                            l = z[i[1]]\n                            h = z[i[0]]\n                        elif z[i[1]] > z[i[0]]:\n                            l = z[i[0]]\n                            h = z[i[1]]\n                        tempd = dic2[h]\n                        dic2[h] = []\n                        dic2[l] += tempd\n                        for ad in tempd:\n                            z[ad] = l\n                            arr[ad] = abs(arr[ad] - 1)\n                elif i[2] == 1:\n                    if arr[i[0]] != arr[i[1]]:\n                        if z[i[0]] > z[i[1]]:\n                            l = z[i[1]]\n                            h = z[i[0]]\n                        elif z[i[1]] > z[i[0]]:\n                            l = z[i[0]]\n                            h = z[i[1]]\n                        tempd = dic2[h]\n                        dic2[h] = []\n                        dic2[l] += tempd\n                        for ad in tempd:\n                            z[ad] = l\n                    elif arr[i[0]] == arr[i[1]]:\n                        if z[i[0]] > z[i[1]]:\n                            l = z[i[1]]\n                            h = z[i[0]]\n                        elif z[i[1]] > z[i[0]]:\n                            l = z[i[0]]\n                            h = z[i[1]]\n                        tempd = dic2[h]\n                        dic2[h] = []\n                        dic2[l] += tempd\n                        for ad in tempd:\n                            z[ad] = l\n                            arr[ad] = abs(arr[ad] - 1)\n                printeve(arr, z, dic2, 5)\n    print('yes')\n\ndef printeve(a, b, c, s):\n    pass\nt = int(input())\nfor i in range(t):\n    func()", "test = int(input())\nfor bing in range(test):\n    (n, q) = list(map(int, input().split()))\n    b = [list(map(int, input().split())) for i in range(q)]\n    m = 0\n    x = 5.5\n    b.sort()\n    A = [x for i in range(n)]\n    for i in range(q):\n        if b[i][2] == 1:\n            if A[b[i][0] - 1] == x and A[b[i][1] - 1] == x:\n                A[b[i][0] - 1] = 1\n                A[b[i][1] - 1] = 0\n            elif A[b[i][0] - 1] == x:\n                if A[b[i][1] - 1] == 0:\n                    A[b[i][0] - 1] = 1\n                elif A[b[i][1] - 1] == 1:\n                    A[b[i][0] - 1] = 0\n            elif A[b[i][1] - 1] == x:\n                if A[b[i][0] - 1] == 0:\n                    A[b[i][1] - 1] = 1\n                elif A[b[i][0] - 1] == 1:\n                    A[b[i][1] - 1] = 0\n            elif A[b[i][0] - 1] == 0 and A[b[i][1] - 1] == 1:\n                continue\n            elif A[b[i][1] - 1] == 0 and A[b[i][0] - 1] == 1:\n                continue\n        elif b[i][2] == 0:\n            if A[b[i][0] - 1] == x and A[b[i][1] - 1] == x:\n                A[b[i][0] - 1] = 0\n                A[b[i][1] - 1] = 0\n            elif A[b[i][0] - 1] == x:\n                A[b[i][0] - 1] = A[b[i][1] - 1]\n            elif A[b[i][1] - 1] == x:\n                A[b[i][1] - 1] = A[b[i][0] - 1]\n            elif A[b[i][1] - 1] == 1 and A[b[i][0] - 1] == 1:\n                continue\n            elif A[b[i][1] - 1] == 0 and A[b[i][0] - 1] == 0:\n                continue\n    for i in range(q):\n        if abs(A[b[i][1] - 1] - A[b[i][0] - 1]) != b[i][2]:\n            m += 1\n    if m != 0:\n        print('no')\n    else:\n        print('yes')", "def func(x):\n    if x == 1:\n        return 0\n    else:\n        return 1\nqq = int(input())\nwhile qq > 0:\n    (n, q) = map(int, input().split())\n    a = [-1]\n    b = [((-1, -1), -1)]\n    flaqq = 0\n    for i in range(n):\n        a.append(-1)\n    for i in range(q):\n        (x, y, z) = map(int, input().split())\n        b.append(((x, y), z))\n    b = sorted(b, key=lambda x: x[0])\n    for i in range(1, q + 1):\n        if b[i][0][0] == b[i][0][1] and b[i][1] != 0:\n            flaqq = 1\n            break\n        elif b[i][0][0] == b[i][0][1]:\n            pass\n        elif a[b[i][0][0]] == -1 and a[b[i][0][1]] == -1:\n            if b[i][1] != 0:\n                a[b[i][0][0]] = 0\n                a[b[i][0][1]] = 1\n            else:\n                a[b[i][0][0]] = 0\n                a[b[i][0][1]] = 0\n        elif a[b[i][0][0]] == -1 and a[b[i][0][1]] != -1:\n            if b[i][1] != 0:\n                a[b[i][0][0]] = func(a[b[i][0][1]])\n            else:\n                a[b[i][0][0]] = a[b[i][0][1]]\n        elif a[b[i][0][0]] != -1 and a[b[i][0][1]] == -1:\n            if b[i][1] != 0:\n                a[b[i][0][1]] = func(a[b[i][0][0]])\n            else:\n                a[b[i][0][1]] = a[b[i][0][0]]\n        elif a[b[i][0][0]] != -1 and a[b[i][0][1]] != -1:\n            if abs(a[b[i][0][0]] - a[b[i][0][1]]) != b[i][1]:\n                flaqq = 1\n                break\n    if flaqq:\n        print('no')\n    else:\n        print('yes')\n    qq -= 1", "g = int(input())\nwhile g > 0:\n    (n, q) = map(int, input().split())\n    a = [-1]\n    b = [((-1, -1), -1)]\n    flag = 0\n    for i in range(n):\n        a.append(-1)\n    for i in range(q):\n        (x, y, z) = map(int, input().split())\n        b.append(((x, y), z))\n\n    def invert(x):\n        if x == 1:\n            return 0\n        else:\n            return 1\n    b = sorted(b, key=lambda x: x[0])\n    for i in range(1, q + 1):\n        if b[i][0][0] == b[i][0][1] and b[i][1] != 0:\n            flag = 1\n            break\n        elif b[i][0][0] == b[i][0][1]:\n            pass\n        elif a[b[i][0][0]] == -1 and a[b[i][0][1]] == -1:\n            if b[i][1] != 0:\n                a[b[i][0][0]] = 0\n                a[b[i][0][1]] = 1\n            else:\n                a[b[i][0][0]] = 0\n                a[b[i][0][1]] = 0\n        elif a[b[i][0][0]] == -1 and a[b[i][0][1]] != -1:\n            if b[i][1] != 0:\n                a[b[i][0][0]] = invert(a[b[i][0][1]])\n            else:\n                a[b[i][0][0]] = a[b[i][0][1]]\n        elif a[b[i][0][0]] != -1 and a[b[i][0][1]] == -1:\n            if b[i][1] != 0:\n                a[b[i][0][1]] = invert(a[b[i][0][0]])\n            else:\n                a[b[i][0][1]] = a[b[i][0][0]]\n        elif a[b[i][0][0]] != -1 and a[b[i][0][1]] != -1:\n            if abs(a[b[i][0][0]] - a[b[i][0][1]]) != b[i][1]:\n                flag = 1\n                break\n    if flag:\n        print('no')\n    else:\n        print('yes')\n    g -= 1", "g = int(input())\nwhile g > 0:\n    (n, q) = map(int, input().split())\n    a = [-1]\n    b = [((-1, -1), -1)]\n    flag = 0\n    for i in range(n):\n        a.append(-1)\n    for i in range(q):\n        (x, y, z) = map(int, input().split())\n        b.append(((x, y), z))\n\n    def invert(x):\n        if x == 1:\n            return 0\n        else:\n            return 1\n    b = sorted(b, key=lambda x: x[0])\n    for i in range(1, q + 1):\n        if b[i][0][0] == b[i][0][1] and b[i][1] != 0:\n            flag = 1\n            break\n        elif b[i][0][0] == b[i][0][1]:\n            pass\n        elif a[b[i][0][0]] == -1 and a[b[i][0][1]] == -1:\n            if b[i][1] != 0:\n                a[b[i][0][0]] = 0\n                a[b[i][0][1]] = 1\n            else:\n                a[b[i][0][0]] = 0\n                a[b[i][0][1]] = 0\n        elif a[b[i][0][0]] == -1 and a[b[i][0][1]] != -1:\n            if b[i][1] != 0:\n                a[b[i][0][0]] = invert(a[b[i][0][1]])\n            else:\n                a[b[i][0][0]] = a[b[i][0][1]]\n        elif a[b[i][0][0]] != -1 and a[b[i][0][1]] == -1:\n            if b[i][1] != 0:\n                a[b[i][0][1]] = invert(a[b[i][0][0]])\n            else:\n                a[b[i][0][1]] = a[b[i][0][0]]\n        elif a[b[i][0][0]] != -1 and a[b[i][0][1]] != -1:\n            if abs(a[b[i][0][0]] - a[b[i][0][1]]) != b[i][1]:\n                flag = 1\n                break\n    if flag:\n        print('no')\n    else:\n        print('yes')\n    g -= 1", "t = int(input())\nwhile t > 0:\n    t -= 1\n    (n, q) = map(int, input().split())\n    Dic = {}\n    ans = True\n    A = [-1] * (n + 1)\n    query = []\n    for i in range(q):\n        (x, y, z) = map(int, input().split())\n        query.append([int(x), int(y), int(z)])\n        if x == y and z != 0:\n            ans = False\n    query.sort()\n    if ans == True:\n        for i in range(q):\n            x = query[i][0]\n            y = query[i][1]\n            z = query[i][2]\n            st = str(query[i][0]) + ' ' + str(query[i][1])\n            if A[x] == -1 and A[y] == -1:\n                if z == 1:\n                    A[x] = 0\n                    A[y] = z\n                else:\n                    A[x] = 0\n                    A[y] = 0\n            elif A[x] != -1 and A[y] == -1:\n                st1 = str(y) + ' ' + str(x)\n                if Dic.get(st1, None) != None:\n                    if z != Dic.get(st1, None):\n                        ans = False\n                        break\n                if z == 0:\n                    A[y] = A[x]\n                else:\n                    A[y] = 1 - A[x]\n            elif A[x] == -1 and A[y] != -1:\n                st1 = str(y) + ' ' + str(x)\n                if Dic.get(st1, None) != None:\n                    if z != Dic.get(st1, None):\n                        ans = False\n                        break\n                if z == 0:\n                    A[x] = A[y]\n                else:\n                    A[x] = 1 - A[y]\n            elif A[x] != -1 and A[y] != -1:\n                key = str(y) + ' ' + str(x)\n                if Dic.get(st1, None) != None:\n                    if z != Dic.get(st1, None):\n                        ans = False\n                        break\n                if abs(A[x] - A[y]) != z:\n                    ans = False\n                    break\n            Dic[st] = z\n    if ans == True:\n        print('yes')\n    else:\n        print('no')", "t = int(input())\nwhile t:\n    t -= 1\n    (n, q) = map(int, input().split())\n    m = set()\n    flag = 0\n    l = []\n    r = []\n    a = [float('inf')] * n\n    er = set()\n    while q:\n        q -= 1\n        (i, j, val) = map(int, input().split())\n        l.append([i, j, val])\n        m.add((i, j))\n        r.append((i, j))\n        if i == j and val != 0:\n            flag = 1\n    l.sort()\n    for k in range(len(l)):\n        if (l[k][1], l[k][0]) in m and l[k][1] != l[k][0]:\n            if l[r.index((l[k][1], l[k][0]))][2] != l[k][2]:\n                flag = 1\n        if l[k][0] in er and l[k][1] in er:\n            if abs(a[l[k][0] - 1] - a[l[k][1] - 1]) != l[k][2]:\n                flag = 1\n        elif a[l[k][0] - 1] == float('inf') and a[l[k][1] - 1] == float('inf'):\n            a[l[k][0] - 1] = 0\n            a[l[k][1] - 1] = l[k][2]\n        elif a[l[k][1] - 1] == float('inf') and a[l[k][0] - 1] == 1:\n            if l[k][2] == 1:\n                a[l[k][1] - 1] = 0\n            else:\n                a[l[k][1] - 1] = 1\n        elif a[l[k][1] - 1] == float('inf') and a[l[k][0] - 1] == 0:\n            if l[k][2] == 1:\n                a[l[k][1] - 1] = 1\n            else:\n                a[l[k][1] - 1] = 0\n        elif a[l[k][0] - 1] == float('inf') and a[l[k][1] - 1] == 1:\n            if l[k][2] == 1:\n                a[l[k][0] - 1] = 0\n            else:\n                a[l[k][0] - 1] = 1\n        elif a[l[k][0] - 1] == float('inf') and a[l[k][1] - 1] == 0:\n            if l[k][2] == 1:\n                a[l[k][0] - 1] = 1\n            else:\n                a[l[k][0] - 1] = 0\n        er.add(l[k][0])\n        er.add(l[k][1])\n    if flag == 1:\n        print('no')\n    else:\n        print('yes')", "t = int(input())\nwhile t:\n    t -= 1\n    (n, q) = map(int, input().split())\n    m = set()\n    flag = 0\n    l = []\n    r = []\n    a = [float('inf')] * n\n    er = set()\n    while q:\n        q -= 1\n        (i, j, val) = map(int, input().split())\n        l.append([i, j, val])\n        m.add((i, j))\n        r.append((i, j))\n        if i == j and val != 0:\n            flag = 1\n    l.sort()\n    for k in range(len(l)):\n        if (l[k][1], l[k][0]) in m and l[k][1] != l[k][0]:\n            if l[r.index((l[k][1], l[k][0]))][2] != l[k][2]:\n                flag = 1\n        if l[k][0] in er and l[k][1] in er:\n            if abs(a[l[k][0] - 1] - a[l[k][1] - 1]) != l[k][2]:\n                flag = 1\n        elif a[l[k][0] - 1] == float('inf') and a[l[k][1] - 1] == float('inf'):\n            a[l[k][0] - 1] = 0\n            a[l[k][1] - 1] = l[k][2]\n        elif a[l[k][1] - 1] == float('inf') and a[l[k][0] - 1] == 1:\n            if l[k][2] == 1:\n                a[l[k][1] - 1] = 0\n            else:\n                a[l[k][1] - 1] = 1\n        elif a[l[k][1] - 1] == float('inf') and a[l[k][0] - 1] == 0:\n            if l[k][2] == 1:\n                a[l[k][1] - 1] = 1\n            else:\n                a[l[k][1] - 1] = 0\n        elif a[l[k][0] - 1] == float('inf') and a[l[k][1] - 1] == 1:\n            if l[k][2] == 1:\n                a[l[k][0] - 1] = 0\n            else:\n                a[l[k][0] - 1] = 1\n        elif a[l[k][0] - 1] == float('inf') and a[l[k][1] - 1] == 0:\n            if l[k][2] == 1:\n                a[l[k][0] - 1] = 1\n            else:\n                a[l[k][0] - 1] = 0\n        er.add(l[k][0])\n        er.add(l[k][1])\n    if flag == 1:\n        print('no')\n    else:\n        print('yes')", "def main():\n    for t in range(int(input())):\n        (n, q) = [int(x) for x in input().strip().split()]\n        a = [None] * n\n        failure = False\n\n        def make_key(i, j):\n            return tuple(sorted([i, j]))\n        relations = dict()\n        mapping = dict()\n\n        def read_queries():\n            nonlocal failure\n            for query in range(q):\n                (i, j, v) = [int(x) for x in input().strip().split()]\n                if i == j or failure:\n                    if v != 0:\n                        failure = True\n                else:\n                    i -= 1\n                    j -= 1\n                    k = make_key(i, j)\n                    if k in relations:\n                        if relations[k] != v:\n                            failure = True\n                    else:\n                        relations[k] = v\n                    if i in mapping:\n                        mapping[i].append(j)\n                    else:\n                        mapping[i] = [j]\n                    if j in mapping:\n                        mapping[j].append(i)\n                    else:\n                        mapping[j] = [i]\n        read_queries()\n        if failure:\n            print('no')\n            continue\n\n        def make_possibilities(i, v):\n            nonlocal a\n            ans = set()\n            for p in a[i]:\n                ans.add(p + v)\n                ans.add(p - v)\n                ans.add(v - p)\n            return ans\n\n        def combine_possibilities(i, j, v):\n            nonlocal a\n            newi = set()\n            newj = set()\n            for pi in a[i]:\n                for pj in a[j]:\n                    if pi + pj == v or pi - pj == v or pj - pi == v:\n                        newi.add(pi)\n                        newj.add(pj)\n            a[i] = newi\n            a[j] = newj\n            return len(newi) != 0 and len(newj) != 0\n\n        def solve():\n            nonlocal failure\n            while len(mapping) > 0 and (not failure):\n                done = set()\n                todo = []\n                for i in mapping:\n                    a[i] = {0}\n                    done.add(i)\n                    todo.append(i)\n                    break\n                while len(todo) > 0 and (not failure):\n                    i = todo.pop()\n                    for j in mapping[i]:\n                        k = make_key(i, j)\n                        if k not in relations:\n                            continue\n                        v = relations[k]\n                        del relations[k]\n                        if a[j] is None:\n                            a[j] = make_possibilities(i, v)\n                        else:\n                            success = combine_possibilities(i, j, v)\n                            if not success:\n                                failure = True\n                        if j not in done:\n                            todo.append(j)\n                            done.add(j)\n                for i in done:\n                    del mapping[i]\n                done.clear()\n        solve()\n        print('no' if failure else 'yes')\nmain()", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    arr = [None for i in range(n)]\n    brr = []\n    for i in range(q):\n        (x, y, val) = map(int, input().split())\n        x -= 1\n        y -= 1\n        brr.append((x, y, val))\n    brr.sort()\n    f = 0\n    for i in range(len(brr)):\n        (x, y, val) = brr[i]\n        if arr[x] == None and arr[y] == None:\n            arr[x] = 0\n            arr[y] = val\n        elif arr[x] == None and arr[y] != None:\n            if arr[y] == 1:\n                arr[x] = (1 + val) % 2\n            else:\n                arr[y] = (0 + val) % 2\n        elif arr[x] != None and arr[y] == None:\n            if arr[x] == 0:\n                arr[y] = val\n            else:\n                arr[y] = (1 + val) % 2\n        if abs(arr[x] - arr[y]) != val:\n            f = 1\n            break\n    if f == 0:\n        print('yes')\n    else:\n        print('no')", "t = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    brr = [None for i in range(n)]\n    qu = []\n    for j in range(q):\n        (a, b, c) = map(int, input().split())\n        a = a - 1\n        b = b - 1\n        qu.append((a, b, c))\n    qu.sort()\n    flag = 0\n    for j in range(len(qu)):\n        (a, b, c) = qu[j]\n        if brr[a] == None and brr[b] == None:\n            brr[a] = 0\n            brr[b] = c\n        elif brr[a] == None and brr[b] != None:\n            if brr[b] == 1:\n                brr[a] = (1 + c) % 2\n            else:\n                brr[a] = (0 + c) % 2\n        elif brr[a] != None and brr[b] == None:\n            if brr[a] == 1:\n                brr[b] = (1 + c) % 2\n            else:\n                brr[b] = (0 + c) % 2\n        if abs(brr[b] - brr[a]) != c:\n            flag = 1\n            break\n    if flag == 0:\n        print('yes')\n    else:\n        print('no')", "for _ in range(int(input())):\n    (n, q) = map(int, input().split())\n    arr = []\n    a = [-1] * (n + 1)\n    b = []\n    a[1] = 0\n    ans = 0\n    for _ in range(q):\n        (x, y, z) = map(int, input().split())\n        if x == y:\n            if z != 0:\n                ans += 1\n        else:\n            arr.append([min(x, y), max(x, y), z])\n    arr.sort()\n    for i in arr:\n        if a[i[0]] != -1 and a[i[1]] != -1:\n            if abs(a[i[0]] - a[i[1]]) == i[2]:\n                continue\n            else:\n                ans += 1\n                break\n        elif a[i[0]] != -1 and a[i[1]] == -1:\n            if i[2] == 0:\n                a[i[1]] = a[i[0]]\n            elif i[2] == 1:\n                if a[i[0]] == 0:\n                    a[i[1]] = 1\n                elif a[i[0]] == 1:\n                    a[i[1]] = 0\n        elif a[i[0]] == -1 and a[i[1]] != -1:\n            if i[2] == 0:\n                a[i[0]] = a[i[1]]\n            elif i[2] == 1:\n                if a[i[1]] == 0:\n                    a[i[1]] = 0\n                elif a[i[1]] == 1:\n                    a[i[1]] = 1\n        else:\n            b.append(i)\n    if ans == 0:\n        for i in b:\n            if a[i[0]] != -1 and a[i[1]] != -1:\n                if abs(a[i[0]] - a[i[1]]) == i[2]:\n                    continue\n                else:\n                    ans += 1\n                    break\n            elif a[i[0]] != -1 and a[i[1]] == -1:\n                if i[2] == 0:\n                    a[i[1]] = a[i[0]]\n                elif i[2] == 1:\n                    if a[i[0]] == 0:\n                        a[i[1]] = 1\n                    elif a[i[0]] == 1:\n                        a[i[1]] = 0\n            elif a[i[0]] == -1 and a[i[1]] != -1:\n                if i[2] == 0:\n                    a[i[0]] = a[i[1]]\n                elif i[2] == 1:\n                    if a[i[1]] == 0:\n                        a[i[1]] = 0\n                    elif a[i[1]] == 1:\n                        a[i[1]] = 1\n            elif i[2] == 0:\n                a[i[0]] = 0\n                a[i[1]] = 0\n            elif i[2] == 1:\n                a[i[1]] = 0\n                a[i[1]] = 1\n    if ans == 0:\n        print('yes')\n    else:\n        print('no')", "from collections import defaultdict\nfor _ in range(int(input())):\n    (N, Q) = map(int, input().split(' '))\n    colorArr = [-1 for x in range(N + 1)]\n    Queries = []\n    ans = 1\n    for i in range(Q):\n        (x, y, val) = map(int, input().split(' '))\n        Queries.append(tuple([x, y, val]))\n        Queries.append(tuple([y, x, val]))\n    Queries.sort()\n    for (x, y, val) in Queries:\n        if x == y and val == 1:\n            ans = 0\n            break\n        elif x != y:\n            if colorArr[x] != -1 and colorArr[y] != -1:\n                if int(abs(colorArr[x] - colorArr[y])) != val:\n                    ans = 0\n                    break\n            elif colorArr[x] != -1:\n                if val == 1:\n                    colorArr[y] = 1 - colorArr[x]\n                else:\n                    colorArr[y] = colorArr[x]\n            elif colorArr[y] != -1:\n                if val == 1:\n                    colorArr[x] = 1 - colorArr[y]\n                else:\n                    colorArr[x] = colorArr[y]\n            elif val == 0:\n                colorArr[x] = 0\n                colorArr[y] = 0\n            else:\n                colorArr[x] = 0\n                colorArr[y] = 1\n    if ans == 0:\n        print('no')\n    else:\n        print('yes')", "def bfs(vertex):\n    q = []\n    arr[vertex] = 0\n    q.append(vertex)\n    while len(q) != 0:\n        u = q.pop(0)\n        visited[u] = True\n        for (v, edge) in con[u]:\n            if arr[v] == -1:\n                arr[v] = edge ^ arr[u]\n                q.append(v)\n            elif arr[v] != edge ^ arr[u]:\n                return False\n    return True\nfor _ in range(int(input().strip())):\n    (n, q) = map(int, input().strip().split())\n    arr = [-1 for i in range(n + 1)]\n    con = [[] for i in range(n + 1)]\n    visited = [False for i in range(n + 1)]\n    ans = True\n    for y in range(q):\n        (i, j, v) = map(int, input().strip().split())\n        con[i].append((j, v))\n    for i in range(1, n + 1):\n        if visited[i] is False and ans is True:\n            q = []\n            arr[i] = 0\n            q.append(i)\n            while len(q) != 0:\n                u = q.pop(0)\n                visited[u] = True\n                for (v, edge) in con[u]:\n                    if arr[v] == -1:\n                        arr[v] = edge ^ arr[u]\n                        q.append(v)\n                    elif arr[v] != edge ^ arr[u]:\n                        ans = False\n                        break\n    if ans:\n        print('yes')\n    else:\n        print('no')", "def bfs(vertex):\n    q = []\n    arr[vertex] = 0\n    q.append(vertex)\n    while len(q) != 0:\n        u = q.pop(0)\n        visited[u] = True\n        for (v, edge) in con[u]:\n            if arr[v] == -1:\n                arr[v] = edge ^ arr[u]\n                q.append(v)\n            elif arr[v] != edge ^ arr[u]:\n                return False\n    return True\nfor _ in range(int(input().strip())):\n    (n, q) = map(int, input().strip().split())\n    arr = [-1 for i in range(n + 1)]\n    con = [[] for i in range(n + 1)]\n    visited = [False for i in range(n + 1)]\n    ans = True\n    for y in range(q):\n        (i, j, v) = map(int, input().strip().split())\n        con[i].append((j, v))\n    for i in range(1, n + 1):\n        if visited[i] is False and ans is True:\n            ans = bfs(i)\n    if ans:\n        print('yes')\n    else:\n        print('no')", "t = int(input())\nwhile t:\n    t -= 1\n    (n, q) = list(map(int, input().split()))\n    a = dict()\n    f = 1\n    store = []\n    for i in range(q):\n        store.append(list(map(int, input().split())))\n    store = sorted(store)\n    for query in store:\n        if query[0] == query[1] and query[2] == 1:\n            f = 0\n        elif query[0] in a and query[1] in a:\n            x = set()\n            y = set()\n            for i in a[query[0]]:\n                for j in a[query[1]]:\n                    if abs(i - j) == query[2]:\n                        x.add(i)\n                        y.add(j)\n            if x == set():\n                f = 0\n            else:\n                a[query[0]] = x\n                a[query[1]] = y\n        elif query[0] in a:\n            y = set()\n            for i in a[query[0]]:\n                y.add(i - query[2])\n                y.add(i + query[2])\n            a[query[1]] = y\n        elif query[1] in a:\n            x = set()\n            for i in a[query[1]]:\n                x.add(i - query[2])\n                x.add(i + query[2])\n            a[query[0]] = x\n        else:\n            a[query[0]] = {0}\n            a[query[1]] = {query[2], -query[2]}\n    if f:\n        print('yes')\n    else:\n        print('no')", "t = int(input())\nfor _ in range(t):\n    (n, q) = map(int, input().split())\n    array = [-1 for i in range(n)]\n    commands = []\n    yes = True\n    for i in range(q):\n        (row, col, val) = map(int, input().split())\n        commands.append((row, col, val))\n    commands.sort()\n    for i in commands:\n        row = i[0]\n        col = i[1]\n        val = i[2]\n        if row == col and val == 1:\n            yes = False\n        if array[row - 1] == -1 and array[col - 1] == -1:\n            array[row - 1] = 0\n            array[col - 1] = val\n        elif array[row - 1] == -1:\n            array[row - 1] = abs(array[col - 1] - val)\n        elif array[col - 1] == -1:\n            array[col - 1] = abs(array[row - 1] - val)\n        elif abs(array[row - 1] - array[col - 1]) != val:\n            yes = False\n    if yes:\n        print('yes')\n    else:\n        print('no')", "T = int(input())\nfor i in range(T):\n    (N, Q) = map(lambda s: int(s), input().split())\n    valid = True\n    r = [set() for i in range(N + 1)]\n    visit = [False for i in range(N + 1)]\n    delta = dict()\n    a = [set() for i in range(N + 1)]\n    for j in range(Q):\n        (x, y, v) = map(lambda s: int(s), input().split())\n        if x == y:\n            valid = True if v == 0 else False\n        else:\n            r[x].add(y)\n            r[y].add(x)\n            if (x, y) not in delta:\n                delta.setdefault((x, y), v)\n                delta.setdefault((y, x), v)\n            elif delta[x, y] != v:\n                valid = False\n    if valid:\n        for (node, neighbor) in enumerate(r):\n            if not valid:\n                break\n            if neighbor:\n                if not a[node]:\n                    a[node].add(0)\n                for n in neighbor:\n                    if not visit[n]:\n                        possible = set()\n                        for e in a[node]:\n                            (p1, p2) = (e + delta[node, n], e - delta[node, n])\n                            possible.add(p1)\n                            possible.add(p2)\n                        if a[n]:\n                            a[n] = a[n].intersection(possible)\n                            if not a[n]:\n                                valid = False\n                        else:\n                            a[n] = possible\n            visit[node] = True\n    if valid:\n        print('yes')\n    else:\n        print('no')", "def make_graph(inp):\n    g = {}\n    for x in inp:\n        if not x[0] in g:\n            g[x[0]] = {}\n        if x[1] in g[x[0]]:\n            if g[x[0]][x[1]] != inp[x]:\n                return None\n        g[x[0]][x[1]] = inp[x]\n        g[x[1]][x[0]] = inp[x]\n    return g\n\ndef bfs(g, a, s, visited, flag):\n    a[s] = 0\n    q = [s]\n    visited[s] = True\n    while len(q) != 0:\n        u = q.pop(0)\n        for (v, val) in g[u]:\n            if not visited[v]:\n                q.append(v)\n                visited[v] = True\n                if val == 1:\n                    if a[u] == 0:\n                        a[v] = 1\n                    else:\n                        a[v] = 0\n                else:\n                    a[v] = a[u]\n            elif val != abs(a[u] - a[v]):\n                flag[0] = False\n                return\n\ndef solve(inp, n):\n    a = [None for i in range(n + 1)]\n    visited = [False for i in range(n + 1)]\n    obj = [True, 0]\n    for i in list(range(1, n + 1)):\n        if not visited[i]:\n            bfs(inp, a, i, visited, obj)\n    if obj[0]:\n        print('yes')\n    else:\n        print('no')\nfor _ in range(int(input())):\n    (n, q) = tuple(map(int, input().split()))\n    adj = [[] for i in range(n + 1)]\n    while q:\n        (i, j, val) = tuple(map(int, input().split()))\n        adj[i].append((j, val))\n        adj[j].append((i, val))\n        q -= 1\n    solve(adj, n)", "def make_aid_map(N, zeroes):\n    aid_map = dict()\n    aid_size = 0\n    adj_list = [list() for _ in range(N)]\n    for (i, j) in zeroes:\n        adj_list[i].append(j)\n        adj_list[j].append(i)\n    visited = set()\n    for i in range(N):\n        if i in visited:\n            continue\n        visited.add(i)\n        aid_map[i] = aid_size\n        S = [i]\n        while S:\n            cur = S.pop()\n            for adj in adj_list[cur]:\n                if adj in visited:\n                    continue\n                visited.add(adj)\n                aid_map[adj] = aid_size\n                S.append(adj)\n        aid_size += 1\n    return (aid_size, aid_map)\n\ndef available(N, zeroes, ones):\n    (aid_size, aid_map) = make_aid_map(N, zeroes)\n    adj_aid_list = [list() for _ in range(aid_size)]\n    for (i, j) in ones:\n        (ai, aj) = (aid_map[i], aid_map[j])\n        if ai == aj:\n            return False\n        adj_aid_list[ai].append(aj)\n        adj_aid_list[aj].append(ai)\n    color = dict()\n    for i in range(aid_size):\n        if i in color:\n            continue\n        color[i] = 0\n        S = [i]\n        while S:\n            cur = S.pop()\n            for adj in adj_aid_list[cur]:\n                if adj in color:\n                    if color[adj] == color[cur]:\n                        return False\n                else:\n                    color[adj] = 1 - color[cur]\n                    S.append(adj)\n    return True\nT = int(input())\nfor _ in range(T):\n    (N, Q) = map(int, input().split())\n    QO = list()\n    QI = list()\n    for _ in range(Q):\n        (i, j, val) = map(int, input().split())\n        i -= 1\n        j -= 1\n        if val == 0:\n            QO.append((i, j))\n        else:\n            QI.append((i, j))\n    print('yes' if available(N, QO, QI) else 'no')", "import sys\nsys.setrecursionlimit(1000000)\ncases = int(input())\n\ndef dfs(index, values, flags, neighbors):\n    flags[index - 1] = True\n    for neighbor in neighbors[index]:\n        if values[neighbor[0] - 1] is None:\n            values[neighbor[0] - 1] = values[index - 1] + neighbor[1]\n            if not flags[neighbor[0] - 1]:\n                if dfs(neighbor[0], values, flags, neighbors) is False:\n                    return False\n        elif (values[neighbor[0] - 1] - (values[index - 1] + neighbor[1])) % 2 != 0:\n            return False\n    return True\nfor _ in range(cases):\n    (side, queries) = input().split()\n    (side, queries) = (int(side), int(queries))\n    possible = True\n    neighbors = {num: set() for num in range(1, side + 1)}\n    flags = [False for k in range(side)]\n    values = [None for k in range(side)]\n    for q in range(queries):\n        (i, j, val) = input().split()\n        (i, j, val) = (int(i), int(j), int(val))\n        neighbors[i].add((j, val))\n        neighbors[j].add((i, val))\n    poss = True\n    for index in range(1, side + 1):\n        if not flags[index - 1]:\n            values[index - 1] = 0\n            poss &= dfs(index, values, flags, neighbors)\n    if poss:\n        print('yes')\n    else:\n        print('no')", "class Graph:\n\n    def __init__(self):\n        self.edge_zero = {}\n        self.edge_one = {}\n        self.equiv_rep = {}\n        self.invalid = False\n\n    def add_edge(self, i, j, val):\n        if i == j:\n            if val == 1:\n                self.invalid = True\n            return\n        if val == 1 and i in self.edge_zero and (j in self.edge_zero[i]):\n            self.invalid = True\n            return\n        if val == 0 and i in self.edge_one and (j in self.edge_one[i]):\n            self.invalid = True\n            return\n        table = self.edge_zero if val == 0 else self.edge_one\n        if i not in table:\n            table[i] = set()\n        if j not in table:\n            table[j] = set()\n        table[i].add(j)\n        table[j].add(i)\n\n    def is_equal(self, i, j):\n        if i in self.edge_zero and j in self.edge_zero:\n            return self.equiv_rep[i] == self.equiv_rep[j]\n        return False\n\n    def check_valid(self):\n        if self.invalid:\n            return False\n        colour = {}\n        for i in set(self.edge_one.keys()).union(self.edge_zero.keys()):\n            if i in colour:\n                continue\n            colour[i] = 0\n            q = [i]\n            closed = set()\n            while q:\n                current = q.pop()\n                if current in closed:\n                    continue\n                closed.add(current)\n                if current in self.edge_one:\n                    for nbr in self.edge_one[current]:\n                        if nbr not in colour:\n                            colour[nbr] = 1 - colour[current]\n                        elif colour[nbr] == colour[current]:\n                            return False\n                        q.append(nbr)\n                if current in self.edge_zero:\n                    for nbr in self.edge_zero[current]:\n                        if nbr not in colour:\n                            colour[nbr] = colour[current]\n                        elif colour[nbr] != colour[current]:\n                            return False\n                        q.append(nbr)\n        return True\nT = int(input())\nfor _ in range(T):\n    (N, Q) = (int(x) for x in input().split())\n    graph = Graph()\n    for q in range(Q):\n        (i, j, val) = (int(x) for x in input().split())\n        graph.add_edge(i, j, val)\n    if graph.check_valid():\n        print('yes')\n    else:\n        print('no')", "class Graph:\n\n    def __init__(self):\n        self.edge_zero = {}\n        self.edge_one = {}\n        self.equiv_rep = {}\n        self.invalid = False\n\n    def add_edge(self, i, j, val):\n        if i == j:\n            if val == 1:\n                self.invalid = True\n            return\n        if val == 1 and i in self.edge_zero and (j in self.edge_zero[i]):\n            self.invalid = True\n            return\n        if val == 0 and i in self.edge_one and (j in self.edge_one[i]):\n            self.invalid = True\n            return\n        table = self.edge_zero if val == 0 else self.edge_one\n        if i not in table:\n            table[i] = set()\n        if j not in table:\n            table[j] = set()\n        table[i].add(j)\n        table[j].add(i)\n\n    def is_equal(self, i, j):\n        if i in self.edge_zero and j in self.edge_zero:\n            return self.equiv_rep[i] == self.equiv_rep[j]\n        return False\n\n    def check_valid(self):\n        if self.invalid:\n            return False\n        colour = {}\n        for i in set(self.edge_one.keys()) | set(self.edge_zero.keys()):\n            if i in colour:\n                continue\n            colour[i] = 0\n            q = [i]\n            closed = set()\n            while q:\n                current = q.pop()\n                if current in closed:\n                    continue\n                closed.add(current)\n                if current in self.edge_one:\n                    for nbr in self.edge_one[current]:\n                        if nbr not in colour:\n                            colour[nbr] = 1 - colour[current]\n                        elif colour[nbr] == colour[current]:\n                            return False\n                        q.append(nbr)\n                if current in self.edge_zero:\n                    for nbr in self.edge_zero[current]:\n                        if nbr not in colour:\n                            colour[nbr] = colour[current]\n                        elif colour[nbr] != colour[current]:\n                            return False\n                        q.append(nbr)\n        return True\nT = int(input())\nfor _ in range(T):\n    (N, Q) = (int(x) for x in input().split())\n    graph = Graph()\n    for q in range(Q):\n        (i, j, val) = (int(x) for x in input().split())\n        graph.add_edge(i, j, val)\n    if graph.check_valid():\n        print('yes')\n    else:\n        print('no')"]