["from sys import stdin, stdout\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    l = []\n    departure = cnt = 0\n    ans = float('inf')\n    for i in range(n):\n        (arr, dep) = list(map(int, stdin.readline().split()))\n        l += [[arr, 1], [dep, -1]]\n    l.sort(key=lambda x: (x[0], -x[1]))\n    for (pt, type) in l:\n        cnt += type\n        if type == 1:\n            if departure:\n                ans = min(ans, cnt - 1)\n        else:\n            departure = 1\n    print(ans if ans != float('inf') else -1)", "from sys import stdin, stdout\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    l = []\n    departure = cnt = 0\n    ans = float('inf')\n    for i in range(n):\n        (arr, dep) = list(map(int, stdin.readline().split()))\n        l += [[arr, 1], [dep, -1]]\n    l.sort(key=lambda x: (x[0], -x[1]))\n    for (pt, type) in l:\n        cnt += type\n        if type == 1:\n            if departure:\n                ans = min(ans, cnt - 1)\n        else:\n            departure = 1\n    print(ans if ans != float('inf') else -1)", "for _ in range(int(input())):\n    (n, lisa, lisb, curr, ans, i, j) = (int(input()), [], [], 0, 10000000.0, 0, 0)\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        (lisa.append(a), lisb.append(b + 1))\n    (lisa.sort(), lisb.sort())\n    while i < n:\n        if lisa[i] < lisb[j]:\n            (curr, i) = (curr + 1, i + 1)\n        else:\n            (curr, j) = (curr - 1, j + 1)\n        if curr != i:\n            ans = min(ans, curr)\n    print(-1) if ans == 10000000.0 else print(ans)", "from sys import stdin\ninput = stdin.readline\nfor _ in range(int(input())):\n    n = int(input())\n    ranges = []\n    first = (0, 10 ** 9)\n    last = (-1, 0)\n    for _ in range(n):\n        (l, r) = map(int, input().split())\n        ranges.append((l, r))\n        if r < first[1]:\n            first = (l, r)\n        if l > last[0]:\n            last = (l, r)\n    if first[1] >= last[0]:\n        print(-1)\n        continue\n    vals = {}\n    for tpl in ranges:\n        (l, r) = tpl\n        vals[l] = vals.get(l, 0) + 1\n        vals[l + 0.5] = vals.get(l + 0.5, 0)\n        vals[r + 0.5] = vals.get(r + 0.5, 0) - 1\n    points = []\n    for point in vals.keys():\n        points.append(point)\n    points.sort()\n    points.pop()\n    mincount = 10 ** 9\n    count = 0\n    for point in points:\n        count += vals[point]\n        if point > first[1] and point < last[0]:\n            mincount = min(mincount, count)\n        if mincount == 0:\n            break\n    print(mincount)", "for _ in range(int(input())):\n    n = int(input())\n    lisa = []\n    lisb = []\n    for _ in range(n):\n        (a, b) = map(int, input().split())\n        lisa.append(a)\n        lisb.append(b + 1)\n    curr = 0\n    lisa.sort()\n    lisb.sort()\n    ans = 10000000.0\n    i = 0\n    j = 0\n    while i < n:\n        if lisa[i] < lisb[j]:\n            curr += 1\n            i += 1\n        else:\n            curr -= 1\n            j += 1\n        if curr != i:\n            ans = min(ans, curr)\n    if ans == 10000000.0:\n        print(-1)\n    else:\n        print(ans)", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    begin = []\n    end = []\n    for iterations in range(N):\n        l = [int(i) for i in input().split()]\n        begin.append(l[0])\n        end.append(l[1])\n    begin = sorted(begin)\n    end = sorted(end)\n    array = [-1] * (2 * N)\n    begin_index = 0\n    end_index = 0\n    k = 0\n    count = 0\n    while end_index < N and begin_index < N:\n        if begin[begin_index] > end[end_index]:\n            count -= 1\n            array[k] = ['-', count]\n            end_index += 1\n        else:\n            count += 1\n            array[k] = ['+', count]\n            begin_index += 1\n        k += 1\n    while begin_index < N:\n        count += 1\n        array[k] = ['+', count]\n        begin_index += 1\n        k += 1\n    while end_index < N:\n        count -= 1\n        array[k] = ['-', count]\n        end_index += 1\n        k += 1\n    result = float('inf')\n    temp = 0\n    for item in array:\n        if item[0] == '-':\n            temp = 1\n        elif item[0] == '+':\n            if temp:\n                result = min(result, item[1] - 1)\n    if result == float('inf'):\n        print(-1)\n    else:\n        print(result)", "for _ in range(int(input())):\n    n = int(input())\n    (l, r) = ([], [])\n    for _ in range(n):\n        (x, y) = map(int, input().strip().split())\n        l.append(x)\n        r.append(y)\n    l.sort()\n    r.sort()\n    (ans, b, j) = (float('Inf'), False, 0)\n    for i in range(n):\n        while l[j] <= r[i]:\n            j += 1\n            if j == n:\n                b = True\n                break\n        if b:\n            break\n        ans = min(ans, j - i - 1)\n    print(-1 if ans == float('Inf') else ans)", "T = int(input())\nwhile T:\n    N = int(input())\n    arrive = []\n    depart = []\n    for i in range(N):\n        (u, v) = map(int, input().split())\n        arrive.append(u)\n        depart.append(v)\n    depart.sort()\n    arrive.sort()\n    List = [-1] * 2 * N\n    (i, j, k) = (0, 0, 0)\n    prev = 0\n    while i < N and j < N:\n        if arrive[i] > depart[j]:\n            prev -= 1\n            List[k] = ['d', prev]\n            j += 1\n        else:\n            prev += 1\n            List[k] = ['a', prev]\n            i += 1\n        k += 1\n    while i < N:\n        prev += 1\n        List[k] = ['a', prev]\n        i += 1\n        k += 1\n    while j < N:\n        prev -= 1\n        List[k] = ['d', prev]\n        j += 1\n        k += 1\n    count = 10 ** 7\n    flag = False\n    for (u, v) in List:\n        if u == 'a':\n            if flag:\n                count = min(count, v - 1)\n        else:\n            flag = True\n    if count == 10 ** 7:\n        print(-1)\n    else:\n        print(count)\n    T -= 1", "for _ in range(int(input())):\n    N = int(input())\n    (X, Y) = ([], [])\n    for i in range(N):\n        (H, Z) = map(int, input().split())\n        X.append([H, 0])\n        X.append([Z, 1])\n    X.sort()\n    M = float('inf')\n    count = 0\n    a = 0\n    for i in range(len(X)):\n        if a == N:\n            break\n        if X[i][1] == 0:\n            count += 1\n            a += 1\n        else:\n            count -= 1\n            if count < M:\n                M = count\n    if M < N - 1:\n        print(M)\n    else:\n        print('-1')", "import bisect\nfor _ in range(int(input())):\n    n = int(input())\n    arr = []\n    dep = []\n    for i in range(n):\n        (l1, r1) = map(int, input().split())\n        arr.append(l1)\n        dep.append(r1)\n    arr.sort()\n    dep.sort()\n    mini = 10 ** 6\n    merger = []\n    count = 0\n    a = 0\n    d = 0\n    while len(merger) != 2 * n:\n        if arr[a] <= dep[d]:\n            count += 1\n            merger.append([count, 'a'])\n            a += 1\n            if a >= len(arr):\n                arr.append(10 ** 9 + 1)\n        else:\n            count -= 1\n            merger.append([count, 'd'])\n            d += 1\n            if d >= len(dep):\n                dep.append(10 ** 9 + 1)\n    f = 0\n    for (i, j) in merger:\n        if j == 'a':\n            if f:\n                mini = min(mini, i - 1)\n        if j == 'd':\n            f = 1\n    if mini == 10 ** 6:\n        mini = -1\n    print(mini)", "import functools\nfor _ in range(int(input())):\n    x = int(input())\n    start = []\n    end = []\n    min_end = float('inf')\n    max_start = float('-inf')\n    for i in range(x):\n        (m, n) = map(int, input().split())\n        if n < min_end:\n            min_end = n\n        if m > max_start:\n            max_start = m\n        start.append(m)\n        end.append(n)\n    if min_end >= max_start:\n        print(-1)\n    else:\n        ar = []\n        for (i, j) in zip(start, end):\n            ar.append([i, 1])\n            ar.append([j, -1])\n        ar.sort(key=lambda x: x[1], reverse=True)\n        ar.sort(key=lambda x: x[0])\n        en = x\n        i = len(ar) - 1\n        while ar[i][1] != 1 and i >= 0:\n            i -= 1\n        en = i\n        res = float('inf')\n        s = i = 0\n        flg = False\n        while i < len(ar):\n            s += int(ar[i][1])\n            if ar[i][1] == -1:\n                flg = True\n            if flg and i < en:\n                res = min(s, res)\n            i += 1\n        if res == float('inf'):\n            print(-1)\n        else:\n            print(res)", "import functools\n\ndef cmpr(a, b):\n    if a[0] < b[0] or (a[0] == b[0] and a[1] >= b[1]):\n        return -1\n    else:\n        return 1\nfor _ in range(int(input())):\n    x = int(input())\n    start = []\n    end = []\n    min_end = float('inf')\n    max_start = float('-inf')\n    for i in range(x):\n        (m, n) = map(int, input().split())\n        if n < min_end:\n            min_end = n\n        if m > max_start:\n            max_start = m\n        start.append(m)\n        end.append(n)\n    if min_end >= max_start:\n        print(-1)\n    else:\n        ar = []\n        for (i, j) in zip(start, end):\n            ar.append([i, 1])\n            ar.append([j, -1])\n        ar.sort(key=lambda x: x[1], reverse=True)\n        ar.sort(key=lambda x: x[0])\n        en = x\n        i = len(ar) - 1\n        while ar[i][1] != 1 and i >= 0:\n            i -= 1\n        en = i\n        res = float('inf')\n        s = i = 0\n        flg = False\n        while i < len(ar):\n            s += int(ar[i][1])\n            if ar[i][1] == -1:\n                flg = True\n            if flg and i < en:\n                res = min(s, res)\n            i += 1\n        if res == float('inf'):\n            print(-1)\n        else:\n            print(res)", "from collections import defaultdict as t\nfor _ in range(int(input())):\n    n = int(input())\n    pt = set()\n    (s, e) = (t(int), t(int))\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        pt.add(a)\n        pt.add(b)\n        s[a] += 1\n        e[b] += 1\n    l = 0\n    ans = 10 ** 10\n    se = 0\n    pt = sorted(pt)\n    for i in pt:\n        l += s[i]\n        l -= e[i]\n        se += e[i]\n        if se and n - l - se >= 1:\n            ans = min(ans, l)\n    if ans == 10 ** 10:\n        print(-1)\n    else:\n        print(ans)", "try:\n    import sys\n    t = int(input())\n    for _ in range(t):\n        l = []\n        r = []\n        arr = []\n        n = int(input())\n        for i in range(n):\n            (a, b) = map(int, input().split())\n            l.append(a)\n            r.append(b)\n        l.sort()\n        r.sort()\n        overlap = 1\n        result = 1\n        i = 1\n        j = 0\n        while i < n and j < n:\n            if l[i] <= r[j]:\n                overlap += 1\n                i += 1\n            else:\n                overlap -= 1\n                j += 1\n            arr.append(overlap)\n            if overlap == 0:\n                result = 0\n                break\n            elif overlap == n:\n                result = -1\n                break\n        a = sys.maxsize\n        if result != 0 and result != -1:\n            i = 0\n            while i <= len(arr) - 3:\n                if arr[i] == arr[i + 2]:\n                    if a > arr[i + 1]:\n                        a = arr[i + 1]\n                i += 1\n            print(a)\n        else:\n            print(result)\nexcept:\n    pass", "def main(debug=False):\n    for _ in range(int(input())):\n        n = int(input())\n        (l, r) = ([], [])\n        for i in range(n):\n            lr = list(map(int, input().split()))\n            l.append(lr[0])\n            r.append(lr[1])\n        l.sort()\n        r.sort()\n        if debug:\n            print(l)\n            print(r)\n        (lp, rp, mp) = (0, 0, 0)\n        merged = [0 for i in range(2 * n)]\n        if debug:\n            print(merged)\n        cnt = 0\n        while True:\n            if mp == 2 * n:\n                break\n            if lp == n:\n                merged[mp:] = [cnt - (i - rp + 1) for i in range(rp, n)]\n                break\n            if rp == n:\n                merged[mp:] = [cnt + (i - lp + 1) for i in range(lp, n)]\n                break\n            if debug:\n                print('For i=', mp, 'l[lp] r[rp]', l[lp], r[rp])\n            if l[lp] < r[rp]:\n                cnt += 1\n                merged[mp] = cnt\n                lp += 1\n            elif l[lp] == r[rp]:\n                cnt += 1\n                merged[mp] = cnt\n                lp += 1\n            elif l[lp] > r[rp]:\n                cnt -= 1\n                merged[mp] = cnt\n                rp += 1\n            mp += 1\n        if debug:\n            print(merged)\n        prev = merged[0]\n        flag = False\n        count = 10 ** 5 + 1\n        for i in range(1, 2 * n - 1):\n            curr = merged[i]\n            if curr > prev:\n                if flag:\n                    count = min(count, merged[i] - 1)\n            elif curr < prev:\n                flag = True\n            prev = curr\n        if debug:\n            print('Count', count)\n        if count == 10 ** 5 + 1:\n            print(-1)\n        else:\n            print(count)\nmain(debug=False)", "def solve(l, r):\n    l.sort()\n    r.sort()\n    overlap = 1\n    n = len(l)\n    arr = []\n    (i, j) = (1, 0)\n    while i < n and j < n:\n        if l[i] <= r[j]:\n            overlap += 1\n            i += 1\n        else:\n            overlap -= 1\n            j += 1\n        arr.append(overlap)\n        if overlap == 0:\n            print(0)\n            return\n        if overlap == n:\n            print(-1)\n            return\n    result = float('inf')\n    for ind in range(len(arr) - 2):\n        if arr[ind] == arr[ind + 2]:\n            result = min(result, arr[ind + 1])\n    print(result)\nfor case in range(int(input())):\n    (l, r) = ([], [])\n    for tp in range(int(input())):\n        (a, b) = list(map(int, input().split()))\n        l.append(a)\n        r.append(b)\n    solve(l, r)", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nfrom math import inf\nfrom bisect import bisect_left\n\ndef solve():\n    global n, pairs\n    if n == 1:\n        return -1\n    begins = sorted([pair[0] for pair in pairs])\n    ends = sorted([pair[1] for pair in pairs])\n    mini = inf\n    for (i, end) in enumerate(ends):\n        p = bisect_left(begins, end + 1, lo=i)\n        if n - p:\n            mini = min(p - i - 1, mini)\n    return mini if mini != inf else -1\n\ndef read_input():\n    global n, pairs\n    pairs = []\n    n = int(input())\n    for _ in range(n):\n        (l, r) = map(int, stdin.readline().split())\n        pairs.append((l, r))\n\ndef write_output(s):\n    stdout.write('\\n'.join(map(str, s)))\n\ndef main():\n    s = []\n    for _ in range(int(input())):\n        read_input()\n        answer = solve()\n        s.append(answer)\n    write_output(s)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nfrom math import inf\nfrom bisect import bisect_left\n\ndef solve():\n    global n, pairs\n    if n == 1:\n        return -1\n    begins = [pair[0] for pair in pairs]\n    ends = [pair[1] for pair in pairs]\n    begins.sort()\n    ends.sort()\n    mini = inf\n    for (i, end) in enumerate(ends):\n        p = bisect_left(begins, end + 1, lo=i)\n        if n - p:\n            mini = min(p - i - 1, mini)\n    return mini if mini != inf else -1\n\ndef read_input():\n    global n, pairs\n    pairs = []\n    n = int(input())\n    for _ in range(n):\n        (l, r) = list(map(int, stdin.readline().split()))\n        pairs.append((l, r))\n\ndef write_output(s):\n    stdout.write('\\n'.join(map(str, s)))\n\ndef main():\n    s = []\n    for _ in range(int(input())):\n        read_input()\n        answer = solve()\n        s.append(answer)\n    write_output(s)\nmain()", "__author__ = 'Ronald Kaiser'\n__email__ = 'raios dot catodicos at gmail dot com'\nfrom sys import stdin, stdout\nfrom math import inf\nfrom bisect import bisect_left\n\ndef solve():\n    global n, pairs\n    if n == 1:\n        return -1\n    begins = [pair[0] for pair in pairs]\n    ends = [pair[1] for pair in pairs]\n    begins.sort()\n    ends.sort()\n    mini = inf\n    for (i, end) in enumerate(ends):\n        after = len(begins) - bisect_left(begins, end + 1)\n        if after:\n            mini = min(n - after - i - 1, mini)\n    return mini if mini != inf else -1\n\ndef read_input():\n    global n, pairs\n    pairs = []\n    n = int(input())\n    for _ in range(n):\n        (l, r) = list(map(int, stdin.readline().split()))\n        pairs.append((l, r))\n\ndef write_output(s):\n    stdout.write('\\n'.join(map(str, s)))\n\ndef main():\n    s = []\n    for _ in range(int(input())):\n        read_input()\n        answer = solve()\n        s.append(answer)\n    write_output(s)\nmain()", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    arrival = []\n    depart = []\n    for i in range(n):\n        arr = list(map(int, input().split()))\n        arrival.append(arr[0])\n        depart.append(arr[1])\n    arrival.sort()\n    depart.sort()\n    merger = [[0, 'a'] for c in range(2 * n)]\n    i = 0\n    j = 0\n    count = 0\n    point = 0\n    ans = 1000000\n    while i < len(arrival) and j < len(depart):\n        if arrival[i] <= depart[j]:\n            count = count + 1\n            merger[point][0] = count\n            point = point + 1\n            i = i + 1\n        else:\n            count = count - 1\n            merger[point][0] = count\n            merger[point][1] = 'd'\n            point = point + 1\n            j = j + 1\n    while i < len(arrival):\n        count = count + 1\n        merger[point][0] = count\n        point = point + 1\n        i = i + 1\n    while j < len(depart):\n        count = count - 1\n        merger[point][0] = count\n        merger[point][1] = 'd'\n        point = point + 1\n        j = j + 1\n    flag = False\n    for (a, b) in merger:\n        if b == 'a':\n            if flag:\n                ans = min(ans, a - 1)\n                flag = True\n        else:\n            flag = True\n    if ans == 1000000:\n        print(-1)\n    else:\n        print(ans)\n    t = t - 1", "from sys import stdin\nfrom collections import defaultdict\nfrom bisect import bisect_right, insort\nt = int(stdin.readline())\nwhile t:\n    n = int(stdin.readline())\n    a = []\n    for _ in range(n):\n        (l, r) = map(int, stdin.readline().split())\n        a.append((l, r))\n    a.sort(key=lambda x: x[1])\n    ans = 999999\n    temp = [j[0] for j in a]\n    temp.sort()\n    for i in range(n - 1):\n        v = bisect_right(temp, a[i][1])\n        if v < len(temp):\n            ans = min(ans, v - i - 1)\n    if ans == 999999:\n        ans = -1\n    print(ans if n - ans >= 2 else '-1')\n    t -= 1", "t = int(input())\nwhile t > 0:\n    n = int(input())\n    ends = []\n    starts = []\n    for _ in range(n):\n        inp = list(map(int, input().split()))\n        starts.append(inp[0])\n        ends.append(inp[1])\n    starts.sort()\n    ends.sort()\n    i = 0\n    j = 0\n    vals = []\n    cnt = 999999999\n    ctr = 0\n    while i < n and j < n:\n        if starts[i] > ends[j]:\n            ctr -= 1\n            j += 1\n            cnt = min(cnt, ctr)\n        else:\n            i += 1\n            ctr += 1\n    if cnt == 999999999 or cnt == n:\n        print(-1)\n    else:\n        print(cnt)\n    t -= 1", "T = int(input())\nwhile T > 0:\n    N = int(input())\n    res = N\n    count = 0\n    l = []\n    r = []\n    for _ in range(N):\n        (t1, t2) = list(map(int, input().split()))\n        l.append(t1)\n        r.append(t2)\n    l = sorted(l)\n    r = sorted(r)\n    for _ in range(N):\n        if l[_] > r[0]:\n            count = _\n            break\n    else:\n        print(-1)\n        T -= 1\n        continue\n    (result, i, j) = (0, count, 0)\n    while True:\n        if l[i] <= r[j]:\n            count += 1\n            i += 1\n            if i == N:\n                break\n        else:\n            count -= 1\n            res = min(res, count)\n            j += 1\n    print(res)\n    T -= 1", "T = int(input())\nwhile T > 0:\n    N = int(input())\n    res = N\n    count = 0\n    l = []\n    r = []\n    for _ in range(N):\n        (t1, t2) = list(map(int, input().split()))\n        l.append(t1)\n        r.append(t2)\n    l = sorted(l)\n    r = sorted(r)\n    for _ in range(N):\n        if l[_] > r[0]:\n            count = _\n            break\n    else:\n        print(-1)\n        T -= 1\n        continue\n    (result, i, j) = (0, count, 0)\n    while True:\n        if l[i] <= r[j]:\n            count += 1\n            i += 1\n            if i == N:\n                break\n        else:\n            count -= 1\n            res = min(res, count)\n            j += 1\n    print(res)\n    T -= 1", "import numpy as np\ni8 = np.int64\n\ndef solve(l, r, n):\n    res = n\n    for i in range(n):\n        if l[i] > r[0]:\n            count = i\n            break\n    else:\n        return -1\n    il = count\n    ir = 0\n    while True:\n        if l[il] <= r[ir]:\n            count += 1\n            il += 1\n            if il == n:\n                break\n        else:\n            count -= 1\n            res = min(res, count)\n            ir += 1\n    return res\n\ndef main():\n    f = open(0, 'r')\n    stdin = np.fromstring(f.read(), i8, sep=' ')\n    T = stdin[0]\n    i = 1\n    for _ in range(T):\n        N = stdin[i]\n        lr = stdin[i + 1:i + 1 + 2 * N].reshape(-1, 2).T\n        l = lr[0]\n        l = np.sort(l)\n        r = lr[1]\n        r = np.sort(r)\n        print(solve(l, r, N))\n        i += 2 * N + 1\nmain()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    arr = []\n    end = []\n    count1 = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        arr.append(a)\n        end.append(b)\n    arr.sort()\n    end.sort()\n    p1 = p2 = 0\n    pre = 0\n    while p1 != n and p2 != n:\n        if arr[p1] <= end[p2]:\n            if pre == 0:\n                count1.append((1, 'a'))\n            else:\n                (x, y) = count1[pre - 1]\n                count1.append((x + 1, 'a'))\n            pre += 1\n            p1 += 1\n        else:\n            (x, y) = count1[pre - 1]\n            count1.append((x - 1, 'd'))\n            pre += 1\n            p2 += 1\n    while p2 != n:\n        (x, y) = count1[pre - 1]\n        count1.append((x - 1, 'd'))\n        pre += 1\n        p2 += 1\n    ans = 10000000\n    flag = False\n    for (i, j) in count1:\n        if j == 'a':\n            if flag:\n                ans = min(ans, i - 1)\n        else:\n            flag = True\n    if ans == 10000000:\n        print('-1')\n    else:\n        print(ans)", "from sys import stdin\nfrom collections import defaultdict\ntest = int(stdin.readline())\nMAX = 1000000001\nfor _ in range(test):\n    N = int(stdin.readline())\n    if N == 1:\n        (a, b) = map(int, stdin.readline())\n        print(-1)\n        continue\n    if N == 2:\n        (a1, a2) = map(int, stdin.readline().split())\n        (b1, b2) = map(int, stdin.readline().split())\n        if a2 > b2:\n            if b2 >= a1:\n                print(-1)\n            else:\n                print(0)\n        elif a2 == b2:\n            print(-1)\n        elif a2 >= b1:\n            print(-1)\n        else:\n            print(0)\n        continue\n    entry = defaultdict(int)\n    end = defaultdict(int)\n    s = set()\n    for i in range(N):\n        (l, r) = map(int, stdin.readline().strip().split())\n        s.add(l)\n        s.add(r)\n        entry[l] += 1\n        end[r] += 1\n    s = list(s)\n    s.sort()\n    ans = -1\n    cnt = 0\n    for i in range(len(s) - 1):\n        cnt += entry[s[i]] - end[s[i]]\n        if end[s[i]] > 0:\n            if entry[s[i + 1]] > 0:\n                if ans == -1:\n                    ans = cnt\n                else:\n                    ans = min(ans, cnt)\n    if ans == -1:\n        print(-1)\n    else:\n        print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    l = []\n    r = []\n    arr = []\n    for i in range(n):\n        (l1, l2) = map(int, input().split())\n        l.append(l1)\n        r.append(l2)\n    l.sort()\n    r.sort()\n    res = 1\n    overlapping = 1\n    i = 1\n    j = 0\n    while i < n and j < n:\n        if l[i] <= r[j]:\n            overlapping += 1\n            i += 1\n        else:\n            overlapping -= 1\n            j += 1\n        arr.append(overlapping)\n        if overlapping == 0:\n            res = 0\n            break\n        if overlapping == n:\n            res = -1\n            break\n    if res != 0 and res != -1:\n        m = -1\n        for i in range(len(arr) - 2):\n            if arr[i] == arr[i + 2]:\n                if m == -1:\n                    m = arr[i + 1]\n                else:\n                    m = min(m, arr[i + 1])\n        print(m)\n    else:\n        print(res)", "T = int(input())\nfor t in range(T):\n    n = int(input())\n    ranges = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        ranges.append((a, 0))\n        ranges.append((b, 1))\n    ranges = list(sorted(ranges))\n    cnt = 0\n    res = 1000000000.0\n    possible = False\n    for (_, dir) in ranges:\n        if dir == 0:\n            if possible:\n                res = min(res, cnt)\n            cnt += 1\n        else:\n            cnt -= 1\n            possible = True\n    if res == 1000000000.0:\n        res = -1\n    print(res)", "for _ in range(int(input())):\n    n = int(input())\n    (a, b) = ([], [])\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        a.append(l)\n        b.append(r)\n    temp = []\n    a.sort(reverse=True)\n    b.sort(reverse=True)\n    count = 0\n    while a and b:\n        if a[-1] <= b[-1]:\n            count += 1\n            temp.append([count, 'a'])\n            a.pop()\n        else:\n            count -= 1\n            temp.append([count, 'd'])\n            b.pop()\n    while a:\n        count += 1\n        temp.append([count, 'a'])\n        a.pop()\n    while b:\n        count -= 1\n        temp.append([count, 'd'])\n        b.pop()\n    flag = False\n    ans = 100000000\n    for (i, j) in temp:\n        if j == 'a':\n            if flag:\n                ans = min(ans, i - 1)\n        else:\n            flag = True\n    if ans == 100000000:\n        print(-1)\n    else:\n        print(ans)", "for _ in range(int(input())):\n    n = int(input())\n    l = []\n    r = []\n    for i in range(n):\n        (li, ri) = map(int, input().split())\n        l.append(li)\n        r.append(ri)\n    l.sort()\n    r.sort()\n    (exists, flag) = (False, False)\n    j = 0\n    ans = n\n    for i in range(n - 1):\n        while l[j] <= r[i]:\n            j += 1\n            if j == n:\n                flag = True\n                break\n        if flag == True:\n            break\n        ans = min(ans, j - i - 1)\n        exists = True\n    if exists == True:\n        print(ans)\n    else:\n        print(-1)", "t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    a = []\n    b = []\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        a.append(l)\n        b.append(r)\n    a.sort()\n    b.sort()\n    (i, j) = (0, 0)\n    cur = 0\n    ans = 2 << 32\n    while i < n and j < n:\n        if a[i] <= b[j]:\n            cur += 1\n            i += 1\n        else:\n            cur -= 1\n            j += 1\n        if j > 0:\n            ans = min(ans, cur)\n    if ans == 2 << 32:\n        print(-1)\n    else:\n        print(ans)", "from collections import defaultdict as dd\nfor _ in range(int(input())):\n    app = dd(int)\n    dep = dd(int)\n    all_set = set()\n    n = int(input())\n    for __ in range(n):\n        (i, j) = input().strip().split()\n        (i, j) = (int(i), int(j))\n        app[i] += 1\n        dep[j] += 1\n        all_set.add(i)\n        all_set.add(j)\n    all_set = sorted(all_set)\n    curr = 0\n    min1 = float('inf')\n    flag = 0\n    for t in all_set:\n        if flag == 0:\n            if t in dep:\n                flag = 1\n        elif app[t] != 0:\n            min1 = min(curr, min1)\n        curr += app[t] - dep[t]\n    if min1 == n - 1 or min1 == float('inf'):\n        min1 = -1\n    print(min1)", "from collections import defaultdict\n\ndef checkdisjoint(a, b):\n    if a[1] < b[0] or b[1] < a[0]:\n        return True\n    else:\n        return False\nfor _ in range(int(input())):\n    N = int(input())\n    R = []\n    FirstCloser = (0, 10000000000)\n    LastOpener = (-1, 0)\n    for k in range(N):\n        (a, b) = map(int, input().split())\n        if b < FirstCloser[1]:\n            FirstCloser = (a, b)\n        if a > LastOpener[0]:\n            LastOpener = (a, b)\n        R.append((a, b))\n    if checkdisjoint(FirstCloser, LastOpener) == False:\n        print('-1')\n        continue\n    d = defaultdict(int)\n    for x in R:\n        d[x[0]] += 1\n        d[x[1] + 0.5] -= 1\n    Points = []\n    for x in d:\n        Points.append(x)\n    Points = sorted(Points)\n    m = 10000000000\n    s = 0\n    Points.pop()\n    for x in Points:\n        s = s + d[x]\n        if x > FirstCloser[1] and x < LastOpener[0]:\n            m = min(m, s)\n        if m == 0:\n            break\n        if x == LastOpener[0]:\n            break\n    print(m)", "t = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    l = []\n    r = []\n    arr = []\n    for i in range(n):\n        (l1, l2) = map(int, input().split())\n        l.append(l1)\n        r.append(l2)\n    l.sort()\n    r.sort()\n    res = 1\n    overlapping = 1\n    i = 1\n    j = 0\n    while i < n and j < n:\n        if l[i] <= r[j]:\n            overlapping += 1\n            i += 1\n        else:\n            overlapping -= 1\n            j += 1\n        arr.append(overlapping)\n        if overlapping == 0:\n            res = 0\n            break\n        if overlapping == n:\n            res = -1\n            break\n    if res != 0 and res != -1:\n        m = -1\n        for i in range(len(arr) - 2):\n            if arr[i] == arr[i + 2]:\n                if m == -1:\n                    m = arr[i + 1]\n                else:\n                    m = min(m, arr[i + 1])\n        print(m)\n    else:\n        print(res)", "from sys import stdin, stdout\nimport bisect\n\ndef add(arr, N, lo, hi, val):\n    arr[lo] += val\n    if hi != N - 1:\n        arr[hi + 1] -= val\n\ndef updateArray(arr, N):\n    for i in range(1, N):\n        arr[i] += arr[i - 1]\nfor i in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    l = [0] * n\n    l1 = []\n    l2 = []\n    for j in range(n):\n        l1.append(list(map(int, stdin.readline().split())))\n    l1.sort()\n    for i in l1:\n        l2.append(i[0])\n    for i in range(n - 1):\n        j = bisect.bisect(l2, l1[i][1])\n        add(l, n, i + 1, j - 1, 1)\n    updateArray(l, n)\n    c = 10 ** 5 + 1\n    for i in range(n):\n        if l[i] < c and l[i] != i:\n            c = l[i]\n        if c == 0:\n            break\n    if c == 10 ** 5 + 1:\n        print(-1)\n        continue\n    print(c)", "test = int(input())\nfor intnt in range(test):\n    num = int(input())\n    arr1 = []\n    arr2 = []\n    for indx1 in range(num):\n        (val1, y) = list(map(int, input().split()))\n        arr1.append(val1)\n        arr2.append(y)\n    arr1.sort()\n    arr2.sort()\n    ar = []\n    for i in range(num):\n        ar.append(i)\n    if num != 1:\n        val1 = list(set(arr2))\n        val1.sort()\n        p = [0] * len(val1)\n        q = [0] * len(val1)\n        indx2 = 0\n        indx1 = 0\n        while indx1 < num:\n            if indx2 == len(val1):\n                break\n            if arr1[indx1] <= val1[indx2]:\n                p[indx2] += 1\n                indx1 += 1\n            else:\n                indx2 += 1\n        indx2 = 0\n        indx1 = 0\n        while indx1 < num:\n            if indx2 == len(val1):\n                break\n            if arr2[indx1] <= val1[indx2]:\n                q[indx2] += 1\n                indx1 += 1\n            else:\n                indx2 += 1\n                q[indx2] = q[indx2 - 1]\n        for indx1 in range(1, len(p)):\n            p[indx1] += p[indx1 - 1]\n        for indx1 in range(len(p)):\n            p[indx1] = num - p[indx1]\n        ans = num + 2\n        for indx1 in range(len(val1)):\n            if not (p[indx1] == 0 or q[indx1] == 0):\n                ans = min(ans, num - p[indx1] - q[indx1])\n        if ans == num + 2:\n            print(-1)\n        else:\n            print(ans)\n    else:\n        print(-1)", "try:\n    import sys\n    t = int(input())\n    for _ in range(t):\n        l = []\n        r = []\n        arr = []\n        n = int(input())\n        for i in range(n):\n            (a, b) = map(int, input().split())\n            l.append(a)\n            r.append(b)\n        l.sort()\n        r.sort()\n        overlap = 1\n        result = 1\n        i = 1\n        j = 0\n        while i < n and j < n:\n            if l[i] <= r[j]:\n                overlap += 1\n                i += 1\n            else:\n                overlap -= 1\n                j += 1\n            arr.append(overlap)\n            if overlap == 0:\n                result = 0\n                break\n            elif overlap == n:\n                result = -1\n                break\n        a = sys.maxsize\n        if result != 0 and result != -1:\n            i = 0\n            while i <= len(arr) - 3:\n                if arr[i] == arr[i + 2]:\n                    if a > arr[i + 1]:\n                        a = arr[i + 1]\n                i += 1\n            print(a)\n        else:\n            print(result)\nexcept:\n    pass", "from sys import stdin\nfrom collections import defaultdict\ntest = int(stdin.readline())\nMAX = 1000000001\nfor _ in range(test):\n    N = int(stdin.readline())\n    if N == 1:\n        (a, b) = map(int, stdin.readline())\n        print(-1)\n        continue\n    if N == 2:\n        (a1, a2) = map(int, stdin.readline().split())\n        (b1, b2) = map(int, stdin.readline().split())\n        if a2 > b2:\n            if b2 >= a1:\n                print(-1)\n            else:\n                print(0)\n        elif a2 == b2:\n            print(-1)\n        elif a2 >= b1:\n            print(-1)\n        else:\n            print(0)\n        continue\n    entry = defaultdict(int)\n    end = defaultdict(int)\n    s = set()\n    for i in range(N):\n        (l, r) = map(int, stdin.readline().strip().split())\n        s.add(l)\n        s.add(r)\n        entry[l] += 1\n        end[r] += 1\n    s = list(s)\n    s.sort()\n    ans = -1\n    cnt = 0\n    for i in range(len(s) - 1):\n        cnt += entry[s[i]] - end[s[i]]\n        if end[s[i]] > 0:\n            if entry[s[i + 1]] > 0:\n                if ans == -1:\n                    ans = cnt\n                else:\n                    ans = min(ans, cnt)\n    if ans == -1:\n        print(-1)\n    else:\n        print(ans)", "t = int(input())\nfor i in range(t):\n    start = []\n    end = []\n    n = int(input())\n    for j in range(n):\n        inp = list(map(int, input().split()))\n        start.append(inp[0])\n        end.append(inp[1])\n    cum_end = []\n    cum_start = []\n    from collections import Counter\n    c = Counter(start)\n    d = Counter(end)\n    k = 0\n    l = 0\n    start_list = list(c.keys())\n    end_list = list(d.keys())\n    start_list.sort()\n    end_list.sort()\n    for item in start_list:\n        k += c[item]\n        cum_start.append(k)\n    for item in end_list:\n        l += d[item]\n        cum_end.append(l)\n    mini = 9999999999\n    x = 0\n    y = 0\n    flag = 0\n    while x < len(end_list) and y < len(start_list):\n        a = cum_end[x]\n        while start_list[y] <= end_list[x]:\n            y += 1\n            if y == len(start_list):\n                flag = 1\n                break\n        if flag == 1:\n            break\n        else:\n            b = l - cum_start[y - 1]\n            if b == 0:\n                break\n            elif n - a - b < mini:\n                mini = n - a - b\n        x += 1\n    if mini == 9999999999:\n        print(-1)\n    else:\n        print(mini)", "from sys import stdin\n\ndef search2(array, s, end):\n    i = s\n    j = len(array) - 1 - s\n    while j > 0:\n        while i + j < len(array) and array[i + j] <= end:\n            i += j\n        j //= 2\n    if i == len(array) - 1:\n        if array[len(array) - 1] < end:\n            i += 1\n    return i\nfor __ in range(int(stdin.readline())):\n    starts = []\n    ends = []\n    n = int(stdin.readline())\n    for i in range(n):\n        (start, end) = map(int, stdin.readline().split())\n        starts.append(start)\n        ends.append(end)\n    starts.sort()\n    ends.sort()\n    ans = 1010101\n    e = s = 0\n    while e < n and s < n:\n        while s < n and starts[s] <= ends[e]:\n            s += 1\n        if s - e > 0 and s - e < ans and (s < n):\n            ans = s - e\n        e += 1\n    if ans == 1010101:\n        ans = 0\n    print(ans - 1)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    A = []\n    for i in range(n):\n        (l, r) = list(map(int, input().split()))\n        A.append((l, 0))\n        A.append((r, 1))\n    A = sorted(A)\n    minimumIntervals = float('inf')\n    currentIntervals = 0\n    lLeft = n\n    foundR = False\n    for (i, (l, r)) in enumerate(A[:-1]):\n        if r == 0:\n            currentIntervals += 1\n            lLeft -= 1\n        else:\n            foundR = True\n            currentIntervals -= 1\n        if not foundR:\n            continue\n        if lLeft == 0:\n            continue\n        if currentIntervals < minimumIntervals:\n            minimumIntervals = currentIntervals\n    if minimumIntervals == float('inf'):\n        print(-1)\n    else:\n        print(minimumIntervals)", "t = int(input())\nwhile t > 0:\n    t -= 1\n    n = int(input())\n    d = {}\n    b = set()\n    lm = 0\n    rm = 1000000001\n    mn = n\n    while n > 0:\n        n -= 1\n        (l, r) = list(map(int, input().split()))\n        if l not in d:\n            d[l] = 0\n        if r + 1 not in d:\n            d[r + 1] = 0\n        if r not in d:\n            d[r] = 0\n        d[l] += 1\n        d[r + 1] -= 1\n        b.add(l)\n        b.add(r)\n        if rm > r:\n            rm = r\n        if lm < l:\n            lm = l\n    if rm >= lm:\n        print(-1)\n    else:\n        b1 = list(b)\n        b1.sort()\n        p = 0\n        f = 0\n        for i in range(len(b1) - 1):\n            p = p + d[b1[i]] + f\n            if b1[i] >= rm and b1[i] <= lm:\n                if p < mn:\n                    mn = p\n                if p == 1:\n                    break\n            if b1[i] + 1 in d and b1[i] + 1 != b1[i + 1]:\n                f = d[b1[i] + 1]\n            else:\n                f = 0\n        print(mn - 1)", "from collections import defaultdict as dd\nfor _ in range(int(input())):\n    app = dd(int)\n    dep = dd(int)\n    all_set = set()\n    n = int(input())\n    for __ in range(n):\n        (i, j) = input().strip().split()\n        (i, j) = (int(i), int(j))\n        app[i] += 1\n        dep[j] += 1\n        all_set.add(i)\n        all_set.add(j)\n    all_set = sorted(all_set)\n    curr = 0\n    min1 = float('inf')\n    flag = 0\n    for t in all_set:\n        if flag == 0:\n            if t in dep:\n                flag = 1\n        elif app[t] != 0:\n            min1 = min(curr, min1)\n        curr += app[t] - dep[t]\n    if min1 == n - 1 or min1 == float('inf'):\n        min1 = -1\n    print(min1)", "from functools import cmp_to_key\nimport sys\nVALUE = 0\nDIR = 1\n\ndef sort_cmp(a, b):\n    if a[VALUE] != b[VALUE]:\n        return 1 if a[VALUE] > b[VALUE] else -1\n    return -1 if a[DIR] else 1\n\ndef key_func(x):\n    d = 0 if x[DIR] else 0.5\n    return x[VALUE] + d\n\ndef optimized():\n    n = int(input())\n    ranges = []\n    for i in range(n):\n        (l, r) = input().split()\n        (l, r) = (int(l), int(r))\n        ranges.append([l, True])\n        ranges.append([r, False])\n    ranges = sorted(ranges, key=key_func)\n    rem = n - 1\n    covered = 0\n    over = 1\n    ans = sys.maxsize\n    for i in range(1, len(ranges)):\n        if ranges[i][VALUE] != ranges[i - 1][VALUE]:\n            if covered > 0 and rem > 0:\n                ans = min(ans, over)\n        if ans == 0:\n            break\n        if ranges[i][DIR]:\n            rem -= 1\n            over += 1\n        else:\n            over -= 1\n            covered += 1\n    if ans == sys.maxsize:\n        ans = -1\n    print(ans)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        optimized()\nmain()", "import math\nimport bisect\nimport sys\ninput = sys.stdin.readline\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef inn():\n    return int(input())\n\ndef inl():\n    return list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nINF = inf = 10 ** 18 + 5\nfor t in range(int(input())):\n    n = int(input())\n    arr = []\n    for i in range(n):\n        arr.append(inl())\n    lmax = -INF\n    rmin = INF\n    for i in arr:\n        lmax = max(lmax, i[0])\n        rmin = min(rmin, i[1])\n    if rmin >= lmax or n == 1:\n        print(-1)\n        continue\n    arr.sort()\n    if n == 2:\n        if arr[0][1] < arr[1][0]:\n            print(0)\n        else:\n            print(-1)\n        continue\n    pos = {}\n    for i in arr:\n        pos[i[0]] = 0\n        pos[i[1]] = 0\n    for i in arr:\n        pos[i[0]] += 1\n        pos[i[1]] -= 1\n    k = list(pos.keys())\n    k.sort()\n    for i in range(1, len(k)):\n        pos[k[i]] += pos[k[i - 1]]\n    ans = INF\n    for i in range(len(k)):\n        if k[i] < rmin:\n            continue\n        if k[i] >= lmax:\n            break\n        ans = min(ans, pos[k[i]])\n    print(ans)", "import math\nimport bisect\nimport sys\ninput = sys.stdin.readline\n\ndef power(x, y, p):\n    res = 1\n    x = x % p\n    while y > 0:\n        if y & 1 == 1:\n            res = res * x % p\n        y = y >> 1\n        x = x * x % p\n    return res\n\ndef inn():\n    return int(input())\n\ndef inl():\n    return list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nINF = inf = 10 ** 18 + 5\nfor t in range(int(input())):\n    n = int(input())\n    arr = []\n    for i in range(n):\n        arr.append(inl())\n    lmax = -INF\n    rmin = INF\n    for i in arr:\n        lmax = max(lmax, i[0])\n        rmin = min(rmin, i[1])\n    if rmin >= lmax or n == 1:\n        print(-1)\n        continue\n    arr.sort()\n    if n == 2:\n        if arr[0][1] < arr[1][0]:\n            print(0)\n        else:\n            print(-1)\n        continue\n    pos = {}\n    for i in arr:\n        pos[i[0]] = 0\n        pos[i[1]] = 0\n    for i in arr:\n        pos[i[0]] += 1\n        pos[i[1]] -= 1\n    k = list(pos.keys())\n    k.sort()\n    for i in range(1, len(k)):\n        pos[k[i]] += pos[k[i - 1]]\n    ans = INF\n    for i in range(len(k)):\n        if k[i] < rmin:\n            continue\n        if k[i] >= lmax:\n            break\n        ans = min(ans, pos[k[i]])\n    print(ans)", "def fun(partitions):\n    if len(partitions) == 2:\n        print(0)\n    else:\n        end_points = {}\n        for j in partitions:\n            end_points[j[0]] = end_points.get(j[0], 0) + 1\n            end_points[j[1]] = end_points.get(j[1], 0) - 1\n        final_partitions = sorted(end_points.items())\n        temp = []\n        temp.append(0)\n        for j in final_partitions:\n            temp.append(temp[-1] + j[1])\n        if len(temp) > 4:\n            a = min(temp[2:-2])\n        else:\n            a = min(temp[1:-1])\n        if a >= len(partitions) - 1:\n            print(-1)\n        else:\n            print(a)\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    ans = n\n    maxl0 = int(0)\n    minl1 = int(0)\n    partitions = {}\n    for j in range(n):\n        l = input().split(' ')\n        l[0] = int(l[0])\n        l[1] = int(l[1])\n        partitions[l[0]] = partitions.get(l[0], 0) + 1\n        partitions[l[1]] = partitions.get(l[1], 0) - 1\n        if j == 0:\n            maxl0 = l[0]\n            minl1 = l[1]\n        else:\n            maxl0 = max(maxl0, l[0])\n            minl1 = min(minl1, l[1])\n    sorted_partitions = []\n    for j in sorted(partitions.keys()):\n        sorted_partitions.append([j, partitions[j]])\n    cnt = int(0)\n    for j in sorted_partitions:\n        cnt += j[1]\n        if cnt < ans and j[0] >= minl1 and (j[0] < maxl0):\n            ans = cnt\n    if ans > n - 2:\n        print(-1)\n    else:\n        print(ans)", "from bisect import bisect_left, bisect_right\nT = int(input())\nfor t in range(T):\n    lefts = list()\n    rights = list()\n    N = int(input())\n    for i in range(N):\n        (l, r) = map(int, input().split())\n        lefts.append(l)\n        rights.append(r)\n    lefts.sort()\n    rights.sort()\n    found = False\n    minDropped = int(1000000000.0)\n    for r in rights:\n        leftLen = bisect_right(rights, r)\n        rightLen = N - bisect_left(lefts, r + 1)\n        if rightLen > 0:\n            found = True\n            minDropped = min(minDropped, N - (leftLen + rightLen))\n    if found:\n        print(minDropped)\n    else:\n        print(-1)", "import functools\n\ndef cmpr(a, b):\n    if a[0] < b[0] or (a[0] == b[0] and a[1] >= b[1]):\n        return -1\n    else:\n        return 1\nfor _ in range(int(input())):\n    x = int(input())\n    start = []\n    end = []\n    min_end = float('inf')\n    max_start = float('-inf')\n    for i in range(x):\n        (m, n) = map(int, input().split())\n        if n < min_end:\n            min_end = n\n        if m > max_start:\n            max_start = m\n        start.append(m)\n        end.append(n)\n    if min_end >= max_start:\n        print(-1)\n    else:\n        ar = []\n        for (i, j) in zip(start, end):\n            ar.append([i, 1])\n            ar.append([j, -1])\n        ar.sort(key=lambda x: x[1], reverse=True)\n        ar.sort(key=lambda x: x[0])\n        en = x\n        i = len(ar) - 1\n        while ar[i][1] != 1 and i >= 0:\n            i -= 1\n        en = i\n        res = float('inf')\n        s = i = 0\n        flg = False\n        while i < len(ar):\n            s += int(ar[i][1])\n            if ar[i][1] == -1:\n                flg = True\n            if flg and i < en:\n                res = min(s, res)\n            i += 1\n        if res == float('inf'):\n            print(-1)\n        else:\n            print(res)", "n_of_test_cases = input()\nn_of_test_cases = int(n_of_test_cases)\nfor test_cases in range(n_of_test_cases):\n    begin = []\n    end = []\n    for iterations in range(int(input())):\n        l = [int(i) for i in input().split()]\n        begin.append(l[0])\n        end.append(l[1])\n    size = len(begin)\n    begin = sorted(begin)\n    end = sorted(end)\n    array = [-1] * (2 * size)\n    begin_index = 0\n    end_index = 0\n    k = 0\n    count = 0\n    while end_index < size and begin_index < size:\n        if begin[begin_index] > end[end_index]:\n            count -= 1\n            array[k] = ['-', count]\n            end_index += 1\n        else:\n            count += 1\n            array[k] = ['+', count]\n            begin_index += 1\n        k += 1\n    while begin_index < size:\n        count += 1\n        array[k] = ['+', count]\n        begin_index += 1\n        k += 1\n    while end_index < size:\n        count -= 1\n        array[k] = ['-', count]\n        end_index += 1\n        k += 1\n    result = float('inf')\n    temp = 0\n    for item in array:\n        if item[0] == '-':\n            temp = 1\n        elif item[0] == '+':\n            if temp:\n                result = min(result, item[1] - 1)\n    if result == float('inf'):\n        print(-1)\n    else:\n        print(result)", "for _ in range(int(input())):\n    arr = []\n    dep = []\n    pair = []\n    n = int(input())\n    for _ in range(n):\n        (a, d) = input().split()\n        pair.append((int(a), int(d)))\n        arr.append(int(a))\n        dep.append(int(d))\n    arr.sort()\n    dep.sort()\n    i = 0\n    j = 0\n    count = 0\n    plat = []\n    while i < n and j < n:\n        if arr[i] <= dep[j]:\n            count += 1\n            plat.append((count, 'a'))\n            i += 1\n        elif arr[i] > dep[j]:\n            count -= 1\n            plat.append((count, 'd'))\n            j += 1\n    while i < n:\n        count += 1\n        plat.append((count, 'a'))\n        i += 1\n    while j < n:\n        count -= 1\n        plat.append((count, 'd'))\n        j += 1\n    flag = False\n    ans = 1000000\n    for (cnt, typ) in plat:\n        if typ == 'a':\n            if flag:\n                ans = min(ans, cnt - 1)\n        else:\n            flag = True\n    if ans == 1000000:\n        ans = -1\n    print(ans)", "def main():\n    nn = rem = cnt = a = b = i = temp = 0\n    for _ in range(int(input())):\n        vec = []\n        nn = int(input())\n        rem = cnt = 0\n        res = nn\n        for i in range(nn):\n            (a, b) = input().split()\n            vec.append([int(a), 1])\n            vec.append([int(b), 0])\n        vec.sort()\n        i = 0\n        while i < len(vec) - 1:\n            j = i\n            while j < len(vec) and vec[j][0] == vec[i][0]:\n                if vec[j][1] == 1:\n                    cnt += 1\n                else:\n                    cnt -= 1\n                    rem += 1\n                j += 1\n            i = j\n            temp = nn - rem - cnt\n            if temp != 0 and rem != 0:\n                if res > cnt:\n                    res = cnt\n        if res == nn:\n            res = -1\n        print(res)\nmain()", "for _ in range(int(input())):\n    n = int(input())\n    d = {}\n    inter = []\n    laststart = 0\n    firstend = 1000000000\n    for i in range(n):\n        (l, r) = input().split()\n        l = int(l)\n        r = int(r)\n        if l > laststart:\n            laststart = l\n        if firstend > r:\n            firstend = r\n        if l in d.keys():\n            d[l][0] += 1\n        else:\n            d[l] = [1, 0]\n        if r in d.keys():\n            d[r][1] += 1\n        else:\n            d[r] = [0, 1]\n    k = sorted(list(d.keys()))\n    flag = 0\n    temp = 0\n    for i in k:\n        if i == laststart:\n            break\n        if flag == 0:\n            temp += d[i][0] - d[i][1]\n            if i == firstend and d[i][1] != 0:\n                inter.append(temp)\n                flag = 1\n        elif flag == 1:\n            temp += d[i][0] - d[i][1]\n            inter.append(temp)\n    if len(inter) == 0:\n        print(-1)\n    else:\n        inter = sorted(inter)\n        print(inter[0])", "def testcase(arr, dep, n):\n    arr.sort()\n    dep.sort()\n    plat_needed = 0\n    result = n\n    i = 0\n    j = 0\n    flag = False\n    while i < n and j < n - 1:\n        if arr[i] <= dep[j]:\n            plat_needed += 1\n            i += 1\n        else:\n            flag = True\n            plat_needed -= 1\n            j += 1\n        if plat_needed < result and flag:\n            result = plat_needed\n        if result == 0:\n            return 0\n    if n - result < 2:\n        return -1\n    if result > n - 1:\n        return -1\n    return result\n\ndef testcase2(n, pair):\n    counter = len(pair)\n    for current in range(len(pair)):\n        flag = True\n        count = 0\n        upper = pair[current][1]\n        for i in range(len(pair)):\n            if i == current:\n                continue\n            if pair[i][1] <= upper:\n                continue\n            if pair[i][1] > upper:\n                if pair[i][0] > upper:\n                    flag = False\n                    continue\n                else:\n                    count += 1\n        if flag:\n            count = len(pair)\n        counter = min(counter, count)\n    if counter >= n - 1:\n        return -1\n    else:\n        return counter\nt = int(input())\nfor i in range(t):\n    n = int(input())\n    arr = []\n    dep = []\n    for j in range(n):\n        (a, b) = [int(_) for _ in input().split()]\n        arr.append(a)\n        dep.append(b)\n    print(testcase(arr, dep, n))", "for t in range(int(input())):\n    n = int(input())\n    (starts, ends) = ([], [])\n    (minimum, maximum) = (float('inf'), 0)\n    for i in range(n):\n        t = [int(i) for i in input().split()]\n        starts.append(t[0])\n        ends.append(t[1])\n    starts.sort()\n    ends.sort()\n    (counts, startI) = ({}, 0)\n    for (i, end) in enumerate(ends):\n        end += 0.5\n        while startI < n and starts[startI] < end:\n            startI += 1\n        endBef = i + 1\n        counts[end] = (startI, endBef)\n    best = None\n    for (pt, (startBef, endBef)) in counts.items():\n        contains = startBef - endBef\n        if startBef != n and startBef != 0 and (best == None or contains < best):\n            best = contains\n    if best == None:\n        print(-1)\n    else:\n        print(best)", "def binary(a, l, r, e):\n    if e > a[r] or l > r:\n        return -1\n    (start, end, mid, max1) = (l, r, -1, -1)\n    while start <= end:\n        mid = start + end >> 1\n        if a[mid] > e:\n            end = mid - 1\n        else:\n            start = mid + 1\n            max1 = max(mid, max1)\n    return max1\nfor _ in range(int(input())):\n    n = int(input())\n    tr = {}\n    arr = [0 for i in range(n)]\n    for i in range(n):\n        (l, r) = [int(i) for i in input().split(' ')]\n        tr[l] = tr.get(l, 0) + 1\n        arr[i] = r\n    arr.sort()\n    (last, count, ans) = (0, 0, n)\n    for k in sorted(tr.keys()):\n        last = max(binary(arr, last, n - 1, k - 1) + 1, last)\n        delete = count - last\n        if delete != count:\n            ans = min(ans, delete)\n        if ans == 0:\n            break\n        count += tr[k]\n    if ans != n:\n        print(ans)\n    else:\n        print(-1)", "from collections import defaultdict\n\ndef solve(lr, N):\n    levels = defaultdict(lambda : [0, 0])\n    for (l, r) in lr:\n        levels[l][1] += 1\n        levels[r][0] -= 1\n    levels = [(key, val1, val2) for (key, (val1, val2)) in levels.items()]\n    levels.sort()\n    level = 0\n    min_level = N\n    started = False\n    for (p, l, r) in levels:\n        if r > 0 and started:\n            if level < min_level:\n                min_level = level\n            started = False\n        if l < 0:\n            started = True\n        level += l + r\n    if min_level == N:\n        min_level = -1\n    return min_level\nT = int(input())\nfor t in range(T):\n    N = int(input())\n    lr = [tuple(map(int, input().split())) for _ in range(N)]\n    lr.sort()\n    result = solve(lr, N)\n    print(result)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    start = []\n    end = []\n    for i in range(n):\n        s = list(map(int, input().split()))\n        start.append(s[0])\n        end.append(s[1])\n    s = e = ps = pe = 0\n    start.sort()\n    end.sort()\n    a = start[0]\n    b = start[n - 1]\n    c = end[0]\n    d = end[n - 1]\n    m = n\n    if b <= c:\n        m = -1\n    else:\n        while pe == 0:\n            if start[ps] < end[pe]:\n                tmp = start[ps]\n                s += 1\n                ps += 1\n                while ps < n and start[ps] == tmp:\n                    s += 1\n                    ps += 1\n            elif start[ps] == end[pe]:\n                tmp = start[ps]\n                e += 1\n                pe += 1\n                s += 1\n                ps += 1\n                while ps < n and start[ps] == tmp:\n                    s += 1\n                    ps += 1\n                while pe < n and end[pe] == tmp:\n                    e += 1\n                    pe += 1\n            else:\n                tmp = end[pe]\n                e += 1\n                pe += 1\n                while pe < n and end[pe] == tmp:\n                    e += 1\n                    pe += 1\n        while ps < n and pe < n:\n            if s - e < m:\n                m = s - e\n            if start[ps] < end[pe]:\n                s += 1\n                ps += 1\n            elif start[ps] == end[pe]:\n                s += 1\n                ps += 1\n                e += 1\n                pe += 1\n            else:\n                e += 1\n                pe += 1\n    print(m)", "import math\nimport random\nfrom collections import defaultdict\n\ndef type1():\n    return map(int, input().split())\n\ndef type2():\n    return list(type1())\n\ndef type3():\n    return int(input())\n\ndef solve2(l, r, n):\n    l.sort()\n    r.sort()\n    noofends = 0\n    noofstarts = n\n    i = 0\n    j = 0\n    ans = 999999999999\n    while (i < n and j < n) and i + j < 2 * n:\n        if l[i] < r[j]:\n            limit = l[i]\n            while i < n and l[i] == limit:\n                i += 1\n                noofstarts -= 1\n            if noofends > 0 and noofstarts > 0:\n                ans = min(ans, n - (noofends + noofstarts))\n        elif l[i] > r[j]:\n            limit = r[j]\n            while j < n and r[j] == limit:\n                j += 1\n                noofends += 1\n            if noofends > 0 and noofstarts > 0:\n                ans = min(ans, n - (noofends + noofstarts))\n        else:\n            limit = l[i]\n            temp = noofstarts\n            while i < n and l[i] == limit:\n                i += 1\n                noofstarts -= 1\n            if noofends > 0 and noofstarts > 0:\n                ans = min(ans, n - (noofends + noofstarts))\n            limit = r[j]\n            while j < n and r[j] == limit:\n                j += 1\n                noofends += 1\n            if noofends > 0 and noofstarts > 0:\n                ans = min(ans, n - (noofends + noofstarts))\n    return -1 if ans == 999999999999 else ans\nfor _ in range(type3()):\n    n = type3()\n    left = []\n    right = []\n    for i in range(n):\n        (l, r) = type1()\n        left.append(l)\n        right.append(r)\n    print(solve2(left, right, n))", "import math\nimport random\nfrom collections import defaultdict\n\ndef type1():\n    return map(int, input().split())\n\ndef type2():\n    return list(type1())\n\ndef type3():\n    return int(input())\n\ndef solve(l, r, n):\n    if n == 1:\n        return -1\n    if n == 2:\n        l = sorted(l)\n        r = sorted(r)\n        if l[1] > r[0]:\n            return 0\n        else:\n            return -1\n    if n > 2:\n        sortedright = sorted(list(set(r)))\n        sortedleft = sorted(list(set(l)))\n        if sortedright >= 2 or sortedleft >= 2:\n            secmin = sortedleft[1]\n            secmax = sortedright[-2]\n            prefix = [0] * (sortedright[-1] + 2)\n            edges = [[0, 0] for i in range(sortedright[-1] + 2)]\n            for i in range(n):\n                prefix[l[i]] += 1\n                prefix[r[i] + 1] -= 1\n                edges[l[i]][0] += 1\n                edges[r[i]][1] += 1\n            print(prefix, secmin, secmax)\n            for i in range(sortedleft[0], sortedright[-1] + 1):\n                prefix[i] += prefix[i - 1]\n            print(prefix)\n            ans = 9999999999\n            for i in range(secmin, secmax + 1):\n                ans = min(ans, prefix[i])\n            print(ans)\n            fans = 9999999999\n            print(edges)\n            for i in range(secmin, secmax + 1):\n                if prefix[i] == ans:\n                    fans = min(ans, ans - edges[i][0], ans - edges[i][1])\n            print(fans)\n            fans = -1 if n - 2 < fans else fans\n            return fans\n        else:\n            return -1\n\ndef solve1(l, r, n):\n    start = min(l)\n    end = max(r)\n    prefix = [0] * (end + 2)\n    edges = [[0, 0] for i in range(end + 2)]\n    for i in range(n):\n        prefix[l[i]] += 1\n        prefix[r[i] + 1] -= 1\n        edges[l[i]][0] += 1\n        edges[r[i]][1] += 1\n    for i in range(start, end + 1):\n        prefix[i] += prefix[i - 1]\n    nstarts = n\n    nends = 0\n    ans = 99999999999\n    for i in range(start, end + 1):\n        nstarts -= edges[i][0]\n        nends += edges[i][1]\n        if nstarts > 0 and nends > 0:\n            ans = min(prefix[i] - edges[i][0], prefix[i] - edges[i][1])\n    ans = -1 if ans == 99999999999 else ans\n    return ans\n\ndef solve2(l, r, n):\n    l.sort()\n    r.sort()\n    noofends = 0\n    noofstarts = n\n    i = 0\n    j = 0\n    ans = 999999999999\n    while (i < n and j < n) and i + j < 2 * n:\n        if l[i] < r[j]:\n            limit = l[i]\n            while i < n and l[i] == limit:\n                i += 1\n                noofstarts -= 1\n            if noofends > 0 and noofstarts > 0:\n                ans = min(ans, n - (noofends + noofstarts))\n        elif l[i] > r[j]:\n            limit = r[j]\n            while j < n and r[j] == limit:\n                j += 1\n                noofends += 1\n            if noofends > 0 and noofstarts > 0:\n                ans = min(ans, n - (noofends + noofstarts))\n        else:\n            limit = l[i]\n            temp = noofstarts\n            while i < n and l[i] == limit:\n                i += 1\n                noofstarts -= 1\n            if noofends > 0 and noofstarts > 0:\n                ans = min(ans, n - (noofends + noofstarts))\n            limit = r[j]\n            while j < n and r[j] == limit:\n                j += 1\n                noofends += 1\n            if noofends > 0 and noofstarts > 0:\n                ans = min(ans, n - (noofends + noofstarts))\n    return -1 if ans == 999999999999 else ans\nfor _ in range(type3()):\n    n = type3()\n    left = []\n    right = []\n    for i in range(n):\n        (l, r) = type1()\n        left.append(l)\n        right.append(r)\n    print(solve2(left, right, n))", "try:\n    testcase = int(input())\n    while testcase:\n        testcase -= 1\n        n = int(input())\n        (mi, ma1) = (10 ** 9 + 9, 10 ** 9 + 9)\n        (ma, mi1) = (0, 0)\n        (l, d) = ({}, {})\n        for i in range(0, n):\n            (x, y) = map(int, input().split())\n            l.setdefault(x, 0)\n            l.setdefault(y + 1, 0)\n            d.setdefault(x, 0)\n            l[x] += 1\n            l[y + 1] -= 1\n            d[x] += 1\n            mi = min(mi, x)\n            mi1 = max(mi1, x)\n            ma = max(ma, y)\n            ma1 = min(ma1, y)\n        o = sorted(l.items(), key=lambda t: t[0])\n        sp = 0\n        c = {}\n        for i in o:\n            sp += i[1]\n            if i[0] >= ma1 + 1 and i[0] < mi1 + 1 and (i[0] in d):\n                c[i[0]] = sp\n        an = 10 ** 9 + 6\n        for (x, y) in c.items():\n            an = min(c[x] - d[x], an)\n        print(-1 if n - an <= 1 else an)\nexcept:\n    pass", "from sys import *\n\ndef input():\n    return stdin.readline()\nimport collections\nfor _ in range(int(input())):\n    stp = collections.defaultdict(int)\n    edp = collections.defaultdict(int)\n    lis = []\n    seg = []\n    for i in range(int(input())):\n        (x, y) = map(int, input().split())\n        stp[x] += 1\n        edp[y] += 1\n    com = stp.keys() & edp.keys()\n    for i in com:\n        seg.append([i, stp[i], edp[i]])\n    for i in stp.keys() - com:\n        seg.append([i, stp[i], 0])\n    for i in edp.keys() - com:\n        seg.append([i, 0, edp[i]])\n    seg.sort(key=lambda x: x[0])\n    st = seg[0]\n    curr = st[1] - st[2]\n    unable = 0\n    res = 9999999\n    if st[2] == 0:\n        firseg = True\n    else:\n        firseg = False\n    step = 1\n    while firseg and step < len(seg):\n        if seg[step][2] > 0:\n            firseg = False\n        unable += curr\n        curr = seg[step][1] - seg[step][2]\n        step += 1\n    while step < len(seg):\n        unable += curr\n        if seg[step][1] > 0:\n            res = min(res, unable)\n        curr = seg[step][1] - seg[step][2]\n        step += 1\n    if res == 9999999:\n        print(-1)\n    else:\n        print(res)", "import bisect\n\ndef result(l1, l2, num):\n    res = num\n    for nex in range(1, num):\n        inter = num - bisect.bisect_right(l1, l2[nex - 1])\n        if inter > 0:\n            inter = num - inter - nex\n            if res > inter:\n                res = inter\n            continue\n    if res > num - 2:\n        return -1\n    return res\nT = int(input())\nwhile T:\n    T -= 1\n    N = int(input())\n    if N == 1:\n        print(-1)\n    else:\n        leftRanges = []\n        rightRanges = []\n        for i in range(0, N):\n            (a, b) = map(int, input().split())\n            leftRanges.append(a)\n            rightRanges.append(b)\n        print(result(sorted(leftRanges), sorted(rightRanges), N))", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = []\n    e = []\n    for i in range(n):\n        (l, r) = map(int, input().strip().split(' '))\n        s.append(l)\n        e.append(r)\n    s.sort()\n    e.sort()\n    i = 0\n    j = 0\n    mi = float('inf')\n    for i in range(1, n):\n        while e[j] < s[i]:\n            j += 1\n        if j == 0:\n            continue\n        mi = min(i - j, mi)\n    if mi == float('inf'):\n        print(-1)\n    else:\n        print(mi)", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = []\n    B = []\n    C = []\n    (a, b) = map(int, input().split())\n    mb = b\n    xb = b\n    ma = a\n    xa = a\n    A.append([a, b])\n    B.append(a)\n    C.append(b)\n    for i in range(N - 1):\n        (a, b) = map(int, input().split())\n        if b < mb:\n            mb = b\n        if b > xb:\n            xb = b\n        if a < ma:\n            ma = a\n        if a > xa:\n            xa = a\n        A.append([a, b])\n        B.append(a)\n        C.append(b)\n    if xa <= mb:\n        print(-1)\n        continue\n    maxval = N - 1\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n    count = 0\n    i = len(B) - 1\n    j = len(C) - 1\n    while True:\n        if i == -1:\n            break\n        if B[i] <= C[j]:\n            count = count + 1\n            if B[i] > mb:\n                maxval = min(count - 1, maxval)\n            i = i - 1\n        else:\n            count = count - 1\n            j = j - 1\n    print(maxval)", "T = int(input())\nfor _ in range(T):\n    N = int(input())\n    A = []\n    B = []\n    C = []\n    (a, b) = map(int, input().split())\n    mb = b\n    xb = b\n    ma = a\n    xa = a\n    A.append([a, b])\n    B.append(a)\n    C.append(b)\n    for i in range(N - 1):\n        (a, b) = map(int, input().split())\n        if b < mb:\n            mb = b\n        if b > xb:\n            xb = b\n        if a < ma:\n            ma = a\n        if a > xa:\n            xa = a\n        A.append([a, b])\n        B.append(a)\n        C.append(b)\n    if xa <= mb:\n        print(-1)\n        continue\n    maxval = N - 1\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n    count = 0\n    i = len(B) - 1\n    j = len(C) - 1\n    while True:\n        if i == -1:\n            break\n        if B[i] <= C[j]:\n            count = count + 1\n            if B[i] > mb:\n                maxval = min(count - 1, maxval)\n            i = i - 1\n        else:\n            count = count - 1\n            j = j - 1\n    print(maxval)", "for _ in range(int(input())):\n    n = int(input())\n    ranges = []\n    first = (0, 10 ** 9)\n    last = (-1, 0)\n    for _ in range(n):\n        (l, r) = map(int, input().split())\n        ranges.append((l, r))\n        if r < first[1]:\n            first = (l, r)\n        if l > last[0]:\n            last = (l, r)\n    if first[1] >= last[0]:\n        print(-1)\n        continue\n    vals = {}\n    for tpl in ranges:\n        (l, r) = tpl\n        vals[l] = vals.get(l, 0) + 1\n        vals[l + 0.5] = vals.get(l + 0.5, 0)\n        vals[r + 0.5] = vals.get(r + 0.5, 0) - 1\n    points = []\n    for point in vals.keys():\n        points.append(point)\n    points.sort()\n    points.pop()\n    mincount = 10 ** 9\n    count = 0\n    for point in points:\n        count += vals[point]\n        if point > first[1] and point < last[0]:\n            mincount = min(mincount, count)\n        if mincount == 0:\n            break\n    print(mincount)", "for t in range(int(input())):\n    n = int(input())\n    d = dict()\n    for _ in range(n):\n        (x, y) = map(int, input().split())\n        if x in d:\n            d[x][0] += 1\n        else:\n            d[x] = [1, 0, 0]\n        if y in d:\n            d[y][1] += 1\n        else:\n            d[y] = [0, 1, 0]\n    o = 0\n    c = 0\n    ans = n + 1\n    for i in sorted(d):\n        o += d[i][0]\n        c += d[i][1]\n        d[i][2] = o - c\n        if c == 0 or o == n:\n            continue\n        ans = min(ans, d[i][2])\n    if n - ans > 1:\n        print(ans)\n    else:\n        print('-1')", "for t in range(int(input())):\n    n = int(input())\n    d = dict()\n    for _ in range(n):\n        (x, y) = map(int, input().split())\n        if x in d:\n            d[x][0] += 1\n        else:\n            d[x] = [1, 0, 0, 0]\n        if y in d:\n            d[y][1] += 1\n        else:\n            d[y] = [0, 1, 0, 0]\n    o = 0\n    c = 0\n    ans = n + 1\n    for i in sorted(d):\n        o += d[i][0]\n        c += d[i][1]\n        d[i][2] = o - c\n        if c == 0 or o == n:\n            continue\n        ans = min(ans, d[i][2])\n    if n - ans > 1:\n        print(ans)\n    else:\n        print('-1')", "import bisect\nfor _ in range(int(input())):\n    n = int(input())\n    (l, r) = (list(), list())\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        l.append(a)\n        r.append(b)\n    l.sort()\n    r.sort()\n    ans = pow(10, 9) + 1\n    for i in range(1, n):\n        temp = n - bisect.bisect_right(l, r[i - 1])\n        if temp:\n            ans = min(ans, n - temp - i)\n    if ans > n:\n        print(-1)\n    else:\n        print(ans)", "def compare(a, b):\n    if a[0] < b[0]:\n        return -1\n    elif a[0] == b[0]:\n        if a[1] == b[1]:\n            return -1\n        if a[1] < b[1]:\n            return 1\n        else:\n            return -1\n    else:\n        return 1\nimport functools\n\ndef test4(start, end, x):\n    ar = []\n    start.sort()\n    end.sort()\n    for (i, j) in zip(start, end):\n        ar.append([i, 1])\n        ar.append([j, -1])\n    ar.sort(key=lambda x: x[1], reverse=True)\n    ar.sort(key=lambda x: x[0])\n    en = x\n    i = len(ar) - 1\n    while ar[i][1] != 1 and i >= 0:\n        i -= 1\n    en = i\n    res = float('inf')\n    s = 0\n    i = 0\n    flg = False\n    while i < len(ar):\n        s += int(ar[i][1])\n        if ar[i][1] == -1:\n            flg = True\n        if flg and i < en:\n            res = min(s, res)\n        i += 1\n    if res == float('inf'):\n        print(-1)\n    else:\n        print(res)\nt = int(input())\nwhile t:\n    t -= 1\n    p = int(input())\n    (start, end) = ([], [])\n    min_end = float('inf')\n    max_start = float('-inf')\n    for i in range(p):\n        (m, n) = map(int, input().split())\n        if n < min_end:\n            min_end = n\n        if m > max_start:\n            max_start = m\n        start.append(m)\n        end.append(n)\n    if min_end >= max_start:\n        print(-1)\n    else:\n        test4(start, end, p)", "import itertools\nfor _ in range(0, int(input())):\n    n = int(input())\n    l = {}\n    d = {}\n    mi = 10 ** 9 + 4\n    ma = 0\n    mi1 = 0\n    ma1 = 10 ** 9 + 4\n    for i in range(0, n):\n        (x, y) = map(int, input().split())\n        if x in l:\n            l[x] += 1\n        else:\n            l[x] = 1\n        if y + 1 in l:\n            l[y + 1] -= 1\n        else:\n            l[y + 1] = -1\n        if x not in d:\n            d[x] = 1\n        else:\n            d[x] += 1\n        mi = min(mi, x)\n        mi1 = max(mi1, x)\n        ma = max(ma, y)\n        ma1 = min(ma1, y)\n    ans = 10 ** 9 + 6\n    l = sorted(l.items(), key=lambda t: t[0])\n    s = 0\n    j = 0\n    c = {}\n    for i in range(0, len(l)):\n        s += l[i][1]\n        if l[i][0] >= ma1 + 1 and l[i][0] < mi1 + 1 and (l[i][0] in d):\n            c[l[i][0]] = s\n    for (u, v) in c.items():\n        ans = min(c[u] - d[u], ans)\n    if n - ans <= 1:\n        print(-1)\n    else:\n        print(ans)", "from collections import defaultdict\n\ndef checkdisjoint(a, b):\n    if a[1] < b[0] or b[1] < a[0]:\n        return True\n    else:\n        return False\nfor _ in range(int(input())):\n    N = int(input())\n    R = []\n    FirstCloser = (0, 10000000000)\n    LastOpener = (-1, 0)\n    for k in range(N):\n        (a, b) = map(int, input().split())\n        if b < FirstCloser[1]:\n            FirstCloser = (a, b)\n        if a > LastOpener[0]:\n            LastOpener = (a, b)\n        R.append((a, b))\n    if checkdisjoint(FirstCloser, LastOpener) == False:\n        print('-1')\n        continue\n    d = defaultdict(int)\n    for x in R:\n        d[x[0]] += 1\n        d[x[0] + 0.5] += 0\n        d[x[1] + 0.5] -= 1\n    Points = []\n    for x in d:\n        Points.append(x)\n    Points = sorted(Points)\n    m = 10000000000\n    s = 0\n    Points.pop()\n    for x in Points:\n        s = s + d[x]\n        if x > FirstCloser[1] and x < LastOpener[0]:\n            m = min(m, s)\n        if m == 0:\n            break\n        if x == LastOpener[0]:\n            break\n    print(m)", "from collections import defaultdict\n\ndef checkdisjoint(a, b):\n    if a[1] < b[0] or b[1] < a[0]:\n        return True\n    else:\n        return False\nfor _ in range(int(input())):\n    N = int(input())\n    R = []\n    FirstCloser = (0, 10000000000)\n    LastOpener = (-1, 0)\n    for k in range(N):\n        (a, b) = map(int, input().split())\n        if b < FirstCloser[1]:\n            FirstCloser = (a, b)\n        if a > LastOpener[0]:\n            LastOpener = (a, b)\n        R.append((a, b))\n    if checkdisjoint(FirstCloser, LastOpener) == False:\n        print('-1')\n        continue\n    d = defaultdict(int)\n    for x in R:\n        d[x[0]] += 1\n        d[x[0] + 0.5] += 0\n        d[x[1] + 0.5] -= 1\n    Points = []\n    for x in d:\n        Points.append(x)\n    Points = sorted(Points)\n    m = 10000000000\n    s = 0\n    Points.pop()\n    for x in Points:\n        s = s + d[x]\n        if x > FirstCloser[1] and x < LastOpener[0]:\n            m = min(m, s)\n        if m == 0:\n            break\n        if x == LastOpener[0]:\n            break\n    print(m)", "from collections import defaultdict\n\ndef checkdisjoint(a, b):\n    if a[1] < b[0] or b[1] < a[0]:\n        return True\n    else:\n        return False\nfor _ in range(int(input())):\n    N = int(input())\n    R = []\n    FirstCloser = (0, 10000000000)\n    LastOpener = (-1, 0)\n    for k in range(N):\n        (a, b) = map(int, input().split())\n        if b < FirstCloser[1]:\n            FirstCloser = (a, b)\n        if a > LastOpener[0]:\n            LastOpener = (a, b)\n        R.append((a, b))\n    if checkdisjoint(FirstCloser, LastOpener) == False:\n        print('-1')\n        continue\n    d = defaultdict(int)\n    for x in R:\n        d[x[0]] += 1\n        d[x[0] + 0.5] += 0\n        d[x[1] + 0.5] -= 1\n    Points = []\n    for x in d:\n        Points.append(x)\n    Points = sorted(Points)\n    m = 10000000000\n    s = 0\n    Points.pop()\n    for x in Points:\n        s = s + d[x]\n        if x > FirstCloser[1] and x < LastOpener[0]:\n            m = min(m, s)\n        if m == 0:\n            break\n        if x == LastOpener[0]:\n            break\n    print(m)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ip = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        ip.append((a, 0))\n        ip.append((b, 1))\n    ip = sorted(ip)\n    c = 0\n    ans = n\n    closed = 0\n    for i in ip:\n        if closed >= 1 and c != n - closed:\n            ans = min(c, ans)\n        if i[1] == 0:\n            c += 1\n        else:\n            c -= 1\n            closed += 1\n    if ans == n or ans == n - 1:\n        print(-1)\n    else:\n        print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = []\n    b = []\n    for i in range(n):\n        (l, r) = list(map(int, input().split()))\n        a.append(l)\n        b.append(r)\n    a.sort()\n    b.sort()\n    if n == 1:\n        print(-1)\n    else:\n        x = set(b)\n        x = list(x)\n        x.sort()\n        p = [0] * len(x)\n        q = [0] * len(x)\n        j = 0\n        i = 0\n        while i < n:\n            if j == len(x):\n                break\n            if b[i] <= x[j]:\n                q[j] += 1\n                i += 1\n            else:\n                j += 1\n                q[j] = q[j - 1]\n        j = 0\n        i = 0\n        while i < n:\n            if j == len(x):\n                break\n            if a[i] <= x[j]:\n                p[j] += 1\n                i += 1\n            else:\n                j += 1\n        for i in range(1, len(p)):\n            p[i] += p[i - 1]\n        for i in range(len(p)):\n            p[i] = n - p[i]\n        ans = 2 * n\n        for i in range(len(x)):\n            if not (p[i] == 0 or q[i] == 0):\n                ans = min(ans, n - p[i] - q[i])\n        if ans == 2 * n:\n            print(-1)\n        else:\n            print(ans)", "from bisect import *\nfrom collections import *\nfrom sys import *\n\ndef input():\n    return stdin.readline()\nfor _ in range(int(input())):\n    x1 = defaultdict(int)\n    y1 = defaultdict(int)\n    lis = []\n    fin = []\n    for i in range(int(input())):\n        (x, y) = map(int, input().split())\n        x1[x] += 1\n        y1[y] += 1\n    inter = x1.keys() & y1.keys()\n    for i in inter:\n        fin.append([i, [x1[i], y1[i]]])\n    intrax = x1.keys() - inter\n    for i in intrax:\n        fin.append([i, [x1[i], 0]])\n    intray = y1.keys() - inter\n    for i in intray:\n        fin.append([i, [0, y1[i]]])\n    fin.sort(key=lambda x: x[0])\n    st = fin[0]\n    tmp = st[1][0] - st[1][1]\n    u = 0\n    r = 999999999\n    if st[1][1] == 0:\n        subset = True\n    else:\n        subset = False\n    it = 1\n    while subset and it < len(fin):\n        if fin[it][1][1] > 0:\n            subset = False\n        u += tmp\n        tmp = fin[it][1][0] - fin[it][1][1]\n        it += 1\n    while it < len(fin):\n        u += tmp\n        if fin[it][1][0] > 0:\n            r = min(r, u)\n        tmp = fin[it][1][0] - fin[it][1][1]\n        it += 1\n    if r == 999999999:\n        print(-1)\n    else:\n        print(r)", "def main():\n    t = int(input())\n    for p in range(t):\n        n = int(input())\n        arr = []\n        left_max = 0\n        right_min = 10 ** 9\n        for i in range(n):\n            x = input().split()\n            (x[0], x[1]) = (int(x[0]), int(x[1]))\n            left_max = max(left_max, x[0])\n            right_min = min(right_min, x[1])\n            arr.append([x[0], 'L'])\n            arr.append([x[1], 'R'])\n        arr.sort()\n        final_ans = 10 ** 5\n        ans = 0\n        for i in range(2 * n):\n            if arr[i][1] == 'L':\n                if arr[i][0] > right_min:\n                    final_ans = min(final_ans, ans)\n                ans += 1\n            else:\n                ans -= 1\n        if final_ans == 10 ** 5:\n            print(-1)\n        else:\n            print(final_ans)\nmain()", "def upper_bound(arr, x):\n    (l, h) = (0, len(arr))\n    while l < h:\n        mid = (l + h) // 2\n        if x >= arr[mid]:\n            l = mid + 1\n        else:\n            h = mid\n    return l\n\ndef main():\n    for t in range(int(input())):\n        n = int(input())\n        XS = [0 for i in range(n)]\n        YS = [0 for i in range(n)]\n        for i in range(n):\n            (a, b) = map(int, input().split())\n            XS[i] = a\n            YS[i] = b\n        XS.sort()\n        YS.sort()\n        (res, i) = (n, 0)\n        while i < n:\n            it = i\n            while it < n and YS[it] == YS[i]:\n                it += 1\n            idx = upper_bound(XS, YS[i])\n            if it < n and idx < n:\n                res = min(res, idx - it)\n            i = it\n        print(res if res != n else -1)\nmain()", "def upper_bound(arr, x):\n    l = 0\n    h = len(arr)\n    while l < h:\n        mid = (l + h) // 2\n        if x >= arr[mid]:\n            l = mid + 1\n        else:\n            h = mid\n    return l\n\ndef main():\n    MAX = int(1000000000.0)\n    for t in range(int(input())):\n        n = int(input())\n        XS = [0 for i in range(n)]\n        YS = [0 for i in range(n)]\n        for i in range(n):\n            (a, b) = map(int, input().split())\n            XS[i] = a\n            YS[i] = b\n        XS.sort()\n        YS.sort()\n        res = n\n        i = 0\n        while i < n:\n            it = i\n            while it < n and YS[it] == YS[i]:\n                it += 1\n            idx = upper_bound(XS, YS[i])\n            if it < n and idx < n:\n                res = min(res, idx - it)\n            i = it\n        if res == n:\n            res = -1\n        print(res)\nmain()", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = []\n    for i in range(n):\n        (l, r) = input().split()\n        l = int(l)\n        r = int(r)\n        s.append([l, r])\n    s.sort()\n    l = []\n    l.append([s[0][0], s[0][1], 1])\n    for i in range(1, n):\n        if s[i][0] > l[-1][1]:\n            l.append([s[i][0], s[i][1], 1])\n        elif s[i][0] <= l[-1][1]:\n            l[-1][1] = max(l[-1][1], s[i][1])\n            l[-1][2] += 1\n    if len(l) > 1:\n        print(0)\n    elif l[0][2] <= 2:\n        print(-1)\n    else:\n        l2 = []\n        for i in range(0, len(s)):\n            l2.append(s[i][1])\n        l2.sort()\n        sp = 0\n        ep = 0\n        m = n + 1\n        i = 0\n        j = 0\n        f = 0\n        while i < n:\n            if s[i][0] <= l2[j]:\n                sp += 1\n                if sp - 1 - ep < m and ep != 0:\n                    f = 1\n                    m = sp - ep - 1\n                i += 1\n            else:\n                ep += 1\n                j += 1\n        if f == 1:\n            print(m)\n        else:\n            print(-1)", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    brr = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x = min(a, b)\n        y = max(a, b)\n        arr.append([x, y])\n        brr.append(y)\n    arr.sort()\n    curr_max = arr[0][1]\n    ind = 0\n    rs = []\n    for i in range(1, n):\n        if arr[i][0] > curr_max:\n            rs.append(i - ind)\n            ind = i\n            curr_max = arr[i][1]\n        elif arr[i][1] > curr_max:\n            curr_max = arr[i][1]\n    rs.append(n - ind)\n    if len(rs) >= 2:\n        print(0)\n    else:\n        brr.sort()\n        i = 0\n        j = 0\n        result = -1\n        while i < n and j < n:\n            if arr[i][0] <= brr[j]:\n                if i != 0 and j != 0:\n                    if result == -1:\n                        result = i - j\n                        rs_ind = i\n                    elif result > i - j:\n                        result = i - j\n                        rs_ind = i\n                i += 1\n            else:\n                j += 1\n        print(result)", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    brr = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x = min(a, b)\n        y = max(a, b)\n        arr.append([x, y])\n        brr.append(y)\n    arr.sort()\n    curr_max = arr[0][1]\n    ind = 0\n    rs = []\n    for i in range(1, n):\n        if arr[i][0] > curr_max:\n            rs.append(i - ind)\n            ind = i\n            curr_max = arr[i][1]\n        elif arr[i][1] > curr_max:\n            curr_max = arr[i][1]\n    rs.append(n - ind)\n    if len(rs) >= 2:\n        print(0)\n    else:\n        brr.sort()\n        i = 0\n        j = 0\n        result = -1\n        rs_ind = -1\n        while i < n and j < n:\n            if arr[i][0] <= brr[j]:\n                if i != 0 and j != 0:\n                    if result == -1:\n                        result = i - j\n                        rs_ind = i\n                    elif result > i - j:\n                        result = i - j\n                        rs_ind = i\n                i += 1\n            else:\n                j += 1\n        if rs_ind == -1:\n            print(-1)\n        else:\n            i = rs_ind - 1\n            fres = 0\n            while i > -1:\n                if arr[rs_ind][0] <= arr[i][1]:\n                    arr.pop(i)\n                    rs_ind -= 1\n                    fres += 1\n                i -= 1\n            n = len(arr)\n            curr_max = arr[0][1]\n            ind = 0\n            rs = []\n            for i in range(1, n):\n                if arr[i][0] > curr_max:\n                    rs.append(i - ind)\n                    ind = i\n                    curr_max = arr[i][1]\n                elif arr[i][1] > curr_max:\n                    curr_max = arr[i][1]\n            rs.append(n - ind)\n            if len(rs) == 2:\n                print(0 + fres)\n            else:\n                maxi = max(rs[0], rs[1])\n                secondmax = min(rs[0], rs[1])\n                for i in range(2, len(rs)):\n                    if rs[i] > maxi:\n                        secondmax = maxi\n                        maxi = rs[i]\n                    elif rs[i] > secondmax:\n                        secondmax = rs[i]\n                print(n - maxi - secondmax + fres)", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    brr = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        arr.append([a, b])\n        brr.append(b)\n    arr.sort()\n    curr_max = arr[0][1]\n    ind = 0\n    rs = []\n    for i in range(1, n):\n        if arr[i][0] > curr_max:\n            rs.append(i - ind)\n            ind = i\n            curr_max = arr[i][1]\n        elif arr[i][1] > curr_max:\n            curr_max = arr[i][1]\n    rs.append(n - ind)\n    if len(rs) >= 2:\n        print(0)\n    else:\n        brr.sort()\n        i = 0\n        j = 0\n        result = -1\n        while i < n and j < n:\n            if arr[i][0] <= brr[j]:\n                if i != 0 and j != 0:\n                    if result == -1:\n                        result = i - j\n                    elif result > i - j:\n                        result = i - j\n                i += 1\n            else:\n                j += 1\n        print(result)", "for _ in range(int(input())):\n    n = int(input())\n    arr = []\n    brr = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        x = min(a, b)\n        y = max(a, b)\n        arr.append([x, y])\n        brr.append(y)\n    arr.sort()\n    curr_max = arr[0][1]\n    ind = 0\n    rs = []\n    for i in range(1, n):\n        if arr[i][0] > curr_max:\n            rs.append(i - ind)\n            ind = i\n            curr_max = arr[i][1]\n        elif arr[i][1] > curr_max:\n            curr_max = arr[i][1]\n    rs.append(n - ind)\n    if len(rs) >= 2:\n        print(0)\n    else:\n        brr.sort()\n        i = 0\n        j = 0\n        result = -1\n        rs_ind = -1\n        while i < n and j < n:\n            if arr[i][0] <= brr[j]:\n                if i != 0 and j != 0:\n                    if result == -1:\n                        result = i - j\n                        rs_ind = i\n                    elif result > i - j:\n                        result = i - j\n                        rs_ind = i\n                i += 1\n            else:\n                j += 1\n        if rs_ind == -1:\n            print(-1)\n        else:\n            i = rs_ind - 1\n            fres = 0\n            while i > -1:\n                if arr[rs_ind][0] <= arr[i][1]:\n                    arr.pop(i)\n                    rs_ind -= 1\n                    fres += 1\n                i -= 1\n            n = len(arr)\n            curr_max = arr[0][1]\n            ind = 0\n            rs = []\n            for i in range(1, n):\n                if arr[i][0] > curr_max:\n                    rs.append(i - ind)\n                    ind = i\n                    curr_max = arr[i][1]\n                elif arr[i][1] > curr_max:\n                    curr_max = arr[i][1]\n            rs.append(n - ind)\n            if len(rs) == 2:\n                print(0 + fres)\n            else:\n                maxi = max(rs[0], rs[1])\n                secondmax = min(rs[0], rs[1])\n                for i in range(2, len(rs)):\n                    if rs[i] > maxi:\n                        secondmax = maxi\n                        maxi = rs[i]\n                    elif rs[i] > secondmax:\n                        secondmax = rs[i]\n                print(n - maxi - secondmax + fres)", "for h in range(int(input())):\n    beg = []\n    end = []\n    n = int(input())\n    for _ in range(n):\n        (s, e) = map(int, input().strip().split())\n        beg.append(s)\n        end.append(e)\n    mini = float('inf')\n    beg.sort()\n    end.sort()\n    (j1, j2) = (n - 1, n - 1)\n    while beg[j1] == beg[j1 - 1] and j1 > 0:\n        j1 -= 1\n    while end[j2] == end[j2 - 1] and j2 > 0:\n        j2 -= 1\n    if j1 == 0 or j2 == 0:\n        print(-1)\n        continue\n    c = 0\n    (i1, i2) = (0, 0)\n    while i1 < j1 and i2 < j2:\n        if beg[i1] <= end[i2]:\n            c += 1\n            i1 += 1\n        else:\n            c -= 1\n            i2 += 1\n            mini = min(c, mini)\n    while i2 < j2 and end[i2] < beg[j1]:\n        c -= 1\n        i2 += 1\n        mini = min(c, mini)\n    if mini == n or mini == float('inf'):\n        print(-1)\n    else:\n        print(mini)", "for _ in range(int(input())):\n    n = int(input())\n    xlis = []\n    ylis = []\n    for i in range(n):\n        (a, b) = map(int, input().split())\n        xlis.append(a)\n        ylis.append(b)\n    xlis.sort()\n    ylis.sort()\n    ans = 0\n    poi = 0\n    for i in range(n):\n        y = ylis[i]\n        while poi != n:\n            if xlis[poi] <= y:\n                poi += 1\n            else:\n                break\n        gx = n - poi\n        if gx == 0:\n            break\n        else:\n            smly = i + 1\n            ans = max(ans, smly + gx)\n            fl = 1\n    if ans:\n        print(n - ans)\n    else:\n        print(-1)", "t = int(input())\nfor i in range(t):\n    n = int(input())\n    li = []\n    for j in range(n):\n        (x, y) = map(int, input().split())\n        li.append([x, 's'])\n        li.append([y + 0.01, 'c'])\n    li.sort(key=lambda x: x[0])\n    mi = 1000000001\n    l = 0\n    pre = li[0]\n    for i in range(1, len(li)):\n        if li[i][1] == 's':\n            l += 1\n        elif li[i][1] == 'c':\n            l -= 1\n        if li[i][1] == 's' and pre[1] == 'c':\n            mi = min(mi, l)\n        pre = li[i]\n    if mi == 1000000001:\n        print(-1)\n    else:\n        print(mi)", "from collections import defaultdict\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    dic = defaultdict(lambda : 0)\n    for i in range(n):\n        (a, b) = [int(i) for i in input().split()]\n        dic[a] += 1\n        dic[b + 0.1] -= 1\n    vals = sorted(list(dic.keys()))\n    ans = 10 ** 10\n    s = 0\n    ans_arr = [-1]\n    for val in vals:\n        curr = dic[val]\n        s += curr\n        ans_arr.append(s)\n    ans_arr.append(-1)\n    for i in range(1, len(ans_arr) - 1):\n        if ans_arr[i - 1] > ans_arr[i] and ans_arr[i + 1] > ans_arr[i]:\n            ans = min(ans, ans_arr[i])\n    if ans >= n - 1 or ans == 10 ** 9:\n        print(-1)\n    else:\n        print(ans)", "t = int(input())\nfor _ in range(t):\n    n = int(input())\n    ranges = {1: [0, 0, 0, 0]}\n    for i in range(n):\n        (l, r) = map(int, input().split())\n        if l in ranges:\n            ranges[l][0] += 1\n        else:\n            ranges[l] = [1, 0, 0, 0]\n        if r in ranges:\n            ranges[r][1] += 1\n        else:\n            ranges[r] = [0, 1, 0, 0]\n    sortedkeys = sorted(ranges)\n    opened = 0\n    closed = 0\n    for i in sortedkeys:\n        opened += ranges[i][0]\n        closed += ranges[i][1]\n        opened -= ranges[i][1]\n        ranges[i][2] = opened\n        ranges[i][3] = closed\n    sortedkeysDesc = sorted(ranges, reverse=True)\n    flag = 0\n    todelete = -1\n    x = -1\n    for j in sortedkeysDesc:\n        if flag == 0 and ranges[j][0] >= 1:\n            flag = 1\n        elif flag == 1 and ranges[j][3] > 0:\n            if ranges[j][2] < todelete or todelete == -1:\n                todelete = ranges[j][2]\n    print(todelete)", "for _ in range(int(input())):\n    n = int(input())\n    start = []\n    end = []\n    for __ in range(n):\n        (a, b) = map(int, input().split())\n        start.append(a)\n        end.append(b)\n    start.sort()\n    end.sort()\n    s = {}\n    e = {}\n    su = 1\n    en = 0\n    k = 0\n    for i in range(1, n):\n        if start[i] > start[i - 1]:\n            s[start[i]] = su\n        su += 1\n        while start[i] > end[k]:\n            en += 1\n            k += 1\n        e[start[i]] = k\n    ans = 1000000007\n    for i in s.keys():\n        if i > end[0]:\n            t = s[i] - e[i]\n            if ans > t:\n                ans = t\n    if ans == 1000000007:\n        print(-1)\n    else:\n        print(ans)", "for _ in range(int(input())):\n    N = int(input())\n    li = []\n    for i in range(N):\n        (a, b) = [int(j) for j in input().split()]\n        li.append((a, 0))\n        li.append((b, 1))\n    li.sort()\n    r = len(li) - 1\n    while li[r][1] == 1:\n        r -= 1\n    flag = -1\n    curr = -1\n    mn = N\n    for (ind, i) in enumerate(li):\n        if curr == 0:\n            flag = 1\n            break\n        elif curr == N:\n            flag = 2\n            break\n        elif curr == -1:\n            curr = 0\n        if i[1] == 0:\n            curr += 1\n        else:\n            curr -= 1\n            if ind <= r + 1:\n                mn = min(curr, mn)\n    if flag == -1:\n        print(mn)\n    elif flag == 1:\n        print(0)\n    else:\n        print(-1)"]