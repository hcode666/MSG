["import sys\nsys.setrecursionlimit(100100)\n\ndef solve():\n    (n, s) = map(int, input().split())\n    children = []\n    for i in range(n):\n        children.append([])\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        children[u - 1].append(v - 1)\n        children[v - 1].append(u - 1)\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    vis = [False] * n\n    (req, avail, comb) = find_path(0, children, a, b, vis)\n    if req or req is None:\n        print(0)\n    elif s == 1:\n        print(1)\n    else:\n        print(comb % MODULO)\nMODULO = 1000000007\n\ndef find_path(node, children, a, b, vis):\n    connected = False\n    vis[node] = True\n    (ret_req, ret_avail, children_comb) = (None, None, 1)\n    for child in children[node]:\n        if vis[child]:\n            continue\n        (req, avail, comb) = find_path(child, children, a, b, vis)\n        if req:\n            if connected:\n                return (None, None, None)\n            connected = True\n            if a[node] != b[node]:\n                if b[node] in avail:\n                    if avail[b[node]] == 1:\n                        del avail[b[node]]\n                    else:\n                        avail[b[node]] -= 1\n                elif b[node] in req:\n                    req[b[node]] += 1\n                else:\n                    req[b[node]] = 1\n                if a[node] in req:\n                    if req[a[node]] == 1:\n                        del req[a[node]]\n                    else:\n                        req[a[node]] -= 1\n                elif a[node] in avail:\n                    avail[a[node]] += 1\n                else:\n                    avail[a[node]] = 1\n            (ret_req, ret_avail) = (req, avail)\n        elif req is None:\n            return (None, None, None)\n        children_comb = children_comb * comb\n    if not connected:\n        (ret_req, ret_avail) = ({}, {})\n        if a[node] != b[node]:\n            ret_req[b[node]] = 1\n            ret_avail[a[node]] = 1\n        if node != 0:\n            children_comb = children_comb * len(children[node])\n        else:\n            children_comb = children_comb * (len(children[node]) + 1)\n    return (ret_req, ret_avail, children_comb)\nt = int(input())\nfor i in range(t):\n    solve()", "MOD = int(1000000000.0 + 7)\n\nclass TreeNode:\n\n    def __init__(self, val=0, children=[], parent=None):\n        self.v = val\n        self.c = children\n        self.p = parent\n        self.a = 0\n        self.b = 0\n        self.count = 1\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return str(self.v)\n\ndef solve():\n    (n, ss) = map(int, input().split())\n    nodes = [None]\n    for i in range(1, n + 1):\n        nodes.append(TreeNode(i, []))\n    edges = {}\n    for i in range(1, n):\n        s = input()\n        (u, v) = map(int, s.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    st = [nodes[1]]\n    done = {}\n    if len(edges) > 0:\n        while len(st) > 0:\n            node = st.pop()\n            done[node.v] = True\n            for c in edges[node.v]:\n                if not c in done:\n                    node.c.append(nodes[c])\n                    nodes[c].p = node\n                    st.append(nodes[c])\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        nodes[i].a = a[i - 1]\n        nodes[i].b = b[i - 1]\n    levels = [[nodes[1]]]\n    while len(levels[-1]) > 0:\n        l = []\n        for node in levels[-1]:\n            l.extend(node.c)\n        levels.append(l)\n    levels.pop()\n    ans = 1\n    passed = {}\n    for i in range(len(levels) - 1, -1, -1):\n        for node in levels[i]:\n            if node.v in passed:\n                continue\n            ans = ans * (len(node.c) + 1) % MOD\n            if node.a == node.b:\n                continue\n            cur = node\n            diff = {}\n            while True:\n                if cur.v in passed:\n                    print(0)\n                    return\n                passed[cur.v] = True\n                if cur.a in diff:\n                    diff[cur.a] -= 1\n                    if diff[cur.a] == 0:\n                        del diff[cur.a]\n                else:\n                    diff[cur.a] = -1\n                if cur.b in diff:\n                    diff[cur.b] += 1\n                    if diff[cur.b] == 0:\n                        del diff[cur.b]\n                else:\n                    diff[cur.b] = 1\n                temp_v = cur.v\n                if cur.v == 1 and len(diff) > 0:\n                    print(0)\n                    return\n                cur = cur.p\n                if len(diff) == 0:\n                    break\n    if ss == 2:\n        print(ans)\n    elif ans >= 1:\n        print(1)\n    else:\n        print(0)\nt = int(input())\nfor _ in range(t):\n    solve()", "MOD = int(1000000000.0 + 7)\n\nclass TreeNode:\n\n    def __init__(self, val=0, children=[], parent=None):\n        self.v = val\n        self.c = children\n        self.p = parent\n        self.a = 0\n        self.b = 0\n        self.count = 1\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return str(self.v)\n\ndef solve():\n    (n, ss) = map(int, input().split())\n    nodes = [None]\n    for i in range(1, n + 1):\n        nodes.append(TreeNode(i, []))\n    edges = {}\n    for i in range(1, n):\n        s = input()\n        (u, v) = map(int, s.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    st = [nodes[1]]\n    done = {}\n    if len(edges) > 0:\n        while len(st) > 0:\n            node = st.pop()\n            done[node.v] = True\n            for c in edges[node.v]:\n                if not c in done:\n                    node.c.append(nodes[c])\n                    nodes[c].p = node\n                    st.append(nodes[c])\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        nodes[i].a = a[i - 1]\n        nodes[i].b = b[i - 1]\n    levels = [[nodes[1]]]\n    while len(levels[-1]) > 0:\n        l = []\n        for node in levels[-1]:\n            l.extend(node.c)\n        levels.append(l)\n    levels.pop()\n    ans = 1\n    passed = {}\n    for i in range(len(levels) - 1, -1, -1):\n        for node in levels[i]:\n            if node.v in passed:\n                continue\n            ans = ans * (len(node.c) + 1) % MOD\n            if node.a == node.b:\n                continue\n            cur = node\n            diff = {}\n            while True:\n                if cur.v in passed:\n                    print(0)\n                    return\n                passed[cur.v] = True\n                if cur.a in diff:\n                    diff[cur.a] -= 1\n                    if diff[cur.a] == 0:\n                        del diff[cur.a]\n                else:\n                    diff[cur.a] = -1\n                if cur.b in diff:\n                    diff[cur.b] += 1\n                    if diff[cur.b] == 0:\n                        del diff[cur.b]\n                else:\n                    diff[cur.b] = 1\n                temp_v = cur.v\n                if cur.v == 1 and len(diff) > 0:\n                    print(0)\n                    return\n                cur = cur.p\n                if len(diff) == 0:\n                    break\n    if ss == 2:\n        print(ans)\n    elif ans >= 1:\n        print(1)\n    else:\n        print(0)\nt = int(input())\nfor _ in range(t):\n    solve()", "MOD = int(1000000000.0 + 7)\n\nclass TreeNode:\n\n    def __init__(self, val=0, children=[], parent=None):\n        self.v = val\n        self.c = children\n        self.p = parent\n        self.a = 0\n        self.b = 0\n        self.count = 1\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return str(self.v)\n\ndef solve():\n    (n, ss) = map(int, input().split())\n    nodes = [None]\n    for i in range(1, n + 1):\n        nodes.append(TreeNode(i, []))\n    edges = {}\n    for i in range(1, n):\n        s = input()\n        (u, v) = map(int, s.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    st = [nodes[1]]\n    done = {}\n    if len(edges) > 0:\n        while len(st) > 0:\n            node = st.pop()\n            done[node.v] = True\n            for c in edges[node.v]:\n                if not c in done:\n                    node.c.append(nodes[c])\n                    nodes[c].p = node\n                    st.append(nodes[c])\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        nodes[i].a = a[i - 1]\n        nodes[i].b = b[i - 1]\n    levels = [[nodes[1]]]\n    while len(levels[-1]) > 0:\n        l = []\n        for node in levels[-1]:\n            l.extend(node.c)\n        levels.append(l)\n    levels.pop()\n    ans = 1\n    passed = {}\n    for i in range(len(levels) - 1, -1, -1):\n        for node in levels[i]:\n            if node.v in passed:\n                continue\n            ans = ans * (len(node.c) + 1) % MOD\n            if node.a == node.b:\n                continue\n            cur = node\n            diff = {}\n            while True:\n                if cur.v in passed:\n                    print(0)\n                    return\n                passed[cur.v] = True\n                if cur.a in diff:\n                    diff[cur.a] -= 1\n                    if diff[cur.a] == 0:\n                        del diff[cur.a]\n                else:\n                    diff[cur.a] = -1\n                if cur.b in diff:\n                    diff[cur.b] += 1\n                    if diff[cur.b] == 0:\n                        del diff[cur.b]\n                else:\n                    diff[cur.b] = 1\n                temp_v = cur.v\n                if cur.v == 1 and len(diff) > 0:\n                    print(0)\n                    return\n                cur = cur.p\n                if len(diff) == 0:\n                    break\n    if ss == 2:\n        print(ans)\n    elif ans >= 1:\n        print(1)\n    else:\n        print(0)\nt = int(input())\nfor _ in range(t):\n    solve()", "MOD = int(1000000000.0 + 7)\n\nclass TreeNode:\n\n    def __init__(self, val=0, children=[], parent=None):\n        self.v = val\n        self.c = children\n        self.p = parent\n        self.a = 0\n        self.b = 0\n        self.count = 1\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return str(self.v)\n\ndef solve():\n    (n, ss) = map(int, input().split())\n    nodes = [None]\n    for i in range(1, n + 1):\n        nodes.append(TreeNode(i, []))\n    edges = {}\n    for i in range(1, n):\n        s = input()\n        (u, v) = map(int, s.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    st = [nodes[1]]\n    done = {}\n    if len(edges) > 0:\n        while len(st) > 0:\n            node = st.pop()\n            done[node.v] = True\n            for c in edges[node.v]:\n                if not c in done:\n                    node.c.append(nodes[c])\n                    nodes[c].p = node\n                    st.append(nodes[c])\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        nodes[i].a = a[i - 1]\n        nodes[i].b = b[i - 1]\n    levels = [[nodes[1]]]\n    while len(levels[-1]) > 0:\n        l = []\n        for node in levels[-1]:\n            l.extend(node.c)\n        levels.append(l)\n    levels.pop()\n    ans = 1\n    passed = {}\n    for i in range(len(levels) - 1, -1, -1):\n        for node in levels[i]:\n            if node.v in passed:\n                continue\n            ans = ans * (len(node.c) + 1) % MOD\n            if node.a == node.b:\n                continue\n            cur = node\n            diff = {}\n            while True:\n                if cur.v in passed:\n                    print(0)\n                    return\n                passed[cur.v] = True\n                if cur.a in diff:\n                    diff[cur.a] -= 1\n                    if diff[cur.a] == 0:\n                        del diff[cur.a]\n                else:\n                    diff[cur.a] = -1\n                if cur.b in diff:\n                    diff[cur.b] += 1\n                    if diff[cur.b] == 0:\n                        del diff[cur.b]\n                else:\n                    diff[cur.b] = 1\n                temp_v = cur.v\n                if cur.v == 1 and len(diff) > 0:\n                    print(0)\n                    return\n                cur = cur.p\n                if len(diff) == 0:\n                    break\n    if ss == 2:\n        print(ans)\n    elif ans >= 1:\n        print(1)\n    else:\n        print(0)\nt = int(input())\nfor _ in range(t):\n    solve()", "MOD = int(1000000000.0 + 7)\n\nclass TreeNode:\n\n    def __init__(self, val=0, children=[], parent=None):\n        self.v = val\n        self.c = children\n        self.p = parent\n        self.a = 0\n        self.b = 0\n        self.count = 1\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return str(self.v)\n\ndef solve():\n    (n, ss) = map(int, input().split())\n    nodes = [None]\n    for i in range(1, n + 1):\n        nodes.append(TreeNode(i, []))\n    edges = {}\n    for i in range(1, n):\n        s = input()\n        (u, v) = map(int, s.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    st = [nodes[1]]\n    done = {}\n    if len(edges) > 0:\n        while len(st) > 0:\n            node = st.pop()\n            done[node.v] = True\n            for c in edges[node.v]:\n                if not c in done:\n                    node.c.append(nodes[c])\n                    nodes[c].p = node\n                    st.append(nodes[c])\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        nodes[i].a = a[i - 1]\n        nodes[i].b = b[i - 1]\n    levels = [[nodes[1]]]\n    while len(levels[-1]) > 0:\n        l = []\n        for node in levels[-1]:\n            l.extend(node.c)\n        levels.append(l)\n    levels.pop()\n    ans = 1\n    passed = {}\n    for i in range(len(levels) - 1, -1, -1):\n        for node in levels[i]:\n            if node.v in passed:\n                continue\n            ans = ans * (len(node.c) + 1) % MOD\n            if node.a == node.b:\n                continue\n            cur = node\n            diff = {}\n            while True:\n                if cur.v in passed:\n                    print(0)\n                    return\n                passed[cur.v] = True\n                if cur.a in diff:\n                    diff[cur.a] -= 1\n                    if diff[cur.a] == 0:\n                        del diff[cur.a]\n                else:\n                    diff[cur.a] = -1\n                if cur.b in diff:\n                    diff[cur.b] += 1\n                    if diff[cur.b] == 0:\n                        del diff[cur.b]\n                else:\n                    diff[cur.b] = 1\n                temp_v = cur.v\n                if cur.v == 1 and len(diff) > 0:\n                    print(0)\n                    return\n                cur = cur.p\n                if len(diff) == 0:\n                    break\n    if ss == 2:\n        print(ans)\n    elif ans >= 1:\n        print(1)\n    else:\n        print(0)\nt = int(input())\nfor _ in range(t):\n    solve()", "MOD = int(1000000000.0 + 7)\n\nclass TreeNode:\n\n    def __init__(self, val=0, children=[], parent=None):\n        self.v = val\n        self.c = children\n        self.p = parent\n        self.a = 0\n        self.b = 0\n        self.count = 1\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return str(self.v)\n\ndef solve():\n    (n, ss) = map(int, input().split())\n    nodes = [None]\n    edges = {}\n    for i in range(1, n + 1):\n        nodes.append(TreeNode(i, []))\n    for i in range(1, n):\n        s = input()\n        (u, v) = map(int, s.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    st = [nodes[1]]\n    done = {}\n    if len(edges) > 0:\n        while len(st) > 0:\n            node = st.pop()\n            done[node.v] = True\n            for c in edges[node.v]:\n                if not c in done:\n                    node.c.append(nodes[c])\n                    nodes[c].p = node\n                    st.append(nodes[c])\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        nodes[i].a = a[i - 1]\n        nodes[i].b = b[i - 1]\n    levels = [[nodes[1]]]\n    while len(levels[-1]) > 0:\n        l = []\n        for node in levels[-1]:\n            l.extend(node.c)\n        levels.append(l)\n    levels.pop()\n    ans = 1\n    passed = {}\n    for i in range(len(levels) - 1, -1, -1):\n        for node in levels[i]:\n            if node.v in passed:\n                continue\n            ans = ans * (len(node.c) + 1) % MOD\n            if node.a == node.b:\n                continue\n            cur = node\n            diff = {}\n            while True:\n                if cur.v in passed:\n                    print(0)\n                    return\n                passed[cur.v] = True\n                if cur.a in diff:\n                    diff[cur.a] -= 1\n                    if diff[cur.a] == 0:\n                        del diff[cur.a]\n                else:\n                    diff[cur.a] = -1\n                if cur.b in diff:\n                    diff[cur.b] += 1\n                    if diff[cur.b] == 0:\n                        del diff[cur.b]\n                else:\n                    diff[cur.b] = 1\n                temp_v = cur.v\n                if cur.v == 1 and len(diff) > 0:\n                    print(0)\n                    return\n                cur = cur.p\n                if len(diff) == 0:\n                    break\n    if ss == 2:\n        print(ans)\n    else:\n        print(1) if ans >= 1 else print(0)\nfor _ in range(int(input())):\n    solve()", "MOD = int(1000000000.0 + 7)\n\nclass TreeNode:\n\n    def __init__(self, val=0, children=[], parent=None):\n        self.v = val\n        self.c = children\n        self.p = parent\n        self.a = 0\n        self.b = 0\n        self.count = 1\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return str(self.v)\n\ndef solve():\n    (n, ss) = map(int, input().split())\n    nodes = [None]\n    edges = {}\n    for i in range(1, n + 1):\n        nodes.append(TreeNode(i, []))\n    for i in range(1, n):\n        s = input()\n        (u, v) = map(int, s.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    st = [nodes[1]]\n    done = {}\n    if len(edges) > 0:\n        while len(st) > 0:\n            node = st.pop()\n            done[node.v] = True\n            for c in edges[node.v]:\n                if not c in done:\n                    node.c.append(nodes[c])\n                    nodes[c].p = node\n                    st.append(nodes[c])\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        nodes[i].a = a[i - 1]\n        nodes[i].b = b[i - 1]\n    levels = [[nodes[1]]]\n    while len(levels[-1]) > 0:\n        l = []\n        for node in levels[-1]:\n            l.extend(node.c)\n        levels.append(l)\n    levels.pop()\n    ans = 1\n    passed = {}\n    for i in range(len(levels) - 1, -1, -1):\n        for node in levels[i]:\n            if node.v in passed:\n                continue\n            ans = ans * (len(node.c) + 1) % MOD\n            if node.a == node.b:\n                continue\n            cur = node\n            diff = {}\n            while True:\n                if cur.v in passed:\n                    print(0)\n                    return\n                passed[cur.v] = True\n                if cur.a in diff:\n                    diff[cur.a] -= 1\n                    if diff[cur.a] == 0:\n                        del diff[cur.a]\n                else:\n                    diff[cur.a] = -1\n                if cur.b in diff:\n                    diff[cur.b] += 1\n                    if diff[cur.b] == 0:\n                        del diff[cur.b]\n                else:\n                    diff[cur.b] = 1\n                temp_v = cur.v\n                if cur.v == 1 and len(diff) > 0:\n                    print(0)\n                    return\n                cur = cur.p\n                if len(diff) == 0:\n                    break\n    if ss == 2:\n        print(ans)\n    else:\n        print(1) if ans >= 1 else print(0)\nfor _ in range(int(input())):\n    solve()", "MOD = int(1000000000.0 + 7)\n\nclass TreeNode:\n\n    def __init__(self, val=0, children=[], parent=None):\n        self.v = val\n        self.c = children\n        self.p = parent\n        self.a = 0\n        self.b = 0\n        self.count = 1\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return str(self.v)\n\ndef solve():\n    (n, ss) = map(int, input().split())\n    nodes = [None]\n    for i in range(1, n + 1):\n        nodes.append(TreeNode(i, []))\n    edges = {}\n    for i in range(1, n):\n        s = input()\n        (u, v) = map(int, s.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    st = [nodes[1]]\n    done = {}\n    if len(edges) > 0:\n        while len(st) > 0:\n            node = st.pop()\n            done[node.v] = True\n            for c in edges[node.v]:\n                if not c in done:\n                    node.c.append(nodes[c])\n                    nodes[c].p = node\n                    st.append(nodes[c])\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        nodes[i].a = a[i - 1]\n        nodes[i].b = b[i - 1]\n    levels = [[nodes[1]]]\n    while len(levels[-1]) > 0:\n        l = []\n        for node in levels[-1]:\n            l.extend(node.c)\n        levels.append(l)\n    levels.pop()\n    ans = 1\n    passed = {}\n    for i in range(len(levels) - 1, -1, -1):\n        for node in levels[i]:\n            if node.v in passed:\n                continue\n            ans = ans * (len(node.c) + 1) % MOD\n            if node.a == node.b:\n                continue\n            cur = node\n            diff = {}\n            while True:\n                if cur.v in passed:\n                    print(0)\n                    return\n                passed[cur.v] = True\n                if cur.a in diff:\n                    diff[cur.a] -= 1\n                    if diff[cur.a] == 0:\n                        del diff[cur.a]\n                else:\n                    diff[cur.a] = -1\n                if cur.b in diff:\n                    diff[cur.b] += 1\n                    if diff[cur.b] == 0:\n                        del diff[cur.b]\n                else:\n                    diff[cur.b] = 1\n                temp_v = cur.v\n                if cur.v == 1 and len(diff) > 0:\n                    print(0)\n                    return\n                cur = cur.p\n                if len(diff) == 0:\n                    break\n    if ss == 2:\n        print(ans)\n    else:\n        print(1) if ans >= 1 else print(0)\nfor _ in range(int(input())):\n    solve()", "MOD = int(1000000000.0 + 7)\n\nclass TreeNode:\n\n    def __init__(self, val=0, children=[], parent=None):\n        self.v = val\n        self.c = children\n        self.p = parent\n        self.a = 0\n        self.b = 0\n        self.count = 1\n\n    def __repr__(self):\n        return self.__str__()\n\n    def __str__(self):\n        return str(self.v)\n\ndef solve():\n    (n, ss) = map(int, input().split())\n    nodes = [None]\n    for i in range(1, n + 1):\n        nodes.append(TreeNode(i, []))\n    edges = {}\n    for i in range(1, n):\n        s = input()\n        (u, v) = map(int, s.split())\n        if u in edges:\n            edges[u].append(v)\n        else:\n            edges[u] = [v]\n        if v in edges:\n            edges[v].append(u)\n        else:\n            edges[v] = [u]\n    st = [nodes[1]]\n    done = {}\n    if len(edges) > 0:\n        while len(st) > 0:\n            node = st.pop()\n            done[node.v] = True\n            for c in edges[node.v]:\n                if not c in done:\n                    node.c.append(nodes[c])\n                    nodes[c].p = node\n                    st.append(nodes[c])\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n + 1):\n        nodes[i].a = a[i - 1]\n        nodes[i].b = b[i - 1]\n    levels = [[nodes[1]]]\n    while len(levels[-1]) > 0:\n        l = []\n        for node in levels[-1]:\n            l.extend(node.c)\n        levels.append(l)\n    levels.pop()\n    ans = 1\n    passed = {}\n    for i in range(len(levels) - 1, -1, -1):\n        for node in levels[i]:\n            if node.v in passed:\n                continue\n            ans = ans * (len(node.c) + 1) % MOD\n            if node.a == node.b:\n                continue\n            cur = node\n            diff = {}\n            while True:\n                if cur.v in passed:\n                    print(0)\n                    return\n                passed[cur.v] = True\n                if cur.a in diff:\n                    diff[cur.a] -= 1\n                    if diff[cur.a] == 0:\n                        del diff[cur.a]\n                else:\n                    diff[cur.a] = -1\n                if cur.b in diff:\n                    diff[cur.b] += 1\n                    if diff[cur.b] == 0:\n                        del diff[cur.b]\n                else:\n                    diff[cur.b] = 1\n                temp_v = cur.v\n                if cur.v == 1 and len(diff) > 0:\n                    print(0)\n                    return\n                cur = cur.p\n                if len(diff) == 0:\n                    break\n    if ss == 2:\n        print(ans)\n    elif ans >= 1:\n        print(1)\n    else:\n        print(0)\nt = int(input())\nfor _ in range(t):\n    solve()", "from functools import reduce\nfrom collections import deque\nfrom math import gcd\n\ndef ints():\n    return map(int, input().split())\n\ndef bfs(graph, v):\n    q = deque()\n    vis = set([v])\n    q.append(v)\n    ans = [v]\n    par = {v: -1}\n    while q:\n        curr = q.popleft()\n        for nbr in graph[curr]:\n            if nbr not in vis:\n                par[nbr] = curr\n                vis.add(nbr)\n                q.append(nbr)\n                ans.append(nbr)\n    return (ans[::-1], par)\n\ndef find_path(v, par, a, b, vis):\n    if a[v] == b[v]:\n        return (v, v)\n    count = {a[v]: 1, b[v]: -1}\n    orig = v\n    while True:\n        v = par[v]\n        if v == -1 or v in vis:\n            return False\n        vis.add(v)\n        if a[v] not in count:\n            count[a[v]] = 0\n        if b[v] not in count:\n            count[b[v]] = 0\n        count[a[v]] += 1\n        count[b[v]] -= 1\n        if count[a[v]] == 0:\n            del count[a[v]]\n        if b[v] in count and count[b[v]] == 0:\n            del count[b[v]]\n        if not count:\n            return tuple([v, orig])\n\ndef main(n, s, graph, a, b):\n    (revord, par) = bfs(graph, 0)\n    ans = []\n    vis = set()\n    for v in revord:\n        if v not in vis:\n            vis.add(v)\n            verd = find_path(v, par, a, b, vis)\n            if not verd:\n                return (0, revord, par)\n            ans.append(verd)\n    return (ans, revord, par)\n\ndef make_graph(v, graph, par, newgraph, nextv, vis):\n    vis.add(v[0])\n    for nbr in graph[v[1]]:\n        if nbr == par[v[1]]:\n            continue\n        newgraph[v].append((nbr, nextv[nbr]))\n        make_graph((nbr, nextv[nbr]), graph, par, newgraph, nextv, vis)\nmod = 10 ** 9 + 7\n\ndef mult(x, y):\n    return x * y % mod\nt = int(input())\nfor _ in range(t):\n    (n, s) = ints()\n    graph = {i: [] for i in range(n)}\n    for __ in range(n - 1):\n        (a, b) = ints()\n        (a, b) = (a - 1, b - 1)\n        graph[a].append(b)\n        graph[b].append(a)\n    a = list(ints())\n    b = list(ints())\n    (ans, rev, par) = main(n, s, graph, a, b)\n    if not ans:\n        print(0)\n    else:\n        nextv = {v[0]: v[1] for v in ans}\n        newgraph = {i: [] for i in ans}\n        vis = set()\n        for v in reversed(rev):\n            if v not in vis and v in nextv:\n                make_graph((v, nextv[v]), graph, par, newgraph, nextv, vis)\n        fin = reduce(mult, [len(newgraph[x]) + 1 for x in newgraph])\n        if s == 1:\n            print(1)\n        else:\n            print(fin)", "import sys\nsys.setrecursionlimit(10 ** 6)\nfrom collections import deque\nfrom queue import PriorityQueue\nfrom math import gcd\ninput_ = lambda : sys.stdin.readline().strip('\\r\\n')\nii = lambda : int(input_())\nil = lambda : list(map(int, input_().split()))\nilf = lambda : list(map(float, input_().split()))\nip = lambda : input_()\nfi = lambda : float(input_())\nap = lambda ab, bc, cd: ab[bc].append(cd)\nli = lambda : list(input_())\npr = lambda x: print(x)\nprinT = lambda x: print(x)\nf = lambda : sys.stdout.flush()\nmod = 10 ** 9 + 7\n\ndef dfs(u, p):\n    t = 0\n    leaf = True\n    fl = True\n    sub = False\n    count = 0\n    n1 = {}\n    n2 = {}\n    ans = 1\n    xy = 1\n    for i in adj[u]:\n        if i == p:\n            continue\n        leaf = False\n        mn = dfs(i, u)\n        count += 1\n        if mn[0][1] == False:\n            return mn\n        elif mn[0][0] == False:\n            if t == 1:\n                return [[False, False, {}, {}], -1]\n            else:\n                m1 = mn[0][2]\n                m2 = mn[0][3]\n                t = 1\n                xy = mn[1]\n                m1[a[u]] = m1.get(a[u], 0) + 1\n                m2[b[u]] = m2.get(b[u], 0) + 1\n                sub = True\n                for j in m1:\n                    if m2.get(j):\n                        if m2[j] != m1[j]:\n                            fl = False\n                            n1 = m1\n                            n2 = m2\n                            break\n                    else:\n                        fl = False\n                        n1 = m1\n                        n2 = m2\n                        break\n        else:\n            ans = ans * mn[1] % mod\n    if leaf:\n        if a[u] == b[u]:\n            return [[True, True, {a[u]: 1}, {b[u]: 1}], 1]\n        else:\n            return [[False, True, {a[u]: 1}, {b[u]: 1}], 1]\n    if fl == True:\n        if sub == False:\n            if a[u] == b[u]:\n                return [[True, True], ans * (count + 1) % mod]\n            else:\n                return [[False, True, {a[u]: 1}, {b[u]: 1}], ans * (count + 1) % mod]\n        return [[True, True], ans * xy % mod]\n    else:\n        return [[False, True, n1, n2], ans * xy % mod]\nfor _ in range(ii()):\n    (n, s) = il()\n    adj = [[] for i in range(n + 1)]\n    for _ in range(n - 1):\n        (x, y) = il()\n        ap(adj, x, y)\n        ap(adj, y, x)\n    a = [0] + il()\n    b = [0] + il()\n    mn = dfs(1, 0)\n    if mn[0][0] and mn[0][1]:\n        if s == 1:\n            print(1)\n        else:\n            print(mn[1])\n    else:\n        print(0)", "import sys\nsys.setrecursionlimit(10 ** 6)\nN = 10 ** 5 + 10\nglobal n, s\nmod = 10 ** 9 + 7\nglobal ok\ngraph = [[] for i in range(N)]\nspec = [0 for i in range(N)]\n(a, b) = ([0 for i in range(N)], [0 for i in range(N)])\ndp = [0 for i in range(N)]\nbal = [{} for i in range(N)]\ndummy = {}\n\ndef dfs1(node, par, cntr, freq):\n    global ok\n    cnt = 0\n    for to in graph[node]:\n        if to == par:\n            continue\n        (tempo, t_freq) = dfs1(to, node, bal[to], 0)\n        if not ok:\n            return (dummy, -1)\n        if t_freq == 0:\n            spec[to] = 1\n            tempo.clear()\n        else:\n            cnt += 1\n            cntr = tempo\n            freq = t_freq\n    if cnt > 1:\n        ok = False\n        return (dummy, -1)\n    aa = a[node]\n    bb = b[node]\n    if cntr.get(aa, 0) == 0:\n        freq += 1\n        cntr[aa] = cntr.get(aa, 0) - 1\n    else:\n        cntr[aa] = cntr.get(aa, 0) - 1\n        if cntr.get(aa, 0) == 0:\n            freq -= 1\n    if cntr.get(bb, 0) == 0:\n        freq += 1\n        cntr[bb] = cntr.get(bb, 0) + 1\n    else:\n        cntr[bb] = cntr.get(bb, 0) + 1\n        if cntr.get(bb, 0) == 0:\n            freq -= 1\n    return (cntr, freq)\n\ndef dfs2(node, par):\n    global ok\n    dp[node] = 1\n    cnt = 0\n    temp = True\n    for to in graph[node]:\n        if to == par:\n            continue\n        if not spec[to]:\n            temp = False\n        dfs2(to, node)\n        dp[node] *= dp[to]\n        dp[node] %= mod\n        cnt += 1\n    if temp:\n        dp[node] *= cnt + 1\n        dp[node] %= mod\nfor _ in range(int(input())):\n    global ok\n    (n, s) = [int(i) for i in input().split()]\n    ok = True\n    for i in range(n - 1):\n        (u, v) = [int(i) for i in input().split()]\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n    t1 = [int(i) for i in input().split()]\n    t2 = [int(i) for i in input().split()]\n    for i in range(n):\n        a[i] = t1[i]\n        b[i] = t2[i]\n    (not_req, freq) = dfs1(0, -1, bal[0], 0)\n    if freq != 0:\n        ok = False\n    else:\n        spec[0] = True\n    if not ok:\n        print(0)\n    elif s == 1:\n        print(1)\n    else:\n        dfs2(0, -1)\n        print(dp[0])\n    for i in range(n):\n        graph[i].clear()\n        dp[i] = 0\n        spec[i] = 0\n        bal[i].clear()", "import sys\nsys.setrecursionlimit(10 ** 6)\nN = 10 ** 5 + 10\nglobal n, s\nmod = 10 ** 9 + 7\nglobal ok\ngraph = [[] for i in range(N)]\nspec = [0 for i in range(N)]\n(a, b) = ([0 for i in range(N)], [0 for i in range(N)])\ndp = [0 for i in range(N)]\nbal = [{} for i in range(N)]\ndummy = {}\n\ndef dfs1(node, par, cntr, freq):\n    global ok\n    cnt = 0\n    for to in graph[node]:\n        if to == par:\n            continue\n        (tempo, t_freq) = dfs1(to, node, bal[to], 0)\n        if not ok:\n            return (dummy, -1)\n        if t_freq == 0:\n            spec[to] = 1\n            tempo.clear()\n        else:\n            cnt += 1\n            cntr = tempo\n            freq = t_freq\n    if cnt > 1:\n        ok = False\n        return (dummy, -1)\n    aa = a[node]\n    bb = b[node]\n    if cntr.get(aa, 0) == 0:\n        freq += 1\n        cntr[aa] = cntr.get(aa, 0) - 1\n    else:\n        cntr[aa] = cntr.get(aa, 0) - 1\n        if cntr.get(aa, 0) == 0:\n            freq -= 1\n    if cntr.get(bb, 0) == 0:\n        freq += 1\n        cntr[bb] = cntr.get(bb, 0) + 1\n    else:\n        cntr[bb] = cntr.get(bb, 0) + 1\n        if cntr.get(bb, 0) == 0:\n            freq -= 1\n    return (cntr, freq)\n\ndef dfs2(node, par):\n    global ok\n    dp[node] = 1\n    cnt = 0\n    temp = True\n    for to in graph[node]:\n        if to == par:\n            continue\n        if not spec[to]:\n            temp = False\n        dfs2(to, node)\n        dp[node] *= dp[to]\n        dp[node] %= mod\n        cnt += 1\n    if temp:\n        dp[node] *= cnt + 1\n        dp[node] %= mod\nfor _ in range(int(input())):\n    global ok\n    (n, s) = [int(i) for i in input().split()]\n    ok = True\n    for i in range(n - 1):\n        (u, v) = [int(i) for i in input().split()]\n        u -= 1\n        v -= 1\n        graph[u].append(v)\n        graph[v].append(u)\n    t1 = [int(i) for i in input().split()]\n    t2 = [int(i) for i in input().split()]\n    for i in range(n):\n        a[i] = t1[i]\n        b[i] = t2[i]\n    (not_req, freq) = dfs1(0, -1, bal[0], 0)\n    if freq != 0:\n        ok = False\n    else:\n        spec[0] = True\n    if not ok:\n        print(0)\n    elif s == 1:\n        print(1)\n    else:\n        dfs2(0, -1)\n        print(dp[0])\n    for i in range(n):\n        graph[i].clear()\n        dp[i] = 0\n        spec[i] = 0\n        bal[i].clear()", "from collections import defaultdict, deque\nfrom sys import stdin\ninput = stdin.readline\nMODULO = 1000000007\n\ndef buildtree(parents, graph, N):\n    queue = [(1, 0)]\n    while queue:\n        (u, parent) = queue.pop()\n        for v in graph[u]:\n            if v != parent:\n                parents[v] = u\n                queue.append((v, u))\n    if N == 1:\n        leaves = deque([1])\n    else:\n        leaves = deque([])\n        for u in range(2, N + 1):\n            if len(graph[u]) == 1:\n                leaves.append(u)\n    return leaves\n\ndef buildpartition(graph, parents, leaves, A, B, N):\n    partition = [0] * (N + 1)\n    increment = 1\n    while leaves:\n        u = leaves.pop()\n        count = defaultdict(int)\n        nonzero = 0\n        while u != 0 and partition[u] == 0:\n            if A[u] != B[u]:\n                if count[A[u]] == 0:\n                    count[A[u]] = 1\n                    nonzero += 1\n                else:\n                    count[A[u]] += 1\n                    if count[A[u]] == 0:\n                        nonzero -= 1\n                if count[B[u]] == 0:\n                    count[B[u]] = -1\n                    nonzero += 1\n                else:\n                    count[B[u]] -= 1\n                    if count[B[u]] == 0:\n                        nonzero -= 1\n            partition[u] = increment\n            if nonzero == 0:\n                break\n            u = parents[u]\n        if u == 0 or partition[u] != increment:\n            return None\n        increment += 1\n        u = parents[u]\n        if u != 0 and partition[u] == 0:\n            ok = True\n            for v in graph[u]:\n                if v != parents[u] and partition[v] == 0:\n                    ok = False\n                    break\n            if ok:\n                leaves.append(u)\n    return partition\n\ndef F(u, graph2):\n    answer = 1 + len(graph2[u])\n    for v in graph2[u]:\n        answer = answer * F(v, graph2) % MODULO\n    return answer\n\ndef solve(parents, N, S, graph, A, B):\n    leaves = buildtree(parents, graph, N)\n    partition = buildpartition(graph, parents, list(leaves), A, B, N)\n    if partition == None:\n        return 0\n    if S == 1:\n        return 1\n    graph2 = {u: [] for u in partition[1:]}\n    roots = []\n    visited = set([])\n    while leaves:\n        node = leaves.pop()\n        while parents[node] != 0 and partition[parents[node]] == partition[node]:\n            node = parents[node]\n        if node == 1:\n            roots.append(partition[node])\n        else:\n            parent = parents[node]\n            ok = True\n            for v in graph[parent]:\n                if v != parents[parent] and partition[v] == partition[parent]:\n                    ok = False\n                    break\n            if ok:\n                graph2[partition[parent]].append(partition[node])\n                if parent not in visited:\n                    leaves.appendleft(parent)\n                    visited.add(parent)\n            else:\n                roots.append(partition[node])\n    answer = 1\n    for root in roots:\n        answer = answer * F(root, graph2) % MODULO\n    return answer\nT = int(input().strip())\nparents = [0] * (10 ** 5 + 1)\nfor problem in range(1, T + 1):\n    (N, S) = [int(x) for x in input().strip().split()]\n    graph = {u: [] for u in range(1, N + 1)}\n    for i in range(N - 1):\n        (u, v) = [int(x) for x in input().strip().split()]\n        graph[u].append(v)\n        graph[v].append(u)\n    A = [None] + [int(x) for x in input().strip().split()]\n    B = [None] + [int(x) for x in input().strip().split()]\n    print(solve(parents, N, S, graph, A, B))"]