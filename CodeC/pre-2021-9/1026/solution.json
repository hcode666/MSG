["T = int(input())\nwhile T:\n    (N, K) = map(int, input().rstrip().rsplit())\n    st = str(input())\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N & 1:\n        a += '0'\n        b += '1'\n    (n1, n2) = (0, 0)\n    for i in range(N):\n        if a[i] != st[i]:\n            n1 += 1\n        if b[i] != st[i]:\n            n2 += 1\n    if n1 <= K or n2 <= K:\n        print(1)\n    else:\n        blocks = []\n        count = 1\n        for i in range(1, N):\n            if st[i] != st[i - 1]:\n                blocks.append(count)\n                count = 1\n            else:\n                count += 1\n        blocks.append(count)\n        (l, r) = (2, N)\n        while l < r:\n            mid = (l + r) // 2\n            c = 0\n            for i in blocks:\n                if i > mid:\n                    c += i // (mid + 1)\n            if c > K:\n                l = mid + 1\n            else:\n                r = mid\n        print(l)\n    T -= 1", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().rstrip().rsplit())\n    st = str(input())\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N & 1:\n        a += '0'\n        b += '1'\n    (n1, n2) = (0, 0)\n    for i in range(N):\n        if a[i] != st[i]:\n            n1 += 1\n        if b[i] != st[i]:\n            n2 += 1\n    if n1 <= K or n2 <= K:\n        print(1)\n    else:\n        blocks = []\n        count = 1\n        for i in range(1, N):\n            if st[i] != st[i - 1]:\n                blocks.append(count)\n                count = 1\n            else:\n                count += 1\n        blocks.append(count)\n        (l, r) = (2, N)\n        while l < r:\n            mid = (l + r) // 2\n            c = 0\n            for i in blocks:\n                if i > mid:\n                    c += i // (mid + 1)\n            if c > K:\n                l = mid + 1\n            else:\n                r = mid\n        print(l)\n    T -= 1", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().rstrip().rsplit())\n    st = str(input())\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N & 1:\n        a += '0'\n        b += '1'\n    (n1, n2) = (0, 0)\n    for i in range(N):\n        if a[i] != st[i]:\n            n1 += 1\n        if b[i] != st[i]:\n            n2 += 1\n    if n1 <= K or n2 <= K:\n        print(1)\n    else:\n        blocks = []\n        count = 1\n        for i in range(1, N):\n            if st[i] != st[i - 1]:\n                blocks.append(count)\n                count = 1\n            else:\n                count += 1\n        blocks.append(count)\n        (l, r) = (2, N)\n        while l < r:\n            mid = (l + r) // 2\n            c = 0\n            for i in blocks:\n                if i > mid:\n                    c += i // (mid + 1)\n            if c > K:\n                l = mid + 1\n            else:\n                r = mid\n        print(l)\n    T -= 1", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().rstrip().rsplit())\n    st = str(input())\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N & 1:\n        a += '0'\n        b += '1'\n    (n1, n2) = (0, 0)\n    for i in range(N):\n        if a[i] != st[i]:\n            n1 += 1\n        if b[i] != st[i]:\n            n2 += 1\n    if n1 <= K or n2 <= K:\n        print(1)\n    else:\n        blocks = []\n        count = 1\n        for i in range(1, N):\n            if st[i] != st[i - 1]:\n                blocks.append(count)\n                count = 1\n            else:\n                count += 1\n        blocks.append(count)\n        (l, r) = (2, N)\n        while l < r:\n            mid = (l + r) // 2\n            c = 0\n            for i in blocks:\n                if i > mid:\n                    c += i // (mid + 1)\n            if c > K:\n                l = mid + 1\n            else:\n                r = mid\n        print(l)\n    T -= 1", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().rstrip().rsplit())\n    st = str(input())\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N & 1:\n        a += '0'\n        b += '1'\n    (n1, n2) = (0, 0)\n    for i in range(N):\n        if a[i] != st[i]:\n            n1 += 1\n        if b[i] != st[i]:\n            n2 += 1\n    if n1 <= K or n2 <= K:\n        print(1)\n    else:\n        blocks = []\n        count = 1\n        for i in range(1, N):\n            if st[i] != st[i - 1]:\n                blocks.append(count)\n                count = 1\n            else:\n                count += 1\n        blocks.append(count)\n        (l, r) = (2, N)\n        while l < r:\n            mid = (l + r) // 2\n            c = 0\n            for i in blocks:\n                if i > mid:\n                    c += i // (mid + 1)\n            if c > K:\n                l = mid + 1\n            else:\n                r = mid\n        print(l)\n    T -= 1", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().rstrip().rsplit())\n    st = str(input())\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N & 1:\n        a += '0'\n        b += '1'\n    (n1, n2) = (0, 0)\n    for i in range(N):\n        if a[i] != st[i]:\n            n1 += 1\n        if b[i] != st[i]:\n            n2 += 1\n    if n1 <= K or n2 <= K:\n        print(1)\n    else:\n        blocks = []\n        count = 1\n        for i in range(1, N):\n            if st[i] != st[i - 1]:\n                blocks.append(count)\n                count = 1\n            else:\n                count += 1\n        blocks.append(count)\n        (l, r) = (2, N)\n        while l < r:\n            mid = (l + r) // 2\n            c = 0\n            for i in blocks:\n                if i > mid:\n                    c += i // (mid + 1)\n            if c > K:\n                l = mid + 1\n            else:\n                r = mid\n        print(l)\n    T -= 1", "T = int(input())\nwhile T:\n    (N, K) = map(int, input().rstrip().rsplit())\n    st = str(input())\n    a = '01' * (N // 2)\n    b = '10' * (N // 2)\n    if N & 1:\n        a += '0'\n        b += '1'\n    (n1, n2) = (0, 0)\n    for i in range(N):\n        if a[i] != st[i]:\n            n1 += 1\n        if b[i] != st[i]:\n            n2 += 1\n    if n1 <= K or n2 <= K:\n        print(1)\n    else:\n        blocks = []\n        count = 1\n        for i in range(1, N):\n            if st[i] != st[i - 1]:\n                blocks.append(count)\n                count = 1\n            else:\n                count += 1\n        blocks.append(count)\n        (l, r) = (2, N)\n        while l < r:\n            mid = (l + r) // 2\n            c = 0\n            for i in blocks:\n                if i > mid:\n                    c += i // (mid + 1)\n            if c > K:\n                l = mid + 1\n            else:\n                r = mid\n        print(l)\n    T -= 1", "def requiredLessThanK(m):\n    count = 0\n    for i in blocks:\n        if i > m:\n            count += i // (m + 1)\n    return count <= k\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    cnt = 1\n    blocks = []\n    s1 = '01' * (n // 2)\n    s2 = '10' * (n // 2)\n    c1 = 0\n    c2 = 0\n    if n & 1:\n        s1 += '0'\n        s2 += '1'\n    for i in range(n):\n        if s1[i] == s[i]:\n            c1 += 1\n        if s2[i] == s[i]:\n            c2 += 1\n    if min(c1, c2) <= k:\n        print(1)\n    else:\n        for i in range(1, n):\n            if s[i] != s[i - 1]:\n                blocks.append(cnt)\n                cnt = 1\n            else:\n                cnt += 1\n        blocks.append(cnt)\n        l = 2\n        r = n\n        ans = n\n        while l <= r:\n            mid = (l + r) // 2\n            if requiredLessThanK(mid):\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        print(ans)", "def requiredLessThanK(m):\n    count = 0\n    for i in blocks:\n        if i > m:\n            count += i // (m + 1)\n    return count <= k\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    cnt = 1\n    blocks = []\n    s1 = '01' * (n // 2)\n    s2 = '10' * (n // 2)\n    c1 = 0\n    c2 = 0\n    if n & 1:\n        s1 += '0'\n        s2 += '1'\n    for i in range(n):\n        if s1[i] == s[i]:\n            c1 += 1\n        if s2[i] == s[i]:\n            c2 += 1\n    if min(c1, c2) <= k:\n        print(1)\n    else:\n        for i in range(1, n):\n            if s[i] != s[i - 1]:\n                blocks.append(cnt)\n                cnt = 1\n            else:\n                cnt += 1\n        blocks.append(cnt)\n        l = 2\n        r = n\n        ans = n\n        while l <= r:\n            mid = (l + r) // 2\n            if requiredLessThanK(mid):\n                ans = mid\n                r = mid - 1\n            else:\n                l = mid + 1\n        print(ans)", "def ispzbl(block, mid, k):\n    c = 0\n    for j in block:\n        if j > mid:\n            c += j // (mid + 1)\n    return c <= k\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    a = list(input())\n    block = []\n    count = 1\n    for i in range(1, n):\n        if a[i] != a[i - 1]:\n            block.append(count)\n            count = 1\n        else:\n            count += 1\n    block.append(count)\n    s1 = '10' * (n // 2)\n    s2 = '01' * (n // 2)\n    if n & 1:\n        s1 += '1'\n        s2 += '0'\n    (cn1, cn2) = (0, 0)\n    for i in range(n):\n        if a[i] == s1[i]:\n            cn1 += 1\n        if a[i] == s2[i]:\n            cn2 += 1\n    if min(cn1, cn2) <= k:\n        print(1)\n    else:\n        (low, high) = (2, n)\n        ans = n\n        while low <= high:\n            mid = (low + high) // 2\n            if ispzbl(block, mid, k):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        print(ans)", "def possible(m):\n    (left_contiguous_idx, right_contiguous_idx, flips) = (0, 0, 0)\n    for i in range(n):\n        if s[left_contiguous_idx] == s[right_contiguous_idx]:\n            right_contiguous_idx += 1\n        else:\n            flips += (right_contiguous_idx - left_contiguous_idx) // (m + 1)\n            left_contiguous_idx = right_contiguous_idx\n            right_contiguous_idx += 1\n    flips += (right_contiguous_idx - left_contiguous_idx) // (m + 1)\n    return flips <= k\nfor _ in range(int(input().strip())):\n    (n, k) = map(int, input().strip().split())\n    s = [int(i) for i in input().strip()]\n    s_copy_0 = s[:]\n    s_copy_1 = s[:]\n    s_copy_1[0] = 1 - s_copy_1[0]\n    count_0 = 0\n    count_1 = 1\n    for i in range(1, n):\n        if s_copy_0[i] == s_copy_0[i - 1]:\n            s_copy_0[i] = 1 - s_copy_0[i - 1]\n            count_0 += 1\n        if s_copy_1[i] == s_copy_1[i - 1]:\n            s_copy_1[i] = 1 - s_copy_1[i - 1]\n            count_1 += 1\n    if min(count_1, count_0) <= k:\n        print(1)\n    else:\n        ans = n\n        l = 2\n        r = n\n        while l < r:\n            m = (l + r) // 2\n            if possible(m):\n                r = m\n            else:\n                l = m + 1\n        print(r)", "def solve(ls, l, k):\n    for i in ls:\n        p = len(i)\n        if p > l:\n            k -= p // (l + 1)\n    if k < 0:\n        return False\n    return True\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    st = input()\n    ls = list()\n    prev = st[0]\n    for i in st[1:]:\n        if i != prev[-1]:\n            ls.append(prev)\n            prev = i\n        else:\n            prev += i\n    ls.append(prev)\n    s1 = '10' * (n // 2)\n    s2 = '01' * (n // 2)\n    if n % 2 != 0:\n        s1 += '1'\n        s2 += '0'\n    a = b = 0\n    for i in range(n):\n        if s1[i] != st[i]:\n            a += 1\n        if s2[i] != st[i]:\n            b += 1\n    if min(a, b) <= k:\n        print(1)\n    else:\n        (l, r, res) = (2, n, n)\n        while l <= r:\n            m = l + (r - l) // 2\n            if solve(ls, m, k):\n                res = min(res, m)\n                r = m - 1\n            else:\n                l = m + 1\n        print(res)", "import math\n\ndef is_pzbl(grps, mid, m):\n    req = 0\n    for i in grps:\n        if i <= mid:\n            pass\n        else:\n            req += i // (mid + 1)\n    return req <= m\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    l = list(input())\n    grps = []\n    i = 0\n    c = 1\n    while i < n - 1:\n        if l[i] == l[i + 1]:\n            c += 1\n        else:\n            grps.append(c)\n            c = 1\n        i += 1\n    if c != 0:\n        grps.append(c)\n    s1 = ''\n    s2 = ''\n    for i in range(0, n):\n        if i % 2 == 0:\n            s1 += '0'\n            s2 += '1'\n        else:\n            s1 += '1'\n            s2 += '0'\n    cnt1 = 0\n    cnt2 = 0\n    for i in range(0, n):\n        if s1[i] != l[i]:\n            cnt1 += 1\n        if s2[i] != l[i]:\n            cnt2 += 1\n    r = min(cnt1, cnt2)\n    if r <= m:\n        print(1)\n    else:\n        low = 2\n        high = n\n        while low <= high:\n            mid = (low + high) // 2\n            if is_pzbl(grps, mid, m):\n                ans = mid\n                high = mid - 1\n            else:\n                low = mid + 1\n        print(ans)", "def fun(break_status, l, k):\n    for i in break_status:\n        p = len(i)\n        if p > l:\n            k -= p // (l + 1)\n    if k < 0:\n        return 0\n    else:\n        return 1\nfor _ in range(int(input().strip())):\n    (n, k) = map(int, input().strip().split())\n    chef_status = input()\n    break_status = []\n    prev = chef_status[0]\n    for i in chef_status[1:]:\n        if i != prev[-1]:\n            break_status.append(prev)\n            prev = i\n        else:\n            prev += i\n    break_status.append(prev)\n    s1 = '10' * (n // 2)\n    s2 = '01' * (n // 2)\n    if n % 2 != 0:\n        s1 += '1'\n        s2 += '0'\n    a = 0\n    b = 0\n    for i in range(n):\n        if s1[i] != chef_status[i]:\n            a += 1\n        if s2[i] != chef_status[i]:\n            b += 1\n    if min(a, b) <= k:\n        print(1)\n    else:\n        start = 2\n        ans = n\n        end = n\n        while start <= end:\n            mid = (start + end) // 2\n            if fun(break_status, mid, k):\n                ans = min(ans, mid)\n                end = mid - 1\n            else:\n                start = mid + 1\n        print(ans)", "def possible(m):\n    (left_contiguous_idx, right_contiguous_idx, flips) = (0, 0, 0)\n    for i in range(n):\n        if s[left_contiguous_idx] == s[right_contiguous_idx]:\n            right_contiguous_idx += 1\n        else:\n            flips += (right_contiguous_idx - left_contiguous_idx) // (m + 1)\n            left_contiguous_idx = right_contiguous_idx\n            right_contiguous_idx += 1\n    flips += (right_contiguous_idx - left_contiguous_idx) // (m + 1)\n    return flips <= k\nfor _ in range(int(input().strip())):\n    (n, k) = map(int, input().strip().split())\n    s = [int(i) for i in input().strip()]\n    s_copy_0 = s[:]\n    s_copy_1 = s[:]\n    s_copy_1[0] = 1 - s_copy_1[0]\n    count_0 = 0\n    count_1 = 1\n    for i in range(1, n):\n        if s_copy_0[i] == s_copy_0[i - 1]:\n            s_copy_0[i] = 1 - s_copy_0[i - 1]\n            count_0 += 1\n        if s_copy_1[i] == s_copy_1[i - 1]:\n            s_copy_1[i] = 1 - s_copy_1[i - 1]\n            count_1 += 1\n    if min(count_1, count_0) <= k:\n        print(1)\n    else:\n        ans = n\n        l = 2\n        r = n\n        while l <= r:\n            m = (l + r) // 2\n            if possible(m):\n                ans = min(ans, m)\n                r = m - 1\n            else:\n                l = m + 1\n        print(ans)", "def possible(z):\n    l = 0\n    r = 0\n    tot = 0\n    for i in range(n):\n        if s[r] == s[l]:\n            r += 1\n        else:\n            tot += (r - l) // (z + 1)\n            l = r\n            r += 1\n    tot += (r - l) // (z + 1)\n    return tot <= k\nT = int(input())\nwhile T > 0:\n    (n, k) = map(int, input().split())\n    s = list(map(int, list(input())))\n    u = s[:]\n    v = s[:]\n    v[0] = 1 - v[0]\n    c1 = 0\n    c2 = 1\n    for i in range(1, n):\n        if u[i] == u[i - 1]:\n            u[i] = 1 - u[i - 1]\n            c1 += 1\n        if v[i] == v[i - 1]:\n            v[i] = 1 - v[i - 1]\n            c2 += 1\n    if min(c1, c2) <= k:\n        res = 1\n    else:\n        lo = 2\n        hi = n\n        res = n\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if possible(mid):\n                res = min(mid, res)\n                hi = mid - 1\n            else:\n                lo = mid + 1\n    print(res)\n    T -= 1", "def transform():\n    t1 = t2 = ''\n    c1 = c2 = 0\n    c = 1\n    for i in range(n):\n        t1 += str(c)\n        t2 += str(1 - c)\n        c = 1 - c\n    for i in range(n):\n        if t1[i] != s[i]:\n            c1 += 1\n        if t2[i] != s[i]:\n            c2 += 1\n    if k >= min(c1, c2):\n        return 1\n    blocks = []\n    count = 1\n    for i in range(1, n):\n        if s[i] == s[i - 1]:\n            count += 1\n        else:\n            blocks.append(count)\n            count = 1\n    if count > 0:\n        blocks.append(count)\n    (low, high) = (1, n)\n    while low < high:\n        total = 0\n        mid = (low + high) // 2\n        for block_size in blocks:\n            total += block_size // (mid + 1)\n        if total > k:\n            low = mid + 1\n        else:\n            high = mid\n    if low == 1:\n        low += 1\n    return low\nfor tc in range(int(input())):\n    (n, k) = map(int, input().strip().split(' '))\n    s = input().strip()\n    print(transform())", "cases = int(input())\nfor _ in range(cases):\n    (n, k) = list(map(int, input().split()))\n    s = input().strip()\n\n    def getans():\n        s1 = s2 = ''\n        cost1 = cost2 = 0\n        c = 1\n        for i in range(n):\n            s1 += str(c)\n            s2 += str(1 - c)\n            c = 1 - c\n        for i in range(n):\n            if s[i] != s1[i]:\n                cost1 += 1\n            if s[i] != s2[i]:\n                cost2 += 1\n        if k >= min(cost1, cost2):\n            return 1\n        blocks = []\n        c = 1\n        for i in range(1, n):\n            if s[i] == s[i - 1]:\n                c += 1\n            else:\n                blocks.append(c)\n                c = 1\n        if c > 0:\n            blocks.append(c)\n        (lo, hi) = (1, n)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            cost = 0\n            for i in blocks:\n                cost += i // (mid + 1)\n            if cost > k:\n                lo = mid + 1\n            else:\n                hi = mid\n        if lo == 1:\n            lo += 1\n        return lo\n    print(getans())", "def main():\n    from sys import stdin, stdout\n    t = int(stdin.readline())\n    for i in range(t):\n        (length, swaps) = map(int, stdin.readline().split())\n        seq = list(stdin.readline())\n        one = False\n        temp = 0\n        for j in range(length):\n            if j % 2 == 0:\n                if seq[j] != '1':\n                    temp += 1\n            elif seq[j] != '0':\n                temp += 1\n            if temp > swaps:\n                break\n        if temp <= swaps:\n            one = True\n        else:\n            temp = 0\n            for j in range(length):\n                if j % 2 == 0:\n                    if seq[j] != '0':\n                        temp += 1\n                elif seq[j] != '1':\n                    temp += 1\n                if temp > swaps:\n                    break\n            if temp <= swaps:\n                one = True\n        if not one:\n            blocks = []\n            last = seq[0]\n            counter = 1\n            for k in seq[1:]:\n                if k == last:\n                    counter += 1\n                else:\n                    blocks.append(counter)\n                    counter = 1\n                    last = k\n            blocks.append(counter)\n            ll = 2\n            ul = max(blocks)\n            while ll <= ul:\n                mid = ll + (ul - ll) // 2\n                tempswaps = 0\n                for a in blocks:\n                    tempswaps += a // (mid + 1)\n                if tempswaps > swaps:\n                    ll = mid + 1\n                elif tempswaps <= swaps:\n                    ul = mid - 1\n            stdout.write(str(ll) + '\\n')\n        elif one:\n            stdout.write(str(1) + '\\n')\nmain()", "t = int(input())\nfor i in range(t):\n    (length, swaps) = map(int, input().split())\n    seq = list(input())\n    one = False\n    temp = 0\n    for j in range(length):\n        if j % 2 == 0:\n            if seq[j] != '1':\n                temp += 1\n        elif seq[j] != '0':\n            temp += 1\n        if temp > swaps:\n            break\n    if temp <= swaps:\n        one = True\n    else:\n        temp = 0\n        for j in range(length):\n            if j % 2 == 0:\n                if seq[j] != '0':\n                    temp += 1\n            elif seq[j] != '1':\n                temp += 1\n            if temp > swaps:\n                break\n        if temp <= swaps:\n            one = True\n    if not one:\n        blocks = []\n        last = seq[0]\n        counter = 1\n        for k in seq[1:]:\n            if k == last:\n                counter += 1\n            else:\n                blocks.append(counter)\n                counter = 1\n                last = k\n        blocks.append(counter)\n        ll = 2\n        ul = max(blocks)\n        while ll <= ul:\n            mid = ll + (ul - ll) // 2\n            tempswaps = 0\n            for a in blocks:\n                tempswaps += a // (mid + 1)\n            if tempswaps > swaps:\n                ll = mid + 1\n            elif tempswaps <= swaps:\n                ul = mid - 1\n        print(ll)\n    elif one:\n        print(1)", "def minswaps(x, y):\n    return x // (y + 1)\nt = int(input())\nfor i in range(t):\n    (length, swaps) = map(int, input().split())\n    seq = list(input())\n    one = False\n    temp = 0\n    for j in range(length):\n        if j % 2 == 0:\n            if seq[j] != '1':\n                temp += 1\n        elif seq[j] != '0':\n            temp += 1\n        if temp > swaps:\n            break\n    if temp <= swaps:\n        one = True\n    else:\n        temp = 0\n        for j in range(length):\n            if j % 2 == 0:\n                if seq[j] != '0':\n                    temp += 1\n            elif seq[j] != '1':\n                temp += 1\n            if temp > swaps:\n                break\n        if temp <= swaps:\n            one = True\n    if not one:\n        blocks = []\n        last = seq[0]\n        counter = 1\n        for k in seq[1:]:\n            if k == last:\n                counter += 1\n            else:\n                blocks.append(counter)\n                counter = 1\n                last = k\n        blocks.append(counter)\n        ll = 2\n        ul = max(blocks)\n        while ll <= ul:\n            mid = ll + (ul - ll) // 2\n            tempswaps = 0\n            for a in blocks:\n                tempswaps += minswaps(a, mid)\n            if tempswaps > swaps:\n                ll = mid + 1\n            elif tempswaps <= swaps:\n                ul = mid - 1\n        print(ll)\n    elif one:\n        print(1)", "def solve(s, n, k):\n    cnt1 = 0\n    cnt2 = 0\n    for i in range(n):\n        if i % 2 == 0:\n            if s[i] == '1':\n                cnt1 += 1\n            else:\n                cnt2 += 1\n        elif s[i] == '0':\n            cnt1 += 1\n        else:\n            cnt2 += 1\n    if k >= min(cnt1, cnt2):\n        print(1)\n        return\n    blocks = []\n    cnt = 1\n    for (idx, bit) in enumerate(s):\n        if idx == n - 1:\n            break\n        if idx < n - 1 and s[idx] != s[idx + 1]:\n            blocks.append(cnt)\n            cnt = 0\n        cnt += 1\n    blocks.append(cnt)\n    low = 2\n    high = n\n    while low < high:\n        L = int((low + high) / 2)\n        flips = 0\n        for x in blocks:\n            flips += int(x / (L + 1))\n        if flips <= k:\n            high = L\n        else:\n            low = L + 1\n    print(low)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = input()\n    solve(s, n, k)", "def solve(s, n, k):\n    cnt1 = 0\n    cnt2 = 0\n    for i in range(n):\n        if i % 2 == 0:\n            if s[i] == '1':\n                cnt1 += 1\n            else:\n                cnt2 += 1\n        elif s[i] == '0':\n            cnt1 += 1\n        else:\n            cnt2 += 1\n    if k >= min(cnt1, cnt2):\n        print(1)\n        return\n    blocks = []\n    cnt = 1\n    for (idx, bit) in enumerate(s):\n        if idx == n - 1:\n            break\n        if idx < n - 1 and s[idx] != s[idx + 1]:\n            blocks.append(cnt)\n            cnt = 0\n        cnt += 1\n    blocks.append(cnt)\n    low = 2\n    high = n\n    while low < high:\n        L = int((low + high) / 2)\n        flips = 0\n        for x in blocks:\n            flips += int(x / (L + 1))\n        if flips <= k:\n            high = L\n        else:\n            low = L + 1\n    print(low)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = input()\n    solve(s, n, k)", "def solve(s, n, k):\n    cnt1 = 0\n    cnt2 = 0\n    for i in range(n):\n        if i % 2 == 0:\n            if s[i] == '1':\n                cnt1 += 1\n            else:\n                cnt2 += 1\n        elif s[i] == '0':\n            cnt1 += 1\n        else:\n            cnt2 += 1\n    if k >= min(cnt1, cnt2):\n        print(1)\n        return\n    blocks = []\n    cnt = 1\n    for (idx, bit) in enumerate(s):\n        if idx == n - 1:\n            break\n        if idx < n - 1 and s[idx] != s[idx + 1]:\n            blocks.append(cnt)\n            cnt = 0\n        cnt += 1\n    blocks.append(cnt)\n    low = 2\n    high = n\n    blockSize = len(blocks)\n    while low < high:\n        L = int((low + high) / 2)\n        flips = 0\n        for x in blocks:\n            flips += int(x / (L + 1))\n        if flips <= k:\n            high = L\n        else:\n            low = L + 1\n    print(low)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = input()\n    solve(s, n, k)", "def solve(s, n, k):\n    cnt1 = 0\n    cnt2 = 0\n    for i in range(n):\n        if i % 2 == 0:\n            if s[i] == '1':\n                cnt1 += 1\n            else:\n                cnt2 += 1\n        elif s[i] == '0':\n            cnt1 += 1\n        else:\n            cnt2 += 1\n    if k >= min(cnt1, cnt2):\n        print(1)\n        return\n    blocks = []\n    cnt = 1\n    for (idx, bit) in enumerate(s):\n        if idx == n - 1:\n            break\n        if idx < n - 1 and s[idx] != s[idx + 1]:\n            blocks.append(cnt)\n            cnt = 0\n        cnt += 1\n    blocks.append(cnt)\n    low = 2\n    high = n\n    blockSize = len(blocks)\n    while low < high:\n        L = int((low + high) / 2)\n        flips = 0\n        for i in range(blockSize):\n            flips += int(blocks[i] / (L + 1))\n        if flips <= k:\n            high = L\n        else:\n            low = L + 1\n    print(low)\nt = int(input())\nwhile t > 0:\n    t -= 1\n    (n, k) = map(int, input().split())\n    s = input()\n    solve(s, n, k)", "def possible(a, mid, k):\n    cnt = 0\n    for i in a:\n        cnt += i // (mid + 1)\n    return cnt <= k\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = []\n    s = list(input())\n    cur = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            a.append(cur)\n            cur = 1\n        else:\n            cur += 1\n    a.append(cur)\n    k = min(k, n)\n    c1 = 0\n    c2 = 0\n    for i in range(n):\n        if int(s[i]) == 0:\n            if i % 2 == 0:\n                c1 += 1\n            else:\n                c2 += 1\n        elif i % 2 == 1:\n            c1 += 1\n        else:\n            c2 += 1\n    if c1 <= k or c2 <= k:\n        print(1)\n        continue\n    low = 2\n    high = n\n    ans = n\n    while low <= high:\n        mid = (low + high) // 2\n        if possible(a, mid, k):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)", "import heapq\nt = int(input())\nfor i in range(t):\n    (n, k) = map(int, input().split())\n    a = input()\n    ch = a[0]\n    q = []\n    len = 1\n    lenc = []\n    lg = 0\n    for j in range(1, n):\n        if a[j] == ch:\n            len += 1\n        else:\n            if len > 1:\n                lenc.append(len)\n                lg += 1\n            len = 1\n            ch = a[j]\n    if len > 1:\n        lenc.append(len)\n        lg += 1\n    lenc.sort()\n    s1 = ''\n    s2 = ''\n    for j in range(n):\n        if j % 2 == 0:\n            s1 += '0'\n            s2 += '1'\n        else:\n            s1 += '1'\n            s2 += '0'\n    f1 = 0\n    f2 = 0\n    for j in range(n):\n        if s1[j] == a[j]:\n            f1 += 1\n        if s2[j] == a[j]:\n            f2 += 1\n    an1 = min(f1, f2)\n    if k >= an1:\n        print(1)\n        continue\n    arr2 = []\n    for j in range(lg):\n        arr2.append(1)\n        heapq.heappush(q, (-lenc[j], j))\n    (m1, m2) = heapq.heappop(q)\n    m1 = abs(m1)\n    f1 = 1\n    heapq.heappush(q, (-m1, m2))\n    while 1:\n        if m1 == 2 or f1 > k:\n            break\n        (lk1, lk2) = heapq.heappop(q)\n        lk = arr2[lk2]\n        n = (lenc[lk2] - lk) / (lk + 1)\n        if n > (lenc[lk2] - lk) // (lk + 1):\n            n += 1\n        nn = int(n)\n        heapq.heappush(q, (-nn, lk2))\n        arr2[lk2] += 1\n        (m1, m2) = heapq.heappop(q)\n        m1 = abs(m1)\n        heapq.heappush(q, (-m1, m2))\n        f1 += 1\n    print(m1)", "from bisect import *\nfrom math import ceil\nfor t in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    a = input()\n    evens = [0, 0]\n    odds = [0, 0]\n    for i in range(0, n, 2):\n        ai = int(a[i])\n        evens[ai] += 1\n    for i in range(1, n, 2):\n        ai = int(a[i])\n        odds[ai] += 1\n    mink = min(evens[1] + odds[0], evens[0] + odds[1])\n    if k >= mink:\n        print(1)\n        continue\n    counts = [0]\n    i = 0\n    while i < n:\n        try:\n            j = a.index('1' if a[i] == '0' else '0', i + 1)\n            counts.append(j - i)\n            i = j\n        except:\n            counts.append(n - i)\n            i = n\n    counts.sort()\n    splits = [(0, 0, 0)]\n    for i in range(k):\n        if counts[-1] >= splits[-1][0]:\n            c = counts.pop()\n            o = c\n            ks = 0\n        else:\n            e = splits.pop()\n            c = e[0]\n            o = e[1]\n            ks = e[2]\n        if c == 2:\n            print(2)\n            break\n        ks += 1\n        e = (ceil((o - ks) / (ks + 1)), o, ks)\n        insort(splits, e)\n    else:\n        print(max(counts[-1], splits[-1][0]))", "for _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split()]\n    s = input()\n    k1 = k2 = 0\n    for i in range(n):\n        if int(s[i]) != i % 2:\n            k1 += 1\n        else:\n            k2 += 1\n    if k >= min(k1, k2):\n        print(1)\n        continue\n    i = 0\n    arr = []\n    while i < n:\n        arr.append(1)\n        while i < n - 1 and s[i] == s[i + 1]:\n            arr[-1] += 1\n            i += 1\n        i += 1\n    t = 0\n    ind = []\n    for i in arr:\n        if i == 2 or i == 1:\n            ind.append(t)\n        t += 1\n    for i in ind[::-1]:\n        arr.pop(i)\n    for i in range(len(arr)):\n        arr[i] = [arr[i], 1]\n    while len(arr) != 0 and k != 0:\n        arr.sort(key=lambda x: x[0] // x[1], reverse=True)\n        curr = arr[0]\n        if curr[0] // (curr[1] + 1) < 3:\n            arr.pop(0)\n        else:\n            curr[1] += 1\n        k -= 1\n    if len(arr) == 0:\n        print(2)\n    else:\n        maxi = -1\n        for i in arr:\n            maxi = max(maxi, i[0] // i[1])\n        print(maxi)", "def read_input():\n    t = int(input())\n    for _ in range(t):\n        global n, l\n        (n, k) = input().strip().split()\n        (n, k) = (int(n), int(k))\n        l = input().strip()\n        lt = []\n        p = 1\n        for i in range(1, n):\n            if l[i] == l[i - 1]:\n                p += 1\n            else:\n                lt.append(p)\n                p = 1\n        lt.append(p)\n        y1 = 0\n        y2 = 0\n        for i in range(len(l)):\n            if i % 2 == 0:\n                y1 += int(l[i]) ^ 0\n                y2 += int(l[i]) ^ 1\n            else:\n                y1 += int(l[i]) ^ 1\n                y2 += int(l[i]) ^ 0\n        y = min(y1, y2)\n        if y <= k:\n            print(1)\n        else:\n            l = max(lt)\n            start = 2\n            end = max(lt)\n            while start <= end:\n                mid = (start + end) // 2\n                z = k\n                from math import ceil\n                for x in lt:\n                    if x > mid:\n                        kct = 1\n                        while True:\n                            dskda = (x - kct) / (kct + 1)\n                            if ceil(dskda) <= mid:\n                                z -= kct\n                                break\n                            else:\n                                kct += 1\n                if z >= 0:\n                    end = mid - 1\n                    l = mid\n                else:\n                    start = mid + 1\n            print(l)\nread_input()", "def reverse_insort(a, x, lo=0, hi=None):\n    if lo < 0:\n        raise ValueError('lo must be non-negative')\n    if hi is None:\n        hi = len(a)\n    try:\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if x[0] > a[mid][0]:\n                hi = mid\n            elif x[0] < a[mid][0]:\n                lo = mid + 1\n            elif x[2] > a[mid][2]:\n                hi = mid\n            else:\n                lo = mid + 1\n    except:\n        a.append(x)\n        a.sort(key=lambda x: (x[0], x[2]), reverse=True)\n        return\n    a.insert(lo, x)\n\ndef get_counts(s, n):\n    counts = []\n    current_count = 0\n    prev = None\n    for i in range(n):\n        if s[i] == prev:\n            current_count += 1\n        else:\n            if current_count > 1:\n                counts.append(current_count)\n            current_count = 1\n        prev = s[i]\n    if current_count > 1:\n        counts.append(current_count)\n    counts.sort(reverse=True)\n    return counts\n\ndef check_for_one(n, k, s):\n    start_with_one = 0\n    start_with_zero = 0\n    for i in range(n):\n        if i % 2 == int(s[i]):\n            start_with_zero += 1\n        else:\n            start_with_one += 1\n    return start_with_zero == 0 or start_with_one == 0 or min(start_with_zero, start_with_one) <= k\nt = int(input().replace(' ', ''))\nwhile t:\n    t -= 1\n    inputs = list(map(int, input().strip().split()))\n    n = inputs[0]\n    k = inputs[1]\n    s = list(input().replace(' ', ''))\n    if k >= n or check_for_one(n, k, s):\n        print(1)\n        continue\n    counts = get_counts(s, n)\n    op_counts = [{0: count, 1: 0, 2: count} for count in counts]\n    if len(op_counts) == 1:\n        print(max(2, op_counts[0][2] // (k + 1)))\n        continue\n    if op_counts[0][0] == 2 or k == 0:\n        print(max(2, op_counts[0][0]))\n        continue\n    for i in range(k):\n        if op_counts[0][0] == 2:\n            break\n        else:\n            op_counts[0][1] += 1\n            op_counts[0][0] = op_counts[0][2] // (op_counts[0][1] + 1)\n        curr_e = op_counts[0]\n        op_counts = op_counts[1:]\n        reverse_insort(op_counts, curr_e)\n    print(max(2, int(op_counts[0][0])))", "def one(A):\n    a = sum((A[i] != i % 2 for i in range(len(A))))\n    b = sum((A[i] != 1 - i % 2 for i in range(len(A))))\n    return min(a, b)\n\ndef calc(A, x):\n    if x == 1:\n        return one(A)\n    flips = streak = 0\n    A = [-1] + A + [-1]\n    for i in range(1, len(A) - 1):\n        if A[i] != A[i - 1]:\n            streak = 1\n        else:\n            streak += 1\n        if streak > x:\n            A[i] = -1\n            flips += 1\n            streak = 1\n    return flips\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    A = list(map(int, list(input().strip())))\n    lo = 1\n    hi = n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        flips = calc(A[:], mid)\n        if flips > k:\n            lo = mid + 1\n        else:\n            hi = mid\n    print(hi)", "t = int(input())\nfor t0 in range(t):\n    s = [int(i) for i in input().strip().split()]\n    (n, k) = (s[0], s[1])\n    a = input().strip()\n    rc = []\n    p = a[0]\n    ct = 1\n    reqd = 0\n    m = 0\n    for i in range(1, n):\n        if a[i] == p:\n            ct += 1\n            if m == 0:\n                reqd += 1\n                m = 1\n            else:\n                m = 0\n        else:\n            rc.append(ct)\n            ct = 1\n            if m == 1:\n                reqd += 1\n            else:\n                m = 0\n            p = a[i]\n    rc.append(ct)\n    l = len(rc)\n    fl = 2\n    if reqd <= k or n - reqd <= k:\n        print(1)\n        continue\n    l = len(rc)\n    bol = [rc[i] for i in range(l)]\n    bul = [0 for i in range(l)]\n    mx = max(bol)\n    if mx == 2:\n        print(2)\n        continue\n    for i in range(k):\n        ind = bol.index(mx)\n        bul[ind] += 1\n        noc = bul[ind] + 1\n        bol[ind] = (rc[ind] - bul[ind]) // noc\n        if (rc[ind] - bul[ind]) % noc != 0:\n            bol[ind] += 1\n        mx = max(bol)\n        if mx == 2 or mx == 1:\n            fl = 0\n            break\n    if fl == 0:\n        print(2)\n    else:\n        print(int(mx))", "def check(mid):\n    count = 0\n    for i in arr:\n        count += i // (mid + 1)\n    return count\n\ndef get(s, n, k):\n    (low, high) = (2, n)\n    while low < high:\n        mid = (low + high) // 2\n        if check(mid) <= k:\n            high = mid\n        else:\n            low = mid + 1\n    return low\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    s = input()\n    (f1, f0) = (1, 0)\n    (tot1, tot0) = (0, 0)\n    for i in range(n):\n        if f1 != int(s[i]):\n            tot0 += 1\n        if f0 != int(s[i]):\n            tot1 += 1\n        (f0, f1) = (f0 ^ 1, f1 ^ 1)\n    if min(tot0, tot1) <= k:\n        print(1)\n        continue\n    (last, arr, count) = (s[0], [], 1)\n    for i in range(1, n):\n        if s[i] == last:\n            count += 1\n        else:\n            last = s[i]\n            arr.append(count)\n            count = 1\n    arr.append(count)\n    print(get(s, n, k))", "import math\nt = int(input())\nfor i in range(t):\n    (n, k) = list(map(int, input().strip().split()))\n    s = input().strip()\n    i = 0\n    a = []\n    (curr, prev, kk, flag) = ('0', '1', 0, 1)\n    for i in range(0, n):\n        if s[i] == curr:\n            kk += 1\n            if kk > k:\n                flag = 0\n                break\n        (curr, prev) = (prev, curr)\n    if flag == 1:\n        print(1)\n        continue\n    (curr, prev, kk, flag) = ('1', '0', 0, 1)\n    for i in range(0, n):\n        if s[i] == curr:\n            kk += 1\n            if kk > k:\n                flag = 0\n                break\n        (curr, prev) = (prev, curr)\n    if flag == 1:\n        print(1)\n        continue\n    i = 0\n    while i < n:\n        cur = s[i]\n        start = i\n        l = 0\n        while i < n and s[i] == cur:\n            i += 1\n            l += 1\n        a.append([l, l, 0])\n    i = 0\n    while i < k:\n        a.sort(key=lambda r: r[1], reverse=True)\n        if a[0][1] == 1:\n            break\n        a[0][2] += 1\n        a[0][1] = math.ceil((a[0][0] - a[0][2]) / (a[0][2] + 1))\n        i += 1\n    a.sort(key=lambda r: r[1], reverse=True)\n    if a[0][1] == 1:\n        print(2)\n    else:\n        print(a[0][1])", "def can(n, s, seg):\n    ret = 0\n    last = s[0]\n    cnt = 0\n    for i in range(n):\n        if last != s[i]:\n            cnt = 1\n            last = s[i]\n        else:\n            cnt += 1\n        if cnt > seg:\n            last ^= 1\n            if seg > 1 and i + 1 < n and (s[i + 1] == last):\n                last ^= 1\n            ret += 1\n            cnt = 1\n    ret2 = ret\n    ret = 1\n    last = s[0] ^ 1\n    cnt = 1\n    for i in range(1, n):\n        if last != s[i]:\n            cnt = 1\n            last = s[i]\n        else:\n            cnt += 1\n        if cnt > seg:\n            last ^= 1\n            if seg > 1 and i + 1 < n and (s[i + 1] == last):\n                last ^= 1\n            ret += 1\n            cnt = 1\n    return min(ret, ret2)\n\ndef main():\n    for _ in range(int(input())):\n        (n, k) = map(int, input().split())\n        s = [int(c) for c in input().strip()]\n        l = 1\n        r = n\n        while l < r:\n            mid = (l + r) // 2\n            if can(n, s, mid) <= k:\n                r = mid\n            else:\n                l = mid + 1\n        print(l)\nmain()", "def is_valid(arr, k, lim):\n    cnt = 0\n    curr = arr[0]\n    for x in arr:\n        if x != curr:\n            req = cnt // (lim + 1)\n            if req > k:\n                return False\n            else:\n                k -= req\n                cnt = 0\n            curr = x\n        cnt += 1\n    req = cnt // (lim + 1)\n    if req > k:\n        return False\n    else:\n        k -= req\n    return True\nfor inp in range(int(input())):\n    (N, K) = [int(x) for x in input().strip().split()]\n    arr = input().strip()\n    ans = N\n    (low, high) = (2, N)\n    while low <= high:\n        mid = (low + high) // 2\n        if is_valid(arr, K, mid):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    if ans == 2:\n        odd = arr[::2]\n        even = arr[1::2]\n        mink = min(odd.count('1') + even.count('0'), odd.count('0') + even.count('1'))\n        if mink <= K:\n            ans = 1\n    print(ans)", "def possible(a, mid, k):\n    cnt = 0\n    for i in a:\n        cnt += i // (mid + 1)\n    return cnt <= k\nfor _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    a = []\n    s = list(input())\n    cur = 1\n    for i in range(1, n):\n        if s[i] != s[i - 1]:\n            a.append(cur)\n            cur = 1\n        else:\n            cur += 1\n    a.append(cur)\n    k = min(k, n)\n    c1 = 0\n    c2 = 0\n    for i in range(n):\n        if int(s[i]) == 0:\n            if i % 2 == 0:\n                c1 += 1\n            else:\n                c2 += 1\n        elif i % 2 == 1:\n            c1 += 1\n        else:\n            c2 += 1\n    if c1 <= k or c2 <= k:\n        print(1)\n        continue\n    low = 2\n    high = n\n    ans = n\n    while low <= high:\n        mid = (low + high) // 2\n        if possible(a, mid, k):\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    print(ans)"]