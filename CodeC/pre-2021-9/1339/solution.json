["from collections import *\nfrom bisect import *\nfrom math import *\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nwhile t:\n    t -= 1\n    (h, q) = map(int, input().split())\n    r = []\n    for i in range(q):\n        (tt, x, a) = map(int, input().split())\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(q)]\n    for i in range(q):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        if r[i][0] == 0:\n            typ = 0\n        else:\n            typ = 1\n        c = 0\n        for j in range(i + 1, q):\n            if typ == 0:\n                try:\n                    cur = (y - r[j][2]) / (x - r[j][1])\n                except:\n                    c += 1\n                    fr[r[j][3]] += 1\n                    continue\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            else:\n                try:\n                    cur = (y - r[j][2]) / (x - r[j][1])\n                except:\n                    c += 1\n                    fr[r[j][3]] += 1\n                    continue\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    print(*fr)", "from collections import *\nfrom bisect import *\nfrom math import *\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nwhile t:\n    t -= 1\n    (h, q) = map(int, input().split())\n    r = []\n    for i in range(q):\n        (tt, x, a) = map(int, input().split())\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(q)]\n    for i in range(q):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        if r[i][0] == 0:\n            typ = 0\n        else:\n            typ = 1\n        c = 0\n        for j in range(i + 1, q):\n            if typ == 0:\n                try:\n                    cur = (y - r[j][2]) / (x - r[j][1])\n                except:\n                    c += 1\n                    fr[r[j][3]] += 1\n                    continue\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            else:\n                try:\n                    cur = (y - r[j][2]) / (x - r[j][1])\n                except:\n                    c += 1\n                    fr[r[j][3]] += 1\n                    continue\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    print(*fr)", "from sys import stdin\nimport sys\nfor _ in range(int(stdin.readline())):\n    (h, n) = map(int, stdin.readline().split())\n    count = [0] * n\n    l = []\n    for i in range(n):\n        (ti, xi, yi) = map(int, stdin.readline().split())\n        l.append([xi, yi, ti, i])\n    l = sorted(l, key=lambda x: x[0])\n    for i in range(n - 1):\n        upper = sys.maxsize\n        lower = -upper\n        for j in range(i + 1, n):\n            if l[i][0] == l[j][0]:\n                count[l[j][3]] += 1\n                count[l[i][3]] += 1\n                continue\n            slope = (l[i][1] - l[j][1]) / (l[i][0] - l[j][0])\n            if slope > lower and slope < upper:\n                count[l[i][3]] += 1\n                count[l[j][3]] += 1\n            if l[j][2] == 0:\n                lower = max(slope, lower)\n            elif l[j][2] == 1:\n                upper = min(slope, upper)\n            if upper < lower:\n                break\n    for i in count:\n        print(i, end=' ')\n    print('')", "from sys import stdin\nfor _ in range(int(stdin.readline())):\n    (h, n) = map(int, stdin.readline().split())\n    count = [0] * n\n    l = []\n    for i in range(n):\n        (ti, xi, yi) = map(int, stdin.readline().split())\n        l.append([xi, yi, ti, i])\n    l = sorted(l, key=lambda x: x[0])\n    for i in range(n - 1):\n        upper = 1000000001\n        lower = -1000000001\n        for j in range(i + 1, n):\n            if l[i][0] == l[j][0]:\n                count[l[j][3]] += 1\n                count[l[i][3]] += 1\n                continue\n            slope = (l[i][1] - l[j][1]) / (l[i][0] - l[j][0])\n            if slope > lower and slope < upper:\n                count[l[i][3]] += 1\n                count[l[j][3]] += 1\n            if l[j][2] == 0:\n                lower = max(slope, lower)\n            elif l[j][2] == 1:\n                upper = min(slope, upper)\n            if upper < lower:\n                break\n    for i in count:\n        print(i, end=' ')\n    print('')", "from sys import stdin\nimport sys\nfor _ in range(int(stdin.readline())):\n    (h, n) = map(int, stdin.readline().split())\n    count = [0] * n\n    l = []\n    for i in range(n):\n        (ti, xi, yi) = map(int, stdin.readline().split())\n        l.append([xi, yi, ti, i])\n    l = sorted(l, key=lambda x: x[0])\n    for i in range(n - 1):\n        upper = sys.maxsize\n        lower = -upper\n        for j in range(i + 1, n):\n            if l[i][0] == l[j][0]:\n                count[l[j][3]] += 1\n                count[l[i][3]] += 1\n                continue\n            slope = (l[i][1] - l[j][1]) / (l[i][0] - l[j][0])\n            if slope > lower and slope < upper:\n                count[l[i][3]] += 1\n                count[l[j][3]] += 1\n            if l[j][2] == 0:\n                lower = max(slope, lower)\n            elif l[j][2] == 1:\n                upper = min(slope, upper)\n            if upper < lower:\n                break\n    for i in count:\n        print(i, end=' ')\n    print('')", "from sys import stdin\nimport sys\nfor _ in range(int(stdin.readline())):\n    (h, n) = map(int, stdin.readline().split())\n    count = [0] * n\n    l = []\n    for i in range(n):\n        (ti, xi, yi) = map(int, stdin.readline().split())\n        l.append([xi, yi, ti, i])\n    l = sorted(l, key=lambda x: x[0])\n    for i in range(n - 1):\n        upper = sys.maxsize\n        lower = -upper\n        for j in range(i + 1, n):\n            if l[i][0] == l[j][0]:\n                count[l[j][3]] += 1\n                count[l[i][3]] += 1\n                continue\n            slope = (l[i][1] - l[j][1]) / (l[i][0] - l[j][0])\n            if slope > lower and slope < upper:\n                count[l[i][3]] += 1\n                count[l[j][3]] += 1\n            if l[j][2] == 0:\n                lower = max(slope, lower)\n            elif l[j][2] == 1:\n                upper = min(slope, upper)\n            if upper < lower:\n                break\n    print(*count)", "from sys import stdin\nimport sys\nfor _ in range(int(stdin.readline())):\n    (h, n) = map(int, stdin.readline().split())\n    count = [0] * n\n    l = []\n    for i in range(n):\n        (ti, xi, yi) = map(int, stdin.readline().split())\n        l.append([xi, yi, ti, i])\n    l = sorted(l, key=lambda x: x[0])\n    for i in range(n - 1):\n        upper = sys.maxsize\n        lower = -upper\n        for j in range(i + 1, n):\n            if l[i][0] == l[j][0]:\n                count[l[j][3]] += 1\n                count[l[i][3]] += 1\n                continue\n            slope = (l[i][1] - l[j][1]) / (l[i][0] - l[j][0])\n            if slope > lower and slope < upper:\n                count[l[i][3]] += 1\n                count[l[j][3]] += 1\n            if l[j][2] == 0:\n                lower = max(slope, lower)\n            elif l[j][2] == 1:\n                upper = min(slope, upper)\n            if upper < lower:\n                break\n    print(*count)", "from sys import *\nimport collections\nimport math\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = list(map(int, stdin.readline().split(' ')))\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = list(map(int, stdin.readline().split(' ')))\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n, 1):\n            xj = l[j][0]\n            pj = l[j][3]\n            if xj == xi:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            aj = l[j][1]\n            t = l[j][2]\n            s = (aj - ai) / (xj - xi)\n            if s > down and s < up:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    for h in ans:\n        print(h, end=' ')\n    print(' ')", "from sys import *\nimport collections\nimport math\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = list(map(int, stdin.readline().split(' ')))\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = list(map(int, stdin.readline().split(' ')))\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n, 1):\n            xj = l[j][0]\n            pj = l[j][3]\n            if xj == xi:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            aj = l[j][1]\n            t = l[j][2]\n            s = (aj - ai) / (xj - xi)\n            if s > down and s < up:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    for h in ans:\n        print(h, end=' ')\n    print(' ')", "from sys import *\nimport math\nimport collections\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = map(int, stdin.readline().split())\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = map(int, stdin.readline().split())\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        mn = -math.inf\n        mx = math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        fi = l[i][3]\n        for j in range(i + 1, n):\n            xj = l[j][0]\n            fj = l[j][3]\n            aj = l[j][1]\n            t = l[j][2]\n            if xi == xj:\n                ans[fi] += 1\n                ans[fj] += 1\n                continue\n            slope = (aj - ai) / (xj - xi)\n            if slope > mn and slope < mx:\n                ans[fj] += 1\n                ans[fi] += 1\n            if t == 0:\n                mn = max(mn, slope)\n            else:\n                mx = min(mx, slope)\n            if mx <= mn:\n                break\n    for z in ans:\n        print(z, end=' ')\n    print()", "t = int(input())\nfor i in range(t):\n    (h, n) = [int(i) for i in input().split()]\n    ti = []\n    for i in range(n):\n        (a, b, c) = [int(i) for i in input().split()]\n        ti.append((b, c, a, i))\n    ti.sort()\n    l = [0] * n\n    for i in range(n):\n        (max_0, min_1) = (float('-inf'), float('inf'))\n        for j in range(i + 1, n):\n            if ti[j][0] == ti[i][0]:\n                l[ti[i][3]] += 1\n                l[ti[j][3]] += 1\n                continue\n            m = (ti[j][1] - ti[i][1]) / (ti[j][0] - ti[i][0])\n            if max_0 < m < min_1:\n                l[ti[i][3]] += 1\n                l[ti[j][3]] += 1\n            if ti[j][2] == 1:\n                min_1 = min(m, min_1)\n            else:\n                max_0 = max(m, max_0)\n            if max_0 >= min_1:\n                break\n    print(' '.join([str(i) for i in l]))", "t = int(input())\nfor i in range(t):\n    (h, n) = [int(i) for i in input().split()]\n    ti = []\n    for i in range(n):\n        (a, b, c) = [int(i) for i in input().split()]\n        ti.append((b, c, a, i))\n    ti.sort()\n    l = [0] * n\n    for i in range(n):\n        (max_0, min_1) = (float('-inf'), float('inf'))\n        for j in range(i + 1, n):\n            if ti[j][0] == ti[i][0]:\n                l[ti[i][3]] += 1\n                l[ti[j][3]] += 1\n                continue\n            m = (ti[j][1] - ti[i][1]) / (ti[j][0] - ti[i][0])\n            if max_0 < m < min_1:\n                l[ti[i][3]] += 1\n                l[ti[j][3]] += 1\n            if ti[j][2] == 1:\n                min_1 = min(m, min_1)\n            if ti[j][2] == 0:\n                max_0 = max(m, max_0)\n            if max_0 >= min_1:\n                break\n    print(' '.join([str(i) for i in l]))", "from sys import *\nimport collections\nimport math\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = list(map(int, stdin.readline().split(' ')))\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = list(map(int, stdin.readline().split(' ')))\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n, 1):\n            xj = l[j][0]\n            pj = l[j][3]\n            if xj == xi:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            aj = l[j][1]\n            t = l[j][2]\n            s = (aj - ai) / (xj - xi)\n            if s > down and s < up:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    for h in ans:\n        print(h, end=' ')\n    print(' ')", "from sys import *\nimport collections\nimport math\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = list(map(int, stdin.readline().split(' ')))\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = list(map(int, stdin.readline().split(' ')))\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n, 1):\n            xj = l[j][0]\n            pj = l[j][3]\n            if xj == xi:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            aj = l[j][1]\n            t = l[j][2]\n            s = (aj - ai) / (xj - xi)\n            if s > down and s < up:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    for h in ans:\n        print(h, end=' ')\n    print(' ')", "from sys import *\nimport math\ntry:\n    t = int(stdin.readline())\n    while t:\n        t -= 1\n        (h, n) = map(int, stdin.readline().split())\n        tower = []\n        result = [0] * n\n        for i in range(n):\n            arr = list(map(int, stdin.readline().split()))\n            arr.append(i)\n            tower.append(arr)\n        tower.sort(key=lambda pair: pair[1])\n        for i in range(n):\n            up = math.inf\n            down = -math.inf\n            for j in range(i + 1, n):\n                if tower[i][1] == tower[j][1]:\n                    result[tower[i][3]] += 1\n                    result[tower[j][3]] += 1\n                    continue\n                slope = (tower[j][2] - tower[i][2]) / (tower[j][1] - tower[i][1])\n                if slope < up and slope > down:\n                    result[tower[i][3]] += 1\n                    result[tower[j][3]] += 1\n                if tower[j][0] == 1:\n                    up = min(up, slope)\n                else:\n                    down = max(slope, down)\n                if up <= down:\n                    break\n        for i in range(len(result)):\n            print(result[i], end=' ')\n        print(' ')\nexcept:\n    pass", "from sys import *\nimport collections\nimport math\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = list(map(int, stdin.readline().split(' ')))\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = list(map(int, stdin.readline().split(' ')))\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n, 1):\n            xj = l[j][0]\n            pj = l[j][3]\n            if xj == xi:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            aj = l[j][1]\n            t = l[j][2]\n            s = (aj - ai) / (xj - xi)\n            if s > down and s < up:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    for h in ans:\n        print(h, end=' ')\n    print(' ')", "import math\nfor _ in range(int(input())):\n    (h, n) = map(int, input().split())\n    l = []\n    ans = [0] * n\n    for i in range(n):\n        (t, x, a) = map(int, input().split())\n        l.append([x, a, t, i])\n    l.sort()\n    for i in range(n):\n        mx = math.inf\n        mn = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n):\n            xj = l[j][0]\n            pj = l[j][3]\n            aj = l[j][1]\n            t = l[j][2]\n            if xi == xj:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            slope = (aj - ai) / (xj - xi)\n            if slope > mn and slope < mx:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                mx = min(mx, slope)\n            else:\n                mn = max(mn, slope)\n            if mx <= mn:\n                break\n    print(*ans)", "from math import inf\n\ndef check(greater, lesser):\n    if lesser == -inf:\n        return True\n    if greater == inf:\n        return True\n    return greater[0] * lesser[1] > lesser[0] * greater[1]\ntc = int(input())\nwhile tc > 0:\n    (h, n) = map(int, input().split())\n    points = []\n    for i in range(n):\n        (t, x, a) = map(int, input().split())\n        points.append((x, a, t, i))\n    points.sort()\n    ans = [0 for _ in range(n)]\n    for i in range(n):\n        min_up = inf\n        max_down = -inf\n        for j in range(i + 1, n):\n            if points[j][0] == points[i][0]:\n                ans[points[i][3]] += 1\n                ans[points[j][3]] += 1\n                continue\n            cur_slope = (points[j][1] - points[i][1], points[j][0] - points[i][0])\n            cur_max = check(cur_slope, max_down)\n            cur_min = check(min_up, cur_slope)\n            if cur_max and cur_min:\n                ans[points[i][3]] += 1\n                ans[points[j][3]] += 1\n            if not points[j][2]:\n                if cur_max:\n                    max_down = cur_slope\n            elif cur_min:\n                min_up = cur_slope\n            if max_down != -inf and min_up != inf and check(max_down, min_up):\n                break\n    print(*ans)\n    tc -= 1", "from math import inf\ntc = int(input())\nwhile tc > 0:\n    (h, n) = map(int, input().split())\n    points = []\n    for i in range(n):\n        (t, x, a) = map(int, input().split())\n        points.append((x, a, t, i))\n    points.sort()\n    ans = [0 for _ in range(n)]\n    for i in range(n):\n        min_up = inf\n        max_down = -inf\n        cur_x = points[i][0]\n        cur_y = points[i][1]\n        for j in range(i + 1, n):\n            if cur_x == points[j][0]:\n                ans[points[i][3]] += 1\n                ans[points[j][3]] += 1\n                continue\n            cur_slope = (points[j][1] - cur_y) / (points[j][0] - cur_x)\n            cur_min = True if cur_slope < min_up else False\n            cur_max = True if cur_slope > max_down else False\n            if cur_max and cur_min:\n                ans[points[i][3]] += 1\n                ans[points[j][3]] += 1\n            if not points[j][2]:\n                max_down = max(cur_slope, max_down)\n            else:\n                min_up = min(cur_slope, min_up)\n            if min_up <= max_down:\n                break\n    print(*ans)\n    tc -= 1", "import math\nt = int(input())\nfor _ in range(t):\n    (h, n) = map(int, input().split())\n    ans = [0] * n\n    l = []\n    for __ in range(n):\n        (t, x, a) = map(int, input().split())\n        l.append((x, a, t, __))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        curr_x = l[i][0]\n        curr_height = l[i][1]\n        curr_tower_no = l[i][3]\n        for j in range(i + 1, n):\n            next_x = l[j][0]\n            next_height = l[j][1]\n            next_tower_no = l[j][3]\n            next_tow_type = l[j][2]\n            if curr_x == next_x:\n                ans[curr_tower_no] += 1\n                ans[next_tower_no] += 1\n                continue\n            s = (next_height - curr_height) / (next_x - curr_x)\n            if s > down and s < up:\n                ans[curr_tower_no] += 1\n                ans[next_tower_no] += 1\n            if next_tow_type == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    print(*ans)", "import math\nt = int(input())\nfor _ in range(t):\n    (h, n) = map(int, input().split())\n    ans = [0] * n\n    l = []\n    for __ in range(n):\n        (t, x, a) = map(int, input().split())\n        l.append((x, a, t, __))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        curr_x = l[i][0]\n        curr_height = l[i][1]\n        curr_tower_no = l[i][3]\n        for j in range(i + 1, n):\n            next_x = l[j][0]\n            next_height = l[j][1]\n            next_tower_no = l[j][3]\n            next_tow_type = l[j][2]\n            if curr_x == next_x:\n                ans[curr_tower_no] += 1\n                ans[next_tower_no] += 1\n                continue\n            s = (next_height - curr_height) / (next_x - curr_x)\n            if s > down and s < up:\n                ans[curr_tower_no] += 1\n                ans[next_tower_no] += 1\n            if next_tow_type == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    print(*ans)", "import math\n\ndef get_answer(ans, towers):\n    N = len(towers)\n    for i in range(N - 1):\n        curr_x = towers[i][1]\n        curr_a = towers[i][2]\n        idx1 = towers[i][3]\n        up = math.inf\n        down = -math.inf\n        for j in range(i + 1, N):\n            x = towers[j][1]\n            a = towers[j][2]\n            typ = towers[j][0]\n            idx2 = towers[j][3]\n            if curr_x == x:\n                ans[idx1] += 1\n                ans[idx2] += 1\n                continue\n            s = (a - curr_a) / (x - curr_x)\n            if s < up and s > down:\n                ans[idx1] += 1\n                ans[idx2] += 1\n            if typ == 0:\n                if s > down:\n                    down = s\n            elif typ == 1:\n                if s < up:\n                    up = s\n            if up <= down:\n                break\nt = int(input())\nwhile t > 0:\n    str = input().split(' ')\n    (H, N) = (int(str[0]), int(str[1]))\n    towers = []\n    for i in range(N):\n        str1 = input().split(' ')\n        (typ, x, a) = (int(str1[0]), int(str1[1]), int(str1[2]))\n        towers.append((typ, x, a, i))\n    towers.sort(key=lambda x: x[1])\n    ans = [0] * N\n    get_answer(ans, towers)\n    for i in ans:\n        print(i, end=' ')\n    print()\n    t -= 1", "ipnl = lambda n: [int(input()) for _ in range(n)]\ninp = lambda : int(input())\nip = lambda : [int(w) for w in input().split()]\nmp = lambda : map(int, input().split())\nfor _ in range(int(input())):\n    (h, n) = mp()\n    tow = []\n    for i in range(n):\n        t = ip()\n        t = t + [i]\n        tow.append(t)\n    tow.sort(key=lambda i: i[1])\n    ans = [0 for i in range(n)]\n    for i in range(n - 1):\n        up = float('inf')\n        dn = float('-inf')\n        (t, x, y, i1) = tow[i]\n        for j in range(i + 1, n):\n            (tn, xn, yn, i2) = tow[j]\n            if x == xn:\n                ans[i1] += 1\n                ans[i2] += 1\n                continue\n            slope = (yn - y) / (xn - x)\n            if dn < slope and slope < up:\n                ans[i1] += 1\n                ans[i2] += 1\n            if tn == 0:\n                dn = max(dn, slope)\n            elif tn == 1:\n                up = min(up, slope)\n            if up <= dn:\n                break\n    print(*ans)", "from sys import *\nimport collections\nimport math\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = list(map(int, stdin.readline().split(' ')))\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = list(map(int, stdin.readline().split(' ')))\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n, 1):\n            xj = l[j][0]\n            pj = l[j][3]\n            if xj == xi:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            aj = l[j][1]\n            t = l[j][2]\n            s = (aj - ai) / (xj - xi)\n            if s > down and s < up:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    for h in ans:\n        print(h, end=' ')\n    print(' ')", "from sys import *\nimport collections\nimport math\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = list(map(int, stdin.readline().split(' ')))\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = list(map(int, stdin.readline().split(' ')))\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n, 1):\n            xj = l[j][0]\n            pj = l[j][3]\n            if xj == xi:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            aj = l[j][1]\n            t = l[j][2]\n            s = (aj - ai) / (xj - xi)\n            if s > down and s < up:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    for h in ans:\n        print(h, end=' ')\n    print(' ')", "from collections import *\nfrom bisect import *\nfrom math import *\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nwhile t:\n    t -= 1\n    (h, q) = map(int, input().split())\n    r = []\n    for i in range(q):\n        (tt, x, a) = map(int, input().split())\n        r.append([tt, x, a, i])\n    r.sort(key=lambda x: x[1])\n    fr = [0 for i in range(q)]\n    for i in range(q):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][1], r[i][2])\n        if r[i][0] == 0:\n            typ = 0\n        else:\n            typ = 1\n        c = 0\n        for j in range(i + 1, q):\n            if typ == 0:\n                try:\n                    cur = (y - r[j][2]) / (x - r[j][1])\n                except:\n                    c += 1\n                    fr[r[j][3]] += 1\n                    continue\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            else:\n                try:\n                    cur = (y - r[j][2]) / (x - r[j][1])\n                except:\n                    c += 1\n                    fr[r[j][3]] += 1\n                    continue\n                if r[j][0] == 1:\n                    if slope1 > cur and cur > slope2:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope1 = min(cur, slope1)\n                else:\n                    if slope2 < cur and cur < slope1:\n                        c += 1\n                        fr[r[j][3]] += 1\n                    slope2 = max(cur, slope2)\n            if slope2 >= slope1:\n                break\n        fr[r[i][3]] += c\n    print(*fr)", "from collections import *\nfrom bisect import *\nfrom math import *\nimport sys\ninput = sys.stdin.readline\nt = int(input())\nwhile t:\n    t -= 1\n    (h, q) = map(int, input().split())\n    r = []\n    for i in range(q):\n        (tt, x, a) = map(int, input().split())\n        r.append([x, a, tt, i])\n    r.sort()\n    fr = [0 for i in range(q)]\n    for i in range(q):\n        slope1 = float('inf')\n        slope2 = -float('inf')\n        (x, y) = (r[i][0], r[i][1])\n        for j in range(i + 1, q):\n            if x == r[j][0]:\n                fr[r[j][3]] += 1\n                fr[r[i][3]] += 1\n                continue\n            cur = (y - r[j][1]) / (x - r[j][0])\n            if cur > slope2 and cur < slope1:\n                fr[r[j][3]] += 1\n                fr[r[i][3]] += 1\n            if r[j][2] == 0:\n                slope2 = max(slope2, cur)\n            else:\n                slope1 = min(slope1, cur)\n            if slope2 >= slope1:\n                break\n    print(*fr)", "import math\nfor k in range(int(input())):\n    (height, num) = map(int, input().split())\n    temp = []\n    tcount = num * [0]\n    for i in range(num):\n        (stat, x, a) = map(int, input().split())\n        temp.append([x, a, stat, i])\n    temp.sort()\n    for i in range(num):\n        ulimit = math.inf\n        dlimit = -math.inf\n        xi = temp[i][0]\n        ai = temp[i][1]\n        for j in range(i + 1, num):\n            xj = temp[j][0]\n            aj = temp[j][1]\n            if xi - xj == 0:\n                tcount[temp[i][3]] += 1\n                tcount[temp[j][3]] += 1\n                continue\n            tan = (aj - ai) / (xj - xi)\n            if tan > dlimit and tan < ulimit:\n                tcount[temp[i][3]] += 1\n                tcount[temp[j][3]] += 1\n            if temp[j][2] == 0:\n                dlimit = max(dlimit, tan)\n            else:\n                ulimit = min(ulimit, tan)\n            if dlimit >= ulimit:\n                break\n    ans = ' '.join((str(x) for x in tcount))\n    print(ans)", "from sys import *\nimport collections\nimport math\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = list(map(int, stdin.readline().split(' ')))\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = list(map(int, stdin.readline().split(' ')))\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n, 1):\n            xj = l[j][0]\n            pj = l[j][3]\n            if xj == xi:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            aj = l[j][1]\n            t = l[j][2]\n            s = (aj - ai) / (xj - xi)\n            if s > down and s < up:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    for h in ans:\n        print(h, end=' ')\n    print(' ')", "from sys import *\nimport collections\nimport math\nt = int(stdin.readline())\nfor _ in range(t):\n    (h, n) = list(map(int, stdin.readline().split(' ')))\n    ans = [0] * n\n    l = []\n    for i in range(n):\n        (t, x, a) = list(map(int, stdin.readline().split(' ')))\n        l.append((x, a, t, i))\n    l.sort()\n    for i in range(n):\n        up = math.inf\n        down = -math.inf\n        xi = l[i][0]\n        ai = l[i][1]\n        pi = l[i][3]\n        for j in range(i + 1, n, 1):\n            xj = l[j][0]\n            pj = l[j][3]\n            if xj == xi:\n                ans[pi] += 1\n                ans[pj] += 1\n                continue\n            aj = l[j][1]\n            t = l[j][2]\n            s = (aj - ai) / (xj - xi)\n            if s > down and s < up:\n                ans[pi] += 1\n                ans[pj] += 1\n            if t == 1:\n                up = min(up, s)\n            else:\n                down = max(down, s)\n            if up <= down:\n                break\n    for h in ans:\n        print(h, end=' ')\n    print(' ')"]