["from collections import deque\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(1000000)\nfor _ in range(int(input())):\n    (N, K) = list(map(int, input().split()))\n    childnodes = defaultdict(lambda : [])\n    for i in range(N - 1):\n        (u, v) = list(map(int, input().split()))\n        childnodes[u - 1].append(v - 1)\n        childnodes[v - 1].append(u - 1)\n    arr = [0] * N\n\n    def dfs(node, arr, prev, childnodes):\n        if node not in childnodes:\n            arr[node] = 1\n            return 1\n        mx = 0\n        for i in childnodes[node]:\n            if i != prev:\n                mx = max(dfs(i, arr, node, childnodes), mx)\n        arr[node] = mx + 1\n        return mx + 1\n    try:\n        dfs(0, arr, 0, childnodes)\n    except:\n        pass\n    ans = [0] * (N + 1)\n    for i in range(N):\n        try:\n            ans[arr[i]] += 1\n        except:\n            pass\n    for i in range(1, len(ans)):\n        ans[i] = ans[i] + ans[i - 1]\n    print(ans[K])", "from collections import deque\nfrom collections import defaultdict\nimport sys\nsys.setrecursionlimit(1000000)\nfor _ in range(int(input())):\n    (N, K) = list(map(int, input().split()))\n    childnodes = defaultdict(lambda : [])\n    for i in range(N - 1):\n        (u, v) = list(map(int, input().split()))\n        childnodes[u - 1].append(v - 1)\n        childnodes[v - 1].append(u - 1)\n    arr = [0] * N\n\n    def dfs(node, arr, prev, childnodes):\n        if node not in childnodes:\n            arr[node] = 1\n            return 1\n        mx = 0\n        for i in childnodes[node]:\n            if i != prev:\n                mx = max(dfs(i, arr, node, childnodes), mx)\n        arr[node] = mx + 1\n        return mx + 1\n    try:\n        dfs(0, arr, 0, childnodes)\n    except:\n        pass\n    ans = [0] * (N + 1)\n    for i in range(N):\n        try:\n            ans[arr[i]] += 1\n        except:\n            pass\n    for i in range(1, len(ans)):\n        ans[i] = ans[i] + ans[i - 1]\n    print(ans[K])", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(2 * 10 ** 5)\nfrom collections import deque\n\ndef dfs(p, prev):\n    parent[p] = prev\n    for i in child[p]:\n        if i == prev:\n            continue\n        deg[p] += 1\n        dfs(i, p)\n\ndef answer():\n    q = deque([])\n    for p in range(1, n + 1):\n        if deg[p] == 0:\n            q.append([p, 1])\n    ans = 0\n    while len(q):\n        (p, count) = q.popleft()\n        ans += 1\n        if count == k:\n            continue\n        if parent[p] == -1:\n            continue\n        deg[parent[p]] -= 1\n        if deg[parent[p]]:\n            continue\n        q.append([parent[p], count + 1])\n    return ans\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    child = [[] for i in range(n + 1)]\n    deg = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    parent = [-1 for i in range(n + 1)]\n    dfs(1, -1)\n    print(answer())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(2 * 10 ** 5)\nfrom collections import deque\n\ndef dfs(p, prev):\n    parent[p] = prev\n    for i in child[p]:\n        if i == prev:\n            continue\n        deg[p] += 1\n        dfs(i, p)\n\ndef answer():\n    q = deque([])\n    for p in range(1, n + 1):\n        if deg[p] == 0:\n            q.append([p, 1])\n    ans = 0\n    while len(q):\n        (p, count) = q.popleft()\n        ans += 1\n        if count == k:\n            continue\n        if parent[p] == -1:\n            continue\n        deg[parent[p]] -= 1\n        if deg[parent[p]]:\n            continue\n        q.append([parent[p], count + 1])\n    return ans\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    child = [[] for i in range(n + 1)]\n    deg = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    parent = [-1 for i in range(n + 1)]\n    dfs(1, -1)\n    print(answer())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(2 * 10 ** 5)\nfrom collections import deque\n\ndef dfs(p, prev):\n    parent[p] = prev\n    for i in child[p]:\n        if i == prev:\n            continue\n        deg[p] += 1\n        dfs(i, p)\n\ndef answer():\n    q = deque([])\n    for p in range(1, n + 1):\n        if deg[p] == 0:\n            q.append([p, 1])\n    ans = 0\n    while len(q):\n        (p, count) = q.popleft()\n        ans += 1\n        if count == k:\n            continue\n        if parent[p] == -1:\n            continue\n        deg[parent[p]] -= 1\n        if deg[parent[p]]:\n            continue\n        q.append([parent[p], count + 1])\n    return ans\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    child = [[] for i in range(n + 1)]\n    deg = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    parent = [-1 for i in range(n + 1)]\n    dfs(1, -1)\n    print(answer())", "from sys import stdin, setrecursionlimit\ninput = stdin.readline\nsetrecursionlimit(2 * 10 ** 5)\nfrom collections import deque\n\ndef dfs(p, prev):\n    parent[p] = prev\n    for i in child[p]:\n        if i == prev:\n            continue\n        deg[p] += 1\n        dfs(i, p)\n\ndef answer():\n    q = deque([])\n    for p in range(1, n + 1):\n        if deg[p] == 0:\n            q.append([p, 1])\n    ans = 0\n    while len(q):\n        (p, count) = q.popleft()\n        ans += 1\n        if count == k:\n            continue\n        if parent[p] == -1:\n            continue\n        deg[parent[p]] -= 1\n        if deg[parent[p]]:\n            continue\n        q.append([parent[p], count + 1])\n    return ans\nfor T in range(int(input())):\n    (n, k) = map(int, input().split())\n    child = [[] for i in range(n + 1)]\n    deg = [0 for i in range(n + 1)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        child[u].append(v)\n        child[v].append(u)\n    parent = [-1 for i in range(n + 1)]\n    dfs(1, -1)\n    print(answer())", "def ii():\n    a = int(input())\n    return a\n\ndef ai():\n    a = list(map(int, input().split()))\n    return a\n\ndef mi():\n    a = map(int, input().split())\n    return a\nimport sys\nsys.setrecursionlimit(10 ** 7)\n\ndef dfs(u):\n    visited[u] = True\n    m = 0\n    for i in range(len(g[u])):\n        v = g[u][i]\n        if visited[v] == False:\n            depth[v] = dfs(v)\n            m = max(m, depth[v])\n    return m + 1\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    depth = [0 for i in range(n)]\n    visited = [False for i in range(n)]\n    depth[0] = dfs(0)\n    c = 0\n    for i in range(n):\n        if depth[i] <= k:\n            c += 1\n    print(c)", "import sys\nsys.setrecursionlimit(1000000)\nt = int(input())\nwhile t:\n    (n, k) = input().split()\n    n = int(n)\n    k = int(k)\n    adj = []\n    for _ in range(n):\n        adj.append([])\n    dp = [0] * n\n\n    def dfs(u, par):\n        for v in adj[u]:\n            if v == par:\n                continue\n            dfs(v, u)\n            dp[u] = max(dp[u], dp[v])\n        dp[u] += 1\n    for _ in range(n - 1):\n        (a, b) = input().split()\n        a = int(a)\n        b = int(b)\n        a -= 1\n        b -= 1\n        adj[a].append(b)\n        adj[b].append(a)\n    dfs(0, 0)\n    ans = 0\n    for i in dp:\n        ans += i <= k\n    print(ans)\n    t -= 1", "import sys\nsys.setrecursionlimit(1000000)\nfrom collections import defaultdict\n\ndef dfs(root, d, levels):\n    t = 0\n    for j in d[root]:\n        t = max(t, dfs(j, d, levels))\n    levels[t] += 1\n    return t + 1\nfor _ in range(int(input())):\n    (n, k) = [int(i) for i in input().split(' ')]\n    (d, levels, visited) = (defaultdict(list), defaultdict(int), {})\n    visited[1] = 1\n    for i in range(n - 1):\n        (u, v) = [int(i) for i in input().split(' ')]\n        if u not in visited:\n            (u, v) = (v, u)\n        d[u].append(v)\n        visited[v] = 1\n    lev = dfs(1, d, levels)\n    print(sum([levels[i] for i in range(min(k, lev))]))", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef dfs(n):\n    bool[n] = True\n    for i in hash[n]:\n        if bool[i] == False:\n            height[n] = max(dfs(i), height[n])\n    return height[n] + 1\nt = int(input())\nfrom collections import defaultdict, Counter\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    hash = defaultdict(list)\n    bool = [False] * (n + 1)\n    height = [0] * (n + 1)\n    for i in range(n - 1):\n        (a, b) = map(int, input().split())\n        hash[a].append(b)\n        hash[b].append(a)\n    dfs(1)\n    z = Counter(height[1:])\n    ka = sorted(z.values())\n    ka.reverse()\n    print(sum(ka[:k]))", "import sys\nsys.setrecursionlimit(10 ** 7)\n\ndef dfs(u):\n    visited[u] = True\n    m = 0\n    for i in range(len(g[u])):\n        v = g[u][i]\n        if visited[v] == False:\n            depth[v] = dfs(v)\n            m = max(m, depth[v])\n    return m + 1\nfor t in range(int(input())):\n    (n, k) = map(int, input().split())\n    g = [[] for i in range(n)]\n    for i in range(n - 1):\n        (u, v) = map(int, input().split())\n        g[u - 1].append(v - 1)\n        g[v - 1].append(u - 1)\n    depth = [0 for i in range(n)]\n    visited = [False for i in range(n)]\n    depth[0] = dfs(0)\n    c = 0\n    for i in range(n):\n        if depth[i] <= k:\n            c += 1\n    print(c)", "from sys import stdin, stdout\nimport heapq\nimport cProfile, math\nfrom collections import Counter, defaultdict, deque\nfrom bisect import bisect_left, bisect, bisect_right\nimport itertools\nfrom copy import deepcopy\nfrom fractions import Fraction\nimport sys, threading\nimport operator as op\nfrom functools import reduce\nimport sys\nsys.setrecursionlimit(10 ** 6)\nthreading.stack_size(2 ** 27)\nfac_warm_up = False\nprintHeap = str()\nmemory_constrained = False\nP = 10 ** 9 + 7\n\nclass MergeFind:\n\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.num_sets = n\n        self.lista = [[_] for _ in range(n)]\n\n    def find(self, a):\n        to_update = []\n        while a != self.parent[a]:\n            to_update.append(a)\n            a = self.parent[a]\n        for b in to_update:\n            self.parent[b] = a\n        return self.parent[a]\n\n    def merge(self, a, b):\n        a = self.find(a)\n        b = self.find(b)\n        if a == b:\n            return\n        if self.size[a] < self.size[b]:\n            (a, b) = (b, a)\n        self.num_sets -= 1\n        self.parent[b] = a\n        self.size[a] += self.size[b]\n        self.lista[a] += self.lista[b]\n\n    def set_size(self, a):\n        return self.size[self.find(a)]\n\n    def __len__(self):\n        return self.num_sets\n\ndef display(string_to_print):\n    stdout.write(str(string_to_print) + '\\n')\n\ndef prime_factors(n):\n    factors = dict()\n    for i in range(2, math.ceil(math.sqrt(n)) + 1):\n        while n % i == 0:\n            if i in factors:\n                factors[i] += 1\n            else:\n                factors[i] = 1\n            n = n // i\n    if n > 2:\n        factors[n] = 1\n    return factors\n\ndef all_factors(n):\n    return set(reduce(list.__add__, ([i, n // i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0)))\n\ndef fibonacci_modP(n, MOD):\n    if n < 2:\n        return 1\n    return (cached_fn(fibonacci_modP, (n + 1) // 2, MOD) * cached_fn(fibonacci_modP, n // 2, MOD) + cached_fn(fibonacci_modP, (n - 1) // 2, MOD) * cached_fn(fibonacci_modP, (n - 2) // 2, MOD)) % MOD\n\ndef factorial_modP_Wilson(n, p):\n    if p <= n:\n        return 0\n    res = p - 1\n    for i in range(n + 1, p):\n        res = res * cached_fn(InverseEuler, i, p) % p\n    return res\n\ndef binary(n, digits=20):\n    b = bin(n)[2:]\n    b = '0' * (digits - len(b)) + b\n    return b\n\ndef is_prime(n):\n    if n < 4:\n        return True\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True\n\ndef generate_primes(n):\n    prime = [True for i in range(n + 1)]\n    p = 2\n    while p * p <= n:\n        if prime[p]:\n            for i in range(p * 2, n + 1, p):\n                prime[i] = False\n        p += 1\n    return prime\nfactorial_modP = []\n\ndef warm_up_fac(MOD):\n    global factorial_modP, fac_warm_up\n    if fac_warm_up:\n        return\n    factorial_modP = [1 for _ in range(fac_warm_up_size + 1)]\n    for i in range(2, fac_warm_up_size):\n        factorial_modP[i] = factorial_modP[i - 1] * i % MOD\n    fac_warm_up = True\n\ndef InverseEuler(n, MOD):\n    return pow(n, MOD - 2, MOD)\n\ndef nCr(n, r, MOD):\n    global fac_warm_up, factorial_modP\n    if not fac_warm_up:\n        warm_up_fac(MOD)\n        fac_warm_up = True\n    return factorial_modP[n] * (pow(factorial_modP[r], MOD - 2, MOD) * pow(factorial_modP[n - r], MOD - 2, MOD) % MOD) % MOD\n\ndef get_int():\n    return int(stdin.readline().strip())\n\ndef get_tuple():\n    return map(int, stdin.readline().split())\n\ndef get_list():\n    return list(map(int, stdin.readline().split()))\nmemory = dict()\n\ndef clear_cache():\n    global memory\n    memory = dict()\n\ndef cached_fn(fn, *args):\n    global memory\n    if args in memory:\n        return memory[args]\n    else:\n        result = fn(*args)\n        memory[args] = result\n        return result\n\ndef ncr(n, r):\n    return math.factorial(n) / (math.factorial(n - r) * math.factorial(r))\n\ndef binary_search(i, li):\n    fn = lambda x: li[x] - x // i\n    x = -1\n    b = len(li)\n    while b >= 1:\n        while b + x < len(li) and fn(b + x) > 0:\n            x += b\n        b = b // 2\n    return x\nTestCases = True\noptimise_for_recursion = True\n\ndef dfs(root):\n    global rev_height, visited, adj\n    visited[root] = True\n    rev_height[root] = 0\n    for i in adj[root]:\n        if not visited[i]:\n            rev_height[root] = max(dfs(i), rev_height[root])\n    return rev_height[root] + 1\n\ndef main():\n    global rev_height, visited, adj\n    (n, k) = get_tuple()\n    adj = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (x, y) = get_tuple()\n        adj[x - 1].append(y - 1)\n        adj[y - 1].append(x - 1)\n    visited = [False for _ in range(n)]\n    rev_height = [0 for _ in range(n)]\n    dfs(0)\n    cnt = Counter(rev_height)\n    cnt = list(sorted(cnt.values(), reverse=True))\n    print(sum(cnt[:k]))\nif TestCases:\n    for i in range(get_int()):\n        main()\nelse:\n    main() if not optimise_for_recursion else threading.Thread(target=main).start()", "import sys\nsys.setrecursionlimit(10 ** 9)\n\ndef dfs(no, par=-1, l=1):\n    st = False\n    ma = 0\n    for i in adj[no]:\n        if i != par:\n            st = True\n            a = dfs(i, no, l + 1)\n            ma = max(ma, a + 1)\n    if st == False:\n        return 0\n    lev[no] = ma\n    return lev[no]\nt = int(input())\nfor _ in range(t):\n    (n, k) = map(int, input().split())\n    adj = [set() for i in range(n)]\n    for __ in range(n - 1):\n        (a, b) = map(int, input().split())\n        adj[a - 1].add(b - 1)\n        adj[b - 1].add(a - 1)\n    vis = [0] * n\n    vis[0] = 1\n    lev = [0 for i in range(n)]\n    dp = [0] * n\n    dfs(0)\n    ss = {}\n    for i in lev:\n        try:\n            ss[i] += 1\n        except:\n            ss[i] = 1\n    tt = [i for i in ss]\n    tt.sort(reverse=False)\n    ind = 0\n    tot = 0\n    co = 0\n    while co < k and ind < len(tt):\n        tot += ss[tt[ind]]\n        ind += 1\n        co += 1\n    print(tot)"]