["def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    A = [[int(c) for c in input().split()] for r in range(n)]\n    grid = [[0 for c in range(m + 1)] for r in range(n + 1)]\n    for r in range(1, n + 1):\n        for c in range(1, m + 1):\n            grid[r][c] = A[r - 1][c - 1] + grid[r - 1][c] + grid[r][c - 1] - grid[r - 1][c - 1]\n    ans = 0\n    for sz in range(1, n + 1):\n        for r in range(sz, n + 1):\n            low = sz\n            high = m\n            while low <= high:\n                mid = (low + high) // 2\n                yellow = grid[r][mid] - grid[r - sz][mid] - grid[r][mid - sz] + grid[r - sz][mid - sz]\n                if yellow // (sz * sz) >= k:\n                    high = mid - 1\n                    mid1 = mid\n                else:\n                    low = mid + 1\n            if low <= m:\n                ans += m - mid1 + 1\n    print(ans)", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "def testcase():\n    (n, m, k) = map(int, input().split())\n    A = [[int(c) for c in input().split()] for r in range(n)]\n    grid = [[0 for c in range(m + 1)] for r in range(n + 1)]\n    for r in range(1, n + 1):\n        for c in range(1, m + 1):\n            grid[r][c] = A[r - 1][c - 1] + grid[r - 1][c] + grid[r][c - 1] - grid[r - 1][c - 1]\n    phani = 0\n    for sz in range(1, n + 1):\n        for r in range(sz, n + 1):\n            low = sz\n            high = m\n            while low <= high:\n                mid = (low + high) // 2\n                yellow = grid[r][mid] - grid[r - sz][mid] - grid[r][mid - sz] + grid[r - sz][mid - sz]\n                if yellow // (sz * sz) >= k:\n                    high = mid - 1\n                    mid1 = mid\n                else:\n                    low = mid + 1\n            if low <= m:\n                phani += m - mid1 + 1\n    print(phani)\nfor t in range(int(input())):\n    testcase()", "def test_case():\n    (n, m, k) = map(int, input().strip().split())\n    A = [[int(x) for x in input().strip().split()] for y in range(n)]\n    G = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for row in range(1, n + 1):\n        for col in range(1, m + 1):\n            G[row][col] = A[row - 1][col - 1] + G[row - 1][col] + G[row][col - 1] - G[row - 1][col - 1]\n    size = min(n, m)\n    ps = 0\n    for sz in range(1, size + 1):\n        for row in range(sz, n + 1):\n            low = sz\n            high = m\n            while low <= high:\n                mid = (low + high) // 2\n                ssum = G[row][mid] - G[row - sz][mid] - G[row][mid - sz] + G[row - sz][mid - sz]\n                if ssum // (sz * sz) >= k:\n                    high = mid - 1\n                    curr = mid\n                else:\n                    low = mid + 1\n            if low <= m:\n                ps += m - curr + 1\n    print(ps)\nfor _ in range(int(input().strip())):\n    test_case()", "import sys\n\ndef binary_search(arr, col, low, high, order, min_value):\n    while low < high:\n        mid = (low + high) // 2\n        if (arr[mid][col] - arr[mid - order][col] - arr[mid][col - order] + arr[mid - order][col - order]) / (order * order) >= min_value:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low\n\ndef binary_search2(arr, row, low, high, order, min_value):\n    while low < high:\n        mid = (low + high) // 2\n        if (arr[row][mid] - arr[row - order][mid] - arr[row][mid - order] + arr[row - order][mid - order]) / (order * order) >= min_value:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return low\n\ndef count(m, n, k, arr):\n    matrix_count = 0\n    for i in range(1, m + 1):\n        row_sum = 0\n        for j in range(1, n + 1):\n            arr[i][j] = row_sum + arr[i][j]\n            row_sum = arr[i][j]\n    for i in range(1, n + 1):\n        col_sum = 0\n        for j in range(1, m + 1):\n            arr[j][i] = col_sum + arr[j][i]\n            col_sum = arr[j][i]\n    for order in range(1, m + 1):\n        for i in range(binary_search(arr, n, order, m, order, k), m + 1):\n            for j in range(binary_search2(arr, i, order, n, order, k), n + 1):\n                if (arr[i][j] - arr[i - order][j] - arr[i][j - order] + arr[i - order][j - order]) / (order * order) >= k:\n                    matrix_count += n - j + 1\n                    break\n    return matrix_count\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    arr = [[0] * (m + 1)]\n    for row in range(n):\n        temp = list(map(int, sys.stdin.readline().split()))\n        temp.insert(0, 0)\n        arr.append(temp)\n    print(str(count(n, m, k, arr)))", "def solve(A, R, C, K):\n    RLE = [[0] * (C + 1) for _ in range(R + 1)]\n    for r in range(R):\n        for c in range(C):\n            RLE[r + 1][c + 1] = A[r][c]\n    for r in range(1, R + 1):\n        for c in range(1, C + 1):\n            RLE[r][c] += RLE[r][c - 1]\n    for r in range(1, R + 1):\n        for c in range(1, C + 1):\n            RLE[r][c] += RLE[r - 1][c]\n    res = 0\n    for sz in range(1, R + 1):\n        for r in range(1, R - sz + 2):\n            j = flag = 0\n            (lo, hi) = (1, C - sz + 1)\n            while lo <= hi:\n                mi = lo + hi >> 1\n                cand = RLE[r + sz - 1][mi + sz - 1] - RLE[r - 1][mi + sz - 1] - RLE[r + sz - 1][mi - 1] + RLE[r - 1][mi - 1]\n                if cand >= K * sz * sz:\n                    j = mi\n                    flag = 1\n                    hi = mi - 1\n                else:\n                    lo = mi + 1\n            if flag == 1:\n                res += C - sz - j + 2\n    return res\nT = int(input())\nfor t in range(T):\n    (R, C, K) = map(int, input().split())\n    A = []\n    for r in range(R):\n        row = list(map(int, input().split()))\n        A.append(row)\n    res = solve(A, R, C, K)\n    print(res)", "for iiiii in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    dp = []\n    for i in range(n):\n        r = []\n        for j in range(m):\n            r.append(0)\n        dp.append(r)\n    l = []\n    for i in range(n):\n        l.append(list(map(int, input().split())))\n    dp[0][0] = l[0][0]\n    for j in range(1, m):\n        dp[0][j] = l[0][j] + dp[0][j - 1]\n    for i in range(1, n):\n        dp[i][0] = l[i][0] + dp[i - 1][0]\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = l[i][j] - dp[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1]\n    ad = 0\n    sub = min(n, m)\n    itr = 0\n    for i in range(n):\n        maxc = 1\n        for j in range(m):\n            for t in range(max(maxc, 1), sub + 1):\n                if t - 1 <= i and t - 1 <= j:\n                    s = 0\n                    if i == t - 1 or j == t - 1:\n                        if i == t - 1 and j == t - 1:\n                            s = dp[i][j]\n                        elif i == t - 1:\n                            s = dp[i][j] - dp[i][j - t]\n                        else:\n                            s = dp[i][j] - dp[i - t][j]\n                    else:\n                        s = dp[i][j] - dp[i - t][j] - dp[i][j - t] + dp[i - t][j - t]\n                    if s >= t * t * k:\n                        ad += m - j\n                        maxc = t + 1\n                    else:\n                        break\n                itr += 1\n    print(ad)", "def getVal(dp, k, i, j):\n    if i < 0 or j < 0:\n        print('ERROR')\n        exit()\n    return dp[i][j] - dp[i - k][j] - dp[i][j - k] + dp[i - k][j - k]\n\ndef getIndex(li, i, start, end, sz, k):\n    pos = -1\n    while start <= end:\n        mid = start + (end - start) // 2\n        val = getVal(dp, sz, i, mid) / (sz * sz)\n        if val < k:\n            start = mid + 1\n        else:\n            pos = mid\n            end = mid - 1\n    return pos\n\ndef solve(dp, n, m, k):\n    total = 0\n    for sz in range(1, n + 1):\n        for i in range(sz, n + 1):\n            val = getVal(dp, sz, i, m) / (sz * sz)\n            if val >= k:\n                ind = getIndex(dp[i], i, sz, m, sz, k)\n                total += m - ind + 1\n    return total\nfor t in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    dp = [[0 for i in range(m + 1)] for j in range(n + 1)]\n    for i in range(1, n + 1):\n        for (j, val) in enumerate(input().split(), start=1):\n            dp[i][j] = dp[i][j - 1] + int(val)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] += dp[i - 1][j]\n    print(solve(dp, n, m, k))", "def count(mat, n, m, k, order):\n    c = 0\n    mn = min(n, m)\n    order = 1\n    d = 0\n    while order < mn + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            sum = mat[i][j] - mat[i - order][j] - mat[i][j - order] + mat[i - order][j - order]\n            if sum < k * order * order:\n                i = i + 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    sum = mat[i][mid] - mat[x - 1][mid] - mat[i][y - 1] + mat[x - 1][y - 1]\n                    if sum >= k * order * order:\n                        end = mid - 1\n                        ans = mid\n                    else:\n                        start = mid + 1\n                c += m - ans + 1\n                i = i + 1\n        order = order + 1\n    return c\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    l = [list(map(int, input().split())) for i in range(n)]\n    l1 = []\n    l2 = []\n    for i in range(n):\n        sum = 0\n        for j in range(m):\n            sum += l[i][j]\n            l[i][j] = sum\n    for i in range(m):\n        sum = 0\n        for j in range(n):\n            sum += l[j][i]\n            l[j][i] = sum\n    l.insert(0, [0] * m)\n    for i in range(n + 1):\n        l[i].insert(0, 0)\n    print(count(l, n, m, k, 1))", "def count(mat, n, m, k, order):\n    c = 0\n    mn = min(n, m)\n    order = 1\n    d = 0\n    while order < mn + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            sum = mat[i][j] - mat[i - order][j] - mat[i][j - order] + mat[i - order][j - order]\n            if sum < k * order * order:\n                i = i + 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    sum = mat[i][mid] - mat[x - 1][mid] - mat[i][y - 1] + mat[x - 1][y - 1]\n                    if sum >= k * order * order:\n                        end = mid - 1\n                        ans = mid\n                    else:\n                        start = mid + 1\n                c += m - ans + 1\n                i = i + 1\n        order = order + 1\n    return c\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    l = [list(map(int, input().split())) for i in range(n)]\n    l1 = []\n    l2 = []\n    for i in range(n):\n        sum = 0\n        for j in range(m):\n            sum += l[i][j]\n            l[i][j] = sum\n    for i in range(m):\n        sum = 0\n        for j in range(n):\n            sum += l[j][i]\n            l[j][i] = sum\n    l.insert(0, [0] * m)\n    for i in range(n + 1):\n        l[i].insert(0, 0)\n    print(count(l, n, m, k, 1))", "def count(mat, n, m, k, order):\n    c = 0\n    mn = min(n, m)\n    order = 1\n    d = 0\n    while order < mn + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            sum = mat[i][j] - mat[i - order][j] - mat[i][j - order] + mat[i - order][j - order]\n            if sum < k * order * order:\n                i = i + 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    sum = mat[i][mid] - mat[x - 1][mid] - mat[i][y - 1] + mat[x - 1][y - 1]\n                    if sum >= k * order * order:\n                        end = mid - 1\n                        ans = mid\n                    else:\n                        start = mid + 1\n                c += m - ans + 1\n                i = i + 1\n        order = order + 1\n    return c\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    l = []\n    l1 = []\n    l2 = []\n    for i in range(0, n):\n        l1 = list(map(int, input().split()))\n        l.append(l1)\n    for i in range(0, n):\n        sum = 0\n        for j in range(0, m):\n            sum += l[i][j]\n            l[i][j] = sum\n    for i in range(0, m):\n        sum = 0\n        for j in range(0, n):\n            sum += l[j][i]\n            l[j][i] = sum\n    l.insert(0, [0] * m)\n    for i in range(0, n + 1):\n        l[i].insert(0, 0)\n    print(count(l, n, m, k, 1))", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().split(' '))\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "for z in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    matrix = []\n    for y in range(n):\n        temp = list(map(int, input().split()))\n        temp.insert(0, 0)\n        matrix.append(temp)\n    temp = []\n    for i in range(m + 1):\n        temp.append(0)\n    matrix.insert(0, temp)\n    for i in range(n + 1):\n        Sum = 0\n        for j in range(m + 1):\n            Sum += matrix[i][j]\n            matrix[i][j] = Sum\n    for i in range(m + 1):\n        Sum = 0\n        for j in range(n + 1):\n            Sum += matrix[j][i]\n            matrix[j][i] = Sum\n    order = 1\n    count = 0\n    while order < n + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = matrix[i][j] - matrix[x - 1][j] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = matrix[i][mid] - matrix[x - 1][mid] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += m - ans + 1\n                i += 1\n        order += 1\n    print(count)", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "import numpy as np\nfor i in range(int(input())):\n    (n, m, k) = [int(ii) for ii in input().split()]\n    ll = []\n    for ii in range(n):\n        ll.append([int(iii) for iii in input().split()])\n    ll = np.array(ll)\n    for r in range(len(ll) - 1):\n        ll[r + 1] += ll[r]\n    for r in range(len(ll[0]) - 1):\n        ll[:, r + 1] += ll[:, r]\n    ll = [(ll[0] * 0).tolist()] + ll.tolist()\n    ll = np.array(ll).T\n    ll = [(ll[0] * 0).tolist()] + ll.tolist()\n    ll = np.array(ll).T\n    r = 0\n    c = 0\n    ans = 0\n    l = min(n, m)\n    while r < n:\n        l = min(n - r, m)\n        while c < m and l > 0:\n            if l > m - c:\n                l -= 1\n            avg = (ll[r + l, c + l] - ll[r + l, c] - ll[r, c + l] + ll[r, c]) / l / l\n            if avg >= k:\n                ans += m - c - l + 1\n                l -= 1\n            else:\n                c += 1\n        r += 1\n        c = 0\n    print(ans)", "def worthy():\n    testcases = int(input())\n    while testcases:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        auxillary = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            auxillary[i][0] = 0\n        for j in range(n + 1):\n            auxillary[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                auxillary[i][j] += auxillary[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                auxillary[i][j] += auxillary[i - 1][j]\n        result = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    out = auxillary[i + p - 1][mid + p - 1] - auxillary[i + p - 1][mid - 1] - auxillary[i - 1][mid + p - 1] + auxillary[i - 1][mid - 1]\n                    if out >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    result += n - p - q + 2\n        print(result)\n        testcases -= 1\nworthy()", "def solve(sum, n, m, key):\n    c = 0\n    for k in range(1, n + 1):\n        for i in range(k - 1, n):\n            (low, high, j, total) = (k - 1, m - 1, 0, 0)\n            while low <= high:\n                j = (low + high) // 2\n                total = sum[i][j]\n                if i - k >= 0:\n                    total = total - sum[i - k][j]\n                if j - k >= 0:\n                    total = total - sum[i][j - k]\n                if i - k >= 0 and j - k >= 0:\n                    total = total + sum[i - k][j - k]\n                if total / (k * k) >= key:\n                    high = j - 1\n                else:\n                    low = j + 1\n            if total / (k * k) >= key:\n                c += m - j\n            else:\n                c += m - j - 1\n    return c\nfor _ in range(int(input())):\n    (n, m, key) = map(int, input().split())\n    matrix = [list(map(int, input().split())) for j in range(n)]\n    t = [[0 for i in range(m)] for j in range(n)]\n    t[0][0] = matrix[0][0]\n    for i in range(m):\n        t[0][i] = t[0][i - 1] + matrix[0][i]\n    for i in range(n):\n        t[i][0] = t[i - 1][0] + matrix[i][0]\n    for i in range(1, n):\n        for j in range(1, m):\n            t[i][j] = t[i - 1][j] + t[i][j - 1] + matrix[i][j] - t[i - 1][j - 1]\n    print(solve(t, n, m, key))", "for z in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    matrix = []\n    for y in range(n):\n        temp = list(map(int, input().split()))\n        temp.insert(0, 0)\n        matrix.append(temp)\n    temp = []\n    for i in range(m + 1):\n        temp.append(0)\n    matrix.insert(0, temp)\n    for i in range(n + 1):\n        Sum = 0\n        for j in range(m + 1):\n            Sum += matrix[i][j]\n            matrix[i][j] = Sum\n    for i in range(m + 1):\n        Sum = 0\n        for j in range(n + 1):\n            Sum += matrix[j][i]\n            matrix[j][i] = Sum\n    order = 1\n    count = 0\n    while order < n + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = matrix[i][j] - matrix[x - 1][j] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = matrix[i][mid] - matrix[x - 1][mid] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += m - ans + 1\n                i += 1\n        order += 1\n    print(count)", "for z in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    matrix = []\n    for y in range(n):\n        temp = list(map(int, input().split()))\n        temp.insert(0, 0)\n        matrix.append(temp)\n    temp = []\n    for i in range(m + 1):\n        temp.append(0)\n    matrix.insert(0, temp)\n    for i in range(n + 1):\n        Sum = 0\n        for j in range(m + 1):\n            Sum += matrix[i][j]\n            matrix[i][j] = Sum\n    for i in range(m + 1):\n        Sum = 0\n        for j in range(n + 1):\n            Sum += matrix[j][i]\n            matrix[j][i] = Sum\n    order = 1\n    count = 0\n    while order < n + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = matrix[i][j] - matrix[x - 1][j] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = matrix[i][mid] - matrix[x - 1][mid] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += m - ans + 1\n                i += 1\n        order += 1\n    print(count)", "for z in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    matrix = []\n    for y in range(n):\n        temp = list(map(int, input().split()))\n        temp.insert(0, 0)\n        matrix.append(temp)\n    temp = []\n    for i in range(m + 1):\n        temp.append(0)\n    matrix.insert(0, temp)\n    for i in range(n + 1):\n        Sum = 0\n        for j in range(m + 1):\n            Sum += matrix[i][j]\n            matrix[i][j] = Sum\n    for i in range(m + 1):\n        Sum = 0\n        for j in range(n + 1):\n            Sum += matrix[j][i]\n            matrix[j][i] = Sum\n    order = 1\n    count = 0\n    while order < n + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = matrix[i][j] - matrix[x - 1][j] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = matrix[i][mid] - matrix[x - 1][mid] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += m - ans + 1\n                i += 1\n        order += 1\n    print(count)", "for z in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    matrix = []\n    for y in range(n):\n        temp = list(map(int, input().split()))\n        temp.insert(0, 0)\n        matrix.append(temp)\n    temp = []\n    for i in range(m + 1):\n        temp.append(0)\n    matrix.insert(0, temp)\n    for i in range(n + 1):\n        Sum = 0\n        for j in range(m + 1):\n            Sum += matrix[i][j]\n            matrix[i][j] = Sum\n    for i in range(m + 1):\n        Sum = 0\n        for j in range(n + 1):\n            Sum += matrix[j][i]\n            matrix[j][i] = Sum\n    order = 1\n    count = 0\n    while order < n + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = matrix[i][j] - matrix[x - 1][j] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = matrix[i][mid] - matrix[x - 1][mid] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += m - ans + 1\n                i += 1\n        order += 1\n    print(count)", "def pp():\n    llll = list(range(1, 7))\n\ndef summon(mat, n, m, k, o):\n    c = 0\n    p = 0\n    x = min(n, m)\n    while o < x + 1:\n        i = o\n        j = m\n        while i < n + 1:\n            a = i - o + 1\n            b = j - o + 1\n            z = mat[i][j] - mat[a - 1][j] - mat[i][b - 1] + mat[a - 1][b - 1]\n            if z // (o * o) < k:\n                i += 1\n            else:\n                s = o\n                e = m\n                while s <= e:\n                    mi = (s + e) // 2\n                    a = i - o + 1\n                    b = mi - o + 1\n                    z = mat[i][mi] - mat[a - 1][mi] - mat[i][b - 1] + mat[a - 1][b - 1]\n                    if z // (o * o) < k:\n                        s = mi + 1\n                    else:\n                        p = mi\n                        e = mi - 1\n                c += m - p + 1\n                i += 1\n        o += 1\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    ls = []\n    for i in range(n):\n        pp()\n        ls += [list(map(int, input().split()))]\n    ls1 = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            ls1[i + 1][j + 1] = ls[i][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            pp()\n            ls1[i][j] += ls1[i - 1][j] + ls1[i][j - 1] - ls1[i - 1][j - 1]\n    ans = summon(ls1, n, m, k, 1)\n    print(ans)", "def count(mat, n, m, k, order):\n    c = 0\n    mn = min(n, m)\n    order = 1\n    d = 0\n    while order < mn + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            sum = mat[i][j] - mat[i - order][j] - mat[i][j - order] + mat[i - order][j - order]\n            if sum < k * order * order:\n                i = i + 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    sum = mat[i][mid] - mat[x - 1][mid] - mat[i][y - 1] + mat[x - 1][y - 1]\n                    if sum >= k * order * order:\n                        end = mid - 1\n                        ans = mid\n                    else:\n                        start = mid + 1\n                c += m - ans + 1\n                i = i + 1\n        order = order + 1\n    return c\nt = int(input())\nwhile t > 0:\n    (n, m, k) = map(int, input().split())\n    l = []\n    l1 = []\n    l2 = []\n    for i in range(0, n):\n        l1 = list(map(int, input().split()))\n        l.append(l1)\n    for i in range(0, n):\n        sum = 0\n        for j in range(0, m):\n            sum += l[i][j]\n            l[i][j] = sum\n    for i in range(0, m):\n        sum = 0\n        for j in range(0, n):\n            sum += l[j][i]\n            l[j][i] = sum\n    l.insert(0, [0] * m)\n    for i in range(0, n + 1):\n        l[i].insert(0, 0)\n    print(count(l, n, m, k, 1))\n    t = t - 1", "def MyFunc(matrix, n1, n2, k, our_con):\n    con1 = 0\n    con2 = 0\n    x = min(n1, n2)\n    while our_con < x + 1:\n        rows = our_con\n        col = n2\n        while rows < n1 + 1:\n            a = rows - our_con + 1\n            b = col - our_con + 1\n            z = matrix[rows][col] - matrix[a - 1][col] - matrix[rows][b - 1] + matrix[a - 1][b - 1]\n            if z // (our_con * our_con) < k:\n                rows += 1\n            else:\n                con3 = our_con\n                e = n2\n                while con3 <= e:\n                    mi = (con3 + e) // 2\n                    a = rows - our_con + 1\n                    b = mi - our_con + 1\n                    z = matrix[rows][mi] - matrix[a - 1][mi] - matrix[rows][b - 1] + matrix[a - 1][b - 1]\n                    if z // (our_con * our_con) < k:\n                        con3 = mi + 1\n                    else:\n                        con2 = mi\n                        e = mi - 1\n                con1 += n2 - con2 + 1\n                rows += 1\n        our_con += 1\n    return con1\ntest = int(input())\nfor rows in range(test):\n    (n1, n2, k) = map(int, input().split())\n    ls = []\n    for rows in range(n1):\n        ls += [list(map(int, input().split()))]\n    ls1 = [[0 for x in range(n2 + 1)] for y in range(n1 + 1)]\n    for rows in range(n1):\n        for col in range(n2):\n            ls1[rows + 1][col + 1] = ls[rows][col]\n    for rows in range(1, n1 + 1):\n        for col in range(1, n2 + 1):\n            ls1[rows][col] += ls1[rows - 1][col] + ls1[rows][col - 1] - ls1[rows - 1][col - 1]\n    res = MyFunc(ls1, n1, n2, k, 1)\n    print(res)", "from math import *\nfrom collections import *\n\ndef pref_mat(n, m, l):\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            l[i][j] += l[i][j - 1]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            l[j][i] += l[j - 1][i]\n    return l\n\ndef bins_panda(n, m, k, l):\n    cnt = 0\n    for i in range(1, n + 1):\n        for j in range(1, n - i + 2):\n            (low, up) = (1, m - i + 1)\n            fl = False\n            x = 0\n            x1 = 0\n            while low <= up:\n                x = (low + up) // 2\n                s = l[i + j - 1][x + i - 1] - l[i + j - 1][x - 1] - l[j - 1][x + i - 1] + l[j - 1][x - 1]\n                if s >= k * i ** 2:\n                    up = x - 1\n                    fl = True\n                    x1 = x\n                else:\n                    low = x + 1\n            if fl:\n                cnt += m - i - x1 + 2\n    return cnt\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    l = [[0 for x3 in range(m + 1)]]\n    for xx in range(n):\n        l.append([0] + list(map(int, input().split())))\n    l1 = pref_mat(n, m, l)\n    print(bins_panda(n, m, k, l1))", "def summon(mat, n, m, k, o):\n    c = 0\n    p = 0\n    x = min(n, m)\n    while o < x + 1:\n        i = o\n        j = m\n        while i < n + 1:\n            a = i - o + 1\n            b = j - o + 1\n            z = mat[i][j] - mat[a - 1][j] - mat[i][b - 1] + mat[a - 1][b - 1]\n            if z // (o * o) < k:\n                i += 1\n            else:\n                s = o\n                e = m\n                while s <= e:\n                    mi = (s + e) // 2\n                    a = i - o + 1\n                    b = mi - o + 1\n                    z = mat[i][mi] - mat[a - 1][mi] - mat[i][b - 1] + mat[a - 1][b - 1]\n                    if z // (o * o) < k:\n                        s = mi + 1\n                    else:\n                        p = mi\n                        e = mi - 1\n                c += m - p + 1\n                i += 1\n        o += 1\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    ls = []\n    for i in range(n):\n        ls += [list(map(int, input().split()))]\n    ls1 = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            ls1[i + 1][j + 1] = ls[i][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            ls1[i][j] += ls1[i - 1][j] + ls1[i][j - 1] - ls1[i - 1][j - 1]\n    ans = summon(ls1, n, m, k, 1)\n    print(ans)", "def summon(mat, n, m, k, o):\n    c = 0\n    p = 0\n    x = min(n, m)\n    while o < x + 1:\n        i = o\n        j = m\n        while i < n + 1:\n            a = i - o + 1\n            b = j - o + 1\n            z = mat[i][j] - mat[a - 1][j] - mat[i][b - 1] + mat[a - 1][b - 1]\n            if z // (o * o) < k:\n                i += 1\n            else:\n                s = o\n                e = m\n                while s <= e:\n                    mi = (s + e) // 2\n                    a = i - o + 1\n                    b = mi - o + 1\n                    z = mat[i][mi] - mat[a - 1][mi] - mat[i][b - 1] + mat[a - 1][b - 1]\n                    if z // (o * o) < k:\n                        s = mi + 1\n                    else:\n                        p = mi\n                        e = mi - 1\n                c += m - p + 1\n                i += 1\n        o += 1\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    ls = []\n    for i in range(n):\n        ls += [list(map(int, input().split()))]\n    ls1 = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            ls1[i + 1][j + 1] = ls[i][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            ls1[i][j] += ls1[i - 1][j] + ls1[i][j - 1] - ls1[i - 1][j - 1]\n    ans = summon(ls1, n, m, k, 1)\n    print(ans)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, input().split())))\n    for i in range(n):\n        for j in range(1, m):\n            matrix[i][j] += matrix[i][j - 1]\n    for i in range(m):\n        for j in range(1, n):\n            matrix[j][i] += matrix[j - 1][i]\n    for i in range(n):\n        matrix[i].insert(0, 0)\n    matrix.insert(0, [0 for _ in range(len(matrix[0]))])\n    count = 0\n    order = 1\n    while order < n + 1:\n        i = order\n        j = m\n        for i in range(order, n + 1):\n            a = i - order + 1\n            b = j - order + 1\n            z = matrix[i][j] - matrix[a - 1][j] - matrix[i][b - 1] + matrix[a - 1][b - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    a = i - order + 1\n                    b = mid - order + 1\n                    z = matrix[i][mid] - matrix[a - 1][mid] - matrix[i][b - 1] + matrix[a - 1][b - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        res = mid\n                        end = mid - 1\n                count += m - res + 1\n        order += 1\n    print(count)", "testcase = int(input())\nfor _ in range(testcase):\n    (n, m, k) = map(int, input().split())\n    array = []\n    total_sum = []\n    answer = 0\n    for x in range(n):\n        array.append([int(y) for y in input().split()])\n    total_sum.append([])\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if i == 0:\n                total_sum[i].append(0)\n            elif j == 0:\n                total_sum.append([0])\n            else:\n                total_sum[i].append(array[i - 1][j - 1])\n    for i in range(n + 1):\n        previous_value = 0\n        for j in range(m + 1):\n            total_sum[i][j] += previous_value\n            previous_value = total_sum[i][j]\n    for j in range(m + 1):\n        previous_value = 0\n        for i in range(n + 1):\n            total_sum[i][j] += previous_value\n            previous_value = total_sum[i][j]\n    minimum_value = min(n, m)\n    for order in range(1, minimum_value + 1):\n        start = order\n        end = m\n        while start >= 1 and start <= n and (end >= 1) and (end <= m):\n            if (total_sum[start][end] - total_sum[start - order][end] - total_sum[start][end - order] + total_sum[start - order][end - order]) / (order * order) >= k:\n                answer += n - start + 1\n                end -= 1\n            else:\n                start += 1\n    print(answer)", "def counting(dp, n, m, k, ord):\n    i = ord\n    j = m\n    count = 0\n    for i in range(ord, n + 1):\n        x = i - ord + 1\n        y = j - ord + 1\n        sumSubMat = dp[i][j] - dp[x - 1][j] - dp[i][y - 1] + dp[x - 1][y - 1]\n        if sumSubMat / ord ** 2 >= k:\n            low = ord\n            high = m\n            while low <= high:\n                mid = (low + high) // 2\n                x = i - (ord - 1)\n                y = mid - (ord - 1)\n                sumsub = dp[i][mid] - dp[x - 1][mid] - dp[i][y - 1] + dp[x - 1][y - 1]\n                if sumsub / ord ** 2 < k:\n                    low = mid + 1\n                else:\n                    ind = mid\n                    high = mid - 1\n            count += m - ind + 1\n    return count\n\ndef subb(matrix, n, m, k):\n    dp = [[0 for _ in range(m + 1)] for __ in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            dp[i + 1][j + 1] = matrix[i][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n    mini = min(n, m)\n    count = 0\n    for i in range(1, mini + 1):\n        count += counting(dp, n, m, k, i)\n    return count\nfor t in range(int(input())):\n    (n, m, k) = map(float, input().split())\n    n = int(n)\n    m = int(m)\n    matrix = []\n    for i in range(n):\n        x = list(map(float, input().split()))\n        matrix.append(x)\n    print(subb(matrix, n, m, k))", "def func(y, z, Am, size):\n    return Am[y][z] - Am[y - size][z] - Am[y][z - size] + Am[y - size][z - size]\nT = int(input())\nfor _ in range(T):\n    (N, M, K) = map(int, input().split())\n    A = list()\n    count = 0\n    for i in range(N):\n        A.append(list(map(lambda x: int(x) - K, input().split())))\n    Am = [[0 for _ in range(M + 1)] for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            Am[i][j] = Am[i][j - 1] + A[i - 1][j - 1]\n            if A[i - 1][j - 1] >= 0:\n                count += 1\n    for j in range(1, M + 1):\n        for i in range(1, N + 1):\n            Am[i][j] = Am[i - 1][j] + Am[i][j]\n    for size in range(2, N + 1):\n        for i in range(size, N + 1):\n            if func(i, size, Am, size) >= 0:\n                count += M - size + 1\n            elif func(i, M, Am, size) < 0:\n                continue\n            else:\n                low = size\n                high = M\n                mid = 0\n                while low < high - 1:\n                    mid = (high - low) // 2 + low\n                    if func(i, mid, Am, size) < 0:\n                        low = mid\n                    else:\n                        high = mid\n                count += M - high + 1\n    print(count)", "from bisect import bisect_left as bis\nfrom collections import defaultdict\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = []\n    last = []\n    for i in range(n):\n        li = list(map(int, input().split()))\n        a.append(li)\n        last.append(li[-1])\n    if n == 1:\n        if a[0][-1] >= k:\n            print(m - bis(a[0], k))\n            continue\n        else:\n            print(0)\n            continue\n    if m == 1:\n        if a[-1][0] >= k:\n            print(n - bis(last, k))\n            continue\n        else:\n            print(0)\n            continue\n    if a[0][0] >= k:\n        ans = 0\n        for i in range(min(n, m)):\n            ans += (n - i) * (m - i)\n        print(ans)\n        continue\n    if a[-1][-1] < k:\n        print(0)\n        continue\n    row1 = bis(last, k)\n    ans = 0\n    low = defaultdict(lambda : 0)\n    bise = defaultdict(lambda : 0)\n    b = [[0] * (m + 1) for i in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            b[i + 1][j + 1] = a[i][j]\n            b[i + 1][j + 1] += b[i + 1][j]\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            b[i][j] += b[i - 1][j]\n    for i in range(row1, n):\n        bise[i] = bis(a[i], k)\n        ans += m - bise[i]\n        if bise[i] == 0:\n            ans += (n - 1 - i) * m\n            break\n    for size in range(2, min(n, m) + 1):\n        col = 10\n        for i in range(max(0, row1 - size + 1), n - size + 1):\n            col1 = bise[i + size - 1]\n            st = max(0, col1 - size + 1, low[i + size - 1] - size + 2)\n            for j in range(st, m - size + 1):\n                if b[i + size][j + size] - b[i + size][j] - b[i][j + size] + b[i][j] >= k * size * size:\n                    ans += m - j - size + 1\n                    col = j\n                    break\n                low[i + size - 1] = j + size - 1\n                if j + size - 1 == m - 1:\n                    row1 += 1\n            if col == 0:\n                ans += (n - i - size) * (m - size + 1)\n                break\n    print(ans)", "import sys\nt = int(sys.stdin.readline())\nwhile t:\n    (n, m, k) = list(map(int, sys.stdin.readline().split()))\n    A = list()\n    A.append([0] * (m + 1))\n    for i in range(n):\n        A.append([0] + list(map(int, sys.stdin.readline().split())))\n    for i in range(n + 1):\n        prev = 0\n        for j in range(m + 1):\n            A[i][j] += prev\n            prev = A[i][j]\n    for i in range(m + 1):\n        prev = 0\n        for j in range(n + 1):\n            A[j][i] += prev\n            prev = A[j][i]\n    ans = 0\n    B = []\n    for u in range(1, n + 1):\n        u2 = u * u\n        for i in range(1, n - u + 2):\n            low = 1\n            high = m - u + 1\n            flag = 0\n            p = 0\n            while low <= high:\n                mid = (high + low) // 2\n                smm = A[i + u - 1][mid + u - 1] - A[i + u - 1][mid - 1] - A[i - 1][mid + u - 1] + A[i - 1][mid - 1]\n                if smm >= k * u2:\n                    high = mid - 1\n                    p = mid\n                    flag = 1\n                else:\n                    low = mid + 1\n            if flag == 1:\n                ans += m - u - p + 2\n    print(ans)\n    t -= 1", "def countGreater(j, L, u, x, z):\n    leftGreater = u + 1\n    mo = u + 1\n    while L <= u:\n        sumi = 0\n        l = int(L + (u - L) / 2)\n        if j - x + 1 == 0:\n            if l - x + 1 > 0:\n                sumi = cot[j][l] - cot[j][l - x]\n            else:\n                sumi = cot[j][l]\n        elif l - x + 1 > 0:\n            sumi = cot[j][l] - cot[j - x][l] - (cot[j][l - x] - cot[j - x][l - x])\n        else:\n            sumi = cot[j][l] - cot[j - x][l]\n        if sumi / (x * x) >= z:\n            leftGreater = l\n            u = l - 1\n        else:\n            L = l + 1\n    return mo - leftGreater\n\ndef cou(k, v):\n    count = 0\n    h = 10 ** 6\n    for j in range(k - 1, n):\n        gh = countGreater(j, k - 1, m - 1, k, v)\n        count = count + gh\n        if gh == m - (k - 1):\n            count = count + (n - (j + 1)) * (m - (k - 1))\n            break\n    return count\nq = int(input())\nfor i in range(q):\n    (n, m, r) = map(int, input().split())\n    cot = []\n    for j in range(n):\n        cot.append(list(map(int, input().split())))\n    mount = 0\n    bount = 0\n    for j in range(n):\n        mount = 0\n        for l in range(m):\n            mount = mount + cot[j][l]\n            if j == 0:\n                cot[j][l] = mount\n            else:\n                cot[j][l] = mount + cot[j - 1][l]\n    for j in range(1, min(n, m) + 1):\n        bount = bount + cou(j, r)\n    print(bount)", "def countGreater(j, L, u, x, z):\n    leftGreater = u + 1\n    mo = u + 1\n    while L <= u:\n        sumi = 0\n        l = int(L + (u - L) / 2)\n        if j - x + 1 == 0:\n            if l - x + 1 > 0:\n                sumi = cot[j][l] - cot[j][l - x]\n            else:\n                sumi = cot[j][l]\n        elif l - x + 1 > 0:\n            sumi = cot[j][l] - cot[j - x][l] - (cot[j][l - x] - cot[j - x][l - x])\n        else:\n            sumi = cot[j][l] - cot[j - x][l]\n        if sumi / (x * x) >= z:\n            leftGreater = l\n            u = l - 1\n        else:\n            L = l + 1\n    return mo - leftGreater\n\ndef cou(k, v):\n    count = 0\n    h = 10 ** 6\n    for j in range(k - 1, n):\n        gh = countGreater(j, k - 1, m - 1, k, v)\n        count = count + gh\n        if gh == m - (k - 1):\n            count = count + (n - (j + 1)) * (m - (k - 1))\n            break\n    return count\nq = int(input())\nfor i in range(q):\n    (n, m, r) = map(int, input().split())\n    cot = []\n    for j in range(n):\n        cot.append(list(map(int, input().split())))\n    mount = 0\n    bount = 0\n    for j in range(n):\n        mount = 0\n        for l in range(m):\n            mount = mount + cot[j][l]\n            if j == 0:\n                cot[j][l] = mount\n            else:\n                cot[j][l] = mount + cot[j - 1][l]\n    for j in range(1, min(n, m) + 1):\n        bount = bount + cou(j, r)\n    print(bount)", "import sys\nt = int(sys.stdin.readline())\nfor i in range(0, t):\n    (n, m, k) = map(int, sys.stdin.readline().split())\n    mat = []\n    a = []\n    for j in range(0, m + 1):\n        a.append(0)\n    mat.append(a)\n    for j in range(0, n):\n        arr = list(map(int, sys.stdin.readline().split()))\n        arr.insert(0, 0)\n        mat.append(arr)\n    for j in range(0, n + 1):\n        s = 0\n        for p in range(0, m + 1):\n            s += mat[j][p]\n            mat[j][p] = s\n    for j in range(0, m + 1):\n        s = 0\n        for p in range(0, n + 1):\n            s += mat[p][j]\n            mat[p][j] = s\n    size = 1\n    ans = 0\n    lmax = min(n, m)\n    while size < lmax + 1:\n        p = size\n        q = m\n        while p < n + 1:\n            x = p - size + 1\n            y = q - size + 1\n            z = mat[p][q] - mat[x - 1][q] - mat[p][y - 1] + mat[x - 1][y - 1]\n            if z / (size * size) < k:\n                p += 1\n            else:\n                start = size\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = p - size + 1\n                    y = mid - size + 1\n                    z = mat[p][mid] - mat[x - 1][mid] - mat[p][y - 1] + mat[x - 1][y - 1]\n                    if z / (size * size) < k:\n                        start = mid + 1\n                    else:\n                        index = mid\n                        end = mid - 1\n                ans += m - index + 1\n                p += 1\n        size += 1\n    print(ans)", "import sys\nt = int(sys.stdin.readline())\nfor i in range(0, t):\n    (n, m, k) = map(int, sys.stdin.readline().split())\n    mat = []\n    a = []\n    for j in range(0, m + 1):\n        a.append(0)\n    mat.append(a)\n    for j in range(0, n):\n        arr = list(map(int, sys.stdin.readline().split()))\n        arr.insert(0, 0)\n        mat.append(arr)\n    for j in range(0, n + 1):\n        s = 0\n        for p in range(0, m + 1):\n            s += mat[j][p]\n            mat[j][p] = s\n    for j in range(0, m + 1):\n        s = 0\n        for p in range(0, n + 1):\n            s += mat[p][j]\n            mat[p][j] = s\n    size = 1\n    ans = 0\n    lmax = min(n, m)\n    while size < lmax + 1:\n        p = size\n        q = m\n        while p < n + 1:\n            x = p - size + 1\n            y = q - size + 1\n            z = mat[p][q] - mat[x - 1][q] - mat[p][y - 1] + mat[x - 1][y - 1]\n            if z / (size * size) < k:\n                p += 1\n            else:\n                start = size\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = p - size + 1\n                    y = mid - size + 1\n                    z = mat[p][mid] - mat[x - 1][mid] - mat[p][y - 1] + mat[x - 1][y - 1]\n                    if z / (size * size) < k:\n                        start = mid + 1\n                    else:\n                        index = mid\n                        end = mid - 1\n                ans += m - index + 1\n                p += 1\n        size += 1\n    print(ans)", "t = int(input())\nwhile t:\n    t -= 1\n    (n, m, k) = map(int, input().split())\n    a11 = []\n    for i in range(n):\n        a = list(map(int, input().split()))\n        a11.append(a)\n    a1 = [[0 for x in range(m)] for y in range(n)]\n    a1[0][0] = a11[0][0]\n    for i in range(1, m):\n        a1[0][i] = a1[0][i - 1] + a11[0][i]\n    for i in range(0, n):\n        a1[i][0] = a1[i - 1][0] + a11[i][0]\n    for i in range(1, n):\n        for j in range(1, m):\n            a1[i][j] = a1[i - 1][j] + a1[i][j - 1] - a1[i - 1][j - 1] + a11[i][j]\n    ans = 0\n    x = min(n, m)\n    for i in range(n):\n        max1 = 1\n        for j in range(m):\n            for l in range(max(max1, 1), x + 1):\n                if l - 1 <= i and l - 1 <= j:\n                    s = 0\n                    if i == l - 1 or j == l - 1:\n                        if i == l - 1 and j == l - 1:\n                            s = a1[i][j]\n                        elif i == l - 1:\n                            s = a1[i][j] - a1[i][j - l]\n                        else:\n                            s = a1[i][j] - a1[i - l][j]\n                    else:\n                        s = a1[i][j] - a1[i - l][j] - a1[i][j - l] + a1[i - l][j - l]\n                    if s >= l * l * k:\n                        ans += m - j\n                        max1 = l + 1\n                    else:\n                        break\n    print(ans)", "def fun(mat, n, m, k, order):\n    c = 0\n    mini = min(n, m)\n    while order < mini + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = mat[i][j] - mat[x - 1][j] - mat[i][y - 1] + mat[x - 1][y - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = mat[i][mid] - mat[x - 1][mid] - mat[i][y - 1] + mat[x - 1][y - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                c += m - ans + 1\n                i += 1\n        order += 1\n    return c\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    mat = []\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(n):\n        s = 0\n        for j in range(m):\n            s += mat[i][j]\n            mat[i][j] = s\n    for i in range(m):\n        s = 0\n        for j in range(n):\n            s += mat[j][i]\n            mat[j][i] = s\n    for i in range(n):\n        mat[i].insert(0, 0)\n    mat.insert(0, [0] * (m + 1))\n    print(fun(mat, n, m, k, 1))", "T = int(input())\nfor _ in range(1, T + 1):\n    (n, m, val) = [int(j) for j in input().split()]\n    aa = []\n    for i in range(n):\n        aa.append([int(j) for j in input().split()])\n    a = [[0] * (m + 1) for _ in range(n + 1)]\n\n    def doa():\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1] + aa[i - 1][j - 1]\n    doa()\n\n    def calculate():\n        ans = 0\n        for side in range(1, n + 1):\n            for i in range(1, n - side + 2, 1):\n                l = 1\n                r = m - side + 1\n                flag = 0\n                while l <= r:\n                    mid = (l + r) // 2\n                    summ = a[i + side - 1][mid + side - 1] - a[i + side - 1][mid - 1] - a[i - 1][mid + side - 1] + a[i - 1][mid - 1]\n                    if summ >= val * side * side:\n                        r = mid - 1\n                        p = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    ans += m - side - p + 2\n        print(ans)\n    calculate()", "def matrix_fun(matrix, n, m, k, f):\n    count = 0\n    a = min(n, m)\n    while f < a + 1:\n        i = f\n        j = m\n        while i < n + 1:\n            x = i - f + 1\n            y = j - f + 1\n            z = abs(matrix[i][j] - matrix[x - 1][j] - matrix[i][y - 1] + matrix[x - 1][y - 1])\n            if z // (f * f) < k:\n                i += 1\n            else:\n                start = f\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - f + 1\n                    y = mid - f + 1\n                    z = matrix[i][mid] - matrix[x - 1][mid] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n                    if z // (f * f) < k:\n                        start = mid + 1\n                    else:\n                        c = mid\n                        end = mid - 1\n                count += m - c + 1\n                i += 1\n        f += 1\n    return count\nt = int(input())\nfor _ in range(t):\n    (R, C, k) = map(int, input().split())\n    matrix = []\n    for i in range(R):\n        a = list(map(int, input().split()))\n        matrix.append(a)\n    for i in range(R):\n        sum = 0\n        for j in range(C):\n            sum += matrix[i][j]\n            matrix[i][j] = sum\n    for i in range(C):\n        sum = 0\n        for j in range(R):\n            sum += matrix[j][i]\n            matrix[j][i] = sum\n    for i in matrix:\n        i.insert(0, 0)\n    b = []\n    for i in range(C + 1):\n        b.append(0)\n    matrix.insert(0, b)\n    print(matrix_fun(matrix, R, C, k, 1))", "def summon(mat, n, m, k, o):\n    c = 0\n    p = 0\n    x = min(n, m)\n    while o < x + 1:\n        i = o\n        j = m\n        while i < n + 1:\n            a = i - o + 1\n            b = j - o + 1\n            z = mat[i][j] - mat[a - 1][j] - mat[i][b - 1] + mat[a - 1][b - 1]\n            if z // (o * o) < k:\n                i += 1\n            else:\n                s = o\n                e = m\n                while s <= e:\n                    mi = (s + e) // 2\n                    a = i - o + 1\n                    b = mi - o + 1\n                    z = mat[i][mi] - mat[a - 1][mi] - mat[i][b - 1] + mat[a - 1][b - 1]\n                    if z // (o * o) < k:\n                        s = mi + 1\n                    else:\n                        p = mi\n                        e = mi - 1\n                c += m - p + 1\n                i += 1\n        o += 1\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    ls = []\n    for i in range(n):\n        ls += [list(map(int, input().split()))]\n    ls1 = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            ls1[i + 1][j + 1] = ls[i][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            ls1[i][j] += ls1[i - 1][j] + ls1[i][j - 1] - ls1[i - 1][j - 1]\n    ans = summon(ls1, n, m, k, 1)\n    print(ans)", "def summon(mat, n, m, k, o):\n    c = 0\n    p = 0\n    x = min(n, m)\n    while o < x + 1:\n        i = o\n        j = m\n        while i < n + 1:\n            a = i - o + 1\n            b = j - o + 1\n            z = mat[i][j] - mat[a - 1][j] - mat[i][b - 1] + mat[a - 1][b - 1]\n            if z // (o * o) < k:\n                i += 1\n            else:\n                s = o\n                e = m\n                while s <= e:\n                    mi = (s + e) // 2\n                    a = i - o + 1\n                    b = mi - o + 1\n                    z = mat[i][mi] - mat[a - 1][mi] - mat[i][b - 1] + mat[a - 1][b - 1]\n                    if z // (o * o) < k:\n                        s = mi + 1\n                    else:\n                        p = mi\n                        e = mi - 1\n                c += m - p + 1\n                i += 1\n        o += 1\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    ls = []\n    for i in range(n):\n        ls += [list(map(int, input().split()))]\n    ls1 = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            ls1[i + 1][j + 1] = ls[i][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            ls1[i][j] += ls1[i - 1][j] + ls1[i][j - 1] - ls1[i - 1][j - 1]\n    ans = summon(ls1, n, m, k, 1)\n    print(ans)", "def solve():\n    (m, n, k) = map(int, input().split())\n    v = []\n    for i in range(0, m):\n        v.append([int(j) for j in input().split()])\n    summ = [[0 for i in range(n)] for j in range(m)]\n    for i in range(m):\n        summ[i][0] = v[i][0]\n        for j in range(1, n):\n            summ[i][j] = summ[i][j - 1] + v[i][j]\n    for j in range(n):\n        for i in range(1, m):\n            summ[i][j] += summ[i - 1][j]\n    count = 0\n    size_up = min(n, m)\n    for size in range(1, size_up + 1):\n        for i in range(m - size + 1):\n            low = 0\n            high = n - size\n            while low <= high:\n                mid = (low + high) // 2\n                total = summ[i + size - 1][mid + size - 1]\n                if i > 0:\n                    total -= summ[i - 1][mid + size - 1]\n                if mid > 0:\n                    total -= summ[i + size - 1][mid - 1]\n                if i > 0 and mid > 0:\n                    total += summ[i - 1][mid - 1]\n                avg = total * 1.0 / (size * size)\n                if avg >= k:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            if high + 1 <= n - size:\n                high += 1\n                count += n - size - high + 1\n    return count\nt = int(input())\nfor z in range(t):\n    ans = solve()\n    print(ans)", "t = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    a = []\n    for i in range(n):\n        b = list(map(int, input().split()))\n        a.append(b)\n    psm = [[0 for i in range(m)] for j in range(n)]\n    psm[0][0] = a[0][0]\n    for i in range(1, m):\n        psm[0][i] = psm[0][i - 1] + a[0][i]\n    for i in range(1, n):\n        psm[i][0] = psm[i - 1][0] + a[i][0]\n    for i in range(1, n):\n        for j in range(1, m):\n            psm[i][j] = psm[i - 1][j] + psm[i][j - 1] - psm[i - 1][j - 1] + a[i][j]\n    data = 0\n    sab = n\n    for i in range(n):\n        mc = 1\n        for j in range(m):\n            for t in range(max(mc, 1), sab + 1):\n                if t - 1 <= i and t - 1 <= j:\n                    s = 0\n                    if i == t - 1 or j == t - 1:\n                        if i == t - 1 and j == t - 1:\n                            s = psm[i][j]\n                        elif i == t - 1:\n                            s = psm[i][j] - psm[i][j - t]\n                        else:\n                            s = psm[i][j] - psm[i - t][j]\n                    else:\n                        s = psm[i][j] - psm[i - t][j] - psm[i][j - t] + psm[i - t][j - t]\n                    if s >= t * t * k:\n                        data += m - j\n                        mc = t + 1\n                    else:\n                        break\n    print(data)", "def summon(mat, n, m, k, o):\n    c = 0\n    p = 0\n    x = min(n, m)\n    while o < x + 1:\n        i = o\n        j = m\n        while i < n + 1:\n            a = i - o + 1\n            b = j - o + 1\n            z = mat[i][j] - mat[a - 1][j] - mat[i][b - 1] + mat[a - 1][b - 1]\n            if z // (o * o) < k:\n                i += 1\n            else:\n                s = o\n                e = m\n                while s <= e:\n                    mi = (s + e) // 2\n                    a = i - o + 1\n                    b = mi - o + 1\n                    z = mat[i][mi] - mat[a - 1][mi] - mat[i][b - 1] + mat[a - 1][b - 1]\n                    if z // (o * o) < k:\n                        s = mi + 1\n                    else:\n                        p = mi\n                        e = mi - 1\n                c += m - p + 1\n                i += 1\n        o += 1\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    ls = []\n    for i in range(n):\n        ls += [list(map(int, input().split()))]\n    ls1 = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            ls1[i + 1][j + 1] = ls[i][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            ls1[i][j] += ls1[i - 1][j] + ls1[i][j - 1] - ls1[i - 1][j - 1]\n    ans = summon(ls1, n, m, k, 1)\n    print(ans)", "def summon(mat, n, m, k, o):\n    c = 0\n    p = 0\n    x = min(n, m)\n    while o < x + 1:\n        i = o\n        j = m\n        while i < n + 1:\n            a = i - o + 1\n            b = j - o + 1\n            z = mat[i][j] - mat[a - 1][j] - mat[i][b - 1] + mat[a - 1][b - 1]\n            if z // (o * o) < k:\n                i += 1\n            else:\n                s = o\n                e = m\n                while s <= e:\n                    mi = (s + e) // 2\n                    a = i - o + 1\n                    b = mi - o + 1\n                    z = mat[i][mi] - mat[a - 1][mi] - mat[i][b - 1] + mat[a - 1][b - 1]\n                    if z // (o * o) < k:\n                        s = mi + 1\n                    else:\n                        p = mi\n                        e = mi - 1\n                c += m - p + 1\n                i += 1\n        o += 1\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    ls = []\n    for i in range(n):\n        ls += [list(map(int, input().split()))]\n    ls1 = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            ls1[i + 1][j + 1] = ls[i][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            ls1[i][j] += ls1[i - 1][j] + ls1[i][j - 1] - ls1[i - 1][j - 1]\n    ans = summon(ls1, n, m, k, 1)\n    print(ans)", "def summon(mat, n, m, k, o):\n    c = 0\n    p = 0\n    x = min(n, m)\n    while o < x + 1:\n        i = o\n        j = m\n        while i < n + 1:\n            a = i - o + 1\n            b = j - o + 1\n            z = mat[i][j] - mat[a - 1][j] - mat[i][b - 1] + mat[a - 1][b - 1]\n            if z // (o * o) < k:\n                i += 1\n            else:\n                s = o\n                e = m\n                while s <= e:\n                    mi = (s + e) // 2\n                    a = i - o + 1\n                    b = mi - o + 1\n                    z = mat[i][mi] - mat[a - 1][mi] - mat[i][b - 1] + mat[a - 1][b - 1]\n                    if z // (o * o) < k:\n                        s = mi + 1\n                    else:\n                        p = mi\n                        e = mi - 1\n                c += m - p + 1\n                i += 1\n        o += 1\n    return c\nt = int(input())\nfor i in range(t):\n    (n, m, k) = map(int, input().split())\n    ls = []\n    for i in range(n):\n        ls += [list(map(int, input().split()))]\n    ls1 = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for i in range(n):\n        for j in range(m):\n            ls1[i + 1][j + 1] = ls[i][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            ls1[i][j] += ls1[i - 1][j] + ls1[i][j - 1] - ls1[i - 1][j - 1]\n    ans = summon(ls1, n, m, k, 1)\n    print(ans)", "def precomputed(matrix):\n    dp = [[0 for j in range(len(matrix[0]))] for i in range(len(matrix))]\n    for i in range(0, len(matrix)):\n        for j in range(0, len(matrix[0])):\n            dp[i][j] = 0\n    dp[0][0] = matrix[0][0]\n    for j in range(1, len(matrix[0])):\n        dp[0][j] = matrix[0][j] + dp[0][j - 1]\n    for i in range(1, len(matrix)):\n        dp[i][0] = matrix[i][0] + dp[i - 1][0]\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            dp[i][j] = matrix[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n    return dp\n\ndef calculateno(precompmat, matrix, count, k):\n    dsarr = 2\n    while dsarr <= len(matrix):\n        matrixno = dsarr - 1\n        for i in range(dsarr - 1, len(matrix)):\n            target = k * pow(dsarr, 2)\n            pos = binarysearchpos(matrix[i], target, dsarr - 1, precompmat, matrixno)\n            if pos == -1:\n                count += 0\n            else:\n                count += len(matrix[0]) - pos\n            matrixno += 1\n        dsarr += 1\n    return count\n\ndef countSquares(m, n):\n    if n < m:\n        temp = m\n        m = n\n        n = temp\n    return m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2\n\ndef binarysearchpos(arr, k, start, matrix, cols):\n    x = len(matrix[0]) - 1\n    (leftmove, rightmove) = (start + 1, cols)\n    if x - leftmove >= 0 and rightmove - leftmove >= 0:\n        value = matrix[cols][-1] - matrix[cols][x - leftmove] - matrix[rightmove - leftmove][x] + matrix[rightmove - leftmove][x - leftmove]\n    elif x - leftmove >= 0:\n        value = matrix[cols][-1] - matrix[cols][x - leftmove]\n    elif rightmove - leftmove >= 0:\n        value = matrix[cols][-1] - matrix[rightmove - leftmove][x]\n    else:\n        value = matrix[cols][-1]\n    if value < k:\n        return -1\n    else:\n        end = len(arr) - 1\n        x = len(matrix[0]) - 1\n        (leftmove, rightmove) = (start + 1, cols)\n        while start < end:\n            mid = start + (end - start) // 2\n            if mid - leftmove >= 0 and rightmove - leftmove >= 0:\n                value = matrix[cols][mid] - matrix[cols][mid - leftmove] - matrix[rightmove - leftmove][mid] + matrix[rightmove - leftmove][mid - leftmove]\n            elif mid - leftmove >= 0:\n                value = matrix[cols][mid] - matrix[cols][mid - leftmove]\n            elif rightmove - leftmove >= 0:\n                value = matrix[cols][mid] - matrix[rightmove - leftmove][mid]\n            else:\n                value = matrix[cols][mid]\n            if value >= k:\n                end = mid\n            else:\n                start = mid + 1\n        return end\nfor i in range(0, 10):\n    i = 10\nt = int(input())\nwhile t > 0:\n    temp = list(map(int, input().split()))\n    (N, M, K) = (temp[0], temp[1], temp[2])\n    (matrix, norow) = ([], N)\n    while norow:\n        arr = list(map(int, input().split()))\n        matrix.append(arr)\n        norow -= 1\n    if K == 0:\n        finalans = countSquares(M, N)\n        print(int(finalans))\n        t -= 1\n        continue\n    count = 0\n    for i in range(0, N):\n        for j in range(0, M):\n            if matrix[i][j] >= K:\n                count += 1\n    precompmat = precomputed(matrix)\n    finalans = calculateno(precompmat, matrix, count, K)\n    for i in range(0, 10):\n        i = 10\n    print(finalans)\n    t -= 1", "def main():\n    t = int(input())\n    while t:\n        (m, n, k) = map(int, input().strip().split(' '))\n        matrix = [[0 for x in range(n)] for y in range(m)]\n        matrix = []\n        for i in range(m):\n            r = list(map(int, input().strip().split(' ')))\n            matrix.append(r)\n        aux = [[0 for x in range(n + 1)] for y in range(m + 1)]\n        for i in range(m + 1):\n            aux[i][0] = 0\n        for j in range(n + 1):\n            aux[0][j] = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                aux[i][j] = matrix[i - 1][j - 1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                aux[i][j] += aux[i][j - 1]\n        for j in range(1, n + 1):\n            for i in range(1, m + 1):\n                aux[i][j] += aux[i - 1][j]\n        count = 0\n        for p in range(1, m + 1):\n            for i in range(1, m - p + 2):\n                l = 1\n                h = n - p + 1\n                mid = 0\n                q = 0\n                flag = 0\n                while l <= h:\n                    mid = int((l + h) / 2)\n                    ans = aux[i + p - 1][mid + p - 1] - aux[i + p - 1][mid - 1] - aux[i - 1][mid + p - 1] + aux[i - 1][mid - 1]\n                    if ans >= k * p * p:\n                        h = mid - 1\n                        q = mid\n                        flag = 1\n                    else:\n                        l = mid + 1\n                if flag == 1:\n                    count += n - p - q + 2\n        print(count)\n        t -= 1\nmain()", "from sys import stdin, stdout, setrecursionlimit\n\ndef binarySearch(lr, l, h, i, cnt):\n    if l <= h:\n        mid = (l + h) // 2\n        val = lr[i][mid]\n        if i - cnt >= 0 and mid - cnt >= 0:\n            val = val - lr[i - cnt][mid] - lr[i][mid - cnt] + lr[i - cnt][mid - cnt]\n        elif i - cnt >= 0:\n            val -= lr[i - cnt][mid]\n        elif mid - cnt >= 0:\n            val -= lr[i][mid - cnt]\n        if val / (cnt * cnt) >= k:\n            ind = binarySearch(lr, l, mid - 1, i, cnt)\n            return min(mid, ind) if ind != -1 else mid\n        else:\n            return binarySearch(lr, mid + 1, h, i, cnt)\n    else:\n        return -1\nt = int(stdin.readline())\nfor _ in range(t):\n    (n, m, k) = map(int, stdin.readline().strip().split())\n    a = []\n    lr = []\n    for i in range(n):\n        arr = list(map(int, stdin.readline().strip().split()))\n        a.append(arr)\n        lr.append(arr[:])\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if i == 0 and j > 0:\n                lr[i][j] += lr[i][j - 1]\n            if j == 0 and i > 0:\n                lr[i][j] += lr[i - 1][j]\n            if a[i][j] >= k:\n                count += 1\n    for i in range(1, n):\n        for j in range(1, m):\n            lr[i][j] += lr[i][j - 1] + lr[i - 1][j] - lr[i - 1][j - 1]\n    for cnt in range(2, n + 1):\n        for i in range(cnt - 1, n):\n            val = lr[i][m - 1]\n            if i - cnt >= 0 and m - 1 - cnt >= 0:\n                val = val - lr[i - cnt][m - 1] - lr[i][m - 1 - cnt] + lr[i - cnt][m - 1 - cnt]\n            elif i - cnt >= 0:\n                val = val - lr[i - cnt][m - 1]\n            elif m - 1 - cnt >= 0:\n                val = val - lr[i][m - 1 - cnt]\n            if val / (cnt * cnt) >= k:\n                l = cnt - 1\n                h = m - 1\n                ind = binarySearch(lr, l, h, i, cnt)\n                if ind > -1:\n                    count += m - ind\n    print(count)", "def fun(l, n, m, k, order):\n    count = 0\n    minimum = min(n, m)\n    while order < minimum + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = l[i][j] - l[x - 1][j] - l[i][y - 1] + l[x - 1][y - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = l[i][mid] - l[x - 1][mid] - l[i][y - 1] + l[x - 1][y - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += m - ans + 1\n                i += 1\n        order += 1\n    return count\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    l = []\n    l.append([0] * (m + 1))\n    for _ in range(n):\n        a = [0] + list(map(int, input().split()))\n        l.append(a)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            l[i][j] += l[i][j - 1]\n    for j in range(1, m + 1):\n        for i in range(1, n + 1):\n            l[i][j] += l[i - 1][j]\n    ans = fun(l, n, m, k, 1)\n    print(ans)", "def row_sum(s, n, m):\n    for i in range(n + 1):\n        back = 0\n        for j in range(m + 1):\n            s[i][j] += back\n            back = s[i][j]\n    return s\n\ndef col_sum(s, n, m):\n    for j in range(m + 1):\n        back = 0\n        for i in range(n + 1):\n            s[i][j] += back\n            back = s[i][j]\n    return s\n\ndef fun(s, n, m):\n    return\n\ndef solve():\n    (n, m, k) = map(int, input().split())\n    a = []\n    s = []\n    ans = 0\n    for x in range(n):\n        a.append([int(y) for y in input().split()])\n    s.append([])\n    if k == 'kdjflkdf':\n        return\n    if k == 'kdjflkdf':\n        return\n    if k == 'kdjflkdf':\n        return\n    for i in range(n + 1):\n        for j in range(m + 1):\n            if i == 0:\n                s[i].append(0)\n            elif j == 0:\n                s.append([0])\n            else:\n                s[i].append(a[i - 1][j - 1])\n    s = row_sum(s, n, m)\n    s = col_sum(s, n, m)\n    mi = min(n, m)\n    if k == 'kdjflkdf':\n        return\n    if k == 'kdjflkdf':\n        return\n    if k == 'kdjflkdf':\n        return\n    for curr in range(1, mi + 1):\n        first = curr\n        end = m\n        while first >= 1 and first <= n and (end >= 1) and (end <= m):\n            if (s[first][end] - s[first - curr][end] - s[first][end - curr] + s[first - curr][end - curr]) / (curr * curr) >= k:\n                ans += n - first + 1\n                end -= 1\n            else:\n                first += 1\n    print(ans)\nfor _ in range(int(input())):\n    solve()", "def average(mat, l, i, j):\n    ans = (mat[i][j] + mat[i - l][j - l] - mat[i - l][j] - mat[i][j - l]) / (l * l)\n    return ans\nT = int(input())\nfor t in range(T):\n    (n, m, k) = map(int, input().split())\n    A = [[0] * (m + 1)]\n    for i in range(n):\n        A.append([0] + list(map(int, input().split())))\n    (B, C) = ([], [])\n    for i in range(n + 1):\n        B.append([])\n        C.append([])\n        for j in range(m + 1):\n            B[i].append(A[i][j])\n            C[i].append(10 ** 9 + 1)\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            B[i][j] = B[i][j] + B[i][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            B[i][j] = B[i][j] + B[i - 1][j]\n    score = 0\n    for i in range(1, n + 1):\n        mx = min(i, m)\n        mn = 1\n        while mx >= mn:\n            mid = (mx + mn) // 2\n            if average(B, mid, i, m) >= k:\n                mn = mid + 1\n            else:\n                mx = mid - 1\n        score += (mx + mn) // 2\n        C[i][m] = (mx + mn) // 2\n    for j in range(1, m):\n        mx = min(n, j)\n        mn = 1\n        while mx >= mn:\n            mid = (mx + mn) // 2\n            if average(B, mid, n, j) >= k:\n                mn = mid + 1\n            else:\n                mx = mid - 1\n        score += (mx + mn) // 2\n        C[n][j] = (mx + mn) // 2\n    for i in range(n - 1, 0, -1):\n        for j in range(m - 1, 0, -1):\n            c = min(C[i + 1][j], C[i][j + 1])\n            temp = min(i, j)\n            c = min(temp, c)\n            while c > 0 and average(B, c, i, j) < k:\n                c -= 1\n            score += c\n            C[i][j] = c\n    print(score)", "def solve(A, n, m, k):\n    if k == 0:\n        count = 0\n        for l in range(1, n + 1):\n            count += (n - l + 1) * (m - l + 1)\n        return count\n    APS = [[0] * (m + 1), [0] * (m + 1)]\n    APS[1][1] = A[0][0]\n    for i in range(2, m + 1):\n        APS[1][i] = APS[1][i - 1] + A[0][i - 1]\n    for i in range(2, n + 1):\n        APS.append([0] * (m + 1))\n        APS[i][1] = APS[i - 1][1] + A[i - 1][0]\n        for j in range(2, m + 1):\n            APS[i][j] = APS[i - 1][j] + APS[i][j - 1] - APS[i - 1][j - 1] + A[i - 1][j - 1]\n    count = 0\n    for l in range(1, n + 1):\n        lsq = l * l\n        top = n - l + 1\n        left = 1\n        prevTop = n - l + 2\n        sizeCount = 0\n        i = 0\n        while top > 0 and left < m - l + 2:\n            while left < m - l + 2:\n                s = APS[top + l - 1][left + l - 1] - APS[top - 1][left + l - 1] - APS[top + l - 1][left - 1] + APS[top - 1][left - 1]\n                if s >= lsq * k:\n                    break\n                left += 1\n            if s < lsq * k:\n                break\n            while top > 1:\n                s = APS[top + l - 2][left + l - 1] - APS[top - 2][left + l - 1] - APS[top + l - 2][left - 1] + APS[top - 2][left - 1]\n                if s < lsq * k:\n                    break\n                top -= 1\n            sizeCount += (prevTop - top) * (m - left - l + 2)\n            prevTop = top\n            top -= 1\n            i += 1\n        count += sizeCount\n    return count\nt = int(input())\nfor tc in range(t):\n    (n, m, k) = map(int, input().split())\n    A = []\n    for i in range(n):\n        A.append(list(map(int, input().split())))\n    result = solve(A, n, m, k)\n    print(result)", "DEBUG = False\n\ndef solve(A, n, m, k):\n    if k == 0:\n        count = 0\n        for l in range(1, n + 1):\n            count += (n - l + 1) * (m - l + 1)\n        return count\n    APS = [[0] * (m + 1), [0] * (m + 1)]\n    APS[1][1] = A[0][0]\n    for i in range(2, m + 1):\n        APS[1][i] = APS[1][i - 1] + A[0][i - 1]\n    for i in range(2, n + 1):\n        APS.append([0] * (m + 1))\n        APS[i][1] = APS[i - 1][1] + A[i - 1][0]\n        for j in range(2, m + 1):\n            APS[i][j] = APS[i - 1][j] + APS[i][j - 1] - APS[i - 1][j - 1] + A[i - 1][j - 1]\n    count = 0\n    for l in range(1, n + 1):\n        lsq = l * l\n        top = n - l + 1\n        left = 1\n        prevTop = n - l + 2\n        sizeCount = 0\n        i = 0\n        while top > 0 and left < m - l + 2:\n            while left < m - l + 2:\n                s = APS[top + l - 1][left + l - 1] - APS[top - 1][left + l - 1] - APS[top + l - 1][left - 1] + APS[top - 1][left - 1]\n                if s >= lsq * k:\n                    break\n                left += 1\n            if s < lsq * k:\n                break\n            while top > 1:\n                s = APS[top + l - 2][left + l - 1] - APS[top - 2][left + l - 1] - APS[top + l - 2][left - 1] + APS[top - 2][left - 1]\n                if s < lsq * k:\n                    break\n                top -= 1\n            sizeCount += (prevTop - top) * (m - left - l + 2)\n            prevTop = top\n            top -= 1\n            i += 1\n        count += sizeCount\n    return count\nif DEBUG:\n    f = open('tests/KAVGMAT-tests.txt', 'r')\n    t = int(f.readline())\n    for tc in range(t):\n        (n, m, k) = map(int, f.readline().split())\n        A = []\n        for i in range(n):\n            A.append(list(map(int, f.readline().split())))\n        result = solve(A, n, m, k)\n        print(result)\nelse:\n    t = int(input())\n    for tc in range(t):\n        (n, m, k) = map(int, input().split())\n        A = []\n        for i in range(n):\n            A.append(list(map(int, input().split())))\n        result = solve(A, n, m, k)\n        print(result)", "def fun(mat, n, m, k, order):\n    cnt = 0\n    Min = min(n, m)\n    while order < Min + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = mat[i][j] - mat[x - 1][j] - mat[i][y - 1] + mat[x - 1][y - 1]\n            if z / order ** 2 < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = mat[i][mid] - mat[x - 1][mid] - mat[i][y - 1] + mat[x - 1][y - 1]\n                    if z / order ** 2 < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                cnt += m - ans + 1\n                i += 1\n        order += 1\n    return cnt\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = map(int, input().split())\n    mat = []\n    for _ in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(n):\n        s = 0\n        for j in range(m):\n            s += mat[i][j]\n            mat[i][j] = s\n    for i in range(m):\n        s = 0\n        for j in range(n):\n            s += mat[j][i]\n            mat[j][i] = s\n    for i in range(n):\n        mat[i].insert(0, 0)\n    t = len(mat[0])\n    l = [0 for _ in range(t)]\n    mat.insert(0, l)\n    print(fun(mat, n, m, k, 1))", "import sys\n\ndef get_int():\n    return int(sys.stdin.readline().strip())\n\ndef get_ints():\n    return map(int, sys.stdin.readline().strip().split())\n\ndef get_array():\n    return list(map(int, sys.stdin.readline().strip().split()))\n\ndef p_int(x):\n    sys.stdout.write(str(x) + '\\n')\n\ndef solve():\n    (n, m, K) = get_ints()\n    arr = [[0 for ii in range(m + 1)] for jj in range(n + 1)]\n    for i in range(n):\n        temp = get_array()\n        for j in range(m):\n            arr[i + 1][j + 1] = temp[j]\n    for i in range(n + 1):\n        for j in range(1, m + 1):\n            arr[i][j] += arr[i][j - 1]\n    for i in range(m + 1):\n        for j in range(1, n + 1):\n            arr[j][i] += arr[j - 1][i]\n\n    def good(i, j, k, K):\n        k += 1\n        cnt = k * k\n        pref = arr[i + k][j + k] - arr[i][j + k] - arr[i + k][j] + arr[i][j]\n        return pref / cnt >= K\n    res = 0\n    x = min(n, m)\n    for k in range(x):\n        i = n - 1 - k\n        j = 0\n        while i >= 0 and j < m - k:\n            temp = 0\n            if good(i, j, k, K):\n                temp = m - j - k\n                i -= 1\n            else:\n                j += 1\n            res += temp\n    p_int(res)\nt = get_int()\nfor _ in range(t):\n    solve()", "def kavgmat(n, m, matrix):\n    sum_matrix = [[0 for _ in range(m)] for _ in range(n)]\n    sum_matrix[0][0] = matrix[0][0]\n    for i in range(1, m):\n        sum_matrix[0][i] = sum_matrix[0][i - 1] + matrix[0][i]\n    for i in range(1, n):\n        sum_matrix[i][0] = sum_matrix[i - 1][0] + matrix[i][0]\n    for i in range(1, n):\n        for j in range(1, m):\n            sum_matrix[i][j] = sum_matrix[i - 1][j] + sum_matrix[i][j - 1] + matrix[i][j] - sum_matrix[i - 1][j - 1]\n    temp_matrix = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            temp_matrix[i][j] = sum_matrix[i - 1][j - 1]\n    sum_matrix = temp_matrix\n    answer = 0\n    square_sum = lambda x, y, size: sum_matrix[x][y] - sum_matrix[x][y - size] - sum_matrix[x - size][y] + sum_matrix[x - size][y - size]\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] >= 0:\n                answer += 1\n    for size in range(2, n + 1):\n        for i in range(size, n + 1):\n            if square_sum(i, size, size) < 0:\n                continue\n            elif not square_sum(i, -1, size) < 0:\n                answer += m - size + 1\n                continue\n            else:\n                start = size\n                end = m\n                while start < end - 1:\n                    mid = (start + end) // 2\n                    if square_sum(i, mid, size) >= 0:\n                        start = mid\n                    else:\n                        end = mid\n                answer += start - size + 1\n    return answer\nt = int(input())\nwhile t:\n    (n, m, k) = map(int, input().split())\n    matrix = [[None for _ in range(m)] for _ in range(n)]\n    for i in range(1, n + 1):\n        matrix[-i] = [a - k for a in reversed(list(map(int, input().split())))]\n    print(kavgmat(n, m, matrix))\n    t -= 1", "def printMatrix(M):\n    for a in M:\n        for b in a:\n            print(b, end=' ')\n        print()\n    print()\n\ndef getColumn(A, row, m, K, size):\n    (start, end) = (size, m)\n    minCol = end + 1\n    while start <= end:\n        mid = (start + end) // 2\n        (r2, c2) = (row, mid)\n        (r1, c1) = (row - size + 1, mid - size + 1)\n        if getRangeSum(A, r1, c1, r2, c2) / (size * size) >= K:\n            minCol = mid\n            end = mid - 1\n        else:\n            start = mid + 1\n    return minCol\n\ndef getCount(A, N, M, K, size):\n    s = 0\n    Row = getRow(A, N, M, K, size)\n    for row in range(Row, N + 1):\n        col = getColumn(A, row, M, K, size)\n        s += M - col + 1\n    return s\n\ndef getRow(A, n, m, K, size):\n    for row in range(size, n + 1):\n        (r2, c2) = (row, m)\n        (c1, r1) = (m - size + 1, row - size + 1)\n        if getRangeSum(A, r1, c1, r2, c2) / (size * size) >= K:\n            return row\n    return n\n\ndef putZeroes(A, n, m):\n    M = [[0 for x in range(m + 1)] for y in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            M[i][j] = A[i - 1][j - 1]\n    return M\n\ndef getRangeSum(A, r1, c1, r2, c2):\n    s = A[r2][c2] + A[r1 - 1][c1 - 1] - A[r1 - 1][c2] - A[r2][c1 - 1]\n    return s\n\ndef getPresum(A, n, m):\n    P = [[0 for i in range(m)] for y in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if i == 0:\n                P[i][j] = P[i][j - 1] + A[i][j]\n            elif j == 0:\n                P[i][j] = P[i - 1][j] + A[i][j]\n    for i in range(1, n):\n        for j in range(1, m):\n            P[i][j] = A[i][j] + P[i - 1][j] + P[i][j - 1] - P[i - 1][j - 1]\n    return P\nfor t in range(int(input())):\n    (N, M, K) = map(int, input().split())\n    Mat = []\n    for i in range(N):\n        Mat.append(list(map(int, input().split())))\n    COUNT = 0\n    Mat = getPresum(Mat, N, M)\n    Mat = putZeroes(Mat, N, M)\n    for size in range(1, N + 1):\n        s = getCount(Mat, N, M, K, size)\n        COUNT += s\n    print(COUNT)", "from sys import stdin\nfor _ in range(int(stdin.readline())):\n    (n, m, k) = [int(x) for x in stdin.readline().split()]\n    arr = [None] * n\n    for i in range(n):\n        arr[i] = [int(x) for x in stdin.readline().split()]\n    pre = [[0 for _ in range(m)] for _ in range(n)]\n    pre[0][0] = arr[0][0]\n    for i in range(1, n):\n        pre[i][0] = pre[i - 1][0] + arr[i][0]\n    for i in range(1, m):\n        pre[0][i] += pre[0][i - 1] + arr[0][i]\n    for r in range(1, n):\n        for c in range(1, m):\n            pre[r][c] = pre[r - 1][c] + pre[r][c - 1] + arr[r][c]\n            pre[r][c] -= pre[r - 1][c - 1]\n    ans = 0\n    for j in range(min(n, m)):\n        (r, c) = (j, m - 1)\n        while r < n and c >= j:\n            if j == 0:\n                if arr[r][c] >= k:\n                    ans += n - r\n                    c -= 1\n                else:\n                    r += 1\n            else:\n                (a, b) = (r - j, c - j)\n                val = pre[r][c]\n                if b > 0:\n                    val -= pre[r][b - 1]\n                if a > 0:\n                    val -= pre[a - 1][c]\n                if a > 0 and b > 0:\n                    val += pre[a - 1][b - 1]\n                q = (j + 1) * (j + 1)\n                val //= q\n                if val >= k:\n                    ans += n - r\n                    c -= 1\n                else:\n                    r += 1\n    print(ans)", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, m, k) = map(int, input().split())\n    dp = [[0 for i in range(m + 1)]]\n    for i in range(n):\n        dp.append([0] + list(map(int, input().split())))\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n    ans = 0\n    for q in range(min(n, m), 0, -1):\n        for i in range(n, q - 1, -1):\n            (l, r) = (q, m)\n            index = -1\n            while l <= r:\n                j = l + (r - l) // 2\n                (i1, j1, i2, j2) = (i - q, j - q, i, j)\n                s = dp[i2][j2] - dp[i2][j1] - dp[i1][j2] + dp[i1][j1]\n                if s / q ** 2 >= k:\n                    index = j\n                    r = j - 1\n                else:\n                    l = j + 1\n            if index != -1:\n                ans += m - index + 1\n    print(ans)\nfor t in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef solve():\n    (n, m, k) = map(int, input().split())\n    dp = [[0 for i in range(m + 1)]]\n    for i in range(n):\n        dp.append([0] + list(map(int, input().split())))\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n    ans = 0\n    for q in range(min(n, m), 0, -1):\n        for i in range(n, q - 1, -1):\n            (l, r) = (q, m)\n            index = -1\n            while l <= r:\n                j = l + (r - l) // 2\n                (i1, j1, i2, j2) = (i - q, j - q, i, j)\n                s = dp[i2][j2] - dp[i2][j1] - dp[i1][j2] + dp[i1][j1]\n                if s / q ** 2 >= k:\n                    index = j\n                    r = j - 1\n                else:\n                    l = j + 1\n            if index != -1:\n                ans += m - index + 1\n    print(ans)\nfor t in range(int(input())):\n    solve()", "import sys\ninput = sys.stdin.readline\n\ndef fxn(mat, n, m, k, o):\n    cnt = 0\n    mn = min(n, m)\n    while o < mn + 1:\n        (i, j) = (o, m)\n        while i < n + 1:\n            x = i - o + 1\n            y = j - o + 1\n            z = mat[i][j] - mat[x - 1][j] - mat[i][y - 1] + mat[x - 1][y - 1]\n            if z / (o * o) < k:\n                i += 1\n            else:\n                (st, ed) = (o, m)\n                while st <= ed:\n                    mid = (st + ed) // 2\n                    x = i - o + 1\n                    y = mid - o + 1\n                    z = mat[i][mid] - mat[x - 1][mid] - mat[i][y - 1] + mat[x - 1][y - 1]\n                    if z / (o * o) < k:\n                        st = mid + 1\n                    else:\n                        ans = mid\n                        ed = mid - 1\n                cnt += m - ans + 1\n                i += 1\n        o += 1\n    return cnt\n\ndef solve():\n    (n, m, k) = map(int, input().split())\n    mat = []\n    (rows, cols) = (n + 1, m + 1)\n    matrix = [[0] * cols for i in range(rows)]\n    for i in range(n):\n        mat.append(list(map(int, input().split())))\n    for i in range(1, n + 1):\n        sm = 0\n        for j in range(1, m + 1):\n            sm += mat[i - 1][j - 1]\n            matrix[i][j] = sm\n    for i in range(1, m + 1):\n        sm = 0\n        for j in range(1, n + 1):\n            sm += matrix[j][i]\n            matrix[j][i] = sm\n    Ans = fxn(matrix, n, m, k, 1)\n    print(Ans)\nfor _ in range(int(input())):\n    solve()", "T = int(input())\nfor _ in range(T):\n    (N, M, K) = map(int, input().split())\n    lst = []\n    l = [0] * (M + 1)\n    lst.append(l)\n    for i in range(N):\n        arr = list(map(int, input().split()))\n        arr.insert(0, 0)\n        for j in range(1, M + 1):\n            arr[j] = arr[j] + arr[j - 1]\n        lst.append(arr)\n    for i in range(2, N + 1):\n        for j in range(1, M + 1):\n            lst[i][j] += lst[i - 1][j]\n    mini = min(N, M)\n    count = 0\n    order = 1\n    while order <= mini:\n        i = order\n        j = M\n        while i <= N:\n            x = i - order + 1\n            y = j - order + 1\n            total = lst[i][j] - lst[x - 1][j] - lst[i][y - 1] + lst[x - 1][y - 1]\n            if total / (order * order) < K:\n                i += 1\n            else:\n                low = order\n                high = M\n                index = 0\n                while low <= high:\n                    mid = (low + high) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    total = lst[i][mid] - lst[x - 1][mid] - lst[i][y - 1] + lst[x - 1][y - 1]\n                    if total / (order * order) < K:\n                        low = mid + 1\n                    else:\n                        index = mid\n                        high = mid - 1\n                count += M - index + 1\n                i += 1\n        order += 1\n    print(count)", "for _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    matrix = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        l = list(map(int, input().split()))\n        for j in range(m):\n            matrix[i][j + 1] = l[j] + matrix[i][j] + matrix[i - 1][j + 1] - matrix[i - 1][j]\n    ans = 0\n    for order in range(1, n + 1):\n        for raw in range(order, n + 1):\n            value = matrix[raw][m] - matrix[raw][m - order] - matrix[raw - order][m] + matrix[raw - order][m - order]\n            if value / (order * order) < k:\n                continue\n            else:\n                start = order\n                end = m\n                index = m + 1\n                while start <= end:\n                    mid = (start + end) // 2\n                    value = matrix[raw][mid] - matrix[raw][mid - order] - matrix[raw - order][mid] + matrix[raw - order][mid - order]\n                    if value / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        end = mid - 1\n                        index = mid\n                ans += m - index + 1\n    print(ans)", "def func(mat, i, j, lo, rs, k):\n    corner = mat[i][j]\n    backone = mat[i - lo - 1][j]\n    backtwo = mat[i][j - lo - 1]\n    remains = mat[i - lo - 1][j - lo - 1]\n    store = corner - backone - backtwo + remains\n    if store - k * rs >= 0:\n        return True\n    return False\nfor v in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    mat = [[0] * (m + 1)]\n    for i in range(n):\n        mat.append([0] + list(map(int, input().split())))\n    temp = [[0 for g in range(m + 1)] for y in range(n + 1)]\n    for j in range(1, m + 1):\n        for i in range(1, n + 1):\n            temp[i][j] = temp[i - 1][j] + temp[i][j - 1] - temp[i - 1][j - 1] + mat[i][j]\n    mat = temp\n    nums = 0\n    lo = 0\n    if n <= m:\n        fans = n\n    else:\n        fans = m\n    while lo < fans:\n        rs = (lo + 1) ** 2\n        i = lo + 1\n        while i < n + 1:\n            low = lo + 1\n            high = m\n            while low <= high:\n                mid = low + (high - low + 1) // 2\n                testcharge = func(mat, i, mid, lo, rs, k)\n                if testcharge:\n                    high = mid - 1\n                else:\n                    low = mid + 1\n            nums += 1 + m - low\n            i += 1\n        lo += 1\n    print(nums)", "def prefixTable(table, dp, n, m):\n    dp[0][0] = table[0][0]\n    for j in range(1, m):\n        dp[0][j] = table[0][j] + dp[0][j - 1]\n    for i in range(1, n):\n        dp[i][0] = table[i][0] + dp[i - 1][0]\n    for i in range(1, n):\n        for j in range(1, m):\n            dp[i][j] = table[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\nfor i in range(int(input())):\n    (n, m, k) = list(map(int, input().split()))\n    table = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        table.append(row)\n    dp = [[0 for i in range(m)] for j in range(n)]\n    prefixTable(table, dp, n, m)\n    dp.insert(0, [0] * m)\n    for i in dp:\n        i.insert(0, 0)\n    mini = min(n, m)\n    total = 0\n    for window in range(0, mini):\n        for j in range(window + 1, n + 1):\n            start = window + 1\n            end = m\n            ans = m + 1\n            while start <= end:\n                mid = (start + end) // 2\n                x = j - (window + 1)\n                y = mid - (window + 1)\n                avg = (dp[j][mid] - dp[x][mid] - dp[j][y] + dp[x][y]) / ((window + 1) * (window + 1))\n                if avg < k:\n                    start = mid + 1\n                elif avg >= k:\n                    ans = mid\n                    end = mid - 1\n            total += m - ans + 1\n    print(total)", "T = int(input())\nfor _ in range(T):\n    (N, M, K) = map(int, input().split())\n    lst = []\n    l = [0] * (M + 1)\n    lst.append(l)\n    for i in range(N):\n        arr = list(map(int, input().split()))\n        arr.insert(0, 0)\n        for j in range(1, M + 1):\n            arr[j] = arr[j] + arr[j - 1]\n        lst.append(arr)\n    for i in range(2, N + 1):\n        for j in range(1, M + 1):\n            lst[i][j] += lst[i - 1][j]\n    mini = min(N, M)\n    count = 0\n    order = 1\n    while order <= mini:\n        i = order\n        j = M\n        while i <= N:\n            x = i - order + 1\n            y = j - order + 1\n            total = lst[i][j] - lst[x - 1][j] - lst[i][y - 1] + lst[x - 1][y - 1]\n            if total / (order * order) < K:\n                i += 1\n            else:\n                low = order\n                high = M\n                index = 0\n                while low <= high:\n                    mid = (low + high) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    total = lst[i][mid] - lst[x - 1][mid] - lst[i][y - 1] + lst[x - 1][y - 1]\n                    if total / (order * order) < K:\n                        low = mid + 1\n                    else:\n                        index = mid\n                        high = mid - 1\n                count += M - index + 1\n                i += 1\n        order += 1\n    print(count)", "def fun(mat, N, M, K, order):\n    count = 0\n    mini = min(N, M)\n    while order < mini + 1:\n        i = order\n        j = M\n        while i < N + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = mat[i][j] - mat[x - 1][j] - mat[i][y - 1] + mat[x - 1][y - 1]\n            checked = z / (order * order)\n            if checked < K:\n                i += 1\n            else:\n                start = order\n                end = M\n                while start <= end:\n                    mid = int(end + (start - end) / 2)\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = mat[i][mid] - mat[x - 1][mid] - mat[i][y - 1] + mat[x - 1][y - 1]\n                    checked = z / (order * order)\n                    if checked < K:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += M - ans + 1\n                i += 1\n        order += 1\n    return count\nT = int(input())\nfor _ in range(T):\n    (N, M, K) = map(int, input().split(' '))\n    a = [0]\n    mat = []\n    mat.append([0] * (M + 1))\n    for i in range(N):\n        a = [0]\n        a.extend(list(map(int, input().split(' '))))\n        mat.append(a)\n    for i in range(N + 1):\n        pre = 0\n        for j in range(M + 1):\n            mat[i][j] += pre\n            pre = mat[i][j]\n    for j in range(M + 1):\n        pre = 0\n        for i in range(N + 1):\n            pre += mat[i][j]\n            mat[i][j] = pre\n    ans = fun(mat, N, M, K, 1)\n    print(ans)", "def search(sum_a, n, m, k, order):\n    count = 0\n    minimum = min(n, m)\n    while order < minimum + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = sum_a[i][j] - sum_a[x - 1][j] - sum_a[i][y - 1] + sum_a[x - 1][y - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m + 1\n                ans = m + 1\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = sum_a[i][mid] - sum_a[x - 1][mid] - sum_a[i][y - 1] + sum_a[x - 1][y - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += m - ans + 1\n                i += 1\n        order += 1\n    return count\nt = int(input())\nfor _ in range(t):\n    (n, m, kc) = map(int, input().split(' '))\n    arr = []\n    ab = [0 for _ in range(m + 1)]\n    arr.append(ab)\n    for _ in range(n):\n        a = list(map(int, input().split(' ')))[:m]\n        a.insert(0, 0)\n        arr.append(a)\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            arr[i][j] += arr[i][j - 1]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            arr[i][j] += arr[i - 1][j]\n    ans = search(arr, n, m, kc, 1)\n    print(ans)", "import itertools\nimport math\n\ndef binaryRow(arr, k, start, n):\n    eles = n * n\n    low = start\n    high = len(arr) - 1\n    lastPossible = -1\n    while low <= high:\n        mid = (low + high) // 2\n        val = arr[mid][-1] - arr[mid - n][-1] - arr[mid][-(1 + n)] + arr[mid - n][-(1 + n)]\n        if val / eles < k:\n            mid = low + 1\n        else:\n            lastPossible = high\n            mid = high - 1\n    return lastPossible\n\ndef binaryCol(arr, k, start, n, row):\n    eles = n * n\n    low = start\n    high = len(arr[0]) - 1\n    lastPossible = -1\n    while low <= high:\n        mid = (low + high) // 2\n        val = arr[row][mid] - arr[row - n][mid] - arr[row][mid - n] + arr[row - n][mid - n]\n        if val / eles < k:\n            low = mid + 1\n        else:\n            lastPossible = mid\n            high = mid - 1\n    return lastPossible\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = [int(i) for i in input().split()]\n    mat = []\n    mat2 = [[0 for i in range(m + 1)]]\n    for i in range(n):\n        line = [int(i) for i in input().split()]\n        mat.append(line)\n    for i in range(n):\n        line = [0]\n        for j in range(m):\n            line.append(mat[i][j] + line[-1])\n        mat2.append(line)\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            mat2[j][i] += mat2[j - 1][i]\n    res = 0\n    for i in range(1, min(n, m) + 1):\n        for j in range(i, n + 1):\n            col = binaryCol(mat2, k, i, i, j)\n            if col != -1:\n                res += m + 1 - col\n    print(res)", "def solve(a, s, n, k):\n    step = 1\n    cntt = 0\n    for x in range(2, n + 1):\n        step += 1\n        j = x\n        for i in range(n, x - 1, -1):\n            while j < m + 1:\n                if (s[i][j] - s[i][j - step] - s[i - step][j] + s[i - step][j - step]) / (step * step) >= k:\n                    cntt += m + 1 - j\n                    break\n                j += 1\n    return cntt\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [[0] * (n + 1)]\n    for i in range(n):\n        a.append([0] + list(map(int, input().split())))\n    s = [[0] * (m + 1) for i in range(n + 1)]\n    cnt = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            s[i][j] = a[i][j] + s[i][j - 1]\n            if a[i][j] >= k:\n                cnt += 1\n    for j in range(1, m + 1):\n        for i in range(1, n + 1):\n            s[i][j] = s[i][j] + s[i - 1][j]\n    print(cnt + solve(a, s, n, k))", "def solve(a, s, n, k):\n    step = 1\n    cntt = 0\n    for x in range(2, n + 1):\n        step += 1\n        j = x\n        for i in range(n, x - 1, -1):\n            while j < m + 1:\n                if (s[i][j] - s[i][j - step] - s[i - step][j] + s[i - step][j - step]) / (step * step) >= k:\n                    cntt += m + 1 - j\n                    break\n                j += 1\n    return cntt\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    a = [[0] * (n + 1)]\n    for i in range(n):\n        a.append([0] + list(map(int, input().split())))\n    s = [[0] * (m + 1) for i in range(n + 1)]\n    cnt = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            s[i][j] = a[i][j] + s[i][j - 1]\n            if a[i][j] >= k:\n                cnt += 1\n    for j in range(1, m + 1):\n        for i in range(1, n + 1):\n            s[i][j] = s[i][j] + s[i - 1][j]\n    print(cnt + solve(a, s, n, k))", "def solve_advanced(n, m, k, matrix):\n    adv_matrix = [[0 for i in range(m + 1)] for j in range(n + 1)]\n    for i in range(n):\n        total1 = 0\n        for j in range(m):\n            total1 += matrix[i][j]\n            adv_matrix[i + 1][j + 1] = total1 + adv_matrix[i][j + 1]\n    total = 0\n    for l in range(1, min(m, n) + 1):\n        for i in range(n - l + 1):\n            start = 0\n            end = m - l\n            idx = None\n            while True:\n                if end - start <= 1:\n                    mdl = end\n                    sm = adv_matrix[i + l][mdl + l] + adv_matrix[i][mdl] - adv_matrix[i + l][mdl] - adv_matrix[i][mdl + l]\n                    if sm / (l * l) >= k:\n                        idx = end\n                    mdl = start\n                    sm = adv_matrix[i + l][mdl + l] + adv_matrix[i][mdl] - adv_matrix[i + l][mdl] - adv_matrix[i][mdl + l]\n                    if sm / (l * l) >= k:\n                        idx = start\n                    break\n                else:\n                    mdl = (start + end) // 2\n                    sm = adv_matrix[i + l][mdl + l] + adv_matrix[i][mdl] - adv_matrix[i + l][mdl] - adv_matrix[i][mdl + l]\n                    if sm / (l * l) >= k:\n                        end = mdl\n                    else:\n                        start = mdl\n            if idx != None:\n                temp = m - l + 1 - idx\n                total += temp\n    return total\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = [int(i) for i in input().split()]\n    matrix = []\n    for i in range(n):\n        matrix.append([int(i) for i in input().split()])\n    print(solve_advanced(n, m, k, matrix))", "def minimum(n, m):\n    if m < n:\n        return m\n    else:\n        return n\n\ndef calculate(n, m, k, order, arr):\n    count = 0\n    min = minimum(n, m)\n    while order < min + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = arr[i][j] - arr[x - 1][j] - arr[i][y - 1] + arr[x - 1][y - 1]\n            if z / (order * order) < float(k):\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = arr[i][mid] - arr[x - 1][mid] - arr[i][y - 1] + arr[x - 1][y - 1]\n                    if z / (order * order) < float(k):\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += m - ans + 1\n                i += 1\n        order += 1\n    return count\n\ndef solve(result):\n    sum = 0\n    linput = input().split()\n    n = int(linput[0])\n    m = int(linput[1])\n    k = int(linput[2])\n    arr = []\n    for i in range(n):\n        linput = input().split()\n        row = []\n        for j in range(m):\n            row.append(int(linput[j]))\n        arr.append(row)\n    for i in range(n):\n        sum = 0\n        for j in range(m):\n            sum += arr[i][j]\n            arr[i][j] = sum\n    for i in range(m):\n        sum = 0\n        for j in range(n):\n            sum += arr[j][i]\n            arr[j][i] = sum\n    arr.insert(0, [0] * m)\n    for i in range(n + 1):\n        arr[i].insert(0, 0)\n    result.append(calculate(n, m, k, 1, arr))\ntest = int(input())\nresult = []\nfor i in range(test):\n    solve(result)\nfor i in range(test):\n    print(result[i])", "def findMaxSumSubMatrix(mat, z):\n    (M, N) = (len(mat), len(mat[0]))\n    sum = [[0 for x in range(N)] for y in range(M)]\n    sum[0][0] = mat[0][0]\n    for j in range(1, N):\n        sum[0][j] = mat[0][j] + sum[0][j - 1]\n    for i in range(1, M):\n        sum[i][0] = mat[i][0] + sum[i - 1][0]\n    for i in range(1, M):\n        for j in range(1, N):\n            sum[i][j] = mat[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1]\n    mi = min(M, N)\n    count = 0\n    for k in range(1, mi + 1):\n        req = z * (k * k)\n        for i in range(k - 1, M):\n            ans = -1\n            s = k - 1\n            e = N - 1\n            while s <= e:\n                j = (s + e) // 2\n                total = sum[i][j]\n                if i - k >= 0:\n                    total = total - sum[i - k][j]\n                if j - k >= 0:\n                    total = total - sum[i][j - k]\n                if i - k >= 0 and j - k >= 0:\n                    total = total + sum[i - k][j - k]\n                if total >= req:\n                    ans = j\n                    s = s\n                    e = j - 1\n                else:\n                    s = j + 1\n                    e = e\n            if ans != -1:\n                count += N - ans\n    return count\nt = int(input())\nfor test in range(t):\n    (n, m, z) = map(int, input().split())\n    arr = []\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        arr.append(temp)\n    ans = findMaxSumSubMatrix(arr, z)\n    print(ans)", "def auxc(a, n, m):\n    w = [[0 for i in range(m + 1)] for j in range(n + 1)]\n    for i in range(n):\n        for j in range(1, m):\n            a[i][j] += a[i][j - 1]\n    for i in range(1, n):\n        for j in range(m):\n            a[i][j] += a[i - 1][j]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            w[i][j] = a[i - 1][j - 1]\n    return w\nhha = [[2, 2, 3], [4, 4, 5], [4, 5, 5]]\n\ndef bs(a, n, m, k):\n    aux = auxc(a, n, m)\n    ans = 0\n    for s in range(1, n + 1):\n        for i in range(1, n - s + 1 + 1):\n            low = 1\n            high = m - s + 1\n            tem = 0\n            ato = 0\n            while low <= high:\n                mid = (low + high) // 2\n                sm = aux[i + s - 1][mid + s - 1] - aux[i + s - 1][mid - 1] - aux[i - 1][mid + s - 1] + aux[i - 1][mid - 1]\n                if sm >= k * s * s:\n                    high = mid - 1\n                    tem = mid\n                    ato = 1\n                else:\n                    low = mid + 1\n            if ato == 1:\n                ans += m - s - tem + 2\n    return ans\nt = int(input())\nwhile t:\n    (n, m, k) = map(int, input().split())\n    a = []\n    for i in range(n):\n        tem = list(map(int, input().split()))\n        a.append(tem)\n    print(bs(a, n, m, k))\n    t = t - 1", "T = int(input())\nfor _ in range(T):\n    (N, M, K) = map(int, input().split())\n    A = []\n    sum = []\n    Ans = 0\n    for x in range(N):\n        A.append([int(y) for y in input().split()])\n    sum.append([])\n    for i in range(N + 1):\n        for j in range(M + 1):\n            if i == 0:\n                sum[i].append(0)\n            elif j == 0:\n                sum.append([0])\n            else:\n                sum[i].append(A[i - 1][j - 1])\n    for i in range(N + 1):\n        prev = 0\n        for j in range(M + 1):\n            sum[i][j] += prev\n            prev = sum[i][j]\n    for j in range(M + 1):\n        prev = 0\n        for i in range(N + 1):\n            sum[i][j] += prev\n            prev = sum[i][j]\n    Min = min(N, M)\n    for ord in range(1, Min + 1):\n        start = ord\n        end = M\n        while start >= 1 and start <= N and (end >= 1) and (end <= M):\n            if (sum[start][end] - sum[start - ord][end] - sum[start][end - ord] + sum[start - ord][end - ord]) / (ord * ord) >= K:\n                Ans += N - start + 1\n                end -= 1\n            else:\n                start += 1\n    print(Ans)", "for z in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    matrix = []\n    for y in range(n):\n        temp = list(map(int, input().split()))\n        temp.insert(0, 0)\n        matrix.append(temp)\n    temp = []\n    for i in range(m + 1):\n        temp.append(0)\n    matrix.insert(0, temp)\n    for i in range(n + 1):\n        Sum = 0\n        for j in range(m + 1):\n            Sum += matrix[i][j]\n            matrix[i][j] = Sum\n    for i in range(m + 1):\n        Sum = 0\n        for j in range(n + 1):\n            Sum += matrix[j][i]\n            matrix[j][i] = Sum\n    order = 1\n    count = 0\n    while order < n + 1:\n        i = order\n        j = m\n        while i < n + 1:\n            x = i - order + 1\n            y = j - order + 1\n            z = matrix[i][j] - matrix[x - 1][j] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n            if z / (order * order) < k:\n                i += 1\n            else:\n                start = order\n                end = m\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = matrix[i][mid] - matrix[x - 1][mid] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n                    if z / (order * order) < k:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += m - ans + 1\n                i += 1\n        order += 1\n    print(count)", "def func(matrix, N, M, K):\n    count = 0\n    minimum = min(N, M)\n    for order in range(1, minimum + 1):\n        for i in range(order, n + 1):\n            j = M\n            x = i - order + 1\n            y = j - order + 1\n            z = matrix[i][j] - matrix[x - 1][j] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n            if z // (order * order) < K:\n                i += 1\n            else:\n                start = order\n                end = M\n                while start <= end:\n                    mid = (start + end) // 2\n                    x = i - order + 1\n                    y = mid - order + 1\n                    z = matrix[i][mid] - matrix[x - 1][mid] - matrix[i][y - 1] + matrix[x - 1][y - 1]\n                    if z // (order * order) < K:\n                        start = mid + 1\n                    else:\n                        ans = mid\n                        end = mid - 1\n                count += M - ans + 1\n        order += 1\n    return count\ntry:\n    for _ in range(int(input())):\n        (n, m, k) = list(map(int, input().split()))\n        matrix = []\n        for i in range(n):\n            matrix.append(list(map(int, input().split())))\n        listColumn = [0] * m\n        matrix.insert(0, listColumn)\n        for i in range(n + 1):\n            matrix[i].insert(0, 0)\n        for i in range(n + 1):\n            prev = 0\n            for j in range(m + 1):\n                matrix[i][j] += prev\n                prev = matrix[i][j]\n        for i in range(m + 1):\n            prev = 0\n            for j in range(n + 1):\n                matrix[j][i] += prev\n                prev = matrix[j][i]\n        print(func(matrix, n, m, k))\nexcept:\n    pass", "try:\n\n    def fun(l, N, M, K, order):\n        count = 0\n        a = min(M, N)\n        while order < a + 1:\n            i = order\n            j = M\n            while i < N + 1:\n                x = i - order + 1\n                y = j - order + 1\n                z = l[i][j] - l[x - 1][j] - l[i][y - 1] + l[x - 1][y - 1]\n                if z / (order * order) < K:\n                    i += 1\n                else:\n                    start = order\n                    end = M\n                    while start <= end:\n                        mid = (start + end) // 2\n                        x = i - order + 1\n                        y = mid - order + 1\n                        z = l[i][mid] - l[x - 1][mid] - l[i][y - 1] + l[x - 1][y - 1]\n                        if z / (order * order) < K:\n                            start = mid + 1\n                        else:\n                            ans = mid\n                            end = mid - 1\n                    count += M - ans + 1\n                    i += 1\n            order += 1\n        return count\n    T = int(input())\n    for i in range(T):\n        (N, M, K) = map(int, input().split())\n        l = []\n        for i in range(N):\n            a = list(map(int, input().split()))\n            l.append(a)\n        for i in range(N):\n            sum = 0\n            for j in range(M):\n                sum += l[i][j]\n                l[i][j] = sum\n        for i in range(M):\n            sum = 0\n            for j in range(N):\n                sum += l[j][i]\n                l[j][i] = sum\n        p = M * [0]\n        l.insert(0, p)\n        for i in l:\n            i.insert(0, 0)\n        A = fun(l, N, M, K, 1)\n        print(A)\nexcept:\n    pass", "def getAnswer(n, m, k, mat):\n    if k > mat[n - 1][m - 1]:\n        return 0\n    count = 0\n    dp = [[0 for i in range(m + 1)] for j in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = mat[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n    for k1 in range(1, min(m, n) + 1):\n        for i in range(1, n + 1 - k1 + 1):\n            li = 1\n            ri = m - k1 + 1\n            md = (li + ri) // 2\n            fg = False\n            si = 0\n            while li <= ri:\n                md = (li + ri) // 2\n                s1 = dp[i + k1 - 1][md + k1 - 1] - dp[i - 1][md + k1 - 1] - dp[i + k1 - 1][md - 1] + dp[i - 1][md - 1]\n                if s1 / (k1 * k1) >= k:\n                    fg = True\n                    si = md\n                    ri = md - 1\n                else:\n                    li = md + 1\n            if fg == True:\n                count = count + m - k1 + 1 - si + 1\n    return count\nt = int(input())\nfor i in range(t):\n    d = list(map(int, input().split(' ')))\n    mat = []\n    for i in range(d[0]):\n        e = list(map(int, input().split(' ')))\n        mat.append(e)\n    ans = getAnswer(d[0], d[1], d[2], mat)\n    print(ans)", "def countGreater(j, L, u, x, z):\n    leftGreater = u + 1\n    mo = u + 1\n    while L <= u:\n        sumi = 0\n        l = int(L + (u - L) / 2)\n        if j - x + 1 == 0:\n            if l - x + 1 > 0:\n                sumi = cot[j][l] - cot[j][l - x]\n            else:\n                sumi = cot[j][l]\n        elif l - x + 1 > 0:\n            sumi = cot[j][l] - cot[j - x][l] - (cot[j][l - x] - cot[j - x][l - x])\n        else:\n            sumi = cot[j][l] - cot[j - x][l]\n        if sumi / (x * x) >= z:\n            leftGreater = l\n            u = l - 1\n        else:\n            L = l + 1\n    return mo - leftGreater\n\ndef cou(k, v):\n    count = 0\n    h = 10 ** 6\n    for j in range(k - 1, n):\n        gh = countGreater(j, k - 1, m - 1, k, v)\n        count = count + gh\n        if gh == m - (k - 1):\n            count = count + (n - (j + 1)) * (m - (k - 1))\n            break\n    return count\nq = int(input())\nfor i in range(q):\n    (n, m, r) = map(int, input().split())\n    cot = []\n    for j in range(n):\n        cot.append(list(map(int, input().split())))\n    mount = 0\n    bount = 0\n    for j in range(n):\n        mount = 0\n        for l in range(m):\n            mount = mount + cot[j][l]\n            if j == 0:\n                cot[j][l] = mount\n            else:\n                cot[j][l] = mount + cot[j - 1][l]\n    for j in range(1, min(n, m) + 1):\n        bount = bount + cou(j, r)\n    print(bount)", "def precomputed(matrix):\n    dp = [[0 for j in range(len(matrix[0]))] for i in range(len(matrix))]\n    for i in range(0, len(matrix)):\n        for j in range(0, len(matrix[0])):\n            dp[i][j] = 0\n    dp[0][0] = matrix[0][0]\n    for j in range(1, len(matrix[0])):\n        dp[0][j] = matrix[0][j] + dp[0][j - 1]\n    for i in range(1, len(matrix)):\n        dp[i][0] = matrix[i][0] + dp[i - 1][0]\n    for i in range(1, len(matrix)):\n        for j in range(1, len(matrix[0])):\n            dp[i][j] = matrix[i][j] + dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n    return dp\n\ndef calculateno(precompmat, matrix, count, k):\n    dsarr = 2\n    while dsarr <= len(matrix):\n        matrixno = dsarr - 1\n        for i in range(dsarr - 1, len(matrix)):\n            target = k * pow(dsarr, 2)\n            pos = binarysearchpos(matrix[i], target, dsarr - 1, precompmat, matrixno)\n            if pos == -1:\n                count += 0\n            else:\n                count += len(matrix[0]) - pos\n            matrixno += 1\n        dsarr += 1\n    return count\n\ndef countSquares(m, n):\n    if n < m:\n        temp = m\n        m = n\n        n = temp\n    return m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2\n\ndef binarysearchpos(arr, k, start, matrix, cols):\n    x = len(matrix[0]) - 1\n    (leftmove, rightmove) = (start + 1, cols)\n    if x - leftmove >= 0 and rightmove - leftmove >= 0:\n        value = matrix[cols][-1] - matrix[cols][x - leftmove] - matrix[rightmove - leftmove][x] + matrix[rightmove - leftmove][x - leftmove]\n    elif x - leftmove >= 0:\n        value = matrix[cols][-1] - matrix[cols][x - leftmove]\n    elif rightmove - leftmove >= 0:\n        value = matrix[cols][-1] - matrix[rightmove - leftmove][x]\n    else:\n        value = matrix[cols][-1]\n    if value < k:\n        return -1\n    else:\n        end = len(arr) - 1\n        x = len(matrix[0]) - 1\n        (leftmove, rightmove) = (start + 1, cols)\n        while start < end:\n            mid = start + (end - start) // 2\n            if mid - leftmove >= 0 and rightmove - leftmove >= 0:\n                value = matrix[cols][mid] - matrix[cols][mid - leftmove] - matrix[rightmove - leftmove][mid] + matrix[rightmove - leftmove][mid - leftmove]\n            elif mid - leftmove >= 0:\n                value = matrix[cols][mid] - matrix[cols][mid - leftmove]\n            elif rightmove - leftmove >= 0:\n                value = matrix[cols][mid] - matrix[rightmove - leftmove][mid]\n            else:\n                value = matrix[cols][mid]\n            if value >= k:\n                end = mid\n            else:\n                start = mid + 1\n        return end\nt = int(input())\nwhile t > 0:\n    temp = list(map(int, input().split()))\n    (N, M, K) = (temp[0], temp[1], temp[2])\n    (matrix, norow) = ([], N)\n    while norow:\n        arr = list(map(int, input().split()))\n        matrix.append(arr)\n        norow -= 1\n    if K == 0:\n        finalans = countSquares(M, N)\n        print(int(finalans))\n        t -= 1\n        continue\n    count = 0\n    for i in range(0, N):\n        for j in range(0, M):\n            if matrix[i][j] >= K:\n                count += 1\n    precompmat = precomputed(matrix)\n    finalans = calculateno(precompmat, matrix, count, K)\n    print(finalans)\n    t = t - 1", "def bsearch(aux, k, m, size, i):\n    lo = size\n    hi = m\n    ans = 0\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        x = i - size + 1\n        y = mid - size + 1\n        subsum = aux[i][mid] - aux[x - 1][mid] - aux[i][y - 1] + aux[x - 1][y - 1]\n        avg = subsum / size ** 2\n        if avg < k:\n            lo = mid + 1\n        else:\n            ans = mid\n            hi = mid - 1\n    return ans\n\ndef count(aux, n, m, k):\n    ans = 0\n    for size in range(1, n + 1):\n        i = size\n        j = m\n        while i < n + 1:\n            x = i - size + 1\n            y = j - size + 1\n            subsum = aux[i][j] - aux[x - 1][j] - aux[i][y - 1] + aux[x - 1][y - 1]\n            avg = subsum / size ** 2\n            if avg < k:\n                i += 1\n            else:\n                f = bsearch(aux, k, m, size, i)\n                ans += m - f + 1\n                i += 1\n    return ans\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = [int(k) for k in input().split()]\n    mat = []\n    aux = [[0] * (m + 1)]\n    for j in range(n):\n        mat.append([int(c) for c in input().split()])\n        aux.append([0 for x in range(m + 1)])\n    ans = 0\n    for l in range(0, n):\n        s = 0\n        for b in range(0, m):\n            s += mat[l][b]\n            mat[l][b] = s\n            aux[l + 1][b + 1] = mat[l][b]\n    for l in range(0, m):\n        s = 0\n        for b in range(0, n):\n            s += mat[b][l]\n            mat[b][l] = s\n            aux[b + 1][l + 1] = mat[b][l]\n    ans = count(aux, n, m, k)\n    print(ans)", "def summer(a, b, x, y, l, pre):\n    (prev, ptr) = pre\n    if y > 0:\n        t = c[x][y + l - 1] - c[x][y - 1]\n    else:\n        t = c[x][y + l - 1]\n    if y == ptr:\n        return prev + t + b[x + l - 1][y + l - 1] - b[x][y + l - 1]\n    else:\n        return prev + t + b[x + l - 1][y] - b[x][y]\nfor _ in range(int(input())):\n    (a, b, c) = ([], [], [])\n    (n, m, k) = list(map(int, input().split()))\n    for i in range(n):\n        x = list(map(int, input().split()))\n        a.append(x)\n    if a[0][0] >= k:\n        s = 0\n        for i in range(min(n, m)):\n            s += (n - i) * (m - i)\n        print(s)\n        continue\n    if a[-1][-1] < k:\n        print(0)\n        continue\n    b.append(a[0])\n    y = [a[0][0]]\n    for j in range(1, m):\n        y.append(y[j - 1] + a[0][j])\n    c.append(y)\n    for i in range(1, n):\n        (x, y) = ([], [])\n        for j in range(m):\n            if j:\n                y.append(y[j - 1] + a[i][j])\n            else:\n                y.append(a[i][j])\n            x.append(a[i][j] + b[i - 1][j])\n        b.append(x)\n        c.append(y)\n    (start, count, max_l) = (0, 0, min(n, m))\n    for i in range(m):\n        if a[n - 1][i] >= k:\n            start = i\n            break\n    (i, j) = (n - 1, start)\n    while i >= 0 and j < m:\n        if a[i][j] >= k:\n            count += m - j\n            i -= 1\n        else:\n            j += 1\n    prev = [a[n - 1][start], start]\n    for l in range(2, max_l + 1):\n        (i, j) = (n - l, start - l + 1)\n        if j < 0:\n            j = 0\n        s = summer(a, b, i, j, l, prev)\n        prev = [s, j]\n        target = k * l ** 2\n        while i >= 0 and j <= m - l:\n            temp = 0\n            if s >= target:\n                count += m - l - j + 1\n                i -= 1\n                if i < 0:\n                    break\n                if j > 0:\n                    t1 = c[i][j + l - 1] - c[i][j - 1]\n                    t2 = c[i + l][j + l - 1] - c[i + l][j - 1]\n                    s += t1 - t2\n                else:\n                    s += c[i][j + l - 1] - c[i + l][j + l - 1]\n            else:\n                j += 1\n                if j > m - l:\n                    break\n                if i > 0:\n                    t1 = b[i + l - 1][j + l - 1] - b[i - 1][j + l - 1]\n                    t2 = b[i + l - 1][j - 1] - b[i - 1][j - 1]\n                    s += t1 - t2\n                else:\n                    s += b[i + l - 1][j + l - 1] - b[i + l - 1][j - 1]\n    print(count)", "def summer(a, b, x, y, l, pre):\n    (prev, ptr) = pre\n    temp = 0\n    if y == ptr:\n        for i in range(l):\n            temp += a[x][y + i]\n        return prev + temp + b[x + l - 1][y + l - 1] - b[x][y + l - 1]\n    else:\n        for i in range(l):\n            temp += a[x][y + i]\n        return prev + temp + b[x + l - 1][y] - b[x][y]\nfor _ in range(int(input())):\n    (a, b, c) = ([], [], [])\n    (n, m, k) = list(map(int, input().split()))\n    for i in range(n):\n        x = list(map(int, input().split()))\n        a.append(x)\n    if a[0][0] >= k:\n        s = 0\n        for i in range(min(n, m)):\n            s += (n - i) * (m - i)\n        print(s)\n        continue\n    if a[-1][-1] < k:\n        print(0)\n        continue\n    b.append(a[0])\n    y = [a[0][0]]\n    for j in range(1, m):\n        y.append(y[j - 1] + a[0][j])\n    c.append(y)\n    for i in range(1, n):\n        (x, y) = ([], [])\n        for j in range(m):\n            if j:\n                y.append(y[j - 1] + a[i][j])\n            else:\n                y.append(a[i][j])\n            x.append(a[i][j] + b[i - 1][j])\n        b.append(x)\n        c.append(y)\n    (start, count, max_l) = (0, 0, min(n, m))\n    for i in range(m):\n        if a[n - 1][i] >= k:\n            start = i\n            break\n    (i, j) = (n - 1, start)\n    while i >= 0 and j < m:\n        if a[i][j] >= k:\n            count += m - j\n            i -= 1\n        else:\n            j += 1\n    prev = [a[n - 1][start], start]\n    for l in range(2, max_l + 1):\n        (i, j) = (n - l, start - l + 1)\n        if j < 0:\n            j = 0\n        s = summer(a, b, i, j, l, prev)\n        prev = [s, j]\n        target = k * l ** 2\n        while i >= 0 and j <= m - l:\n            temp = 0\n            if s >= target:\n                count += m - l - j + 1\n                i -= 1\n                if i < 0:\n                    break\n                if j > 0:\n                    t1 = c[i][j + l - 1] - c[i][j - 1]\n                    t2 = c[i + l][j + l - 1] - c[i + l][j - 1]\n                    s += t1 - t2\n                else:\n                    s += c[i][j + l - 1] - c[i + l][j + l - 1]\n            else:\n                j += 1\n                if j > m - l:\n                    break\n                if i > 0:\n                    t1 = b[i + l - 1][j + l - 1] - b[i - 1][j + l - 1]\n                    t2 = b[i + l - 1][j - 1] - b[i - 1][j - 1]\n                    s += t1 - t2\n                else:\n                    s += b[i + l - 1][j + l - 1] - b[i + l - 1][j - 1]\n    print(count)", "def binarysearch(res, l, i, j):\n    lo = 1\n    hi = l\n    while lo < hi:\n        mid = lo + (hi - lo + 1) // 2\n        if res[i][j] - res[i - mid][j] - res[i][j - mid] + res[i - mid][j - mid] >= 0:\n            lo = mid\n        else:\n            hi = mid - 1\n    if res[i][j] - res[i - lo][j] - res[i][j - lo] + res[i - lo][j - lo] >= 0:\n        return lo\n    return 0\nt = int(input())\nwhile t:\n    t -= 1\n    (n, m, k) = list(map(int, input().split()))\n    res = [[0 for i in range(m + 1)] for j in range(n + 1)]\n    for i in range(n):\n        temp = list(map(int, input().split()))\n        for j in range(m):\n            res[i + 1][j + 1] = temp[j] - k + res[i][j + 1] + res[i + 1][j] - res[i][j]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            l = min(i, j)\n            ans += binarysearch(res, l, i, j)\n    print(ans)", "t = int(input())\nfor _ in range(t):\n    ans = 0\n    (n, m, k) = map(int, input().split(' '))\n    a = []\n    for i in range(n):\n        a.append(list(map(int, input().split(' '))))\n    b = [[0 for j in range(m + 1)] for i in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            b[i][j] = a[i - 1][j - 1] + (b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1])\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            x1 = min(n - i, m - j)\n            if a[i - 1][j - 1] >= k:\n                if n - i >= m - j:\n                    ans += (x1 + 1) * (x1 + 2) // 2\n                    break\n                else:\n                    ans += (x1 + 1) * (x1 + 2) // 2 + (m - j - n + i) * (n - i + 1)\n                    break\n            else:\n                tans = 0\n                tp = 0\n                tr = 2 * x1\n                if tp != tr:\n                    while tp + 1 != tr and tp < x1:\n                        tq = (tp + tr) // 2\n                        if k * (tq + 1) * (tq + 1) <= b[i + tq][j + tq] - b[i + tq][j - 1] - b[i - 1][j + tq] + b[i - 1][j - 1]:\n                            tr = tq\n                        else:\n                            tp = tq\n                    if tp < x1:\n                        tans = x1 - tr + 1\n                    else:\n                        tans = 0\n                else:\n                    tans = 0\n                ans += tans\n    print(ans)"]