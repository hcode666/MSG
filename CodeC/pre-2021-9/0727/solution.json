["t = int(input())\nfor t_ in range(t):\n    (n, k) = list(map(int, input().split()))\n    d = {}\n    for _ in range(n):\n        arr = frozenset(map(int, input().split()[1:]))\n        if arr not in d:\n            d[arr] = 0\n        d[arr] += 1\n    ans = 0\n    for s1 in d.keys():\n        if len(s1) == k:\n            ans += d[s1] * (d[s1] - 1)\n        for s2 in d.keys():\n            if s1 != s2 and len(s1 | s2) == k:\n                ans += d[s1] * d[s2]\n    print(ans // 2)", "t = int(input())\nfor t_ in range(t):\n    (n, k) = list(map(int, input().split()))\n    d = {}\n    for _ in range(n):\n        arr = frozenset(map(int, input().split()[1:]))\n        if arr not in d:\n            d[arr] = 0\n        d[arr] += 1\n    ans = 0\n    for s1 in d.keys():\n        if len(s1) == k:\n            ans += d[s1] * (d[s1] - 1)\n        for s2 in d.keys():\n            if s1 != s2 and len(s1 | s2) == k:\n                ans += d[s1] * d[s2]\n    print(ans // 2)", "t = int(input())\nfor t_ in range(t):\n    (n, k) = list(map(int, input().split()))\n    d = {}\n    for _ in range(n):\n        arr = frozenset(map(int, input().split()[1:]))\n        if arr not in d:\n            d[arr] = 0\n        d[arr] += 1\n    ans = 0\n    for s1 in d.keys():\n        if len(s1) == k:\n            ans += d[s1] * (d[s1] - 1)\n        for s2 in d.keys():\n            if s1 != s2 and len(s1 | s2) == k:\n                ans += d[s1] * d[s2]\n    print(ans // 2)", "t = int(input())\nfor t_ in range(t):\n    (n, k) = list(map(int, input().split()))\n    d = {}\n    for _ in range(n):\n        arr = frozenset(map(int, input().split()[1:]))\n        if arr not in d:\n            d[arr] = 0\n        d[arr] += 1\n    ans = 0\n    for s1 in d.keys():\n        if len(s1) == k:\n            ans += d[s1] * (d[s1] - 1)\n        for s2 in d.keys():\n            if s1 != s2 and len(s1 | s2) == k:\n                ans += d[s1] * d[s2]\n    print(ans // 2)", "t = int(input())\nfor t_ in range(t):\n    (n, k) = list(map(int, input().split()))\n    d = {}\n    for _ in range(n):\n        arr = frozenset(map(int, input().split()[1:]))\n        if arr not in d:\n            d[arr] = 0\n        d[arr] += 1\n    ans = 0\n    for s1 in d.keys():\n        if len(s1) == k:\n            ans += d[s1] * (d[s1] - 1)\n        for s2 in d.keys():\n            if s1 != s2 and len(s1 | s2) == k:\n                ans += d[s1] * d[s2]\n    print(ans // 2)", "t = int(input())\nfor t_ in range(t):\n    (n, k) = list(map(int, input().split()))\n    d = {}\n    for _ in range(n):\n        arr = frozenset(map(int, input().split()[1:]))\n        if arr not in d:\n            d[arr] = 0\n        d[arr] += 1\n    ans = 0\n    for s1 in d.keys():\n        if len(s1) == k:\n            ans += d[s1] * (d[s1] - 1)\n        for s2 in d.keys():\n            if s1 != s2 and len(s1 | s2) == k:\n                ans += d[s1] * d[s2]\n    print(ans // 2)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    sets = {}\n    ans = 0\n    for i in range(n):\n        arr = input().split()\n        arr.remove(arr[0])\n        arr = frozenset(arr)\n        if arr in sets.keys():\n            sets[arr] += 1\n        else:\n            sets[arr] = 1\n    for i in sets.keys():\n        if len(i) == k:\n            ans += sets[i] * (sets[i] - 1)\n    for i in sets.keys():\n        for j in sets.keys():\n            if i != j and len(i.union(j)) == k:\n                ans += sets[i] * sets[j]\n    print(int(ans / 2))", "for _ in range(int(input())):\n    (n, k) = map(int, input().strip().split())\n    list1 = list()\n    dummy = set([i for i in range(1, k + 1)])\n    for i in range(n):\n        list1.append(list(map(int, input().strip().split())))\n        list1[i] = set(list1[i][1:])\n    count = 0\n    ext = []\n    for i in list1:\n        a = dummy - i\n        ext.append(a)\n    for (i, s) in enumerate(ext):\n        for s1 in list1[i + 1:]:\n            if s.issubset(s1):\n                count += 1\n    print(count)", "for _ in range(int(input())):\n    l = []\n    (n, k) = map(int, input().split())\n    z = set([i for i in range(1, k + 1)])\n    for i in range(n):\n        s = [int(i) for i in input().split()]\n        s = set(s[1:])\n        l.append(s)\n    extra = []\n    for i in l:\n        req = z - i\n        extra.append(req)\n    cnt = 0\n    for (i, s) in enumerate(extra):\n        for s1 in l[i + 1:]:\n            if s.issubset(s1):\n                cnt += 1\n    print(cnt)", "for _ in range(int(input())):\n    (N, K) = map(int, input().split())\n    sets = []\n    for j in range(N):\n        l = [int(x) for x in input().split()]\n        sets.append(set(l[1:]))\n    target = set((x for x in range(1, K + 1)))\n    setcomp = []\n    count = 0\n    for k in sets:\n        rem = target - k\n        setcomp.append(rem)\n    for (a, setcomps) in enumerate(setcomp):\n        for set1 in sets[a + 1:]:\n            if setcomps.issubset(set1):\n                count += 1\n    print(count)", "T = int(input())\nfor _ in range(T):\n    (n, k) = map(int, input().split())\n    sets = {}\n    ans = 0\n    for c in range(n):\n        inp = list(map(int, input().split()))\n        del inp[0]\n        inp = frozenset(inp)\n        if inp in sets.keys():\n            sets[inp] += 1\n        else:\n            sets[inp] = 1\n    for z in sets.keys():\n        if len(z) == k:\n            ans += sets[z] * (sets[z] - 1)\n    for a in sets.keys():\n        for b in sets.keys():\n            if a != b and len(a.union(b)) == k:\n                ans += sets[a] * sets[b]\n    print(ans // 2)", "for _ in range(int(input())):\n    (n, k) = map(int, input().split())\n    (arr, ans) = (dict(), 0)\n    for _ in range(n):\n        s = [int(i) for i in input().split()]\n        s.pop(0)\n        s = frozenset(s)\n        if s in arr:\n            arr[s] += 1\n        else:\n            arr[s] = 1\n    for keys in arr:\n        if len(keys) == k:\n            ans += arr[keys] * (arr[keys] - 1)\n    for a in arr:\n        for b in arr:\n            if a != b and len(a.union(b)) == k:\n                ans += arr[a] * arr[b]\n    print(ans // 2)", "def method_hard():\n    A = [None] * n\n    cnt = [0] * (k + 1)\n    for i in range(n):\n        A[i] = list(map(int, input().split()[1:]))\n        for j in A[i]:\n            cnt[j] += 1\n    minIdx = 1\n    minValue = cnt[1]\n    for i in range(2, k + 1):\n        if minValue > cnt[i]:\n            minValue = cnt[i]\n            minIdx = i\n    cmp = lambda x: (cnt[x], x)\n    for i in range(n):\n        A[i].sort(key=cmp)\n    tmp = [i for i in range(1, k + 1)]\n    tmp.sort(key=cmp)\n    containMinIdx = {}\n    ans = 0\n    for i in range(n):\n        containMinIdx[i] = minIdx in A[i]\n        if not containMinIdx[i]:\n            continue\n        idx = 0\n        f = []\n        for v in tmp:\n            if idx == len(A[i]) or A[i][idx] != v:\n                f.append(v)\n            else:\n                idx += 1\n        for j in range(n):\n            if j <= i and containMinIdx[j]:\n                continue\n            lenf = len(f)\n            idxf = 0\n            for z in A[j]:\n                if idxf == lenf:\n                    break\n                if cnt[z] <= cnt[f[idxf]]:\n                    if z == f[idxf]:\n                        idxf += 1\n                else:\n                    break\n            if idxf == lenf:\n                ans += 1\n    print(ans)\n\ndef method_easy():\n    A = []\n    for i in range(n):\n        tmp = list(map(int, input().split()))\n        tmp.pop(0)\n        mask = 0\n        for v in tmp:\n            mask |= 1 << v - 1\n        A.append(mask)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i] | A[j] == (1 << k) - 1:\n                ans += 1\n    print(ans)\n\ndef solve():\n    global n, k\n    (n, k) = map(int, input().split())\n    if k > 0:\n        method_hard()\n    else:\n        method_easy()\nT = int(input())\nwhile T > 0:\n    solve()\n    T -= 1", "def method_hard():\n    A = [None] * n\n    cnt = [0] * (k + 1)\n    for i in range(n):\n        A[i] = list(map(int, input().split()[1:]))\n        for j in A[i]:\n            cnt[j] += 1\n    minIdx = 1\n    minValue = cnt[1]\n    for i in range(2, k + 1):\n        if minValue > cnt[i]:\n            minValue = cnt[i]\n            minIdx = i\n    cmp = lambda x: (cnt[x], x)\n    for i in range(n):\n        A[i].sort(key=cmp)\n    tmp = [i for i in range(1, k + 1)]\n    tmp.sort(key=cmp)\n    containMinIdx = {}\n    ans = 0\n    for i in range(n):\n        containMinIdx[i] = minIdx in A[i]\n        if not containMinIdx[i]:\n            continue\n        idx = 0\n        f = []\n        for v in tmp:\n            if idx == len(A[i]) or A[i][idx] != v:\n                f.append(v)\n            else:\n                idx += 1\n        for j in range(n):\n            if j <= i and containMinIdx[j]:\n                continue\n            lenf = len(f)\n            idxf = 0\n            for z in A[j]:\n                if idxf == lenf:\n                    break\n                if cnt[z] <= cnt[f[idxf]]:\n                    if z == f[idxf]:\n                        idxf += 1\n                else:\n                    break\n            if idxf == lenf:\n                ans += 1\n    print(ans)\n\ndef method_easy():\n    A = []\n    for i in range(n):\n        tmp = list(map(int, input().split()))\n        tmp.pop(0)\n        mask = 0\n        for v in tmp:\n            mask |= 1 << v - 1\n        A.append(mask)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i] | A[j] == (1 << k) - 1:\n                ans += 1\n    print(ans)\n\ndef solve():\n    global n, k\n    (n, k) = map(int, input().split())\n    if k > 30:\n        method_hard()\n    else:\n        method_easy()\nT = int(input())\nwhile T > 0:\n    solve()\n    T -= 1", "t = int(input())\nfor t0 in range(t):\n    s = [int(i) for i in input().strip().split()]\n    (n, k) = (s[0], s[1])\n    st = []\n    ts1 = []\n    ts2 = []\n    for i in range(n):\n        s = [int(i) for i in input().strip().split()]\n        m = s[0]\n        del s[0]\n        st.append(set(s))\n    tot = 0\n    cts = [0 for i in range(k + 1)]\n    cts[0] = n + 1\n    for i in range(n):\n        for j in st[i]:\n            cts[j] += 1\n    mn = min(cts)\n    ind = cts.index(mn)\n    l1 = 0\n    l2 = 0\n    fl = set([i for i in range(1, k + 1)])\n    for i in range(n):\n        if ind in st[i]:\n            ts1.append(fl - st[i])\n            l1 += 1\n        else:\n            l2 += 1\n            ts2.append(st[i])\n    for i in range(l1):\n        for j in range(i + 1, l1):\n            fl = 0\n            for p in ts1[i]:\n                if p in ts1[j]:\n                    fl = 1\n                    break\n            if fl == 0:\n                tot += 1\n        for j in range(l2):\n            fl = 0\n            for p in ts1[i]:\n                if p not in ts2[j]:\n                    fl = 1\n                    break\n            if fl == 0:\n                tot += 1\n    print(tot)", "import copy\n\ndef main(args):\n    t = int(input())\n    while t > 0:\n        (n, k) = input().split()\n        (n, k) = (int(n), int(k))\n        wholeset = set((i for i in range(1, k + 1)))\n        a = [[] for i in range(n)]\n        for i in range(n):\n            input_stream = input().split()\n            a[i] = set(map(int, input_stream[1:]))\n        c = 0\n        for i in range(n):\n            diffset = wholeset - a[i]\n            for j in range(i + 1, n):\n                if find_set(diffset, a[j]):\n                    c += 1\n        print(c)\n        t -= 1\n\ndef find_set(set1, set2):\n    for i in set1:\n        if i not in set2:\n            return False\n    return True\nimport sys\nsys.exit(main(sys.argv))", "num_tests = int(input())\nfor _ in range(num_tests):\n    (n, k) = map(int, input().split())\n    num_lists = []\n    for _ in range(n):\n        num_lists.append([int(i) for i in input().split()])\n    containing = [set([]) for _ in range(k + 1)]\n    total = 0\n    num_lists.sort(key=len)\n    for i in range(n):\n        nums = num_lists[i]\n        if len(nums) >= k // 2:\n            num_set = set(nums[1:])\n            possible_complements = None\n            for j in range(1, k + 1):\n                if j not in num_set:\n                    if possible_complements is None:\n                        possible_complements = set(containing[j])\n                    else:\n                        possible_complements &= containing[j]\n            total += i if possible_complements is None else len(possible_complements)\n        for num in nums[1:]:\n            containing[num].add(i)\n    print(total)", "class Node:\n\n    def __init__(self, arr):\n        self.set = set(arr[1:])\n        self.size = arr[0]\n        self.counter = 1\ncases = int(input())\nfor i in range(cases):\n    (n, k) = [int(n) for n in input().split(' ')]\n    total_sets = 0\n    lists = []\n    dict = {}\n    for j in range(n):\n        row = [int(n) for n in input().split(' ')]\n        new_node = Node(row)\n        if str(new_node.set) not in dict:\n            dict.update({str(new_node.set): new_node})\n        else:\n            dict[str(new_node.set)].counter += 1\n    lists = sorted(list(dict.values()), key=lambda node: node.size, reverse=True)\n    new_n = len(lists)\n    for outer in range(new_n):\n        if lists[outer].size == k:\n            total_sets += lists[outer].counter * n - lists[outer].counter * (lists[outer].counter + 1) / 2\n            continue\n        if lists[outer].size < k / 2:\n            break\n        for inner in range(outer + 1, new_n):\n            if k - lists[outer].size > lists[inner].size:\n                break\n            elif len(lists[outer].set.union(lists[inner].set)) == k:\n                total_sets += lists[inner].counter * lists[outer].counter\n    print(int(total_sets))", "def binomial(n, k):\n    if 0 <= k <= n:\n        ntok = 1\n        ktok = 1\n        for t in range(1, min(k, n - k) + 1):\n            ntok *= n\n            ktok *= t\n            n -= 1\n        return int(ntok / ktok)\n    else:\n        return 0\nt = int(input())\nfor z in range(t):\n    (n, k) = input().split()\n    n = int(n)\n    k = int(k)\n    a = []\n    ret = 0\n    d = dict()\n    bla = 0\n    for i in range(n):\n        a.append([int(x) for x in input().split()])\n        if len(a[i]) == k + 1:\n            ret = ret + n - 1 - bla\n            bla += 1\n            a[i] = []\n        else:\n            for ai in a[i][1:]:\n                if ai in d:\n                    d[ai].add(i)\n                else:\n                    d[ai] = set()\n                    d[ai].add(i)\n    if bla == n:\n        print(binomial(n, 2))\n        continue\n    if len(d) != k and bla == 0:\n        print(0)\n        continue\n    hlp = set()\n    d1 = sorted(d, key=lambda k: len(d[k]))\n    for t in d[d1[0]]:\n        st = set(list(range(1, k + 1))) - set(a[t][1:])\n        tmp = 1\n        flag = 0\n        while flag == 0 and tmp < len(d1):\n            if d1[tmp] in st:\n                flag = 1\n            else:\n                tmp += 1\n        if flag == 0:\n            continue\n        for y in d[d1[tmp]]:\n            if t != y and st <= set(a[y][1:]) and ((t, y) not in hlp):\n                ret = ret + 1\n                if d1[0] in set(a[y][1:]):\n                    hlp.add((t, y))\n                    hlp.add((y, t))\n    print(ret)", "t = int(input())\nfor t0 in range(t):\n    s = [int(i) for i in input().strip().split()]\n    (n, k) = (s[0], s[1])\n    st = []\n    ts1 = []\n    ts2 = []\n    for i in range(n):\n        s = [int(i) for i in input().strip().split()]\n        m = s[0]\n        del s[0]\n        st.append(set(s))\n    tot = 0\n    cts = [0 for i in range(k + 1)]\n    cts[0] = n + 1\n    for i in range(n):\n        for j in st[i]:\n            cts[j] += 1\n    mn = min(cts)\n    ind = cts.index(mn)\n    l1 = 0\n    l2 = 0\n    fl = set([i for i in range(1, k + 1)])\n    for i in range(n):\n        if ind in st[i]:\n            ts1.append(fl - st[i])\n            l1 += 1\n        else:\n            l2 += 1\n            ts2.append(st[i])\n    for i in range(l1):\n        for j in range(i + 1, l1):\n            fl = 0\n            for p in ts1[i]:\n                if p in ts1[j]:\n                    fl = 1\n                    break\n            if fl == 0:\n                tot += 1\n        for j in range(l2):\n            fl = 0\n            for p in ts1[i]:\n                if p not in ts2[j]:\n                    fl = 1\n                    break\n            if fl == 0:\n                tot += 1\n    print(tot)", "for t in range(int(input())):\n    (n, k) = [int(x) for x in input().strip().split()]\n    valid = [set() for ki in range(k)]\n    mysets = sorted(([int(x) - 1 for x in input().strip().split()] for myset in range(n)))\n    can_match_len = k // 2 - 1\n    ans = 0\n    for (mysetsi, myset) in enumerate(mysets):\n        if myset[0] < can_match_len:\n            for si in myset[1:]:\n                valid[si].add(mysetsi)\n        else:\n            matches = None\n            myset = sorted(myset[1:])\n            myseti = 0\n            for i in range(k):\n                if myseti < len(myset) and i == myset[myseti]:\n                    myseti += 1\n                    valid[i].add(mysetsi)\n                elif matches is not None:\n                    matches = valid[i].intersection(matches)\n                else:\n                    matches = valid[i]\n            ans += len(matches) if matches is not None else mysetsi\n    print(ans)", "def search_value(l, v, start_index):\n    end_index = len(l)\n    index = start_index\n    while index < end_index and l[index] < v:\n        index += 1\n    if index < end_index and l[index] == v:\n        return (1, index)\n    return (0, index)\n\ndef check_completion(list1, list2, K):\n    index1 = 0\n    index2 = 0\n    for i in range(1, K + 1):\n        (found, index1) = search_value(list1, i, index1)\n        if not found:\n            (found, index2) = search_value(list2, i, index2)\n        if not found:\n            return 0\n    return 1\n\ndef solve(bit_sets, expected_result):\n    result = 0\n    N = len(bit_sets)\n    for i in range(N):\n        s = bit_sets[i]\n        for j in range(i + 1, N):\n            if s | bit_sets[j] == expected_result:\n                result += 1\n    return result\n\ndef make_bit_set(l, init_value):\n    s = init_value\n    for i in l:\n        s |= 1 << i\n    return s\nT = int(input())\nfor t in range(T):\n    (N, K) = [int(x) for x in input().split()]\n    bit_sets = []\n    init_value = 1 << K + 1\n    expected_result = (init_value << 1) - 1 - 1\n    for n in range(N):\n        line = [int(x) for x in input().split()]\n        s = make_bit_set(line[1:], init_value)\n        bit_sets.append(s)\n    print(solve(bit_sets, expected_result))", "t = int(input())\nfor i in range(t):\n    (n, k) = list(map(int, input().split()))\n    a = []\n    b = []\n    c = 0\n    yu = 0\n    for j in range(n):\n        e = list(map(int, input().split()))\n        l = e[0]\n        e = e[1:]\n        if l == k:\n            a.append(set(e))\n        elif len(b) > 0:\n            r = set(e)\n            if d == r and yu > 0:\n                c += yu\n                b.append(r)\n            else:\n                yu = 0\n                for nj in b:\n                    if len(nj.union(r)) == k:\n                        c += 1\n                        yu += 1\n                b.append(r)\n                d = r\n        else:\n            d = set(e)\n            b.append(d)\n    if len(a) >= 1:\n        c = c + ((n - 1) * len(a) - len(a) * (len(a) - 1) // 2)\n    print(c)", "import bisect\nT = int(input())\nfor _ in range(T):\n    (N, K) = list(map(int, input().strip().split(' ')))\n    if K > 1000 or (N <= 250 and K <= 250):\n        Set = []\n        length = []\n        for i in range(N):\n            A = list(map(int, input().strip().split(' ')))\n            length += [A[0]]\n            A = A[1:]\n            x = 0\n            for i in range(len(A)):\n                x += 2 ** (A[i] - 1)\n            Set += [[len(A), x]]\n        Set = sorted(Set)\n        length = sorted(length)\n        ans = 0\n        tar = 2 ** K - 1\n        for i in range(len(Set)):\n            (L, x) = Set[i]\n            temp = K - L\n            position = bisect.bisect_left(length, temp)\n            if position >= len(length):\n                continue\n            for j in range(position, len(length)):\n                if j != i:\n                    y = Set[j][1]\n                    if x | y == tar:\n                        ans += 1\n        print(ans // 2)\n    else:\n        Set = [[0 for j in range(K)] for i in range(N)]\n        big = []\n        ans = 0\n        tar = 2 ** K - 1\n        for i in range(N):\n            A = list(map(int, input().strip().split(' ')))\n            A = A[1:]\n            temp = 0\n            for x in A:\n                Set[i][x - 1] = 1\n                temp += 2 ** (x - 1)\n            big += [temp]\n        Containone = [set() for i in range(K)]\n        for j in range(K):\n            for i in range(N):\n                if Set[i][j] == 1:\n                    Containone[j].add(i)\n        GGG = [[] for i in range(N)]\n        for i in range(N):\n            for j in range(K):\n                if Set[i][j] == 0:\n                    GGG[i] += [j]\n        for x in range(N):\n            if big[x] == tar:\n                ans += N - 1\n                continue\n            MIN = N + 1\n            check = 0\n            for y in GGG[x]:\n                if len(Containone[y]) < MIN:\n                    check = y\n                    MIN = len(Containone[y])\n            for L in Containone[check]:\n                if big[L] | big[x] == tar:\n                    ans += 1\n        print(ans // 2)", "import time\n\ndef unionlength(a, b, k):\n    if len(b) < len(a):\n        x = b\n        y = a\n    else:\n        x = a\n        y = b\n    count = len(a) + len(b)\n    for val in x:\n        if val in y:\n            count -= 1\n        if count < k:\n            return k - 1\n    return count\nstart = time.time()\nt = int(input())\nfor u in range(t):\n    inp = input().split()\n    n = int(inp[0])\n    k = int(inp[1])\n    l = []\n    D = {}\n    c2 = 0\n    for i in range(n):\n        inp = input().split()\n        x = set()\n        for val in range(1, len(inp)):\n            x.add(int(inp[val]))\n        if len(x) == k:\n            c2 += 1\n        else:\n            l.append([len(x), x])\n        for val in inp[1:]:\n            val = int(val)\n            try:\n                D[val].add(i)\n            except:\n                D[val] = set()\n                D[val].add(i)\n    count = 0\n    try:\n        for sets in l:\n            if time.time() - start > 4:\n                print(1 / 0)\n            flag = 0\n            s = set()\n            for i in range(1, k + 1):\n                if i in sets[1]:\n                    continue\n                elif flag == 0:\n                    s = set(D[i])\n                    flag = 1\n                else:\n                    s = s & D[i]\n            count += len(s)\n        print((count + c2 * (n - c2) + c2 * (c2 - 1)) // 2)\n    except KeyError:\n        print(0)\n    except ZeroDivisionError:\n        l.sort()\n        count = 0\n        for i in range(n - c2 - 1):\n            for j in range(n - c2 - 1, i, -1):\n                if l[j][0] + l[i][0] < k:\n                    break\n                if unionlength(l[i][1], l[j][1], k) == k:\n                    count += 1\n        print(count + c2 * (n - c2) + c2 * (c2 - 1) // 2)", "def main():\n    T = int(input())\n    for i in range(T):\n        (N, K) = input().split(' ')\n        (N, K) = (int(N), int(K))\n        sets = []\n        for i in range(N):\n            arr = input().split(' ')\n            arr = [int(n) for n in arr]\n            del arr[0]\n            sets.append(arr)\n        sets = sorted(sets, key=lambda x: len(x), reverse=True)\n        solve(K, sets)\n\ndef solve(K, sets):\n    (new, cover) = setsToBin(K, sets)\n    biggest = (1 << K) - 1\n    if cover < biggest:\n        print(0)\n        return\n    count = 0\n    for i in range(len(new)):\n        if new[i] == biggest:\n            count += len(new) - 1 - i\n            continue\n        if i < len(new) - 1:\n            if len(sets[i]) + len(sets[i + 1]) < K:\n                break\n        for j in range(i + 1, len(new)):\n            if len(sets[i]) + len(sets[j]) < K:\n                break\n            if new[i] | new[j] == biggest:\n                count += 1\n    print(count)\n\ndef setsToBin(K, sets):\n    new = []\n    cover = 0\n    for s in sets:\n        num = 0\n        for i in s:\n            num |= 1 << i - 1\n        new.append(num)\n        cover |= num\n    return (new, cover)\nmain()", "T = int(input())\nfor t in range(T):\n    s = input().split()\n    n = int(s[0])\n    k = int(s[1])\n    l = [set()] * n\n    for i in range(n):\n        temp_list = [int(r) for r in input().split()[1:]]\n        l[i] = set(temp_list)\n    pair_count = 0\n    ideal = set(range(1, k + 1))\n    for i in range(len(l)):\n        diff = ideal.difference(l[i])\n        for j in range(i + 1, len(l)):\n            if diff.issubset(l[j]):\n                pair_count += 1\n    print(pair_count)"]