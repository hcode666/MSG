["def side(point1, point2, point):\n    return (point2[0] - point1[0]) * (point1[1] - point[1]) - (point2[1] - point1[1]) * (point1[0] - point[0])\n\ndef print_ans(ans):\n    for point in ans:\n        print(point[0], point[1])\n\ndef answer(A, n):\n    req = int(n / 10)\n    got = 0\n    ans = []\n    for i in range(n):\n        point = A[i]\n        point_before = A[(n + i - 1) % n]\n        point_after = A[(i + 1) % n]\n        P = [point[0] - 1, point[1]]\n        if P not in ans:\n            if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                ans.append(P)\n                got += 1\n                if got == req:\n                    print_ans(ans)\n                    return\n    if req != got:\n        for i in range(n):\n            point = A[i]\n            point_before = A[(n + i - 1) % n]\n            point_after = A[(i + 1) % n]\n            P = [point[0] + 1, point[1]]\n            if P not in ans:\n                if side(point_before, point, P) < 0 and side(point, point_after, P) < 0:\n                    ans.append(P)\n                    got += 1\n                    if got == req:\n                        print_ans(ans)\n                        return\n    print(-1)\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    A = [[0, 0] for _ in range(n)]\n    for i in range(n):\n        A[i] = list(map(int, input().split()))\n    answer(A, n)", "import sys\nsys.setrecursionlimit(50000)\n\ndef sub(p, q):\n    x = p[0] - q[0]\n    y = p[1] - q[1]\n    return [x, y]\n\ndef scprod(p, q, r):\n    (x1, y1) = (q[0] - p[0], q[1] - p[1])\n    (x2, y2) = (r[0] - q[0], r[1] - q[1])\n    return x1 * y2 - x2 * y1 > 0\n\ndef inside(c, eq):\n    n = len(eq)\n    if not scprod(eq[0], eq[1], c) or not scprod(eq[-1], eq[0], c):\n        return False\n    (low, high) = (1, n - 1)\n    for i in range(11):\n        mid = (high + low) // 2\n        if scprod(eq[0], eq[mid], c):\n            low = mid\n        else:\n            high = mid\n    return scprod(eq[low], eq[low + 1], c)\n\ndef floodfillUtil(c, points, k, cor, d):\n    if len(points) >= k:\n        return\n    if not inside(c, cor):\n        return\n    else:\n        points.add(c)\n        if d == 1:\n            floodfillUtil((c[0], c[1] + 1), points, k, cor, 1)\n        elif d == 2:\n            floodfillUtil((c[0] + 1, c[1] + 1), points, k, cor, 2)\n        elif d == 3:\n            floodfillUtil((c[0] + 1, c[1]), points, k, cor, 3)\n        elif d == 4:\n            floodfillUtil((c[0] + 1, c[1] - 1), points, k, cor, 4)\n        elif d == 5:\n            floodfillUtil((c[0], c[1] - 1), points, k, cor, 5)\n        elif d == 6:\n            floodfillUtil((c[0] - 1, c[1] - 1), points, k, cor, 6)\n        elif d == 7:\n            floodfillUtil((c[0] - 1, c[1]), points, k, cor, 7)\n        elif d == 8:\n            floodfillUtil((c[0] - 1, c[1] + 1), points, k, cor, 8)\n\ndef floodfill(c, points, k, cor):\n    floodfillUtil((c[0], c[1] + 1), points, k, cor, 1)\n    floodfillUtil((c[0] + 1, c[1] + 1), points, k, cor, 2)\n    floodfillUtil((c[0] + 1, c[1]), points, k, cor, 3)\n    floodfillUtil((c[0] + 1, c[1] - 1), points, k, cor, 4)\n    floodfillUtil((c[0], c[1] - 1), points, k, cor, 5)\n    floodfillUtil((c[0] - 1, c[1] - 1), points, k, cor, 6)\n    floodfillUtil((c[0] - 1, c[1]), points, k, cor, 7)\n    floodfillUtil((c[0] - 1, c[1] + 1), points, k, cor, 8)\nfor _ in range(int(input())):\n    n = int(input())\n    cor = []\n    xcor = []\n    ycor = []\n    for i in range(n):\n        cordinate = list(map(int, input().split()))\n        cor.append(cordinate)\n        xcor.append(cordinate[0])\n        ycor.append(cordinate[1])\n    count = 0\n    k = n // 10\n    ans = []\n    flag = 0\n    points = set()\n    count = 0\n    for i in range(len(cor)):\n        if count == k:\n            break\n        c = cor[i]\n        floodfill((c[0], c[1]), points, k, cor)\n    points = list(points)\n    if len(points) < k:\n        print(-1)\n    else:\n        for a in range(k):\n            print(points[a][0], points[a][1])", "import sys\nsys.setrecursionlimit(50000)\n\ndef sub(p, q):\n    x = p[0] - q[0]\n    y = p[1] - q[1]\n    return [x, y]\n\ndef scprod(p, q, r):\n    (x1, y1) = (q[0] - p[0], q[1] - p[1])\n    (x2, y2) = (r[0] - q[0], r[1] - q[1])\n    return x1 * y2 - x2 * y1 > 0\n\ndef inside(c, eq):\n    n = len(eq)\n    if not scprod(eq[0], eq[1], c) or not scprod(eq[-1], eq[0], c):\n        return False\n    (low, high) = (1, n - 1)\n    for i in range(21):\n        mid = (high + low) // 2\n        if scprod(eq[0], eq[mid], c):\n            low = mid\n        else:\n            high = mid\n    return scprod(eq[low], eq[low + 1], c)\n\ndef floodfillUtil(c, points, k, cor, d):\n    if len(points) >= k:\n        return\n    if not inside(c, cor):\n        return\n    else:\n        points.add(c)\n        if d == 1:\n            floodfillUtil((c[0], c[1] + 1), points, k, cor, 1)\n        elif d == 2:\n            floodfillUtil((c[0] + 1, c[1] + 1), points, k, cor, 2)\n        elif d == 3:\n            floodfillUtil((c[0] + 1, c[1]), points, k, cor, 3)\n        elif d == 4:\n            floodfillUtil((c[0] + 1, c[1] - 1), points, k, cor, 4)\n        elif d == 5:\n            floodfillUtil((c[0], c[1] - 1), points, k, cor, 5)\n        elif d == 6:\n            floodfillUtil((c[0] - 1, c[1] - 1), points, k, cor, 6)\n        elif d == 7:\n            floodfillUtil((c[0] - 1, c[1]), points, k, cor, 7)\n        elif d == 8:\n            floodfillUtil((c[0] - 1, c[1] + 1), points, k, cor, 8)\n\ndef floodfill(c, points, k, cor):\n    floodfillUtil((c[0], c[1] + 1), points, k, cor, 1)\n    floodfillUtil((c[0] + 1, c[1] + 1), points, k, cor, 2)\n    floodfillUtil((c[0] + 1, c[1]), points, k, cor, 3)\n    floodfillUtil((c[0] + 1, c[1] - 1), points, k, cor, 4)\n    floodfillUtil((c[0], c[1] - 1), points, k, cor, 5)\n    floodfillUtil((c[0] - 1, c[1] - 1), points, k, cor, 6)\n    floodfillUtil((c[0] - 1, c[1]), points, k, cor, 7)\n    floodfillUtil((c[0] - 1, c[1] + 1), points, k, cor, 8)\nfor _ in range(int(input())):\n    n = int(input())\n    cor = []\n    xcor = []\n    ycor = []\n    for i in range(n):\n        cordinate = list(map(int, input().split()))\n        cor.append(cordinate)\n        xcor.append(cordinate[0])\n        ycor.append(cordinate[1])\n    count = 0\n    k = n // 10\n    ans = []\n    flag = 0\n    points = set()\n    count = 0\n    for i in range(len(cor)):\n        if count == k:\n            break\n        c = cor[i]\n        floodfill((c[0], c[1]), points, k, cor)\n    points = list(points)\n    if len(points) < k:\n        print(-1)\n    else:\n        for a in range(k):\n            print(points[a][0], points[a][1])", "def kuch_kar_raha_hai(a, b, c):\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\ndef bata_point_kidhar_hai(l, p, b):\n    a = 1\n    if kuch_kar_raha_hai(l[0], l[a], l[b]) > 0:\n        (a, b) = (b, a)\n    if kuch_kar_raha_hai(l[0], l[a], p) >= 0 or kuch_kar_raha_hai(l[0], l[b], p) <= 0:\n        return False\n    while abs(a - b) > 1:\n        c = (a + b) // 2\n        if kuch_kar_raha_hai(l[0], l[c], p) > 0:\n            b = c\n        else:\n            a = c\n    return kuch_kar_raha_hai(l[a], l[b], p) < 0\nt = int(input())\nwhile t:\n    n = int(input())\n    l = [(a, b) for i in range(n) for (a, b) in [map(int, input().split())]]\n    d = {}\n    for i in l:\n        if bata_point_kidhar_hai(l, (i[0] + 1, i[1]), n - 1):\n            d[i[0] + 1, i[1]] = 1\n        if len(d) == n // 10:\n            break\n        if bata_point_kidhar_hai(l, (i[0] - 1, i[1]), n - 1):\n            d[i[0] - 1, i[1]] = 1\n        if len(d) == n // 10:\n            break\n        if bata_point_kidhar_hai(l, (i[0], i[1] + 1), n - 1):\n            d[i[0], i[1] + 1] = 1\n        if len(d) == n // 10:\n            break\n        if bata_point_kidhar_hai(l, (i[0], i[1] - 1), n - 1):\n            d[i[0], i[1] - 1] = 1\n        if len(d) == n // 10:\n            break\n    for i in d:\n        print(i[0], i[1])\n    t -= 1", "for _ in range(int(input())):\n    n = int(input())\n    (xmax, xmin, ymax, ymin) = (-1 << 32, 1 << 32, -1 << 32, 1 << 32)\n    P = []\n    for _ in range(n):\n        (xi, yi) = [int(i) for i in input().split(' ')]\n        P.append([xi, yi])\n        (xmin, xmax, ymin, ymax) = (min(xi, xmin), max(xi, xmax), min(yi, ymin), max(yi, ymax))\n    (maxx, minn, k) = (0, 0, n // 10)\n    for i in range(n):\n        if P[i][1] == ymin:\n            minn = i\n        if P[i][1] == ymax:\n            maxx = i\n    if minn < maxx:\n        (up, down) = (P[minn:maxx + 1], P[maxx + 1:] + P[0:minn])\n    else:\n        (down, up) = (P[maxx:minn + 1], P[minn + 1:] + P[0:maxx])\n    for i in range(len(up)):\n        if up[i][1] != ymax and up[i][1] != ymin:\n            print(up[i][0] - 1, up[i][1])\n            k -= 1\n        if k == 0:\n            break\n    if k > 0:\n        for i in range(len(down)):\n            if down[i][1] != ymax and down[i][1] != ymin:\n                print(down[i][0] + 1, down[i][1])\n                k -= 1\n            if k == 0:\n                break", "for _ in range(int(input())):\n    n = int(input())\n    xmax = -1 << 32\n    xmin = 1 << 32\n    ymax = -1 << 32\n    ymin = 1 << 32\n    P = []\n    for _ in range(n):\n        (xi, yi) = [int(i) for i in input().split(' ')]\n        P.append([xi, yi])\n        xmin = min(xi, xmin)\n        xmax = max(xi, xmax)\n        ymin = min(yi, ymin)\n        ymax = max(yi, ymax)\n    k = n // 10\n    maxx = 0\n    minn = 0\n    for i in range(n):\n        if P[i][1] == ymin:\n            minn = i\n            break\n    for i in range(n):\n        if P[i][1] == ymax:\n            maxx = i\n            break\n    if minn < maxx:\n        up = P[minn:maxx + 1]\n        down = P[maxx + 1:] + P[0:minn]\n    else:\n        down = P[maxx:minn + 1]\n        up = P[minn + 1:] + P[0:maxx]\n    for i in range(len(up)):\n        if up[i][1] != ymax and up[i][1] != ymin:\n            print(up[i][0] - 1, up[i][1])\n            k -= 1\n        if k == 0:\n            break\n    if k > 0:\n        for i in range(len(down)):\n            if down[i][1] != ymax and down[i][1] != ymin:\n                print(down[i][0] + 1, down[i][1])\n                k -= 1\n            if k == 0:\n                break", "from math import atan2\n\ndef square(x1, y1, x2, y2, x3, y3):\n    return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)\n\ndef check(first, second, k=1, axel=0):\n    label = 1\n    n = len(first)\n    for i in range(k):\n        (l, r) = (1, len(first) - 1)\n        if atan2(first[r][1] - first[axel][1], first[r][0] - first[axel][0]) <= atan2(second[i][1] - first[axel][1], second[i][0] - first[axel][0]):\n            label = 0\n            break\n        if atan2(first[l][1] - first[axel][1], first[l][0] - first[axel][0]) >= atan2(second[i][1] - first[axel][1], second[i][0] - first[axel][0]):\n            label = 0\n            break\n        while r - l > 1:\n            m = (r + l) // 2\n            if atan2(first[m][1] - first[axel][1], first[m][0] - first[axel][0]) >= atan2(second[i][1] - first[axel][1], second[i][0] - first[axel][0]):\n                r = m\n            else:\n                l = m\n        if abs(square(first[axel][0], first[axel][1], first[r][0], first[r][1], first[l][0], first[l][1])) == abs(square(second[i][0], second[i][1], first[r][0], first[r][1], first[l][0], first[l][1])) + abs(square(first[axel][0], first[axel][1], second[i][0], second[i][1], first[l][0], first[l][1])) + abs(square(first[axel][0], first[axel][1], first[r][0], first[r][1], second[i][0], second[i][1])) and abs(square(second[i][0], second[i][1], first[r][0], first[r][1], first[l][0], first[l][1])):\n            continue\n        else:\n            label = 0\n    if label:\n        return 1\n    else:\n        return 0\nfor _ in range(int(input())):\n    a = int(input())\n    p = []\n    for i in range(a):\n        p.append([int(i) for i in input().split()])\n    x = []\n    y = []\n    for i in p:\n        x.append(i[0])\n        y.append(i[1])\n    x1 = min(x)\n    x2 = max(x)\n    y1 = min(y)\n    y2 = max(y)\n    pre = a // 10\n    points = set()\n    points2 = set()\n    for i in p:\n        (xc, yc) = (i[0], i[1])\n        for j in range(1, 10000):\n            if check(p, [[xc + j, yc]]) == 1:\n                points.add((xc + j, yc))\n                if len(points) >= pre:\n                    break\n            else:\n                break\n        for j in range(1, 10000):\n            if check(p, [[xc - j, yc]]) == 1:\n                points.add((xc - j, yc))\n                if len(points) >= pre:\n                    break\n            else:\n                break\n        if len(points) >= pre:\n            break\n    points = list(points)\n    if len(points) == 0 or len(points) < pre or pre == 0:\n        print(-1)\n    else:\n        for i in range(pre):\n            print(points[i][0], points[i][1])"]