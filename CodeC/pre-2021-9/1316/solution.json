["import heapq\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    ans = [float('infinity')] * (n + 1)\n    g = [[] for _ in range(n + 1)]\n    h = []\n    for _ in range(k):\n        (v, d) = map(int, input().split())\n        ans[v] = d\n        heapq.heappush(h, (d, v))\n    for _ in range(m):\n        (u, v, d) = map(int, input().split())\n        g[u].append((v, d))\n        g[v].append((u, d))\n    while h:\n        (d, u) = heapq.heappop(h)\n        for (v, w) in g[u]:\n            if ans[v] > ans[u] + w:\n                ans[v] = ans[u] + w\n                heapq.heappush(h, (ans[v], v))\n    print(' '.join(map(str, ans[1:])))", "import heapq\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    ans = [float('infinity')] * (n + 1)\n    g = [[] for _ in range(n + 1)]\n    h = []\n    for _ in range(k):\n        (v, d) = map(int, input().split())\n        ans[v] = d\n        heapq.heappush(h, (d, v))\n    for _ in range(m):\n        (u, v, d) = map(int, input().split())\n        g[u].append((v, d))\n        g[v].append((u, d))\n    while h:\n        (d, u) = heapq.heappop(h)\n        for (v, w) in g[u]:\n            if ans[v] > ans[u] + w:\n                ans[v] = ans[u] + w\n                heapq.heappush(h, (ans[v], v))\n    print(' '.join(map(str, ans[1:])))", "from heapq import *\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\nfor _ in range(int(sys.stdin.readline())):\n    (n, m, k) = map(int, sys.stdin.readline().split())\n    d = defaultdict(list)\n    for i in range(k):\n        (a, b) = map(int, sys.stdin.readline().split())\n        d[a].append((0, b))\n        d[0].append((a, b))\n    for i in range(m):\n        (a, b, c) = map(int, sys.stdin.readline().split())\n        d[a].append((b, c))\n        d[b].append((a, c))\n    visited = [0] * (n + 1)\n    h = [(0, 0)]\n    dist = [INF] * (n + 1)\n    dist[0] = 0\n    while h:\n        (x, y) = heappop(h)\n        if visited[y]:\n            continue\n        visited[y] = 1\n        for (p, q) in d[y]:\n            if dist[p] > q + x:\n                dist[p] = q + x\n                heappush(h, (dist[p], p))\n    print(*dist[1:])", "import heapq\nT = int(input())\n\ndef solve(N, hos, adj):\n    M_dist = [float('inf')] * (N + 1)\n    h = []\n    for (i, C) in hos:\n        heapq.heappush(h, (C, i))\n    while h:\n        (dist, city) = heapq.heappop(h)\n        if dist >= M_dist[city]:\n            continue\n        M_dist[city] = dist\n        for (nei, w) in adj[city]:\n            if M_dist[nei] > dist + w:\n                heapq.heappush(h, (dist + w, nei))\n    ans = []\n    for i in range(1, N + 1):\n        ans.append(M_dist[i])\n    return ans\nfor _ in range(T):\n    (N, M, K) = [int(s) for s in input().split()]\n    hos = []\n    adj = {}\n    for _ in range(K):\n        hos.append(tuple((int(s) for s in input().split())))\n    for _ in range(M):\n        (A, B, D) = [int(s) for s in input().split()]\n        if A not in adj:\n            adj[A] = []\n        if B not in adj:\n            adj[B] = []\n        adj[A].append((B, D))\n        adj[B].append((A, D))\n    ans = solve(N, hos, adj)\n    for num in ans:\n        print(num, end=' ')\n    print()", "import heapq\nT = int(input())\n\ndef solve(N, hos, adj):\n    M_dist = [float('inf')] * (N + 1)\n    h = []\n    for (i, C) in hos:\n        heapq.heappush(h, (C, i))\n    while h:\n        (dist, city) = heapq.heappop(h)\n        if dist >= M_dist[city]:\n            continue\n        M_dist[city] = dist\n        for (nei, w) in adj[city]:\n            if M_dist[nei] > dist + w:\n                heapq.heappush(h, (dist + w, nei))\n    ans = []\n    for i in range(1, N + 1):\n        ans.append(M_dist[i])\n    return ans\nfor _ in range(T):\n    (N, M, K) = [int(s) for s in input().split()]\n    hos = []\n    adj = {}\n    for _ in range(K):\n        hos.append(tuple((int(s) for s in input().split())))\n    for _ in range(M):\n        (A, B, D) = [int(s) for s in input().split()]\n        if A not in adj:\n            adj[A] = []\n        if B not in adj:\n            adj[B] = []\n        adj[A].append((B, D))\n        adj[B].append((A, D))\n    ans = solve(N, hos, adj)\n    for num in ans:\n        print(num, end=' ')\n    print()", "from collections import deque\nimport heapq\n\ndef dijkastra(graph, hospital, dis):\n    heap = []\n    for (k, v) in hospital.items():\n        heap.append((v, k))\n        dis[k] = v\n    heapq.heapify(heap)\n    while heap:\n        (d, node) = heapq.heappop(heap)\n        for (child, w) in graph[node]:\n            nd = d + w\n            if nd < dis[child]:\n                dis[child] = nd\n                heapq.heappush(heap, (nd, child))\nt = int(input())\nfor _ in range(t):\n    (n, m, k) = list(map(int, input().split()))\n    hospital = {}\n    for _ in range(k):\n        (a, c) = list(map(int, input().split()))\n        hospital[a - 1] = c\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        (a, b, w) = list(map(int, input().split()))\n        graph[a - 1].append((b - 1, w))\n        graph[b - 1].append((a - 1, w))\n    inf = float('inf')\n    dis = [inf] * n\n    dijkastra(graph, hospital, dis)\n    print(*dis)", "import heapq\nimport sys\nimport os\nfrom collections import defaultdict\n\ndef dijkstra(graph, source, distance_to_hospital):\n    heap = [(source, distance_to_hospital[source])]\n    while heap:\n        (city, cost) = heapq.heappop(heap)\n        for (connected_city, distance) in graph[city]:\n            if distance_to_hospital[connected_city] > distance + cost:\n                distance_to_hospital[connected_city] = distance + cost\n                heapq.heappush(heap, (connected_city, distance_to_hospital[connected_city]))\nfor _ in range(int(input())):\n    (N, M, K) = map(int, input().split())\n    graph = defaultdict(list)\n    distance_to_hospital = [sys.maxsize for _ in range(N + 1)]\n    distance_to_hospital[0] = 0\n    for _ in range(K):\n        (city, cost) = map(int, input().split())\n        graph[city].append((0, cost))\n        graph[0].append((city, cost))\n    for _ in range(M):\n        (u, v, distance) = map(int, input().split())\n        graph[u].append((v, distance))\n        graph[v].append((u, distance))\n    dijkstra(graph, 0, distance_to_hospital)\n    print(*distance_to_hospital[1:])", "import heapq\nimport sys\nimport os\nfrom collections import defaultdict\n\ndef dijkstra(graph, source, distance_to_hospital):\n    heap = [(source, distance_to_hospital[source])]\n    while heap:\n        (city, cost) = heapq.heappop(heap)\n        for (connected_city, distance) in graph[city]:\n            if distance_to_hospital[connected_city] > distance + cost:\n                distance_to_hospital[connected_city] = distance + cost\n                heapq.heappush(heap, (connected_city, distance_to_hospital[connected_city]))\nfor _ in range(int(input())):\n    (N, M, K) = map(int, input().split())\n    graph = defaultdict(list)\n    distance_to_hospital = [sys.maxsize for _ in range(N + 1)]\n    distance_to_hospital[0] = 0\n    for _ in range(K):\n        (city, cost) = map(int, input().split())\n        graph[city].append((0, cost))\n        graph[0].append((city, cost))\n    for _ in range(M):\n        (u, v, distance) = map(int, input().split())\n        graph[u].append((v, distance))\n        graph[v].append((u, distance))\n    dijkstra(graph, 0, distance_to_hospital)\n    print(*distance_to_hospital[1:])", "from collections import *\nfrom heapq import *\nt = int(input())\nfor _ in range(t):\n    d = defaultdict(list)\n    (n, m, k) = map(int, input().split())\n    for i in range(k):\n        (x, c) = map(int, input().split())\n        d[0].append((x, c))\n        d[x].append((0, c))\n    for i in range(m):\n        (a, b, c) = map(int, input().split())\n        d[a].append((b, c))\n        d[b].append((a, c))\n    dist = [float('inf')] * (n + 1)\n    dist[0] = 0\n    h = [(0, 0)]\n    visited = [0] * (n + 1)\n    while h:\n        (a, b) = heappop(h)\n        if visited[b]:\n            continue\n        visited[b] = 1\n        for (x, y) in d[b]:\n            if dist[x] > a + y:\n                dist[x] = a + y\n                heappush(h, (dist[x], x))\n    print(*dist[1:])", "from collections import defaultdict\nimport sys\nimport heapq\n\ndef dijkstra(graph, start, dist):\n    queue = [(start, dist[start])]\n    while queue:\n        (ele, w) = heapq.heappop(queue)\n        for (adjele, weight) in graph[ele]:\n            if dist[adjele] > w + weight:\n                dist[adjele] = w + weight\n                heapq.heappush(queue, (adjele, dist[adjele]))\nfor _ in range(int(input())):\n    (N, M, K) = [int(x) for x in input().split()]\n    hosp = {}\n    graph = defaultdict(list)\n    dist = [sys.maxsize for _ in range(N + 1)]\n    dist[0] = 0\n    for _ in range(K):\n        (i, c) = [int(x) for x in input().split()]\n        graph[i].append((0, c))\n        graph[0].append((i, c))\n    for _ in range(M):\n        (i, j, d) = [int(x) for x in input().split()]\n        graph[i].append((j, d))\n        graph[j].append((i, d))\n    dijkstra(graph, 0, dist)\n    print(*dist[1:])", "from collections import *\nfrom heapq import *\nt = int(input())\nfor _ in range(t):\n    d = defaultdict(list)\n    (n, m, k) = map(int, input().split())\n    for i in range(k):\n        (x, c) = map(int, input().split())\n        d[0].append((x, c))\n        d[x].append((0, c))\n    for i in range(m):\n        (a, b, c) = map(int, input().split())\n        d[a].append((b, c))\n        d[b].append((a, c))\n    dist = [float('inf')] * (n + 1)\n    dist[0] = 0\n    h = [(0, 0)]\n    visited = [0] * (n + 1)\n    while h:\n        (a, b) = heappop(h)\n        if visited[b]:\n            continue\n        visited[b] = 1\n        for (x, y) in d[b]:\n            if dist[x] > a + y:\n                dist[x] = a + y\n                heappush(h, (dist[x], x))\n    print(*dist[1:])", "from sys import stdin\nfrom collections import defaultdict\nimport heapq\nt = int(stdin.readline())\nfor _ in range(t):\n    (n, m, k) = map(int, stdin.readline().split())\n    hos = []\n    for i in range(k):\n        (x, c) = map(int, stdin.readline().split())\n        hos.append((c, x))\n    graph = defaultdict(list)\n    for i in range(m):\n        (a, b, d) = map(int, stdin.readline().split())\n        graph[a].append((b, d))\n        graph[b].append((a, d))\n    heapq.heapify(hos)\n    dic = {}\n    while len(dic) < n:\n        (cost, cit) = heapq.heappop(hos)\n        if cit not in dic:\n            dic[cit] = cost\n            for nbour in graph[cit]:\n                dist = nbour[1]\n                heapq.heappush(hos, (cost + dist, nbour[0]))\n    ans = []\n    for i in range(1, n + 1):\n        ans.append(dic[i])\n    print(*ans)", "from heapq import *\nimport os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n\ndef solve():\n    (n, m, k) = mp()\n    d = defaultdict(list)\n    for i in range(k):\n        (a, b) = mp()\n        d[a].append((0, b))\n        d[0].append((a, b))\n    for i in range(m):\n        (a, b, c) = mp()\n        d[a].append((b, c))\n        d[b].append((a, c))\n    visited = [0] * (n + 1)\n    h = [(0, 0)]\n    dist = [INF] * (n + 1)\n    dist[0] = 0\n    while h:\n        (x, y) = heappop(h)\n        if visited[y]:\n            continue\n        visited[y] = 1\n        for (p, q) in d[y]:\n            if dist[p] > q + x:\n                dist[p] = q + x\n                heappush(h, (dist[p], p))\n    print(*dist[1:])\nfor _ in range(inp()):\n    solve()", "import heapq\nimport sys\ninput = sys.stdin.readline\nINF = 999999999999999\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(k):\n        (xi, ci) = map(int, input().split())\n        adj[0].append([xi, ci])\n        adj[xi].append([0, ci])\n    for _ in range(m):\n        (a, b, d) = map(int, input().split())\n        adj[a].append([b, d])\n        adj[b].append([a, d])\n    dis = [INF] * (n + 1)\n    source = 0\n    dis[source] = 0\n    pq = []\n    heapq.heappush(pq, (0, source))\n    while len(pq):\n        (dist, prev) = heapq.heappop(pq)\n        for val in adj[prev]:\n            nex = val[0]\n            newDist = val[1]\n            if dis[nex] > dist + newDist:\n                dis[nex] = dist + newDist\n                heapq.heappush(pq, (dis[nex], nex))\n    for i in range(1, n + 1):\n        print(dis[i], end=' ')\n    print()", "import heapq\nimport sys\ninput = sys.stdin.readline\nINF = 999999999999999\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    adj = [[] for _ in range(n + 1)]\n    for _ in range(k):\n        (xi, ci) = map(int, input().split())\n        adj[0].append([xi, ci])\n        adj[xi].append([0, ci])\n    for _ in range(m):\n        (a, b, d) = map(int, input().split())\n        adj[a].append([b, d])\n        adj[b].append([a, d])\n    dis = [INF] * (n + 1)\n    dis[0] = 0\n    pq = []\n    heapq.heappush(pq, (0, 0))\n    while len(pq) > 0:\n        (cst, u) = heapq.heappop(pq)\n        for val in adj[u]:\n            v = val[0]\n            dd = val[1]\n            if cst + dd < dis[v]:\n                dis[v] = cst + dd\n                heapq.heappush(pq, (dis[v], v))\n    for i in range(1, n + 1):\n        print(dis[i], end=' ')\n    print()", "from sys import stdin\ninput = stdin.readline\nfrom queue import PriorityQueue\n\ndef dijkstra():\n    v = [False] * (n + 1)\n    while not q.empty():\n        (val, p) = q.get()\n        if v[p]:\n            continue\n        v[p] = True\n        for x in adj[p]:\n            if ans[p] + d[p, x] < ans[x]:\n                ans[x] = ans[p] + d[p, x]\n                q.put([ans[x], x])\nfor T in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    ans = [float('inf')] * (n + 1)\n    q = PriorityQueue()\n    for i in range(k):\n        (x, c) = map(int, input().split())\n        q.put([c, x])\n        ans[x] = c\n    adj = [[] for i in range(n + 1)]\n    d = dict()\n    for i in range(m):\n        (u, v, dis) = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        d[u, v] = dis\n        d[v, u] = dis\n    dijkstra()\n    print(*ans[1:])", "from collections import defaultdict\nimport heapq\nimport sys\ninput = sys.stdin.readline\nfor _ in range(int(input())):\n    (n, m, k) = map(int, input().split())\n    (costs, neigh) = ([], defaultdict(list))\n    for _ in range(k):\n        (x, C) = map(int, input().split())\n        costs.append((C, x))\n    for _ in range(m):\n        (a, b, d) = map(int, input().split())\n        neigh[a].append((b, d))\n        neigh[b].append((a, d))\n    heapq.heapify(costs)\n    answer = {}\n    while len(answer) < n:\n        (cost, act) = heapq.heappop(costs)\n        if act not in answer:\n            answer[act] = cost\n            for (vei, d) in neigh[act]:\n                heapq.heappush(costs, (cost + d, vei))\n    print(*[answer[i] for i in range(1, n + 1)])"]