["from random import *\nimport time\n\ndef ilog2(n):\n    return 0 if n <= 0 else n.bit_length() - 1\n\ndef pack(pack, shamt):\n    size = len(pack)\n    while size > 1:\n        npack = []\n        for i in range(0, size - 1, 2):\n            npack += [pack[i] | pack[i + 1] << shamt]\n        if size & 1:\n            npack += [pack[-1]]\n        (pack, size, shamt) = (npack, size + 1 >> 1, shamt << 1)\n    return pack[0]\n\ndef unpack(M, size, shamt):\n    (s, sizes) = (size, [])\n    while s > 1:\n        sizes += [s]\n        s = s + 1 >> 1\n    ret = [M]\n    for size in sizes[::-1]:\n        (mask, nret) = ((1 << shamt) - 1, [])\n        for c in ret:\n            nret += [c & mask, c >> shamt]\n        (ret, shamt) = (nret[:size], shamt >> 1)\n    return ret\n\ndef poly_mul_mod(f, g, mod):\n    size = min(len(f), len(g))\n    shift = ((mod - 1) ** 2 * size).bit_length()\n    rsize = len(f) + len(g) - 1\n    h = unpack(pack(f, shift) * pack(g, shift), rsize, shift * (1 << ilog2(rsize - 1)))\n    return [int(x % mod) for x in h]\n\ndef poly_inverse_mod(f, size, mod):\n    assert f[0] == 1\n    (deg, degs) = (size - 1, [])\n    while deg > 0:\n        degs += [deg]\n        deg >>= 1\n    f2 = f[:]\n    if len(f2) < size:\n        f2.extend([0] * (size - len(f2)))\n    inv = [1]\n    for t in degs[::-1]:\n        s = t + 1 - len(inv)\n        tmp = poly_mul_mod(f2[:t + 1], inv, mod)[len(inv):]\n        tmp = poly_mul_mod(tmp[:s], inv[:s], mod)\n        inv.extend([-v % mod for v in tmp[:s]])\n    return inv\n\ndef inv(a, b):\n    return pow(a, b - 2, b)\nMOD = 998244353\n\ndef multiply(A):\n    if len(A) == 1:\n        return A[0]\n    mid = len(A) // 2\n    return poly_mul_mod(multiply(A[:mid]), multiply(A[mid:]), MOD)\n\ndef sum_of_powers(N, n):\n    (A, B) = ([0] * n, [0] * n)\n    A[0] = 1\n    B[0] = N\n    P = (N + 1) % MOD\n    for i in range(1, n):\n        A[i] = A[i - 1] * inv(i + 1, MOD) % MOD\n        P = P * (N + 1) % MOD\n        B[i] = (P - 1) * A[i] % MOD\n    F = poly_mul_mod(B, poly_inverse_mod(A, n, MOD), MOD)[:n]\n    P = 1\n    for i in range(1, n):\n        P = P * i % MOD\n        F[i] = F[i] * P % MOD\n    return F\nfor testcase in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    D = (min(A) + 1) // 2\n    power_sums = sum_of_powers(D, n + 1)\n    B = multiply([[a + 1, MOD - 2] for a in A])\n    (ans, X) = (0, 1)\n    for i in range(n + 1):\n        if i < n:\n            X = X * (A[i] + 1) % MOD\n        ans += B[i] * power_sums[i]\n    print(ans * inv(X, MOD) % MOD)", "from random import *\nimport time\n\ndef ilog2(n):\n    return 0 if n <= 0 else n.bit_length() - 1\n\ndef pack(pack, shamt):\n    size = len(pack)\n    while size > 1:\n        npack = []\n        for i in range(0, size - 1, 2):\n            npack += [pack[i] | pack[i + 1] << shamt]\n        if size & 1:\n            npack += [pack[-1]]\n        (pack, size, shamt) = (npack, size + 1 >> 1, shamt << 1)\n    return pack[0]\n\ndef unpack(M, size, shamt):\n    (s, sizes) = (size, [])\n    while s > 1:\n        sizes += [s]\n        s = s + 1 >> 1\n    ret = [M]\n    for size in sizes[::-1]:\n        (mask, nret) = ((1 << shamt) - 1, [])\n        for c in ret:\n            nret += [c & mask, c >> shamt]\n        (ret, shamt) = (nret[:size], shamt >> 1)\n    return ret\n\ndef poly_mul_mod(f, g, mod):\n    size = min(len(f), len(g))\n    shift = ((mod - 1) ** 2 * size).bit_length()\n    rsize = len(f) + len(g) - 1\n    h = unpack(pack(f, shift) * pack(g, shift), rsize, shift * (1 << ilog2(rsize - 1)))\n    return [int(x % mod) for x in h]\n\ndef poly_inverse_mod(f, size, mod):\n    assert f[0] == 1\n    (deg, degs) = (size - 1, [])\n    while deg > 0:\n        degs += [deg]\n        deg >>= 1\n    f2 = f[:]\n    if len(f2) < size:\n        f2.extend([0] * (size - len(f2)))\n    inv = [1]\n    for t in degs[::-1]:\n        s = t + 1 - len(inv)\n        tmp = poly_mul_mod(f2[:t + 1], inv, mod)[len(inv):]\n        tmp = poly_mul_mod(tmp[:s], inv[:s], mod)\n        inv.extend([-v % mod for v in tmp[:s]])\n    return inv\n\ndef inv(a, b):\n    return pow(a, b - 2, b)\nMOD = 998244353\n\ndef multiply(A):\n    if len(A) == 1:\n        return A[0]\n    mid = len(A) // 2\n    return poly_mul_mod(multiply(A[:mid]), multiply(A[mid:]), MOD)\n\ndef sum_of_powers(N, n):\n    (A, B) = ([0] * n, [0] * n)\n    A[0] = 1\n    B[0] = N\n    P = (N + 1) % MOD\n    for i in range(1, n):\n        A[i] = A[i - 1] * inv(i + 1, MOD) % MOD\n        P = P * (N + 1) % MOD\n        B[i] = (P - 1) * A[i] % MOD\n    F = poly_mul_mod(B, poly_inverse_mod(A, n, MOD), MOD)[:n]\n    P = 1\n    for i in range(1, n):\n        P = P * i % MOD\n        F[i] = F[i] * P % MOD\n    return F\nfor testcase in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    D = (min(A) + 1) // 2\n    power_sums = sum_of_powers(D, n + 1)\n    B = multiply([[a + 1, MOD - 2] for a in A])\n    (ans, X) = (0, 1)\n    for i in range(n + 1):\n        if i < n:\n            X = X * (A[i] + 1) % MOD\n        ans += B[i] * power_sums[i]\n    print(ans * inv(X, MOD) % MOD)", "from random import *\nimport time\n\ndef ilog2(n):\n    return 0 if n <= 0 else n.bit_length() - 1\n\ndef pack(pack, shamt):\n    size = len(pack)\n    while size > 1:\n        npack = []\n        for i in range(0, size - 1, 2):\n            npack += [pack[i] | pack[i + 1] << shamt]\n        if size & 1:\n            npack += [pack[-1]]\n        (pack, size, shamt) = (npack, size + 1 >> 1, shamt << 1)\n    return pack[0]\n\ndef unpack(M, size, shamt):\n    (s, sizes) = (size, [])\n    while s > 1:\n        sizes += [s]\n        s = s + 1 >> 1\n    ret = [M]\n    for size in sizes[::-1]:\n        (mask, nret) = ((1 << shamt) - 1, [])\n        for c in ret:\n            nret += [c & mask, c >> shamt]\n        (ret, shamt) = (nret[:size], shamt >> 1)\n    return ret\n\ndef poly_mul_mod(f, g, mod):\n    size = min(len(f), len(g))\n    shift = ((mod - 1) ** 2 * size).bit_length()\n    rsize = len(f) + len(g) - 1\n    h = unpack(pack(f, shift) * pack(g, shift), rsize, shift * (1 << ilog2(rsize - 1)))\n    return [int(x % mod) for x in h]\n\ndef poly_inverse_mod(f, size, mod):\n    assert f[0] == 1\n    (deg, degs) = (size - 1, [])\n    while deg > 0:\n        degs += [deg]\n        deg >>= 1\n    f2 = f[:]\n    if len(f2) < size:\n        f2.extend([0] * (size - len(f2)))\n    inv = [1]\n    for t in degs[::-1]:\n        s = t + 1 - len(inv)\n        tmp = poly_mul_mod(f2[:t + 1], inv, mod)[len(inv):]\n        tmp = poly_mul_mod(tmp[:s], inv[:s], mod)\n        inv.extend([-v % mod for v in tmp[:s]])\n    return inv\n\ndef inv(a, b):\n    return pow(a, b - 2, b)\nMOD = 998244353\n\ndef multiply(A):\n    if len(A) == 1:\n        return A[0]\n    mid = len(A) // 2\n    return poly_mul_mod(multiply(A[:mid]), multiply(A[mid:]), MOD)\n\ndef sum_of_powers(N, n):\n    (A, B) = ([0] * n, [0] * n)\n    A[0] = 1\n    B[0] = N\n    P = (N + 1) % MOD\n    for i in range(1, n):\n        A[i] = A[i - 1] * inv(i + 1, MOD) % MOD\n        P = P * (N + 1) % MOD\n        B[i] = (P - 1) * A[i] % MOD\n    F = poly_mul_mod(B, poly_inverse_mod(A, n, MOD), MOD)[:n]\n    P = 1\n    for i in range(1, n):\n        P = P * i % MOD\n        F[i] = F[i] * P % MOD\n    return F\nfor testcase in range(int(input())):\n    n = int(input())\n    A = list(map(int, input().split()))\n    D = (min(A) + 1) // 2\n    power_sums = sum_of_powers(D, n + 1)\n    B = multiply([[a + 1, MOD - 2] for a in A])\n    (ans, X) = (0, 1)\n    for i in range(n + 1):\n        if i < n:\n            X = X * (A[i] + 1) % MOD\n        ans += B[i] * power_sums[i]\n    print(ans * inv(X, MOD) % MOD)"]