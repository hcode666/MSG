["from collections import defaultdict\nTrieNode = lambda : defaultdict(TrieNode)\ntrie = TrieNode()\nwords = []\ntrie['idx'] = 0\n\ndef insert(w, cur, idx):\n    for c in w:\n        if c not in cur:\n            cur = cur[c]\n            cur['idx'] = idx\n        else:\n            cur = cur[c]\n    cur['isWord'] = True\n    if '$' not in cur:\n        cur['$'] = idx\n\ndef search(word, cur, idx):\n    for i in word:\n        if i not in cur or cur[i]['idx'] > idx:\n            break\n        pre = cur\n        cur = cur[i]\n    while True:\n        a = []\n        if cur['isWord'] and cur['$'] <= idx:\n            return cur['$']\n        else:\n            for i in 'abcdefghijklmnopqrstuvwxyz':\n                if i in cur and cur[i]['idx'] <= idx:\n                    a.append(i)\n            a.sort()\n            cur = cur[a[0]]\nn = int(input())\nfor i in range(n):\n    x = input().strip()\n    words.append(x)\n    insert(x, trie, i)\nfor i in range(int(input())):\n    (idx, x) = list(input().split())\n    idx = int(idx)\n    idx -= 1\n    print(words[search(x, trie, idx)])", "from collections import defaultdict\nTrieNode = lambda : defaultdict(TrieNode)\ntrie = TrieNode()\nwords = []\ntrie['idx'] = 0\n\ndef insert(w, cur, idx):\n    for c in w:\n        if c not in cur:\n            cur = cur[c]\n            cur['idx'] = idx\n        else:\n            cur = cur[c]\n    cur['isWord'] = True\n    if '$' not in cur:\n        cur['$'] = idx\n\ndef search(word, cur, idx):\n    for i in word:\n        if i not in cur or cur[i]['idx'] > idx:\n            break\n        pre = cur\n        cur = cur[i]\n    while True:\n        a = []\n        if cur['isWord'] and cur['$'] <= idx:\n            return cur['$']\n        else:\n            for i in 'abcdefghijklmnopqrstuvwxyz':\n                if i in cur and cur[i]['idx'] <= idx:\n                    a.append(i)\n            a.sort()\n            cur = cur[a[0]]\nn = int(input())\nfor i in range(n):\n    x = input().strip()\n    words.append(x)\n    insert(x, trie, i)\nfor i in range(int(input())):\n    (idx, x) = list(input().split())\n    idx = int(idx)\n    idx -= 1\n    print(words[search(x, trie, idx)])", "from collections import defaultdict\nTrieNode = lambda : defaultdict(TrieNode)\ntrie = TrieNode()\nwords = []\ntrie['idx'] = 0\n\ndef insert(w, cur, idx):\n    for c in w:\n        if c not in cur:\n            cur = cur[c]\n            cur['idx'] = idx\n        else:\n            cur = cur[c]\n    cur['isWord'] = True\n    if '$' not in cur:\n        cur['$'] = idx\n\ndef search(word, cur, idx):\n    for i in word:\n        if i not in cur or cur[i]['idx'] > idx:\n            break\n        pre = cur\n        cur = cur[i]\n    while True:\n        a = []\n        if cur['isWord'] and cur['$'] <= idx:\n            return cur['$']\n        else:\n            for i in 'abcdefghijklmnopqrstuvwxyz':\n                if i in cur and cur[i]['idx'] <= idx:\n                    a.append(i)\n            a.sort()\n            cur = cur[a[0]]\nn = int(input())\nfor i in range(n):\n    x = input().strip()\n    words.append(x)\n    insert(x, trie, i)\nfor i in range(int(input())):\n    (idx, x) = list(input().split())\n    idx = int(idx)\n    idx -= 1\n    print(words[search(x, trie, idx)])", "import sys\n\ndef input():\n    return sys.stdin.readline()\n\ndef mapi():\n    return map(int, input().split())\n\ndef print(arg, *argv, end=None):\n    sys.stdout.write(str(arg))\n    for i in argv:\n        sys.stdout.write(' ' + str(i))\n    sys.stdout.write(end) if end else sys.stdout.write('\\n')\n\nclass Node(object):\n\n    def __init__(self, idx):\n        self.isWord = False\n        self.children = {}\n        self.idx = idx\n        self.end = None\n\nclass Trie(object):\n\n    def __init__(self):\n        self.root = Node(0)\n\n    def insert(self, word, idx):\n        tmp = self.root\n        for i in word:\n            if i not in tmp.children:\n                tmp.children[i] = Node(idx)\n            tmp = tmp.children[i]\n        tmp.isWord = True\n        if tmp.end == None:\n            tmp.end = idx\n\n    def search(self, word, idx):\n        tmp = self.root\n        for i in word:\n            if i not in tmp.children or tmp.children[i].idx > idx:\n                break\n            tmp = tmp.children[i]\n        while True:\n            a = []\n            if tmp.isWord and tmp.end <= idx:\n                return tmp.end\n            else:\n                for i in tmp.children:\n                    if tmp.children[i].idx <= idx:\n                        a.append(i)\n                a.sort()\n                tmp = tmp.children[a[0]]\n\ndef solve():\n    t = 1\n    while t:\n        t -= 1\n        n = int(input())\n        s = []\n        trie = Trie()\n        for i in range(n):\n            x = input().strip()\n            s.append(x)\n            trie.insert(x, i)\n        for q in range(int(input())):\n            (idx, x) = input().split()\n            idx = int(idx)\n            idx -= 1\n            print(s[trie.search(x, idx)])\nsolve()", "import sys\n\ndef input():\n    return sys.stdin.readline()\n\ndef mapi():\n    return map(int, input().split())\n\ndef print(arg, *argv, end=None):\n    sys.stdout.write(str(arg))\n    for i in argv:\n        sys.stdout.write(' ' + str(i))\n    sys.stdout.write(end) if end else sys.stdout.write('\\n')\n\nclass Node(object):\n\n    def __init__(self, idx):\n        self.isWord = False\n        self.children = {}\n        self.idx = idx\n        self.end = None\n\nclass Trie(object):\n\n    def __init__(self):\n        self.root = Node(0)\n\n    def insert(self, word, idx):\n        tmp = self.root\n        for i in word:\n            if i not in tmp.children:\n                tmp.children[i] = Node(idx)\n            tmp = tmp.children[i]\n        tmp.isWord = True\n        if tmp.end == None:\n            tmp.end = idx\n\n    def search(self, word, idx):\n        tmp = self.root\n        for i in word:\n            if i not in tmp.children or tmp.children[i].idx > idx:\n                break\n            tmp = tmp.children[i]\n        while True:\n            a = []\n            if tmp.isWord and tmp.end <= idx:\n                return tmp.end\n            else:\n                for i in tmp.children:\n                    if tmp.children[i].idx <= idx:\n                        a.append(i)\n                a.sort()\n                tmp = tmp.children[a[0]]\n\ndef solve():\n    t = 1\n    while t:\n        t -= 1\n        n = int(input())\n        s = []\n        trie = Trie()\n        for i in range(n):\n            x = input().strip()\n            s.append(x)\n            trie.insert(x, i)\n        for q in range(int(input())):\n            (idx, x) = input().split()\n            idx = int(idx)\n            idx -= 1\n            print(s[trie.search(x, idx)])\nsolve()", "class node:\n\n    def __init__(self, index, eow=False):\n        self.index = index\n        self.characters = {}\n        self.eow = eow\n        self.end = None\n\ndef insert(root, word, ind):\n    for i in word:\n        if i in root.characters:\n            root = root.characters[i]\n        else:\n            new = node(ind)\n            root.characters[i] = new\n            root = new\n    root.eow = True\n    if root.end == None:\n        root.end = ind\n\ndef search(root, word, ind):\n    a = []\n    for i in word:\n        if i in root.characters and root.characters[i].index <= ind:\n            root = root.characters[i]\n        else:\n            break\n    while True:\n        a = []\n        if root.eow and root.end <= ind:\n            return root.end\n        else:\n            for i in root.characters:\n                if root.characters[i].index <= ind:\n                    a.append(i)\n            a.sort()\n            root = root.characters[a[0]]\nroot_node = node(1)\na = []\nfor i in range(1, int(input()) + 1):\n    s = input()\n    insert(root_node, s, i)\n    a.append(s)\nfor _ in range(int(input())):\n    (idx, s) = input().split()\n    print(a[search(root_node, s, int(idx)) - 1])", "search = {}\nn = int(input())\nread = []\nfor i in range(n):\n    read.append(input())\nfor i in range(n):\n    search[i] = []\nq = int(input())\nfor i in range(q):\n    (na, s) = input().split()\n    na = int(na)\n    na = na - 1\n    search[na].append([i, s])\nresult = [0] * q\nlookup = {}\nmini = read[0]\nfor i in range(n):\n    temp = ''\n    for j in range(len(read[i])):\n        temp += read[i][j]\n        if temp in lookup:\n            lookup[temp] = min(lookup[temp], read[i])\n        else:\n            lookup[temp] = read[i]\n    mini = min(mini, read[i])\n    for s1 in search[i]:\n        string = s1[1]\n        index = s1[0]\n        temp = ''\n        ans = ''\n        for j in range(len(string)):\n            temp += string[j]\n            if temp in lookup:\n                ans = lookup[temp]\n        if not ans:\n            ans = mini\n        result[index] = ans\nfor i in result:\n    print(i)", "class Node:\n\n    def __init__(self):\n        self.key = {}\n        self.leaf = False\n\nclass Trie:\n\n    def __init__(self):\n        self.root = Node()\n\n    def insert(self, word):\n        x = self.root\n        for letter in word:\n            if x.key.get(letter):\n                x = x.key[letter]\n            else:\n                x.key[letter] = Node()\n                x = x.key[letter]\n        x.leaf = True\n\n    def search(self, word):\n        ans = ''\n        x = self.root\n        for letter in word:\n            if x.key.get(letter):\n                ans = ans + letter\n                x = x.key[letter]\n            else:\n                break\n        if not x.leaf:\n            while not x.leaf:\n                for i in sorted(x.key.keys()):\n                    if x.key.get(i):\n                        ans = ans + i\n                        x = x.key[i]\n                        break\n            return ans\n        return ans\nstrings = []\nt = Trie()\nfor _ in range(int(input())):\n    strings.append(input())\ncommands = []\nanswer = []\nfor _ in range(int(input())):\n    commands.append(input().split())\n    commands[_].append(_)\n    answer.append(0)\n    commands[_][0] = int(commands[_][0])\ncommands = sorted(commands)\nm = 0\nfor command in commands:\n    if int(command[0]) > m:\n        for string in range(m, int(command[0])):\n            t.insert(strings[string])\n        m = int(command[0])\n    answer[command[2]] = t.search(command[1])\nfor i in answer:\n    print(i)", "n = int(input())\nd = {}\na = []\noutput = []\noutput.append(0)\nfor i in range(n):\n    an = input()\n    a.append(an)\ncheck = a[0]\ncheckint = 0\nfor i in range(1, n):\n    if check > a[i]:\n        check = a[i]\n        output.append(i)\n    else:\n        output.append(output[-1])\nfor i in range(n):\n    k = len(a[i])\n    for j in range(k):\n        s = a[i][:j + 1]\n        if s not in d:\n            d[s] = [i]\n        elif a[d[s][-1]] > a[i]:\n            d[s].append(i)\nk = int(input())\nfor i in range(k):\n    (x, y) = input().split()\n    x = int(x)\n    l = len(y)\n    while l > 0:\n        ma = 'zzzzzzzzzzzzzz'\n        if y[0:l] in d:\n            for j in sorted(d[y[0:l]]):\n                if j >= x:\n                    break\n                if a[j] < ma:\n                    ma = a[j]\n            if ma != 'zzzzzzzzzzzzzz':\n                break\n        l -= 1\n    if ma != 'zzzzzzzzzzzzzz':\n        print(ma)\n        continue\n    print(a[output[x - 1]])", "from collections import defaultdict\nst = defaultdict(list)\nln = defaultdict(int)\nt = int(input())\nfor ijk in range(0, t):\n    s = input().strip()\n    n = len(s)\n    for i in range(n, -1, -1):\n        if ln[s[:i]] == 0:\n            st[s[:i]].append([ijk + 1, s])\n            ln[s[:i]] += 1\n        elif s < st[s[:i]][-1][1]:\n            st[s[:i]].append([ijk + 1, s])\n            ln[s[:i]] += 1\nq = int(input())\nfor ijk in range(0, q):\n    (r, p) = input().strip().split()\n    r = int(r)\n    n = len(p)\n    y = ''\n    for x in range(n, -1, -1):\n        a = p[:x]\n        l = st[a]\n        if a in st:\n            for i in range(0, len(l)):\n                c = l[i][0]\n                if c <= r:\n                    y = l[i][1]\n                    continue\n        if y != '':\n            break\n    if y == '':\n        print(st[''][0][1])\n    else:\n        print(y)", "class TrieNode:\n\n    def __init__(self, char: str, R: int):\n        self.char = char\n        self.children = [None] * 26\n        self.min_children = []\n        self.word_finished_at = 0\n        self.min_child = None\n        self.min_R = R\n\n    def add(self, word: str, R: int):\n        node = self\n        for char in word:\n            index = ord(char) - ord('a')\n            if node.children[index] is None:\n                new_node = TrieNode(char, R)\n                node.children[index] = new_node\n                if node.min_child is None:\n                    node.min_child = new_node\n                    node.min_children.append(new_node)\n                elif char < node.min_child.char:\n                    node.min_child = new_node\n                    node.min_children.append(new_node)\n            node = node.children[index]\n        if node.word_finished_at == 0:\n            node.word_finished_at = R\n\n    def find_match(self, word: str, R: int):\n        node = self\n        match = ''\n        for char in word:\n            index = ord(char) - ord('a')\n            if node.children[index] is not None:\n                if node.children[index].min_R <= R:\n                    node = node.children[index]\n                    match += node.char\n                else:\n                    break\n            else:\n                break\n        if node.word_finished_at > 0 and node.word_finished_at <= R:\n            return match\n        while node.word_finished_at == 0 or node.word_finished_at > R:\n            if node.min_child.min_R <= R:\n                node = node.min_child\n            else:\n                for child in reversed(node.min_children):\n                    if child.min_R <= R:\n                        node = child\n                        break\n            match += node.char\n        return match\nroot = TrieNode('*', 99999999)\nN = int(input())\nS = set()\nfor i in range(N):\n    string = input()\n    if string not in S:\n        root.add(string, i + 1)\n        S.add(string)\nm = int(input())\nfor _ in range(m):\n    line = input().split()\n    R = int(line[0])\n    query = line[1]\n    print(root.find_match(query, R))", "n = input()\nn = int(n)\ns = []\nd1 = dict()\nl5 = [None] * n\nl6 = [None] * n\nans1 = ''\nfor j in range(n):\n    ele = input()\n    if len(ans1) == 0:\n        ans1 = ele\n    elif ele < ans1:\n        ans1 = ele\n    l5[j] = ans1\n    s.append(ele)\n    for i in range(len(ele)):\n        if ele[0:i + 1] not in d1:\n            l1 = []\n            l1.append((j, s[j]))\n            d1[ele[0:i + 1]] = l1\n        else:\n            l1 = d1[ele[0:i + 1]]\n            pg = l1[len(l1) - 1][1]\n            if pg < s[j]:\n                l1.append((j, pg))\n            else:\n                l1.append((j, s[j]))\n            d1[ele[0:i + 1]] = l1\nq = input()\nq = int(q)\nwhile q > 0:\n    pg = input()\n    pg = pg.split(' ')\n    r = int(pg[0])\n    p = pg[1]\n    ans = ''\n    p1 = ''\n    if len(p) == 0:\n        print(l5[r - 1])\n    elif p[0] not in d1:\n        print(l5[r - 1])\n    else:\n        for i in range(len(p), 0, -1):\n            temp = p[0:i]\n            if temp in d1:\n                l1 = d1[temp]\n                low = 0\n                high = len(l1) - 1\n                flag = 0\n                while low < high:\n                    mid = (low + high) / 2\n                    mid = int(mid)\n                    if l1[mid][0] + 1 == r:\n                        flag = 1\n                        ans = l1[mid][1]\n                        break\n                    elif l1[mid][0] + 1 > r:\n                        high = mid - 1\n                    else:\n                        low = mid + 1\n                if flag == 1:\n                    break\n                elif l1[low][0] + 1 > r:\n                    if low != 0:\n                        ans = l1[low - 1][1]\n                else:\n                    ans = l1[low][1]\n            if len(ans) > 0:\n                break\n        if len(ans) == 0:\n            print(l5[r - 1])\n        else:\n            print(ans)\n    q -= 1", "ROOT = dict()\n(words, queries, results) = ([], [], [])\n\ndef add_word(word, root=ROOT):\n    for letter in word + '$':\n        if letter not in root:\n            root[letter] = dict()\n        root = root[letter]\n\ndef solve(word, root=ROOT):\n    ans = ''\n    for letter in word:\n        if letter not in root:\n            break\n        root = root[letter]\n        ans += letter\n    while root:\n        child = min(root)\n        ans += child\n        root = root[child]\n    return ans[:-1]\nfor _ in range(int(input())):\n    words.append(input().strip())\nfor qid in range(int(input())):\n    (num, word) = input().split()\n    queries.append((int(num), word, qid))\nlast_word_added = -1\nfor (num, word, qid) in sorted(queries, key=lambda x: x[0]):\n    while num > last_word_added + 1:\n        add_word(words[last_word_added + 1])\n        last_word_added += 1\n    ans = solve(word)\n    results.append((qid, ans))\nfor (qid, ans) in sorted(results, key=lambda x: x[0]):\n    print(ans)", "ROOT = dict()\nalpha = ['$', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\nword_list = []\nqueries = []\n\ndef add_word(word):\n    word = word + '$'\n    root = ROOT\n    for letter in word:\n        if letter not in root:\n            root[letter] = dict()\n        root = root[letter]\nfor _ in range(int(input())):\n    word_list.append(input().strip())\nlast_word_added = -1\nfor qid in range(int(input())):\n    (num, word) = input().split()\n    num = int(num)\n    queries.append((num, word, qid))\nqueries.sort(key=lambda x: x[0])\nresults = []\nfor (num, word, qid) in queries:\n    while num > last_word_added + 1:\n        add_word(word_list[last_word_added + 1])\n        last_word_added += 1\n    ans = ''\n    root = ROOT\n    lim = len(word)\n    pos = 0\n    for letter in word:\n        if letter not in root:\n            break\n        root = root[letter]\n        ans += letter\n    while root:\n        key = min(root)\n        ans += key\n        root = root[key]\n    results.append((qid, ans[:-1]))\nresults.sort(key=lambda x: x[0])\nfor (qid, ans) in results:\n    print(ans)", "def insert(oldic, string, depth=0):\n    if type(oldic) == dict:\n        dic = oldic.copy()\n        if string[depth] in dic.keys():\n            dic[string[depth]] = insert(dic[string[depth]], string, depth + 1)\n            return dic.copy()\n        else:\n            dic[string[depth]] = string\n            return dic.copy()\n    else:\n        dic = oldic\n        if dic == string:\n            return dic\n        elif dic[depth] == string[depth]:\n            return {dic[depth]: insert(dic, string, depth + 1)}\n        else:\n            return {dic[depth]: dic, string[depth]: string}\nn = int(input())\narr = []\nfor _ in range(n):\n    arr += [input()]\nmainarr = [{}]\ndic = {}\nfor i in range(1, n + 1):\n    dic = insert(dic, arr[i - 1] + ' ')\n    mainarr.append(dic.copy())\nq = int(input())\nfor _ in range(q):\n    (r, string) = input().split()\n    r = int(r)\n    maindic = mainarr[r]\n    for depth in range(len(string)):\n        if type(maindic) != dict:\n            break\n        elif string[depth] in maindic.keys():\n            maindic = maindic[string[depth]]\n        else:\n            break\n    if type(maindic) != dict:\n        print(maindic)\n    else:\n        lis = [' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n        while type(maindic) == dict:\n            i = ''\n            for letter in lis:\n                if letter in maindic.keys():\n                    i = letter\n                    break\n            maindic = maindic[i]\n        print(maindic)", "class Mynode(object):\n\n    def __init__(self, char):\n        self.char = char\n        self.children = []\n        self.end = False\n\ndef add(root, word):\n    node = root\n    for char in word:\n        found = False\n        for child in node.children:\n            if child.char == char:\n                node = child\n                found = True\n                break\n        if not found:\n            newNode = Mynode(char)\n            node.children.append(newNode)\n            node = newNode\n    node.end = True\n\ndef find(root, prefix):\n    ans = ''\n    node = root\n    for char in prefix:\n        found = False\n        for child in node.children:\n            if child.char == char:\n                found = True\n                ans += child.char\n                node = child\n                break\n        if not found:\n            break\n    while not node.end:\n        temp = node.children[0]\n        for child in node.children:\n            if child.char < temp.char:\n                temp = child\n        node = temp\n        ans += temp.char\n    return ans\nN = int(input())\nstrings = []\nfor k in range(N):\n    strings.append(input())\nQ = int(input())\nqueries = []\nout = []\nfor k in range(Q):\n    queries.append(input().split())\n    out.append('')\nqueries = sorted(enumerate(queries), key=lambda x: int(x[1][0]))\ntrie = Mynode(None)\nptr = 0\nfor k in range(Q):\n    qry = int(queries[k][1][0])\n    while ptr != qry:\n        add(trie, strings[ptr])\n        ptr += 1\n    out[queries[k][0]] = find(trie, queries[k][1][1])\nfor k in range(Q):\n    print(out[k])", "n = int(input())\no = []\np = {}\nfor j in range(n):\n    s = input()\n    c = p\n    for i in s + '1':\n        x = [{}, j]\n        if 'min' not in c and i != '1':\n            c['min'] = i\n        elif i != '1' and i < c['min']:\n            c['min'] = i\n        if i not in c:\n            c[i] = x\n        c = c[i][0]\nq = int(input())\nfor j in range(q):\n    m = input().split()\n    n = int(m[0])\n    c = p\n    x = m[1][0]\n    for i in m[1]:\n        if i in c and c[i][1] < n:\n            print(i, end='')\n            c = c[i][0]\n            x = i\n        else:\n            break\n    if '1' in c and c['1'][1] < n:\n        pass\n    else:\n        while True:\n            if 'min' in c and (not ('1' in c and c['1'][1] < n)):\n                if c[c['min']][1] < n:\n                    print(c['min'], end='')\n                    c = c[c['min']][0]\n                else:\n                    min = '111'\n                    for k in c.keys():\n                        if k != 'min' and c[k][1] < n:\n                            if min == '111' or min > k:\n                                min = k\n                    print(min, end='')\n                    c = c[min][0]\n            else:\n                break\n    print()", "from collections import defaultdict\nst = defaultdict(list)\nln = defaultdict(int)\nt = int(input())\nfor ijk in range(0, t):\n    s = input().strip()\n    n = len(s)\n    for i in range(n, -1, -1):\n        if ln[s[:i]] == 0:\n            st[s[:i]].append([ijk + 1, s])\n            ln[s[:i]] += 1\n        elif s < st[s[:i]][-1][1]:\n            st[s[:i]].append([ijk + 1, s])\n            ln[s[:i]] += 1\nq = int(input())\nfor ijk in range(0, q):\n    (r, p) = input().strip().split()\n    r = int(r)\n    l = 0\n    final = [[float('inf'), 0]]\n    n = len(p)\n    for i in range(n, -1, -1):\n        l = len(st[p[:i]])\n        if l != 0:\n            final = st[p[:i]]\n        if final[0][0] <= r:\n            break\n    ans = final[0][1]\n    for j in final:\n        if j[0] <= r:\n            if j[1] < ans:\n                ans = j[1]\n        else:\n            break\n    print(ans)", "def sheokand2(dic, r, querie):\n    curdic = dic\n    word = ''\n    for i in querie:\n        if i in curdic:\n            if curdic[i]['rList'][0] < r:\n                word += i\n                curdic = curdic[i]\n            else:\n                break\n        else:\n            break\n    result = getrem(r, curdic)\n    word += result\n    return word\n\ndef getrem(r, curdic):\n    if curdic['rList'][0] >= r:\n        return False\n    if 'end' in curdic and curdic['end'] < r:\n        return ''\n    key = curdic['aList']\n    for i in key:\n        word = getrem(r, curdic[i])\n        if word != False:\n            return i + word\n    return False\n\ndef sortdic(dic):\n    dic['aList'] = list(dic['aList'])\n    dic['aList'].sort()\n    for i in dic['aList']:\n        sortdic(dic[i])\n\ndef makedic(strings):\n    dic = {'rList': [], 'aList': set()}\n    for i in range(len(strings)):\n        string = strings[i]\n        curdic = dic\n        curdic['rList'].append(i)\n        for j in string:\n            curdic['aList'].add(j)\n            if j in curdic:\n                curdic = curdic[j]\n            else:\n                curdic[j] = {'rList': [], 'aList': set()}\n                curdic = curdic[j]\n            curdic['rList'].append(i)\n        if 'end' not in curdic:\n            curdic['end'] = i\n    sortdic(dic)\n    return dic\nn = int(input())\nstrings = []\nfor i in range(n):\n    strings.append(input())\ndic = makedic(strings)\nq = int(input())\nfor i in range(q):\n    (r, querie) = input().split(' ')\n    print(sheokand2(dic, int(r), querie))", "def findstring(r, p, s):\n\n    def rec1(t, st):\n        if st != '' and st[0] in s[t][2]:\n            nt = s[t][2][st[0]]\n            if s[nt][1] < r:\n                (t, n) = rec1(nt, st[1:])\n                return (t, n + 1)\n        return (t, 0)\n\n    def rec2(t):\n        l = [x for x in s[t][2] if s[s[t][2][x]][1] < r]\n        m = min(l)\n        if m == '.':\n            return ''\n        return m + rec2(s[t][2][m])\n    (t, n) = rec1(0, p)\n    return p[:n] + rec2(t)\nn = int(input().strip())\ns = [('*', 0, {})]\nx = 1\nfor age in range(n):\n    t = 0\n    w = input() + '.'\n    for i in range(len(w)):\n        if w[i] not in s[t][2]:\n            s[t][2][w[i]] = x\n            s.append((w[i], age, {}))\n            t = x\n            x += 1\n        else:\n            t = s[t][2][w[i]]\nq = int(input().strip())\nfor case in range(q):\n    (r, p) = [i for i in input().strip().split()]\n    print(findstring(int(r), p, s))", "def findstring(r, p, s):\n    z = ''\n    lp = len(p)\n    f = True\n    t = 0\n    i = 0\n    while i < 12:\n        if f and i < lp:\n            if p[i] in s[t][2] and s[s[t][2][p[i]]][1] < r:\n                z += p[i]\n                t = s[t][2][p[i]]\n                i += 1\n            else:\n                f = False\n        else:\n            l = list(s[t][2])\n            l.sort()\n            for j in l:\n                nt = s[t][2][j]\n                if s[nt][1] < r:\n                    i += 1\n                    t = nt\n                    if j == '.':\n                        return z\n                    z += j\n                    break\n    assert 0\nn = int(input().strip())\ns = [('*', 0, {})]\nx = 1\nfor age in range(n):\n    t = 0\n    w = input() + '.'\n    for i in range(len(w)):\n        if w[i] not in s[t][2]:\n            s[t][2][w[i]] = x\n            s.append((w[i], age, {}))\n            t = x\n            x += 1\n        else:\n            t = s[t][2][w[i]]\nq = int(input().strip())\nfor case in range(q):\n    (r, p) = [i for i in input().strip().split()]\n    print(findstring(int(r), p, s))", "def findstring(r, p, s):\n    z = ''\n    lp = len(p)\n    f = True\n    t = 0\n    i = 0\n    while i < 12:\n        if f == True and i < lp:\n            if p[i] in s[t][2]:\n                nt = s[t][2][p[i]]\n                if s[nt][1] < r:\n                    z += p[i]\n                    t = nt\n                    i += 1\n                else:\n                    f = False\n            else:\n                f = False\n        else:\n            l = []\n            for k in s[t][2]:\n                l.append(k)\n            l.sort()\n            for j in l:\n                nt = s[t][2][j]\n                if s[nt][1] < r:\n                    i += 1\n                    t = nt\n                    if j == '.':\n                        return z\n                    z += j\n                    break\n    return z\nn = int(input().strip())\ns = [('*', 0, {})]\nx = 1\nfor age in range(n):\n    t = 0\n    w = input() + '.'\n    for i in range(len(w)):\n        if w[i] not in s[t][2]:\n            s[t][2].update({w[i]: x})\n            s.append((w[i], age, {}))\n            t = x\n            x += 1\n        else:\n            t = s[t][2][w[i]]\nq = int(input().strip())\nfor case in range(q):\n    (r, p) = [i for i in input().strip().split()]\n    print(findstring(int(r), p, s))", "from string import ascii_lowercase\n\ndef main():\n    n = int(input())\n    trie = dict()\n    words = []\n    for i in range(n):\n        word = input() + '-'\n        words.append(word)\n        for j in range(len(word) + 1):\n            key = word[:j]\n            if key not in trie:\n                trie[key] = [i, 1]\n            else:\n                trie[key][1] += 1\n    trie[''] = [min(words), n]\n    m = int(input())\n    for i in range(m):\n        (r, word) = input().split()\n        r = int(r)\n        j = 0\n        while True:\n            sub = word[:j + 1]\n            if sub not in trie:\n                break\n            if trie[sub][0] >= r:\n                break\n            j += 1\n            if j == len(word):\n                break\n            if trie[sub][1] == 1:\n                break\n        ans = word[:j]\n        while trie[ans][1] > 1:\n            for l in '-' + ascii_lowercase:\n                new_ans = ans + l\n                if new_ans in trie and trie[new_ans][0] < r:\n                    ans = new_ans\n                    break\n            else:\n                break\n        print(words[trie[ans][0]][:-1])\nmain()", "def search(list, r):\n    if r < list[0][0]:\n        return None\n    low = 0\n    high = len(list) - 1\n    temp = 0\n    while high >= low:\n        mid = low + high >> 1\n        if list[mid][0] == r:\n            return list[mid][1]\n        elif list[mid][0] < r:\n            if high == low:\n                return list[mid][1]\n            temp = mid\n            low = mid + 1\n        elif high == low:\n            break\n        else:\n            high = mid - 1\n    return list[temp][1]\nno_of_strings = int(input())\nstrings_list = []\nd = {0: 'z' * 10}\nfor i in range(no_of_strings):\n    strings_list.append(input())\n    d[i + 1] = min(strings_list[i], d[i])\nhash_map = {}\nfor i in range(no_of_strings):\n    for j in range(len(strings_list[i])):\n        temp = strings_list[i][:j + 1]\n        if temp in hash_map:\n            if hash_map[temp][-1][-1] > strings_list[i]:\n                hash_map[temp].append([i, strings_list[i]])\n        else:\n            hash_map[temp] = [[i, strings_list[i]]]\nno_of_queries = int(input())\nfor _ in range(no_of_queries):\n    (r, p) = input().split()\n    r = int(r)\n    found = False\n    while not found and len(p) > 0:\n        if p in hash_map:\n            temp = hash_map[p]\n            ans = search(temp, r - 1)\n            if ans != None:\n                print(ans)\n                found = True\n            else:\n                p = p[:-1]\n        else:\n            p = p[:-1]\n    if not found:\n        print(d[r])", "class TrieNode:\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\n\nclass Trie:\n\n    def __init__(self):\n        self.root = self.getNode()\n\n    def getNode(self):\n        return TrieNode()\n\n    def _charToIndex(self, ch):\n        return ord(ch) - ord('a')\n\n    def insert(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            pCrawl = pCrawl.children[index]\n        pCrawl.isEndOfWord = True\n\n    def search(self, key):\n        pCrawl = self.root\n        length = len(key)\n        out = ''\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if pCrawl.children[index]:\n                out += chr(index + ord('a'))\n                pCrawl = pCrawl.children[index]\n            else:\n                break\n        while not pCrawl.isEndOfWord:\n            for i in range(26):\n                if pCrawl.children[i]:\n                    out += chr(i + ord('a'))\n                    pCrawl = pCrawl.children[i]\n                    break\n        return out\nn = int(input())\nstrings = [0] * n\nfor i in range(n):\n    strings[i] = input()\nq = int(input())\nqueries = [0] * q\nouts = [0] * q\nfor i in range(q):\n    (l, t) = input().split()\n    l = int(l)\n    queries[i] = [l, t, i]\nqueries.sort()\nt = Trie()\ninserted = 0\nfor i in range(q):\n    while inserted < queries[i][0]:\n        t.insert(strings[inserted])\n        inserted += 1\n    outs[i] = (queries[i][2], t.search(queries[i][1]))\nouts.sort()\nfor i in outs:\n    print(i[1])", "import sys\nf = sys.stdin\nn = int(f.readline())\ns = []\nsd = []\nfor i in range(n):\n    z = input()\n    s.append(z)\n    sd.append(z)\nq = int(f.readline())\nquer = []\nfor i in range(q):\n    (r, p) = input().split()\n    quer.append([int(r), p, i])\nquer.sort()\narr = {'': s[0]}\nsd.sort()\nsortord = {}\nfor j in range(n):\n    sortord[sd[j]] = j\nc = 0\nfinalans = {}\nfor i in range(q):\n    while c < quer[i][0]:\n        tb = ''\n        if sortord[arr[tb]] >= sortord[s[c]]:\n            arr[tb] = s[c]\n        for k in range(len(s[c])):\n            tb += s[c][k]\n            if tb not in arr:\n                arr[tb] = s[c]\n            elif sortord[arr[tb]] >= sortord[s[c]]:\n                arr[tb] = s[c]\n        c += 1\n    tb = ''\n    ans = arr[tb]\n    for k in range(len(quer[i][1])):\n        tb += quer[i][1][k]\n        if tb in arr:\n            ans = arr[tb]\n        else:\n            break\n    finalans[quer[i][2]] = ans\nfor i in range(q):\n    print(finalans[i])", "class TrieNode:\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEndOfWord = False\n        self.Min = chr(255)\n\nclass Trie:\n\n    def __init__(self):\n        self.root = self.getNode()\n\n    def getNode(self):\n        return TrieNode()\n\n    def _charToIndex(self, ch):\n        return ord(ch) - ord('a')\n\n    def insert(self, key):\n        pCrawl = self.root\n        length = len(key)\n        for level in range(length):\n            index = self._charToIndex(key[level])\n            if not pCrawl.children[index]:\n                pCrawl.children[index] = self.getNode()\n            if pCrawl.Min > key[level]:\n                pCrawl.Min = key[level]\n            pCrawl = pCrawl.children[index]\n        pCrawl.isEndOfWord = True\n\n    def FindAns(self, PFix):\n        pCrawl = self.root\n        i = 0\n        Ans = ''\n        for level in range(len(PFix)):\n            index = self._charToIndex(PFix[level])\n            if not pCrawl.children[index]:\n                break\n            Ans += PFix[level]\n            pCrawl = pCrawl.children[index]\n            i += 1\n        while True:\n            if pCrawl.isEndOfWord:\n                break\n            else:\n                Ans += pCrawl.Min\n                idx = self._charToIndex(pCrawl.Min)\n                pCrawl = pCrawl.children[idx]\n        return Ans\n\ndef main():\n    t = Trie()\n    N = int(input())\n    StrList = []\n    Queries = []\n    for i in range(N):\n        StrList.append(input())\n    Q = int(input())\n    Ans = ['' for x in range(Q)]\n    for i in range(Q):\n        (r, p) = map(str, input().split())\n        r = int(r)\n        Queries.append((r, i, p))\n    Queries.sort()\n    (i, j) = (0, 0)\n    while i < Q:\n        if j == Queries[i][0]:\n            Ans[Queries[i][1]] = t.FindAns(Queries[i][2])\n            i += 1\n        elif j < N:\n            t.insert(StrList[j])\n            j += 1\n    for x in Ans:\n        print(x)\nmain()", "import bisect\ns = []\nd = {}\nd2 = {}\n\ndef createstr():\n    for (j, i) in enumerate(s):\n        if i not in d:\n            d[i] = [s[j]]\n        else:\n            bisect.insort(d[i], s[j])\n        for k in range(len(i) - 2, -1, -1):\n            if i[:k + 1] not in d:\n                d[i[:k + 1]] = [s[j]]\n            else:\n                bisect.insort(d[i[:k + 1]], s[j])\n    d[''] = sorted(s)\n\ndef solve(p, r):\n    for i in range(len(p), -1, -1):\n        if p[:i] in d:\n            for o in d[p[:i]]:\n                if d2[o] < r:\n                    print(o)\n                    return\nn = int(input())\nfor i in range(n):\n    m = input()\n    s.append(m)\n    if m not in d2:\n        d2[m] = i\ncreatestr()\nq = int(input())\nfor i in range(q):\n    (r, p) = input().split()\n    r = int(r)\n    solve(p, r)", "class Node:\n\n    def __init__(self, value, index, next=None, minString=None):\n        self.value = value\n        self.minString = minString or 'zzzzzzzzzzz'\n        self.next = next or set()\n        self.index = index\n\n    def __eq__(self, other):\n        return isinstance(other, Node) and self.value == other.value and (self.index == other.index)\n\n    def __hash__(self):\n        return hash((self.value, self.index))\n\n    def __repr__(self):\n        return '{cls}(value={value}, index={index}, minString={minString}, next={next})'.format(cls=self.__class__.__name__, value=self.value, index=self.index, next=self.next, minString=self.minString)\n\n    def add_min_string(self, minString):\n        self.minString = min(self.minString, minString)\n\n    def get_node_in_next(self, value, index):\n        for nextNode in self.next:\n            if nextNode.value == value and nextNode.index == index:\n                return nextNode\n        return Node(value, index)\n\n    def get_next_node(self, value, index):\n        for nextNode in self.next:\n            if nextNode.value == value and nextNode.index == index:\n                return nextNode\n        return None\n\n    def add_to_next(self, node):\n        self.next.add(node)\n\ndef process_queries(strings, queries):\n    answers = {}\n    startNode = Node(value='', index=0)\n    for (stringId, string) in enumerate(iterable=strings, start=1):\n        prev = startNode\n        startNode.add_min_string(minString=string)\n        for (letterIndex, letter) in enumerate(iterable=string, start=1):\n            node = prev.get_node_in_next(value=letter, index=letterIndex)\n            node.add_min_string(minString=string)\n            prev.add_to_next(node=node)\n            prev = node\n        if stringId in queries:\n            patterns = queries[stringId]\n            for pattern in patterns:\n                answers[stringId, pattern] = query(tree=startNode, pattern=pattern)\n    return answers\n\ndef query(tree, pattern):\n    node = tree\n    prev = node\n    for (index, letter) in enumerate(pattern, 1):\n        node = node.get_next_node(value=letter, index=index)\n        if not node:\n            break\n        prev = node\n    return prev.minString\nstrings = []\nT = int(input())\nfor _ in range(T):\n    s = input()\n    strings.append(s)\nqueryList = []\nQ = int(input())\nfor __ in range(Q):\n    (r, pattern) = list(input().split())\n    queryList.append((int(r), pattern))\nqueries = {}\nfor (index, pattern) in queryList:\n    if index in queries:\n        queries[index].append(pattern)\n    else:\n        queries[index] = [pattern]\nanswers = process_queries(strings=strings, queries=queries)\nfor q in queryList:\n    print(answers[q])", "class Node:\n\n    def __init__(self, value, index, next=None, minString=None):\n        self.value = value\n        self.minString = minString or 'zzzzzzzzzzz'\n        self.next = next or set()\n        self.index = index\n\n    def __eq__(self, other):\n        return isinstance(other, Node) and self.value == other.value and (self.index == other.index)\n\n    def __hash__(self):\n        return hash((self.value, self.index))\n\n    def __repr__(self):\n        return '{cls}(value={value}, index={index}, minString={minString}, next={next})'.format(cls=self.__class__.__name__, value=self.value, index=self.index, next=self.next, minString=self.minString)\n\n    def add_min_string(self, minString):\n        self.minString = min(self.minString, minString)\n\n    def get_node_in_next(self, value, index):\n        for nextNode in self.next:\n            if nextNode.value == value and nextNode.index == index:\n                return nextNode\n        return Node(value, index)\n\n    def get_next_node(self, value, index):\n        for nextNode in self.next:\n            if nextNode.value == value and nextNode.index == index:\n                return nextNode\n        return None\n\n    def add_to_next(self, node):\n        self.next.add(node)\n\ndef process_queries(strings, queries):\n    answers = {}\n    startNode = Node(value='', index=0)\n    for (stringId, string) in enumerate(iterable=strings, start=1):\n        prev = startNode\n        startNode.add_min_string(minString=string)\n        for (letterIndex, letter) in enumerate(iterable=string, start=1):\n            node = prev.get_node_in_next(value=letter, index=letterIndex)\n            node.add_min_string(minString=string)\n            prev.add_to_next(node=node)\n            prev = node\n        if stringId in queries:\n            patterns = queries[stringId]\n            for pattern in patterns:\n                answers[stringId, pattern] = query(tree=startNode, pattern=pattern)\n    return answers\n\ndef query(tree, pattern):\n    match = ''\n    node = tree\n    prev = node\n    for (index, letter) in enumerate(pattern, 1):\n        prev = node\n        node = node.get_next_node(value=letter, index=index)\n        if not node:\n            break\n        prev = node\n    return prev.minString\nstrings = []\nT = int(input())\nfor _ in range(T):\n    s = input()\n    strings.append(s)\nqueryList = []\nQ = int(input())\nfor __ in range(Q):\n    (r, pattern) = list(input().split())\n    queryList.append((int(r), pattern))\nqueries = {}\nfor (index, pattern) in queryList:\n    if index in queries:\n        queries[index].append(pattern)\n    else:\n        queries[index] = [pattern]\nanswers = process_queries(strings=strings, queries=queries)\nfor q in queryList:\n    print(answers[q])", "class TrieNode:\n    mapping = {'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.value = None\n        self.terminal = False\n        self.terminal_word_index = -1\n        self.word_index = -1\n        self.word_value = None\n\n    def __setitem__(self, key, item):\n        idx = self.mapping[key]\n        self.children[idx] = item\n\n    def __getitem__(self, key):\n        idx = self.mapping[key]\n        return self.children[idx]\n\nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode()\n        self.word_counter = 0\n\n    def insert(self, key):\n        node = self.root\n        index_last_char = None\n        for (index_c, c) in enumerate(key):\n            nextnode = node[c]\n            if nextnode:\n                node = nextnode\n            else:\n                index_last_char = index_c\n                break\n        if index_last_char is not None:\n            for c in key[index_last_char:]:\n                newnode = TrieNode()\n                node[c] = newnode\n                node = newnode\n                node.value = c\n                node.word_index = self.word_counter\n        node.terminal = True\n        if node.terminal_word_index == -1:\n            node.terminal_word_index = self.word_counter\n        node.word_value = key\n        self.word_counter += 1\n\n    def search_all(self, key, word_index):\n        node = self.root\n        common_prefix = []\n        for c in key:\n            next_node = node[c]\n            if next_node is None or word_index < next_node.word_index:\n                break\n            node = next_node\n            common_prefix.append(c)\n        stack = [node]\n        while stack:\n            current = stack.pop()\n            if current.terminal and word_index >= current.terminal_word_index:\n                yield current.word_value\n            for child in reversed(current.children):\n                if child is None or word_index < child.word_index:\n                    continue\n                stack.append(child)\n\n    def search(self, key, word_index):\n        for w in self.search_all(key, word_index):\n            return w\n\ndef main():\n    t = Trie()\n    N = int(input())\n    for _ in range(N):\n        t.insert(input())\n    Q = int(input())\n    for _ in range(Q):\n        query = input().split()\n        R = int(query[0])\n        P = query[1]\n        res = t.search(P, R - 1)\n        print(res)\nmain()", "n = int(input())\ns = []\nfians = '{{{{{{{{{{'\nfinalans = []\nfor i in range(n):\n    s.append(input())\n    if s[i] < fians:\n        fians = s[i]\n    finalans.append(fians)\nbest = {}\nans = {}\nfor i in range(n):\n    for k in range(len(s[i])):\n        f = 0\n        temp = s[i][0:k + 1]\n        if temp not in best:\n            best[temp] = s[i]\n            f = 1\n            ans[temp] = []\n        elif s[i] < best[temp]:\n            best[temp] = s[i]\n            f = 1\n        if f == 1:\n            ans[temp].append(i)\nq = int(input())\nfor i in range(q):\n    flag = 0\n    kr = input()\n    kr = kr.split()\n    k = int(kr[0]) - 1\n    r = kr[1]\n    for j in range(len(r) - 1, -1, -1):\n        maybe = -1\n        temp = r[0:j + 1]\n        if temp in ans:\n            li = ans[temp]\n        else:\n            continue\n        if len(li) == 0:\n            continue\n        low = 0\n        up = len(li) - 1\n        while low <= up:\n            mid = (up + low) // 2\n            if low + 1 == up:\n                if li[up] <= k and li[up] > maybe:\n                    maybe = li[up]\n                    flag = 1\n                    break\n                if li[low] <= k and li[low] > maybe:\n                    maybe = li[low]\n                    flag = 1\n                    break\n                break\n            if low == up:\n                if li[low] <= k and li[low] > maybe:\n                    maybe = li[low]\n                    flag = 1\n                    break\n                break\n            if li[mid] <= k and li[mid] > maybe:\n                maybe = li[mid]\n                flag = 1\n            if li[mid] < k:\n                low = mid\n            elif li[mid] > k:\n                up = mid\n            else:\n                break\n        if flag == 1:\n            print(s[maybe])\n            break\n    if flag == 0:\n        print(finalans[k])", "from bisect import bisect\nmax_p = 10\nN = int(input())\nlst = []\nfor _ in range(N):\n    lst.append(input())\nans = {}\nfor p_size in range(max_p + 1):\n    for i in range(len(lst)):\n        s = lst[i]\n        cur_p = s[:p_size]\n        if cur_p in ans:\n            p_lst = ans[cur_p]\n            last_str = lst[p_lst[len(p_lst) - 1]]\n            if s < last_str:\n                p_lst.append(i)\n        else:\n            ans[cur_p] = [i]\nQ = int(input())\nfor _ in range(Q):\n    (R, P) = input().split()\n    R = int(R) - 1\n    while True:\n        if P in ans:\n            cur_lst = ans[P]\n            res = bisect(cur_lst, R)\n            if res - 1 >= 0:\n                print(lst[cur_lst[res - 1]])\n                break\n        P = P[:-1]", "class trieNode:\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEnd = False\n        self.count = ''\n\nclass Trie:\n\n    def __init__(self):\n        self.root = self.getNode()\n\n    def getNode(self):\n        return trieNode()\n\n    def _charToindex(self, ch):\n        return ord(ch) - ord('a')\n\n    def insert(self, key):\n        root1 = self.root\n        for i in range(len(key)):\n            ind = self._charToindex(key[i])\n            if not root1.children[ind]:\n                root1.children[ind] = self.getNode()\n            if root1.count == '':\n                root1.count = key\n            elif root1.count > key:\n                root1.count = key\n            root1 = root1.children[ind]\n        if root1.count == '':\n            root1.count = key\n        elif root1.count > key:\n            root1.count = key\n        root1.isEnd = True\n\n    def search(self, key):\n        root1 = self.root\n        for i in range(len(key)):\n            ind = self._charToindex(key[i])\n            if not root1.children[ind]:\n                return False\n            root1 = root1.children[ind]\n        return root1 != None and root1.isEnd\n\n    def query(self, key):\n        root1 = self.root\n        for i in range(len(key)):\n            ind = self._charToindex(key[i])\n            if not root1.children[ind]:\n                return root1.count\n            root1 = root1.children[ind]\n        return root1.count\n\nclass setx:\n\n    def __init__(self, a, s, r):\n        self.a = a\n        self.s = s\n        self.r = r\nn = int(input())\nx = []\nfor i in range(n):\n    x.append(input())\nq = int(input())\narray = []\nfor i in range(q):\n    a = [j for j in input().split()]\n    z = setx(i, a[1], int(a[0]) - 1)\n    array.append(z)\narray.sort(key=lambda setx: setx.r)\nt = Trie()\nans = []\nfor j in range(q):\n    ans.append('')\nfor i in range(array[0].r + 1):\n    t.insert(x[i])\n    ans[array[0].a] = t.query(array[0].s)\nfor i in range(1, len(array)):\n    y = array[i].r - array[i - 1].r\n    ind = array[i - 1].r + 1\n    if y > 0:\n        for j in range(y):\n            t.insert(x[ind + j])\n    ans[array[i].a] = t.query(array[i].s)\nfor j in ans:\n    print(j)", "class TrieNode:\n\n    def __init__(self):\n        self.children = [None] * 26\n        self.is_end_of_word = False\n        self.mins = ''\n\nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def _giveInd(self, ch):\n        return ord(ch) - ord('a')\n\n    def insert(self, key, l):\n        leafs = key\n        yo = self.root\n        for i in range(l):\n            ind = self._giveInd(key[i])\n            if yo.children[ind] == None:\n                yo.children[ind] = TrieNode()\n            if yo.mins == '':\n                yo.mins = leafs\n            yo.mins = min(yo.mins, leafs)\n            yo = yo.children[ind]\n        if yo.mins == '':\n            yo.mins = leafs\n        yo.mins = min(yo.mins, leafs)\n        yo.is_end_of_word = True\n\n    def search(self, key, l):\n        yo = self.root\n        for i in range(l):\n            ind = self._giveInd(key[i])\n            if yo.children[ind] == None:\n                return False\n            yo = yo.children[ind]\n        return yo != None and yo.is_end_of_word\n\n    def givecount(self, key, l):\n        yo = self.root\n        for i in range(l):\n            ind = self._giveInd(key[i])\n            if yo.children[ind] == None:\n                return yo.mins\n            yo = yo.children[ind]\n        if yo == None:\n            return yo.mins\n        else:\n            return yo.mins\n\nclass query:\n\n    def __init__(self, r, query, ind):\n        self.ind = ind\n        self.query = query\n        self.r = r\nn = int(input())\nsarr = []\nfor i in range(n):\n    si = input()\n    sarr.append(si)\nq = int(input())\nqarr = []\nfor i in range(q):\n    yoarr = list(input().split())\n    ri = int(yoarr[0]) - 1\n    qi = yoarr[1]\n    queryy = query(ri, qi, i)\n    qarr.append(queryy)\nqarr.sort(key=lambda query: query.r)\nprev = -1\ntrie = Trie()\nansarr = []\nfor i in range(q):\n    ansarr.append('')\nfor i in qarr:\n    if i.r > prev:\n        for j in range(prev + 1, i.r + 1):\n            trie.insert(sarr[j], len(sarr[j]))\n            prev = i.r\n        ar = trie.givecount(i.query, len(i.query))\n        ansarr[i.ind] = ar\n    else:\n        ar = trie.givecount(i.query, len(i.query))\n        ansarr[i.ind] = ar\nfor i in range(q):\n    print(ansarr[i])"]