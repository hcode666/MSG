["n = int(input())\na = input().split()\nlen_arr = len(a)\narr = []\ndp = []\nmod = 1000000007\nfor i in range(len_arr):\n    arr.append(int(a[i]))\nfor i in range(len_arr):\n    dp.append([0] * len_arr)\nfor i in range(len_arr):\n    for j in range(len_arr):\n        if i == j:\n            continue\n        if i == 0 or j > i:\n            continue\n        dp[j][i] = dp[j][i - 1]\n        if arr[i] > 0:\n            for k in range(j, i, 1):\n                if arr[k] < 0 and arr[i] == -arr[k] and (k != j):\n                    dp[j][i] = ((dp[j][i] + 1 + dp[k + 1][i - 1]) % mod + (1 + dp[k + 1][i - 1]) % mod * dp[j][k - 1] % mod) % mod\n                elif arr[k] < 0 and arr[i] == -arr[k] and (k == j):\n                    dp[j][i] = (dp[j][i] + 1 % mod + dp[k + 1][i - 1]) % mod\nprint(dp[0][n - 1] + 1)", "n = int(input())\na = input().split()\nlen_arr = len(a)\narr = []\ndp = []\nmod = 1000000007\nfor i in range(len_arr):\n    arr.append(int(a[i]))\nfor i in range(len_arr):\n    dp.append([0] * len_arr)\nfor i in range(len_arr):\n    for j in range(len_arr):\n        if i == j:\n            continue\n        if i == 0 or j > i:\n            continue\n        dp[j][i] = dp[j][i - 1]\n        if arr[i] > 0:\n            for k in range(j, i, 1):\n                if arr[k] < 0 and arr[i] == -arr[k] and (k != j):\n                    dp[j][i] = ((dp[j][i] + 1 + dp[k + 1][i - 1]) % mod + (1 + dp[k + 1][i - 1]) % mod * dp[j][k - 1] % mod) % mod\n                elif arr[k] < 0 and arr[i] == -arr[k] and (k == j):\n                    dp[j][i] = (dp[j][i] + 1 % mod + dp[k + 1][i - 1]) % mod\nprint(dp[0][n - 1] + 1)", "import sys\ninput()\nraw = [i for i in map(int, input().split())]\n\ndef balanced(l):\n    open = []\n    for i in l:\n        if i < 0:\n            open.append(-1 * i)\n        if i > 0:\n            if open.pop() != i:\n                return 0\n    if open == []:\n        return 1\n    return 0\n\ndef even(l):\n    while l != []:\n        if not l[0] * -1 in l:\n            return 0\n        l.remove(l[0] * -1)\n        l.pop(0)\n    return 1\n\ndef removeodds(l):\n    toreturn = []\n    for i in l:\n        if i < 0 and -1 * i in l[l.index(i):]:\n            toreturn.append(i)\n        if i > 0 and -1 * i in l[:l.index(i)]:\n            toreturn.append(i)\n    return toreturn\n\ndef getvalue(l):\n    if l == []:\n        return 1\n    closepos = l.index(-1 * l[0])\n    if even(l[1:closepos]):\n        return 2 * getvalue(l[1:closepos]) * getvalue(l[closepos + 1:])\n    else:\n        topass1 = l[:]\n        topass1.pop(closepos)\n        topass1.pop(0)\n        topass2 = removeodds(l[1:closepos]) + removeodds(l[closepos + 1:])\n        return getvalue(topass1) + getvalue(topass2)\nl = removeodds(raw)\nprint(getvalue(l) % (10 ** 9 + 7))", "MOD = 1000000007\nn = int(input())\ns = [int(x) for x in input().split()]\nvi = {}\nfor (i, x) in enumerate(s):\n    if x not in vi:\n        vi[x] = []\n    vi[x].append(i)\nc = {}\n\ndef search(b, e):\n    if (b, e) in c:\n        return c[b, e]\n    val = 1\n    for i in range(b, e):\n        if s[i] < 0 and -s[i] in vi:\n            for ni in vi[-s[i]]:\n                if ni >= b and ni <= e:\n                    val = (val + search(i + 1, ni - 1) * search(ni + 1, e)) % MOD\n    c[b, e] = val\n    return val\nprint(search(0, n - 1))"]