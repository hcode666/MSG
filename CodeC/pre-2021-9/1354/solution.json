["import sys\nN = int(input())\nsys.setrecursionlimit(1000000)\n\ndef t(l, r):\n    if l + 1 == r:\n        return (1, l)\n    else:\n        m = (l + r) // 2\n        e = t(l, m)\n        d = t(m, r)\n        return (e[0] * d[1] + d[0], e[1] * d[1])\n\ndef calc(a, b, n):\n    if n == 0:\n        return 0\n    k = a // b\n    a -= k * b\n    m = a * n // b\n    return k * (n * (n + 1) >> 1) + m * n - calc(b, a, m)\nprint(N * (N + 1) + calc(*t(2, 3505), N))", "import sys\nN = int(input())\nsys.setrecursionlimit(1000000)\n\ndef t(l, r):\n    if l + 1 == r:\n        return (1, l)\n    else:\n        m = (l + r) // 2\n        e = t(l, m)\n        d = t(m, r)\n        return (e[0] * d[1] + d[0], e[1] * d[1])\n\ndef calc(a, b, n):\n    if n == 0:\n        return 0\n    k = a // b\n    a -= k * b\n    m = a * n // b\n    return k * (n * (n + 1) >> 1) + m * n - calc(b, a, m)\nprint(N * (N + 1) + calc(*t(2, 3505), N))", "import sys\nN = int(input())\nsys.setrecursionlimit(1000000)\n\ndef t(l, r):\n    if l + 1 == r:\n        return (1, l)\n    else:\n        m = (l + r) // 2\n        e = t(l, m)\n        d = t(m, r)\n        return (e[0] * d[1] + d[0], e[1] * d[1])\n\ndef calc(a, b, n):\n    if n == 0:\n        return 0\n    k = a // b\n    a -= k * b\n    m = a * n // b\n    return k * (n * (n + 1) >> 1) + m * n - calc(b, a, m)\nprint(N * (N + 1) + calc(*t(2, 3505), N))", "N = int(input())\n\ndef gcd(a, b):\n    while b > 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef t(l, r):\n    if l + 1 == r:\n        return (1, l)\n    else:\n        m = (l + r) // 2\n        e = t(l, m)\n        d = t(m, r)\n        return (e[0] * d[1] + d[0], e[1] * d[1])\nk = t(2, 5000)\ng = gcd(k[0], k[1])\nk = (k[0] // g, k[1] // g)\n\ndef calc(a, b, n):\n    seq = []\n    (x, y, N) = (a, b, n)\n    while True:\n        if n == 0:\n            seq.append((1, 0))\n            break\n        elif a >= b:\n            temp = n * (n + 1) // 2 * (a // b)\n            if a % b > 0:\n                seq.append((temp, 1))\n                a = a % b\n            else:\n                seq.append((temp + n + 1, 0))\n                break\n        else:\n            seq.append(((n + 1) * (n * a // b + 1) + n // b + 1, -1))\n            (a, b, n) = (b, a, n * a // b)\n    ans = seq.pop()[0]\n    while len(seq) > 0:\n        last = seq.pop()\n        ans = ans * last[1] + last[0]\n    return ans\nprint((N - 1) * (N + 1) + calc(*k, N))", "N = int(input())\n\ndef gcd(a, b):\n    while b > 0:\n        (a, b) = (b, a % b)\n    return a\n\ndef t(l, r):\n    if l + 1 == r:\n        return (1, l)\n    else:\n        m = (l + r) // 2\n        e = t(l, m)\n        d = t(m, r)\n        return (e[0] * d[1] + d[0], e[1] * d[1])\ngot = t(2, 5000)\ng = gcd(got[0], got[1])\ngot = (got[0] // g, got[1] // g)\n\ndef calc(a, b, n):\n    seq = []\n    (x, y, N) = (a, b, n)\n    while True:\n        if a >= b:\n            temp = n * (n + 1) // 2 * (a // b)\n            if a % b > 0:\n                seq.append((temp, 1))\n                a = a % b\n            else:\n                seq.append((temp + n + 1, 0))\n                break\n        else:\n            seq.append(((n + 1) * (n * a // b + 1) + n // b + 1, -1))\n            (a, b, n) = (b, a, n * a // b)\n    ans = seq.pop()[0]\n    while len(seq) > 0:\n        last = seq.pop()\n        ans = ans * last[1] + last[0]\n    return ans\nprint(N * (N + 1) + calc(got[0], got[1], N) - (N + 1))", "import sys\nimport math\nline = lambda : list((int(x) for x in input().split()))\nMOD = int(1000000000.0 + 7)\nMAXN = 4100\na = [0 for i in range(MAXN)]\np = [0 for i in range(MAXN)]\nq = [0 for i in range(MAXN)]\nt = [0 for i in range(MAXN)]\n\ndef build():\n    for i in range(MAXN):\n        if i % 3 < 2:\n            a[i] = 1\n        else:\n            a[i] = i // 3 * 2 + 2\n    a[0] = 2\n    p[MAXN - 1] = a[MAXN - 1]\n    q[MAXN - 1] = 1\n    for k in reversed(range(MAXN - 1)):\n        p[k] = p[k + 1] * a[k] + q[k + 1]\n        q[k] = p[k + 1]\n\ndef solve():\n    build()\n    t[0] = int(input())\n    for i in range(MAXN - 1):\n        t[i + 1] = t[i] * q[i + 1] // p[i + 1]\n    res = 0\n    for i in reversed(range(MAXN - 1)):\n        res *= -1\n        res += t[i] * t[i + 1]\n        res += t[i] * (t[i] + 1) // 2 * a[i]\n    print(res)\nsolve()\nexit(0)", "import sys\n\ndef calc(p, q, n):\n    if n == 0:\n        return 0\n    k = p // q\n    p -= k * q\n    h = n * p // q\n    return k * n * (n + 1) // 2 + n * h - calc(q, p, h)\nsys.setrecursionlimit(100500)\nn = int(input())\np = 1\nq = 1\nfor i in range(1, 3500):\n    p *= i\n    q *= i\n    p += 1\nprint(calc(p, q, n))", "import time\nimport sys\n\ndef calc(p, q, n):\n    if n == 0:\n        return 0\n    a = p // q - 1\n    po = p\n    p -= q * a\n    m = n * (p - q) // q\n    t = m + n\n    return a * n * (n + 1) // 2 + t * (t + 1) // 2 - calc(p, p - q, m)\nsys.setrecursionlimit(100500)\nn = int(input())\np = 1\nq = 1\nfor i in range(1, 3500):\n    p *= i\n    q *= i\n    p += 1\nprint(calc(p, q, n))", "def a(n):\n    if n % 3 == 2:\n        return (n // 3 + 1) * 2\n    if n == 0:\n        return 2\n    return 1\nv = [1]\n\ndef k(n):\n    (c, d) = (0, 1)\n    for i in range(n):\n        (c, d) = (d, c + d * a(i + 1))\n        v.append(d)\n    return d\nw = [2]\n\ndef h(n):\n    (c, d) = (1, 2)\n    for i in range(n):\n        (c, d) = (d, c + d * a(i + 1))\n        w.append(d)\n    return d\nx = k(4000)\ny = h(4000)\n\ndef q(n):\n    for i in range(0, n, 2):\n        if v[i + 2] > n:\n            return v[i]\n\ndef p(n):\n    for i in range(0, n, 2):\n        if v[i + 2] > n:\n            return w[i]\n\ndef t(n):\n    for i in range(1, n, 2):\n        if v[i + 2] > n:\n            return v[i]\n\ndef u(n):\n    for i in range(1, n, 2):\n        if v[i + 2] > n:\n            return w[i]\n\ndef nl(n):\n    if n == 0 or n == 1:\n        return 0\n    if q(n) < t(n):\n        d = n // t(n)\n        r = n % t(n)\n        s = d * (u(n) - 1) * (t(n) - 1) // 2 + (d - 1) * d * u(n) * t(n) // 2 + r * u(n) * d - d + nl(r)\n        if r == 0:\n            return s + 1\n        return s\n    d = n // q(n)\n    r = n % q(n)\n    return d * (p(n) - 1) * (q(n) - 1) // 2 + (d - 1) * d * p(n) * q(n) // 2 + r * p(n) * d + nl(r)\nimport sys\nsys.setrecursionlimit(10000)\nline = sys.stdin.readline()\nprint(nl(1 + int(line)))", "def a(n):\n    if n % 3 == 2:\n        return (n // 3 + 1) * 2\n    if n == 0:\n        return 2\n    return 1\nv = [1]\n\ndef k(n):\n    (c, d) = (0, 1)\n    for i in range(n):\n        (c, d) = (d, c + d * a(i + 1))\n        v.append(d)\n    return d\nw = [2]\n\ndef h(n):\n    (c, d) = (1, 2)\n    for i in range(n):\n        (c, d) = (d, c + d * a(i + 1))\n        w.append(d)\n    return d\nx = k(4000)\ny = h(4000)\n\ndef q(n):\n    for i in range(0, n, 2):\n        if v[i + 2] > n:\n            return v[i]\n\ndef p(n):\n    for i in range(0, n, 2):\n        if v[i + 2] > n:\n            return w[i]\n\ndef t(n):\n    for i in range(1, n, 2):\n        if v[i + 2] > n:\n            return v[i]\n\ndef u(n):\n    for i in range(1, n, 2):\n        if v[i + 2] > n:\n            return w[i]\n\ndef nl(n):\n    if n == 0 or n == 1:\n        return 0\n    if q(n) < t(n):\n        d = n // t(n)\n        r = n % t(n)\n        s = d * (u(n) - 1) * (t(n) - 1) // 2 + (d - 1) * d * u(n) * t(n) // 2 + r * u(n) * d - d + nl(r)\n        if r == 0:\n            return s + 1\n        return s\n    d = n // q(n)\n    r = n % q(n)\n    return d * (p(n) - 1) * (q(n) - 1) // 2 + (d - 1) * d * p(n) * q(n) // 2 + r * p(n) * d + nl(r)\nimport sys\nsys.setrecursionlimit(10000)\nline = sys.stdin.readline()\nprint(nl(1 + int(line)))", "p = [1, 2, 3, 8]\nq = [0, 1, 1, 3]\nn = int(input())\ni = 0\nwhile q[-2] <= n:\n    a = 1\n    if i % 3 == 2:\n        a = 2 * (i // 3 + 2)\n    p.append(a * p[-1] + p[-2])\n    q.append(a * q[-1] + q[-2])\n    i += 1\n\ndef sa(b, i, m):\n    res = m * b * p[i]\n    if i & 1:\n        res += (b * p[i] * q[i] - q[i] + p[i] + 1) * b // 2\n    else:\n        res += (b * p[i] * q[i] - q[i] + p[i] - 1) * b // 2\n    return res\nans = 0\ni = len(p) - 1\nwhile 1:\n    if q[i] <= n and q[i + 1] > n:\n        if q[i] == n:\n            ans += sa(1, i, 0)\n            n = 0\n            break\n        else:\n            b = n // q[i]\n            m = n % q[i]\n            ans += sa(b, i, m)\n            n = m\n    i -= 1\nprint(ans)", "p = [1, 2, 3, 8]\nq = [0, 1, 1, 3]\nn = int(input())\nj = 0\nfor i in range(0, 4100):\n    a = 1\n    if i % 3 == 2:\n        a = 2 * (i // 3 + 2)\n    p.append(a * p[-1] + p[-2])\n    q.append(a * q[-1] + q[-2])\n    if q[i] > n:\n        j = i - 1\n        break\n\ndef sa(b, i, m):\n    res = m * b * p[i]\n    if i & 1:\n        res += (b * p[i] * q[i] - q[i] + p[i] + 1) * b // 2\n    else:\n        res += (b * p[i] * q[i] - q[i] + p[i] - 1) * b // 2\n    return res\nans = 0\ni = j\nwhile 1:\n    if q[i] <= n and q[i + 1] > n:\n        if q[i] == n:\n            ans += sa(1, i, 0)\n            n = 0\n            break\n        else:\n            b = n // q[i]\n            m = n % q[i]\n            ans += sa(b, i, m)\n            n = m\n    i -= 1\nprint(ans)", "p = [1, 2, 3, 8]\nq = [0, 1, 1, 3]\nn = int(input())\nfor i in range(0, 4100):\n    a = 1\n    if i % 3 == 2:\n        a = 2 * (i // 3 + 2)\n    p.append(a * p[-1] + p[-2])\n    q.append(a * q[-1] + q[-2])\n\ndef sa(b, i, m):\n    res = m * b * p[i]\n    if i & 1:\n        res += (b * p[i] * q[i] - q[i] + p[i] + 1) * b // 2\n    else:\n        res += (b * p[i] * q[i] - q[i] + p[i] - 1) * b // 2\n    return res\nans = 0\nfor i in range(4000, 0, -1):\n    if q[i] <= n and q[i + 1] > n:\n        if q[i] == n:\n            ans += sa(1, i, 0)\n            n = 0\n        else:\n            b = n // q[i]\n            m = n % q[i]\n            ans += sa(b, i, m)\n            n = m\nprint(ans)", "p = [0, 1, 2]\nq = [0, 1, 3]\nn = int(input())\nfor i in range(0, 4100):\n    a = 1\n    if i % 3 == 2:\n        a = 2 * (i // 3 + 2)\n    p.append(a * p[-1] + p[-2])\n    q.append(a * q[-1] + q[-2])\n\ndef sa(b, i, m):\n    res = m * b * p[i]\n    if i & 1:\n        res += (b * p[i] * q[i] - q[i] + p[i] - 1) * b // 2\n    else:\n        res += (b * p[i] * q[i] - q[i] + p[i] + 1) * b // 2\n    return res\nans = n * (n + 1)\nfor i in range(4000, 0, -1):\n    if q[i] <= n and q[i + 1] > n:\n        if q[i] == n:\n            ans += sa(1, i, 0)\n            n = 0\n        else:\n            b = n // q[i]\n            m = n % q[i]\n            ans += sa(b, i, m)\n            n = m\nprint(ans)", "import math\np = [0, 1, 2]\nq = [0, 1, 3]\nn = int(input())\nfor i in range(0, 4100):\n    a = 1\n    if i % 3 == 2:\n        a = 2 * (i // 3 + 2)\n    p.append(a * p[-1] + p[-2])\n    q.append(a * q[-1] + q[-2])\n\ndef sa(b, i, m):\n    res = m * b * p[i]\n    if i & 1:\n        res += (b * p[i] * q[i] - q[i] + p[i] - 1) * b // 2\n    else:\n        res += (b * p[i] * q[i] - q[i] + p[i] + 1) * b // 2\n    return res\nans = n * (n + 1)\nfor i in range(4000, 0, -1):\n    if q[i] <= n and q[i + 1] > n:\n        if q[i] == n:\n            ans += sa(1, i, 0)\n            n = 0\n        else:\n            b = n // q[i]\n            m = n % q[i]\n            ans += sa(b, i, m)\n            n = m\nprint(ans)", "import math\np = [0, 1, 2]\nq = [0, 1, 3]\nn = int(input())\na = [0, 1, 2]\nfor i in range(1, 1500):\n    a.append(1)\n    a.append(1)\n    a.append(2 * (i + 1))\nfor i in range(3, 4005):\n    p.append(a[i] * p[i - 1] + p[i - 2])\n    q.append(a[i] * q[i - 1] + q[i - 2])\n\ndef sa(b, i, m):\n    res = m * b * p[i]\n    if i & 1:\n        res += (b * p[i] * q[i] - q[i] + p[i] - 1) * b // 2\n    else:\n        res += (b * p[i] * q[i] - q[i] + p[i] + 1) * b // 2\n    return res\nans = n * (n + 1)\nfor i in range(4000, 0, -1):\n    if q[i] <= n and q[i + 1] > n:\n        if q[i] == n:\n            ans += sa(1, i, 0)\n            n = 0\n        else:\n            b = n // q[i]\n            m = n - b * q[i]\n            ans += sa(b, i, m)\n            n = m\nprint(ans)", "import math\np = [0, 1, 2]\nq = [0, 1, 3]\nn = int(input())\na = [0, 1, 2]\nfor i in range(1, 1500):\n    a.append(1)\n    a.append(1)\n    a.append(2 * (i + 1))\nfor i in range(3, 4005):\n    p.append(a[i] * p[i - 1] + p[i - 2])\n    q.append(a[i] * q[i - 1] + q[i - 2])\n\ndef sa(b, i, m):\n    res = m * b * p[i]\n    if i & 1:\n        res += (b * p[i] * q[i] - q[i] + p[i] - 1) * b // 2\n    else:\n        res += (b * p[i] * q[i] - q[i] + p[i] + 1) * b // 2\n    return res\nans = n * (n + 1)\nfor i in range(4000, 0, -1):\n    if q[i] <= n and q[i + 1] > n:\n        if q[i] == n:\n            ans += sa(1, i, 0)\n            n = 0\n        else:\n            b = n // q[i]\n            m = n % q[i]\n            ans += sa(b, i, m)\n            n = m\nprint(ans)", "import math\np = [0, 1, 2]\nq = [0, 1, 3]\nn = int(input())\na = [0, 1, 2]\nfor i in range(1, 1500):\n    a.append(1)\n    a.append(1)\n    a.append(2 * (i + 1))\nfor i in range(3, 4005):\n    p.append(a[i] * p[i - 1] + p[i - 2])\n    q.append(a[i] * q[i - 1] + q[i - 2])\n\ndef sa(b, i, m):\n    res = m * b * p[i]\n    if i & 1:\n        res += (b * p[i] * q[i] - q[i] + p[i] - 1) * b // 2\n    else:\n        res += (b * p[i] * q[i] - q[i] + p[i] + 1) * b // 2\n    return res\nans = n * (n + 1)\nfor i in range(4000, 0, -1):\n    if q[i] <= n and q[i + 1] > n:\n        if q[i] == n:\n            ans += sa(1, i, 0)\n            n = 0\n        else:\n            b = int(n / q[i])\n            m = n % q[i]\n            ans += sa(b, i, m)\n            n = m\nprint(ans)", "def Solve(a, b, c, n):\n    res = 0\n    op = 1\n    while True:\n        if a == 0:\n            return res + op * (b // c * n)\n        elif b < 0:\n            m = (-b + c - 1) // c\n            b = b + m * c\n            res -= op * m * n\n        elif a >= c:\n            res += op * (a // c) * (n * (n + 1) // 2)\n            a = a % c\n        else:\n            m = (a * n + b) // c\n            res += op * (n + 1) * m\n            b = a - b - 1\n            (a, c) = (c, a)\n            n = m\n            op = -op\nn = int(input())\nC = 1\nA = 1\nlim = 3000\nfor i in range(1, lim):\n    C *= i\nfor i in range(1, lim):\n    A = A * i + 1\nprint(Solve(A, 0, C, n))", "import sys\nsys.setrecursionlimit(1000000000)\n\ndef Solve(a, b, c, n):\n    if a == 0:\n        return b // c * n\n    if b < 0:\n        m = (-b + c - 1) // c\n        return Solve(a, b + m * c, c, n) - m * n\n    if a >= c:\n        return a // c * (n * (n + 1) // 2) + Solve(a % c, b, c, n)\n    m = (a * n + b) // c\n    return (n + 1) * m - Solve(c, a - b - 1, a, m)\nn = int(input())\nC = 1\nA = 1\nlim = 3000\nfor i in range(1, lim):\n    C *= i\nfor i in range(1, lim):\n    A = A * i + 1\nprint(Solve(A, 0, C, n))", "n = int(input())\n\ndef gcd(a, b):\n    while a:\n        (a, b) = (b % a, a)\n    return b\nfrac = [1, 2]\nfor i in range(2, 2001):\n    frac += [1, 1, 2 * i]\nden = 1\nnum = 0\nde = 0\nnu = 1\nfor i in range(len(frac)):\n    (num, den, nu, de) = (frac[i] * num + nu, frac[i] * den + de, num, den)\n    if den > n:\n        break\ns = n * (n + 1)\nt = gcd(num, den)\nnum = num // t\nden = den // t\nz = 1\nwhile den > 0 and n > 0:\n    t = num // den\n    s += z * t * n * (n + 1) // 2\n    num -= den * t\n    t = n // den\n    s += z * num * t * (n + 1) - z * t * (num * den * t + num + den - 1) // 2\n    n -= den * t\n    t = n * num // den\n    s += z * t * n\n    n = t\n    temp = num\n    num = den\n    den = temp\n    z *= -1\nprint(s)", "n = int(input())\n\ndef gcd(a, b):\n    while a:\n        (a, b) = (b % a, a)\n    return b\nfrac = []\nfor i in range(1, 2001):\n    frac += [1, 1, 2 * i]\nden = 1\nnum = 0\nde = 0\nnu = 1\nfor i in range(1, 6000):\n    (num, den, nu, de) = (frac[i] * num + nu, frac[i] * den + de, num, den)\n    if den > n:\n        break\ns = n * (n + 1)\nt = gcd(num, den)\nnum = num // t\nden = den // t\nz = 1\nwhile den > 0 and n > 0:\n    t = num // den\n    s += z * t * n * (n + 1) // 2\n    num -= den * t\n    t = n // den\n    s += z * num * t * (n + 1) - z * t * (num * den * t + num + den - 1) // 2\n    n -= den * t\n    t = n * num // den\n    s += z * t * n\n    n = t\n    temp = num\n    num = den\n    den = temp\n    z *= -1\nprint(s)", "n = int(input())\n\ndef gcd(a, b):\n    while a:\n        (a, b) = (b % a, a)\n    return b\nfrac = [1, 1, 2]\nfor i in range(2, 2000):\n    frac += [1, 1, 2 * i]\n(num, den, nu, de) = (0, 1, 1, 0)\nfor i in range(1, len(frac)):\n    (num, den, nu, de) = (frac[i] * num + nu, frac[i] * den + de, num, den)\n    if den > n:\n        break\ns = n * (n + 1)\nt = gcd(num, den)\nnum = num // t\nden = den // t\nz = 1\nwhile den > 0 and n > 0:\n    t = num // den\n    s += z * t * n * (n + 1) // 2\n    num -= den * t\n    t = n // den\n    s += z * num * t * (n + 1) - z * t * (num * den * t + num + den - 1) // 2\n    n -= den * t\n    t = n * num // den\n    s += z * t * n\n    n = t\n    temp = num\n    num = den\n    den = temp\n    z *= -1\nprint(s)", "def range_prod(lo, hi):\n    if lo + 1 < hi:\n        mid = (hi + lo) // 2\n        return range_prod(lo, mid) * range_prod(mid + 1, hi)\n    if lo == hi:\n        return lo\n    return lo * hi\n\ndef treefactorial(n):\n    if n < 2:\n        return 1\n    return range_prod(1, n)\n\ndef puy(x):\n    t = 1\n    res = 1\n    while x > 0:\n        t = t * x\n        res = res + t\n        x = x - 1\n    return res\n\ndef gcd(x, y):\n    while y != 0:\n        temp = x\n        x = y\n        y = temp % y\n    return x\n\ndef euler(n, p, q):\n    t = gcd(p, q)\n    p = p // t\n    q = q // t\n    s = 0\n    z = 1\n    while q > 0 and n > 0:\n        t = p // q\n        df = z * t * n * (n + 1) // 2\n        s = s + df\n        df = q * t\n        p = p - df\n        t = n // q\n        df = z * p * t * (n + 1) - z * t * (p * q * t + p + q - 1) // 2\n        s = s + df\n        df = q * t\n        n = n - df\n        t = n * p // q\n        df = z * t * n\n        s = s + df\n        n = t\n        temp = p\n        p = q\n        q = temp\n        z = -z\n    return s\nn = int(input())\nprint(euler(n, puy(3000), treefactorial(3000)))", "def range_prod(lo, hi):\n    if lo + 1 < hi:\n        mid = (hi + lo) // 2\n        return range_prod(lo, mid) * range_prod(mid + 1, hi)\n    if lo == hi:\n        return lo\n    return lo * hi\n\ndef treefactorial(n):\n    if n < 2:\n        return 1\n    return range_prod(1, n)\n\ndef nom(x):\n    t = 1\n    res = 1\n    while x > 0:\n        t *= x\n        res += t\n        x -= 1\n    return res\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef euler(n, p, q):\n    t = gcd(p, q)\n    (p, q, s, z) = (p // t, q // t, 0, 1)\n    while q > 0 and n > 0:\n        t = p // q\n        s = s + z * t * n * (n + 1) // 2\n        p = p - q * t\n        t = n // q\n        s = s + (z * p * t * (n + 1) - z * t * (p * q * t + p + q - 1) // 2)\n        n = n - q * t\n        t = n * p // q\n        s = s + z * t * n\n        n = t\n        (p, q) = (q, p)\n        z = -z\n    return s\nn = int(input())\nprint(euler(n, nom(3000), treefactorial(3000)))", "def range_prod(lo, hi):\n    if lo + 1 < hi:\n        mid = (hi + lo) // 2\n        return range_prod(lo, mid) * range_prod(mid + 1, hi)\n    if lo == hi:\n        return lo\n    return lo * hi\n\ndef treefactorial(n):\n    if n < 2:\n        return 1\n    return range_prod(1, n)\n\ndef nom(x):\n    t = 1\n    res = 1\n    while x > 0:\n        t *= x\n        res += t\n        x -= 1\n    return res\n\ndef gcd(x, y):\n    while y:\n        (x, y) = (y, x % y)\n    return x\n\ndef euler(n, p, q):\n    t = gcd(p, q)\n    (p, q, s, z) = (p // t, q // t, 0, 1)\n    while q > 0 and n > 0:\n        t = p // q\n        s += z * t * n * (n + 1) // 2\n        p -= q * t\n        t = n // q\n        s += z * p * t * (n + 1) - z * t * (p * q * t + p + q - 1) // 2\n        n -= q * t\n        t = n * p // q\n        s += z * t * n\n        n = t\n        (p, q) = (q, p)\n        z = -z\n    return s\nn = int(input())\nprint(euler(n, nom(3000), treefactorial(3000)))", "import sys\nsys.setrecursionlimit(1000000000)\n\ndef solve(A, B, C, n):\n    if A == 0:\n        return (n + 1) * (B // C)\n    if A >= C:\n        return solve(A % C, B, C, n) + n * (n + 1) // 2 * (A // C)\n    if B >= C:\n        return solve(A, B % C, C, n) + (n + 1) * (B // C)\n    m = (A * n + B) // C\n    return n * m - solve(C, C - B - 1, A, m - 1)\nn = int(input())\nC = 1\nA = 1\nlim = 3000\nfor i in range(1, lim):\n    C *= i\nfor i in range(1, lim):\n    A = A * i + 1\nprint(solve(A, 0, C, n))", "def approxi():\n    num = 1\n    den = 1\n    fact = 1\n    for x in range(1, 3000):\n        num = num * x + 1\n        den = fact\n        fact *= x + 1\n    return (num, den)\nn = int(input())\n(p, q) = approxi()\np = p // 20\nq = q // 20\ns = 0\nz = 1\nwhile q > 0 and n > 0:\n    t = p // q\n    s = s + z * t * n * (n + 1) // 2\n    p = p - q * t\n    t = n // q\n    s = s + z * p * t * (n + 1) - z * t * (p * q * t + p + q - 1) // 2\n    n = n - q * t\n    t = n * p // q\n    s = s + z * t * n\n    n = t\n    (p, q) = (q, p)\n    z = -z\nprint(s)", "def approxi():\n    num = 1\n    den = 1\n    fact = 1\n    for x in range(1, 3000):\n        num = num * x + 1\n        den = fact\n        fact *= x + 1\n    return (num, den)\nn = int(input())\n(p, q) = approxi()\ns = 0\nz = 1\nwhile q > 0 and n > 0:\n    t = p // q\n    s = s + z * t * n * (n + 1) // 2\n    p = p - q * t\n    t = n // q\n    s = s + z * p * t * (n + 1) - z * t * (p * q * t + p + q - 1) // 2\n    n = n - q * t\n    t = n * p // q\n    s = s + z * t * n\n    n = t\n    (p, q) = (q, p)\n    z = -z\nprint(s)", "def approx():\n    n0 = 2\n    d0 = 1\n    n1 = 3\n    d1 = 1\n    j = 0\n    k = 0\n    for i in range(5000):\n        if i % 3 == 0:\n            j = k + 2\n            k = j\n        else:\n            j = 1\n        n = j * n1 + n0\n        d = j * d1 + d0\n        (n1, n0) = (n, n1)\n        (d1, d0) = (d, d1)\n    return (n1, d1)\nn = int(input())\n(p, q) = approx()\ns = 0\nz = 1\nwhile q > 0 and n > 0:\n    t = p // q\n    s = s + z * t * n * (n + 1) // 2\n    p = p - q * t\n    t = n // q\n    s = s + z * p * t * (n + 1) - z * t * (p * q * t + p + q - 1) // 2\n    n = n - q * t\n    t = n * p // q\n    s = s + z * t * n\n    n = t\n    (p, q) = (q, p)\n    z = -z\nprint(s)", "n = int(input())\nnum = 1\nden = 1\nfor i in range(1, 4001):\n    num = num * i + 1\n    den *= i\nflag = 1\nans = 0\nwhile n > 0:\n    if num >= 2 * den:\n        k = (num - den) // den\n        ans += flag * k * n * (n + 1) // 2\n        num -= k * den\n    else:\n        alpn = num * n // den\n        ans += flag * (alpn * (alpn + 1) // 2)\n        flag *= -1\n        den = num - den\n        n = alpn - n\nprint(ans)", "import math\nu = 2682\nkf = 1\nuf = math.factorial(u)\nnum = uf\nden = uf\nfor k in range(1, u):\n    kf *= k\n    num += uf // kf\nans = 0\nsign = 1\nm = 0\nn = int(input())\nwhile n:\n    m = num // den - 1\n    ans += m * sign * (n * (n + 1) >> 1)\n    num -= m * den\n    n2 = n\n    n = n * num // den\n    ans += sign * (n * (n + 1) >> 1)\n    sign *= -1\n    den = num - den\n    n = n - n2\nprint(ans)", "import math\nu = 2683\nkf = 1\nuf = math.factorial(u)\nnum = uf\nden = uf\nfor k in range(1, u):\n    kf *= k\n    num += uf // kf\nans = 0\nsign = 1\nm = 0\nn = int(input())\nwhile n:\n    m = num // den - 1\n    ans += m * sign * (n * (n + 1) >> 1)\n    num -= m * den\n    n2 = n\n    n = n * num // den\n    ans += sign * (n * (n + 1) >> 1)\n    sign *= -1\n    den = num - den\n    n = n - n2\nprint(ans)", "def gcd(a, b):\n    while b:\n        (a, b) = (b, a % b)\n    return a\n\ndef fact(x):\n    res = 1\n    for i in range(2, x + 1):\n        res *= i\n    return res\n\ndef nom(x):\n    (t, res) = (1, 1)\n    while x > 0:\n        t *= x\n        res += t\n        x -= 1\n    return res\nfrom sys import stdin, stdout\nB = stdin.readline().rstrip()\nB = int(B)\nC = int(0)\nP = nom(3000)\nQ = fact(3000)\nP = int(P)\nQ = int(Q)\nT = gcd(P, Q)\nP = P // T\nQ = Q // T\nZ = 1\nwhile Q > 0 and B > 0:\n    T = P // Q\n    T = int(T)\n    C = C + Z * T * B * (B + 1) // 2\n    P = P - Q * T\n    T = B // Q\n    T = int(T)\n    C = C + Z * P * T * (B + 1) - Z * T * (P * Q * T + Q + P - 1) // 2\n    B = B - Q * T\n    T = B * P // Q\n    T = int(T)\n    C = C + Z * T * B\n    B = T\n    temp = Q\n    Q = P\n    P = temp\n    Z = -Z\nstdout.write(str(int(C)))", "from decimal import *\nfrom fractions import *\na = [2, 1, 2, 1, 1, 4, 1, 1, 6]\nhn = []\nkn = []\ngetcontext().prec = 10\n\ndef gen():\n    for n in range(9, 10005, 1):\n        x = 2 * a[n - 3] - a[n - 6]\n        a.append(x)\n        hn.append(0)\n        kn.append(0)\n    hn[8001] = a[8001]\n    kn[8001] = 1\n    for i in range(8000, -1, -1):\n        hn[i] = hn[i + 1] * a[i] + kn[i + 1]\n        kn[i] = hn[i + 1]\n\ndef rec_again(n):\n    sol = 0\n    cnt = 0\n    while n > 0:\n        ext = 0\n        cur = 0\n        g = a[cnt]\n        ext = n * (n + 1) * g // 2\n        hn[cnt] -= kn[cnt] * a[cnt]\n        n1 = n * hn[cnt] // kn[cnt]\n        if cnt == 0:\n            ext = ext // 2\n        cur = ext + (n + n1) * (n + n1 + 1) // 2\n        if cnt % 2:\n            sol = sol - cur\n        else:\n            sol = sol + cur\n        n = n1\n        cnt += 1\n    return int(sol)\ngen()\nnum = int(input())\nprint(rec_again(num))", "import sys\nn0 = int(input())\n\ndef eMake(n):\n    a = 0\n    b = 1\n    while n > 2:\n        i = b * n + a\n        (a, b) = (i + b, i + i + b)\n        n -= 2\n    (a, b) = (b, 2 * b + a)\n    (a, b) = (b, b + a)\n    a = a + 2 * b\n    return [a, b]\n\ndef anMy(a0, b0, n0):\n    re = 0\n    si = 1\n    a = a0\n    b = b0\n    n = n0\n    while n > 0:\n        k = a // b\n        if k > 1:\n            re = re + (k - 1) * n * (n + 1) // 2 * si\n            a = a - b * (k - 1)\n        else:\n            m = (a - b) * n // b\n            re = re + (n + m) * (n + m + 1) // 2 * si\n            b = a - b\n            si = -si\n            n = m\n    return re\ne = eMake(2480)\nprint(anMy(e[0], e[1], n0))", "import math\nb = 1\na = 1\nfor i in range(1, 3500):\n    a = a * i + 1\n    b *= i\nn = int(input())\nans = 0\nsign = True\nwhile n >= 1:\n    if n <= 1:\n        if sign:\n            ans += n * a // b\n        else:\n            ans -= n * a // b\n        break\n    if a >= 2 * b:\n        c = a // b - 1\n        if sign:\n            ans += c * n * (n + 1) // 2\n        else:\n            ans -= c * n * (n + 1) // 2\n        a -= c * b\n    m = (a - b) * n // b\n    assert b < a and a < 2 * b\n    if sign:\n        ans += (n + m) * (n + m + 1) // 2\n    else:\n        ans -= (n + m) * (n + m + 1) // 2\n    b = a - b\n    n = m\n    sign = not sign\nprint(ans)", "import math\nfrom decimal import *\n\ndef work(n, a, c):\n    res = 0\n    rev = False\n    while True:\n        if n < 5000:\n            for i in range(1, n + 1):\n                tmp = i * a // c\n                if rev == False:\n                    res += tmp\n                else:\n                    res -= tmp\n            break\n        if a >= c:\n            tmp = n * (n + 1) // 2 * (a // c)\n            if rev == False:\n                res += tmp\n            else:\n                res -= tmp\n            a %= c\n        m = n * a // c\n        tmp = n * m\n        if rev == False:\n            res += tmp\n        else:\n            res -= tmp\n        if a > 0:\n            n = m\n            t = a\n            a = c\n            c = t\n            rev = not rev\n        else:\n            break\n    return res\nn = int(input())\nw = str(n).__len__() * 2 + 5\ngetcontext().prec = w + 5\nc = int('1' + '0' * w)\ne = Decimal(0)\nfac = Decimal(1)\nfor i in range(1, 2700):\n    e += fac\n    fac /= i\na = int(e * c)\nprint(work(n, a, c))", "from decimal import *\nimport math\n\ndef calc(a, b, n):\n    ans = 0\n    flag = 1\n    while a != 0 and b != 0:\n        sum = a // b * n * (n + 1) // 2\n        a %= b\n        if a == 0 or b == 0:\n            if flag == 1:\n                ans += sum\n            else:\n                ans -= sum\n            break\n        else:\n            t = a * n // b\n            if flag == 1:\n                ans += sum + n * t + n // b\n            else:\n                ans -= sum + n * t + n // b\n            n = t\n            t = b\n            b = a\n            a = t\n        flag = -flag\n    return ans\ngetcontext().prec = 8010\ne = Decimal(0)\ni = 0\nfact = Decimal(1)\nwhile i <= 2700:\n    e += fact\n    i += 1\n    fact = fact / i\npw = 1\nfor i in range(8005):\n    e = e * 10\n    pw = pw * 10\ne = int(e)\nn = int(input())\nprint(calc(e, pw, n))", "from decimal import *\nimport math\n\ndef calc(a, b, n):\n    ans = 0\n    flag = 1\n    while a != 0 and b != 0:\n        sum = a // b * n * (n + 1) // 2\n        a %= b\n        if a == 0 or b == 0:\n            if flag == 1:\n                ans += sum\n            else:\n                ans -= sum\n            break\n        else:\n            t = a * n // b\n            if flag == 1:\n                ans += sum + n * t + n // b\n            else:\n                ans -= sum + n * t + n // b\n            n = t\n            t = b\n            b = a\n            a = t\n        flag = -flag\n    return ans\ngetcontext().prec = 8010\ne = Decimal(0)\ni = 0\nfact = Decimal(1)\nwhile i <= 2700:\n    e += fact\n    i += 1\n    fact = fact / i\npw = 1\nfor i in range(8005):\n    e = e * 10\n    pw = pw * 10\ne = int(e)\nn = int(input())\nprint(calc(e, pw, n))", "from decimal import *\nimport math\n\ndef calc(a, b, n):\n    ans = 0\n    flag = 1\n    while a != 0 and b != 0:\n        sum = a // b * n * (n + 1) // 2\n        a %= b\n        if a == 0 or b == 0:\n            if flag == 1:\n                ans += sum\n            else:\n                ans -= sum\n            break\n        else:\n            t = a * n // b\n            if flag == 1:\n                ans += sum + n * t + n // b\n            else:\n                ans -= sum + n * t + n // b\n            n = t\n            t = b\n            b = a\n            a = t\n        flag = -flag\n    return ans\ngetcontext().prec = 8010\ne = Decimal(0)\ni = 0\nfact = Decimal(1)\nwhile i <= 2700:\n    e += fact\n    i += 1\n    fact = fact / i\npw = 1\nfor i in range(8005):\n    e = e * 10\n    pw = pw * 10\ne = int(e)\nn = int(input())\nprint(calc(e, pw, n))", "def e(count):\n    (h1, h2) = [2, 1]\n    (k1, k2) = [1, 0]\n    arr = [1, 0, 1]\n    for i in range(1, count, 3):\n        arr[1] += 2\n        for a in arr:\n            (h1, h2) = [a * h1 + h2, h1]\n            (k1, k2) = [a * k1 + k2, k1]\n    return (h1, k1)\n\ndef S(alfa, n):\n    (p, q) = alfa\n    result = 0\n    sign = 1\n    while 1:\n        if p == q:\n            result += sign * n * (n + 1) // 2\n            return result\n        if n <= 100:\n            for k in range(1, n + 1):\n                result += sign * (p * k // q)\n            return result\n        if p > 2 * q:\n            count = p // q - 1\n            result += sign * (n * (n + 1) // 2) * count\n            (p, q) = (p - q * count, q)\n        else:\n            n1 = n * (p - q) // q\n            sumofn = n + n1\n            result += sign * (sumofn * (sumofn + 1) // 2)\n            (p, q) = (p, p - q)\n            n = n1\n            sign *= -1\nn = int(input())\nprint(S(e(4000), n))", "atulag_cf = []\natulag_cf.append(2)\nfor i in range(1, 1334):\n    atulag_cf.append(1)\n    atulag_cf.append(2 * i)\n    atulag_cf.append(1)\n(p, q) = ([], [])\np.append(atulag_cf[len(atulag_cf) - 1])\nq.append(1)\nfor i in range(1, len(atulag_cf)):\n    j = len(atulag_cf) - 1 - i\n    (pj, qj) = (p[0] * atulag_cf[j] + q[0], p[0])\n    p.insert(0, pj)\n    q.insert(0, qj)\nn = int(input())\nrecToLoop = []\ntp = []\nsum = 0\nwhile n != 0:\n    if p[0] > 2 * q[0]:\n        m = atulag_cf[0] - 1\n        atulag_cf[0] = 1\n        p[0] = q[1] + p[1]\n        recToLoop.append(m * n * (n + 1))\n        tp.append(1)\n    else:\n        fparam1n = p[0] * n // q[0]\n        n = (p[0] - q[0]) * n // q[0]\n        atulag_cf.pop(0)\n        p.pop(0)\n        q.pop(0)\n        atulag_cf[0] = atulag_cf[0] + 1\n        p[0] = p[0] + q[0]\n        recToLoop.append(fparam1n * (fparam1n + 1))\n        tp.append(2)\nwhile tp:\n    if tp.pop() == 1:\n        sum = recToLoop.pop() + sum\n    else:\n        sum = recToLoop.pop() - sum\nprint(sum // 2)", "def a(n):\n    if n % 3 == 2:\n        return (n // 3 + 1) * 2\n    if n == 0:\n        return 2\n    return 1\nv = [1]\n\ndef k(n):\n    (c, d) = (0, 1)\n    for i in range(n):\n        (c, d) = (d, c + d * a(i + 1))\n        v.append(d)\n    return d\nw = [2]\n\ndef h(n):\n    (c, d) = (1, 2)\n    for i in range(n):\n        (c, d) = (d, c + d * a(i + 1))\n        w.append(d)\n    return d\nx = k(4000)\ny = h(4000)\n\ndef q(n):\n    for i in range(0, n, 2):\n        if v[i + 2] > n:\n            return v[i]\n\ndef p(n):\n    for i in range(0, n, 2):\n        if v[i + 2] > n:\n            return w[i]\n\ndef t(n):\n    for i in range(1, n, 2):\n        if v[i + 2] > n:\n            return v[i]\n\ndef u(n):\n    for i in range(1, n, 2):\n        if v[i + 2] > n:\n            return w[i]\n\ndef nl(n):\n    if n == 0 or n == 1:\n        return 0\n    if q(n) < t(n):\n        d = n // t(n)\n        r = n % t(n)\n        s = d * (u(n) - 1) * (t(n) - 1) // 2 + (d - 1) * d * u(n) * t(n) // 2 + r * u(n) * d - d + nl(r)\n        if r == 0:\n            return s + 1\n        return s\n    d = n // q(n)\n    r = n % q(n)\n    return d * (p(n) - 1) * (q(n) - 1) // 2 + (d - 1) * d * p(n) * q(n) // 2 + r * p(n) * d + nl(r)\nimport sys\nsys.setrecursionlimit(10000)\nline = sys.stdin.readline()\nprint(nl(1 + int(line)))", "def epsilon(nom, dem, n):\n    i = 1\n    s = 0\n    while n != 0:\n        t = 0\n        t += (nom // dem - 1) * n * (n + 1) // 2\n        nom %= dem\n        np = nom * n // dem\n        t += (n + np) * (n + np + 1) // 2\n        if i == 1:\n            s += t\n        else:\n            s -= t\n        i ^= 1\n        n = np\n        t = nom\n        nom += dem\n        dem = t\n    return s\nnom = 1\ndem = 1\ncount = 2675\ni = 1\nwhile i <= count:\n    nom = nom * i + 1\n    dem *= i\n    i += 1\nn = int(input())\ns = epsilon(nom, dem, n)\nprint(s)", "import math\nimport decimal\nimport time\n\ndef epsilon(nom, dem, n):\n    i = 1\n    s = 0\n    while n != 0:\n        t = 0\n        t += (nom // dem - 1) * n * (n + 1) // 2\n        nom %= dem\n        np = nom * n // dem\n        t += (n + np) * (n + np + 1) // 2\n        if i == 1:\n            s += t\n        else:\n            s -= t\n        i ^= 1\n        n = np\n        t = nom\n        nom += dem\n        dem = t\n    return s\nnom = 1\ndem = 1\ncount = 2675\ni = 1\nwhile i <= count:\n    nom = nom * i + 1\n    dem *= i\n    i += 1\nn = int(input())\ns = epsilon(nom, dem, n)\nprint(s)", "import math\nimport decimal\nimport time\n\ndef epsilon(nom, dem, n):\n    i = 1\n    s = 0\n    while n != 0:\n        t = 0\n        m = nom // dem - 1\n        t += m * n * (n + 1) // 2\n        nom = nom % dem + dem\n        np = (nom - dem) * n // dem\n        t += (n + np) * (n + np + 1) // 2\n        if i == 1:\n            s += t\n        else:\n            s -= t\n        i ^= 1\n        n = np\n        dem = nom - dem\n    return s\nnom = 1\ndem = 1\ncount = 2675\ni = 1\nwhile i <= count:\n    nom = nom * i + 1\n    dem *= i\n    i += 1\nn = int(input())\ns = epsilon(nom, dem, n)\nprint(s)", "import math as ma\nQ = list()\ny = Q.append\ny(2)\ny(1)\nfor x in range(1, 1400):\n    y(x * 2)\n    y(1)\n    y(1)\np = []\nq = []\np.append(Q[len(Q) - 1])\nq.append(1)\nfor i in range(1, len(Q)):\n    j = len(Q) - 1 - i\n    pj = p[0] * Q[j] + q[0]\n    qj = p[0]\n    p.insert(0, pj)\n    q.insert(0, qj)\n\ndef S(n):\n    o = 0\n    sign = 1\n    while n > 0:\n        if p[0] > 2 * q[0]:\n            m = Q[0] - 1\n            Q[0] = 1\n            p[0] = q[1] + p[1]\n            o = o + sign * m * n * (n + 1)\n        else:\n            m = p[0] * n // q[0]\n            o = o + sign * (m + 1) * m\n            n = (p[0] - q[0]) * n // q[0]\n            Q.pop(0)\n            p.pop(0)\n            q.pop(0)\n            Q[0] = Q[0] + 1\n            p[0] = p[0] + q[0]\n            sign = -sign\n    return o\nn = int(input())\nans = S(n)\nprint(ans // 2)", "import sys\nsys.setrecursionlimit(20000)\n\ndef fn(num, den, p):\n    if p == 0:\n        return 0\n    elif p == 1 or num == den:\n        return 1\n    else:\n        t = num // (num - den) - 1\n        p1 = p * (num - den) // den\n        return num * p // den * (num * p // den + 1) // 2 - t * (p1 * (p1 + 1) // 2) - fn(num + t * (den - num), num - den, p1)\n\ndef contfrac_to_frac(seq):\n    (num, den) = (1, 0)\n    for u in reversed(seq):\n        (num, den) = (den + num * u, num)\n    return (num - den, den)\n\ndef e_cont_frac(n):\n    seq = [2 * (i + 1) // 3 if i % 3 == 2 else 1 for i in range(n)]\n    seq[0] += 1\n    return seq\np = int(input())\nn = 4000\nseq = e_cont_frac(n)\n(num, den) = contfrac_to_frac(seq)\nans = fn(num, den, p)\nprint(ans + p * (p + 1) // 2)", "import sys\nsys.setrecursionlimit(1000000000)\n\ndef solve(A, B, C, n):\n    if A == 0:\n        return (n + 1) * (B // C)\n    if A >= C:\n        return solve(A % C, B, C, n) + n * (n + 1) // 2 * (A // C)\n    if B >= C:\n        return solve(A, B % C, C, n) + (n + 1) * (B // C)\n    m = (A * n + B) // C\n    return n * m - solve(C, C - B - 1, A, m - 1)\nn = int(input())\nC = 1\nA = 1\nlim = 3000\nfor i in range(1, lim):\n    C *= i\nfor i in range(1, lim):\n    A = A * i + 1\nprint(solve(A, 0, C, n))", "from decimal import *\nimport math\nimport sys\nx = 1\ny = 0\nz = 1\ni = 0\nn = int(input())\nwhile z < n:\n    i = i + 1\n    x = y + z\n    y = 2 * i * x + z\n    z = x + y\nst = 0\nif x >= n:\n    a = x\n    st = 1\nelif y >= n:\n    a = y\n    st = 2\nelse:\n    a = z\n    st = 3\nj = 0\nx = 1\ny = 1\nz = 2\nwhile j < i:\n    j = j + 1\n    x = y + z\n    y = 2 * j * x + z\n    z = x + y\nif st == 1:\n    b = x\nelif st == 2:\n    b = y\nelse:\n    b = z\nif n == 1:\n    print(2)\n    sys.exit()\nans = 0\nx = 1\ni = 0\nwhile n > 0:\n    i = i + 1\n    y = b // a\n    if y > 1:\n        y = y - 1\n        if x > 0:\n            ans = ans + y * n * (n + 1) // 2\n        else:\n            ans = ans - y * n * (n + 1) // 2\n        b = b - a * y\n    else:\n        y = b * n // a\n        if x > 0:\n            ans = ans + y * (y + 1) // 2\n        else:\n            ans = ans - y * (y + 1) // 2\n        x = x * -1\n        a = b - a\n        n = y - n\nprint(math.floor(ans))", "from decimal import *\nimport math\nimport sys\nx = 1\ny = 0\nz = 1\ni = 0\nn = int(input())\nwhile z < n:\n    i = i + 1\n    x = y + z\n    y = 2 * i * x + z\n    z = x + y\nst = 0\nif x >= n:\n    a = x\n    st = 1\nelif y >= n:\n    a = y\n    st = 2\nelse:\n    a = z\n    st = 3\nj = 0\nx = 1\ny = 1\nz = 2\nwhile j < i:\n    j = j + 1\n    x = y + z\n    y = 2 * j * x + z\n    z = x + y\nif st == 1:\n    b = x\nelif st == 2:\n    b = y\nelse:\n    b = z\nif n == 1:\n    print(2)\n    sys.exit()\nans = 0\nx = 1\ni = 0\nwhile n > 0:\n    i = i + 1\n    y = b // a\n    if y > 1:\n        y = y - 1\n        if x > 0:\n            ans = ans + y * n * (n + 1) // 2\n        else:\n            ans = ans - y * n * (n + 1) // 2\n        b = b - a * y\n    else:\n        y = b * n // a\n        if x > 0:\n            ans = ans + y * (y + 1) // 2\n        else:\n            ans = ans - y * (y + 1) // 2\n        x = x * -1\n        a = b - a\n        n = y - n\nprint(math.floor(ans))", "n = int(input())\ndena = 1\nnuma = 1\nfor i in range(2700, 0, -1):\n    dena *= i\n    numa += dena\ny = 0\nk = 1\ncnt2 = 2\ntempn = 0\nwhile n > 0:\n    if cnt2 == 0:\n        tempn += 2\n        diff = tempn\n        cnt2 = 2\n    else:\n        diff = 1\n        cnt2 -= 1\n    numa = numa - diff * dena\n    numa = numa - dena\n    n2 = numa * n // dena\n    y += k * (diff * n * (n + 1) + (n + n2) * (n + n2 + 1))\n    k = -k\n    n = n2\n    (numa, dena) = (dena, numa)\n    numa += dena\nprint(y // 2)", "from fractions import gcd\nimport math\n\ndef e_frac():\n    (num, den) = (2, 1)\n    k = 2\n    while k < 4100:\n        num = num * k + 1\n        den *= k\n        k += 1\n    g = gcd(num, den)\n    return (num // g, den // g)\n\ndef ES(n):\n    res = 0\n    flip = False\n    (a_num, a_den) = e_frac()\n    while True:\n        if a_num >= 2 * a_den:\n            sub = a_num // a_den - 1\n            a_num = a_den + a_num % a_den\n            if a_num == a_den:\n                res += (sub + 1) * (n * (n + 1) // 2) * (-1 if flip else 1)\n                break\n            else:\n                res += sub * (n * (n + 1) // 2) * (-1 if flip else 1)\n        nplum = (a_num - a_den) * n // a_den\n        plus = n + nplum\n        if plus == 0:\n            break\n        res += plus * (plus + 1) // 2 * (-1 if flip else 1)\n        a_den = a_num - a_den\n        flip = not flip\n        n = nplum\n    return res\nN = int(input())\nprint('%d' % ES(N))", "def A(n):\n    if n % 3 == 0:\n        return 2 * (n // 3)\n    if n == 1:\n        return 2\n    return 1\nnum = 1\nden = 0\nfor i in range(5000, 0, -1):\n    (num, den) = (A(i) * num + den, num)\nn = int(input())\nans = 0\nit = 1\nwhile n:\n    if num > den + den:\n        x = (num - den) // den\n        num -= x * den\n        if it == 0:\n            ans -= x * n * (n + 1) // 2\n        else:\n            ans += x * n * (n + 1) // 2\n    else:\n        nn = (num - den) * n // den\n        if it == 0:\n            ans -= (n + nn) * (n + nn + 1) // 2\n        else:\n            ans += (n + nn) * (n + nn + 1) // 2\n        n = nn\n        den = num - den\n        it ^= 1\nprint(ans)", "import math\nimport fractions\nn = int(input())\na = 1\nb = math.factorial(3000)\nm = 1\nfor i in range(3000, 0, -1):\n    m *= i\n    a += m\ng = fractions.gcd(a, b)\na //= g\nb //= g\nans = 0\nm = 1\nwhile b and n:\n    ans += a // b * n * (n + 1) // 2 * m\n    a %= b\n    k = n // b\n    ans += (n * a * 2 - a * k * b + a - (b - 1)) * k // 2 * m\n    n %= b\n    k = n * a // b\n    ans += k * n * m\n    (n, a, b) = (k, b, a)\n    m *= -1\nprint(ans)", "w = 9000\n\ndef getE():\n    tmp = 10 ** w\n    e = tmp\n    gt = 1\n    while tmp >= gt:\n        tmp //= gt\n        e += tmp\n        gt += 1\n    return e\n\ndef f(a, b, c, n):\n    sign = 1\n    ans = 0\n    while True:\n        if a >= c:\n            ans += sign * (a // c) * n * (n + 1) // 2\n            a %= c\n            continue\n        if b >= c:\n            ans += sign * (b // c) * (n + 1)\n            b %= c\n            continue\n        m = (a * n + b) // c\n        if m == 0:\n            break\n        ans += sign * n * m\n        sign = -sign\n        (a, b, c, n) = (c, c - b - 1, a, m - 1)\n    return ans\nn = int(input().rstrip())\nres = f(getE(), 0, int(10 ** w), n)\nprint(res)", "MAXN = 10000\na = [2, 1, 2, 1, 1]\np = [2, 3, 8, 11, 19]\nq = [1, 1, 3, 4, 7]\nj = 0\nc = -1\nn = int(input())\nsuff = 0\nres = 0\nfor i in range(5, MAXN):\n    if a[i - 1] == 1 and a[i - 2] == 1:\n        a.append(a[i - 3] + 2)\n    else:\n        a.append(1)\n    p.append(a[i] * p[i - 1] + p[i - 2])\n    q.append(a[i] * q[i - 1] + q[i - 2])\n    if q[i] > n:\n        break\nfor i in range(0, MAXN):\n    if q[i] > n:\n        break\n    j = i\n    c = -c\nfor i in range(j, 0, -1):\n    z = n // q[i]\n    if z > 0:\n        n -= z * q[i]\n        res += z * (z * p[i] * q[i] - q[i] + p[i] + c) // 2\n        res += z * q[i] * suff\n        suff += z * p[i]\n    c = -c\nprint(res)", "def floor_sum(p, q, n):\n    sgn = 1\n    res = 0\n    while n > 0:\n        if n >= q:\n            t = n // q\n            res += t * (q - 1) * (p - 1) // 2 * sgn\n            res += p * (n + 1) * t * sgn\n            res -= q * t * (t + 1) // 2 * sgn\n            n -= q * t\n        if p > q:\n            t = p // q\n            res += t * n * (n + 1) // 2 * sgn\n            p -= q * t\n        if n == 0:\n            return res\n        if n == 1:\n            return res + p // q * sgn\n        m = p * n // q\n        res += sgn * n * m\n        sgn = -sgn\n        n = m\n        m = p\n        p = q\n        q = m\n    return res\n\ndef main():\n    n = int(input())\n    k = 1\n    p = 2\n    q = 1\n    while q < n:\n        k = k + 1\n        q *= k\n        p = p * k + 1\n    for i in range(1250):\n        k = k + 1\n        q *= k\n        p = p * k + 1\n    for d in range(2, k):\n        while p % d == 0 and q % d == 0:\n            p = p // d\n            q = q // d\n    res = floor_sum(p, q, n)\n    print(res)\nmain()", "import sys\nfracs = []\n\ndef contfrac_to_frac(seq):\n    (num, den) = (1, 0)\n    for u in reversed(seq):\n        (num, den) = (den + num * u, num)\n        fracs.append((num, den))\n\ndef e_cont_frac(n):\n    seq = [2 * (i + 1) // 3 if i % 3 == 2 else 1 for i in range(n)]\n    seq[0] += 1\n    return seq\nseq = e_cont_frac(4200)\ncontfrac_to_frac(seq)\nfracs.reverse()\n\ndef getans(num, den, n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return num // den\n    if num // den >= 2:\n        return (num // den - 1) * n * (n + 1) // 2 + getans(den + num % den, den, n)\n    nt = num % den * n // den\n    return (n + nt) * (n + nt + 1) // 2 - getans(num, num - den, nt)\n(num, den) = fracs[0]\nn = int(input())\nsys.setrecursionlimit(10000)\nprint(getans(num, den, n))", "import math\np = [0, 1, 2]\nq = [0, 1, 3]\n\ndef Sa(b, n, m):\n    res = m * b * p[n]\n    if n & 1:\n        res += (b * p[n] * q[n] - q[n] + p[n] - 1) * b // 2\n    else:\n        res += (b * p[n] * q[n] - q[n] + p[n] + 1) * b // 2\n    return res\na = [0, 1, 2]\nfor i in range(1, 1500):\n    a.append(1)\n    a.append(1)\n    a.append(2 * (i + 1))\nfor i in range(3, 4005):\n    p.append(a[i] * p[i - 1] + p[i - 2])\n    q.append(a[i] * q[i - 1] + q[i - 2])\nn = int(input())\nres = n * (n + 1)\nfor i in range(4000, 0, -1):\n    if q[i] <= n and n < q[i + 1]:\n        b = int(n / q[i])\n        m = n % q[i]\n        res += Sa(b, i, m)\n        n = m\nprint(res)", "nr = 3\nnr1 = 2\ndr = 1\ndr1 = 1\nans = 0\nt = 3\nn = int(input())\nif n == 1:\n    nr = 2\nwhile dr < n:\n    if t % 3 == 0:\n        a = nr * (t // 3) * 2 + nr1\n        nr1 = nr\n        nr = a\n        a = dr * (t // 3) * 2 + dr1\n        dr1 = dr\n        dr = a\n    else:\n        a = nr + nr1\n        nr1 = nr\n        nr = a\n        a = dr + dr1\n        dr1 = dr\n        dr = a\n    t = t + 1\nt = 0\nwhile n > 0:\n    t = t + 1\n    n1 = nr // dr\n    a = 0\n    if n1 > 1:\n        a = int(n * (n + 1) // 2)\n        a = int(a * (n1 - 1))\n    nr = nr % dr + dr\n    n1 = (nr - dr) * n // dr\n    dr = nr - dr\n    if t % 2 == 1:\n        ans = ans + a + int((n + n1) * (n + n1 + 1) // 2)\n    else:\n        ans = ans - a - int((n + n1) * (n + n1 + 1) // 2)\n    n = n1\nprint(ans)", "import math\np = [0, 1, 2]\nq = [0, 1, 3]\n\ndef Sa(b, n, m):\n    res = m * b * p[n]\n    if n & 1:\n        res += (b * p[n] * q[n] - q[n] + p[n] - 1) * b // 2\n    else:\n        res += (b * p[n] * q[n] - q[n] + p[n] + 1) * b // 2\n    return res\na = [0, 1, 2]\nfor i in range(1, 1500):\n    a.append(1)\n    a.append(1)\n    a.append(2 * (i + 1))\nfor i in range(3, 4005):\n    p.append(a[i] * p[i - 1] + p[i - 2])\n    q.append(a[i] * q[i - 1] + q[i - 2])\nn = int(input())\nres = n * (n + 1)\nfor i in range(4000, 0, -1):\n    if q[i] <= n and n < q[i + 1]:\n        if q[i] == n:\n            res += Sa(1, i, 0)\n            n = 0\n        else:\n            b = int(n / q[i])\n            m = n % q[i]\n            res += Sa(b, i, m)\n            n = m\nprint(res)", "from math import *\nfrom fractions import *\n\ndef compBF(n):\n    S = 0\n    for i in range(n + 1):\n        S += floor(e * i)\n    return S\n\ndef build_e(bnd=10 ** 4000):\n    (n0, d0, n1, d1) = (2, 1, 3, 1)\n    r = [(n0, d0), (n1, d1)]\n    i = 3\n    f = 2\n    while d1 <= bnd:\n        f = 1\n        if i % 3 == 0:\n            f = i // 3 * 2\n        i += 1\n        n2 = f * n1 + n0\n        d2 = f * d1 + d0\n        (n1, n0) = (n2, n1)\n        (d1, d0) = (d2, d1)\n        r.append((n1, d1))\n    return r\n\ndef comp(N):\n    q = build_e(N)\n    S = 0\n    f = q.pop()\n    f = Fraction(f[0], f[1])\n    while N > 0:\n        g = f.limit_denominator(N)\n        (n, d) = (g.numerator, g.denominator)\n        (a, r) = (N // d, N % d)\n        S += ((a * n - 1) * (a * d - 1) - (a - 1)) // 2 + a * (r + 1) * n - 1\n        if g < f:\n            S += a\n        (N, f) = (r, g)\n    return S\n\ndef comp2(N):\n    q = build_e(N)\n    S = 0\n    f = q.pop()\n    f = Fraction(f[0], f[1])\n    while N > 0:\n        g = q.pop()\n        while g[1] > N:\n            g = q.pop()\n        (n, d) = g\n        g = Fraction(n, d)\n        (a, r) = (N // d, N % d)\n        S += ((a * n - 1) * (a * d - 1) - (a - 1)) // 2 + a * (r + 1) * n - 1\n        if g < f:\n            S += a\n        (N, f) = (r, g)\n    return S\nN = int(input())\nprint(comp2(N))\nexit(0)\nfor i in range(10000):\n    r1 = comp(i)\n    r2 = comp2(i)\n    print('res: ', i, r1, r2)\n    assert r1 == r2", "def S(a, n):\n    ans = 0\n    sign = 1\n    while n > 0:\n        if a[-1] >= 2:\n            if sign == 1:\n                ans += (a[-1] - 1) * n * (n + 1)\n            else:\n                ans -= (a[-1] - 1) * n * (n + 1)\n            a[-1] = 1\n        else:\n            p = 1\n            q = 0\n            a[-1] = a[-1] - 1\n            for i in a:\n                (p, q) = (q + i * p, p)\n            nPrim = p * n // q\n            if sign == 1:\n                x = n + nPrim\n                ans += x * (x + 1)\n            else:\n                x = n + nPrim\n                ans -= x * (x + 1)\n            a.pop()\n            a[-1] = a[-1] + 1\n            n = nPrim\n            sign *= -1\n    return ans // 2\n\ndef main():\n    e = [2 * (i + 1) // 3 if i % 3 == 2 else 1 for i in range(4020)]\n    e[0] += 1\n    e.reverse()\n    n = int(input())\n    print(S(e, n))\nmain()", "import math\n\ndef e_cont_frac(n):\n    a = [2 * (i + 1) // 3 if i % 3 == 2 else 1 for i in range(n)]\n    a[0] += 1\n    a.reverse()\n    return a\n\ndef rec(a, n):\n    res = 0\n    sign = 1\n    while n > 0:\n        if a[-1] >= 2:\n            res += sign * (a[-1] - 1) * n * (n + 1) // 2\n            a[-1] = 1\n        x = 1\n        y = 0\n        for i in a:\n            aux = y\n            y = x\n            x = aux + i * x\n        n_prim = n * (x - y) // y\n        res += sign * (n + n_prim) * (n + n_prim + 1) // 2\n        sign = -sign\n        n = n_prim\n        a.pop()\n        a[-1] = a[-1] + 1\n    return res\n\ndef main():\n    n = int(input())\n    print(int(rec(e_cont_frac(4010), n)))\nmain()", "from decimal import Decimal, getcontext\nimport math\no = 9000\ngetcontext().prec = o\n\ndef get2(x):\n    return x * (x + 1) // 2\n\ndef ceil(x):\n    ans = x.to_integral_exact()\n    if ans > x:\n        ans = ans - 1\n    return int(ans)\n\ndef getans(n, aa, bb):\n    s = 1\n    ans = 0\n    while n >= 2:\n        xx = aa // bb\n        ans += s * (xx - 1) * get2(n)\n        aa -= xx * bb\n        n1 = aa * n // bb\n        ans += s * get2(n + n1)\n        s *= -1\n        n = n1\n        aa = aa + bb\n        bb = aa - bb\n    xx = aa // bb\n    return ans + n * xx * s\ne = Decimal(0)\nf = Decimal(1)\nn = Decimal(1)\nwhile n < 4500:\n    e += f\n    f /= n\n    n += Decimal(1)\nz = 1\nh = 0\nwhile h < o:\n    h += 1\n    z *= 10\naa = ceil(e * Decimal(z))\nbb = z\nn = int(input())\na = getans(n, aa, bb)\nprint(a)", "import sys\nsys.setrecursionlimit(5000)\nfrom math import e\n\ndef E(n):\n    return int(n * e)\n\ndef cf(n):\n    if n == 0:\n        return 0\n    elif n % 3 == 1:\n        return 2 * (n // 3 + 1)\n    return 1\nSize = [1, 1]\nSums = [3, 2]\nfor i in range(5000):\n    d = cf(i)\n    Size.append(d * Size[-1] + Size[-2])\n    Sums.append(d * Sums[-1] + Sums[-2])\nmemo = {}\n\ndef _ST(k, n):\n    if k <= 3:\n        return sum((E(i) - 2 for i in range(1, n + 1)))\n    if (k, n) in memo:\n        return memo[k, n]\n    assert Size[k] == Size[k - 1] * cf(k - 2) + Size[k - 2]\n    assert n <= Size[k]\n    d = cf(k - 2)\n    (x, y) = (n // Size[k - 1], n % Size[k - 1])\n    assert x <= d\n    res = (x - 1) * x // 2 * Sums[k - 1] * Size[k - 1] + y * x * Sums[k - 1] + x * _ST(k - 1, Size[k - 1])\n    if x < d:\n        res += _ST(k - 1, y)\n    else:\n        res += _ST(k - 2, y)\n    memo[k, n] = res\n    return res\n\ndef ST(n):\n    k = 0\n    while Size[k] < n:\n        k += 1\n    return 2 * n + _ST(k, n)\nprint(ST(int(input())))", "z = 1550\n(p, q) = (4 * z + 2, 1)\nfor i in range(1, z):\n    j = z - i\n    (p, q) = (q, p)\n    p += 4 * j * q + 2 * q\nq += p\np += p\np += q\nx = int(input())\nans = 0\nflag = 1\nwhile x > 0:\n    if p >= q + q:\n        sub = (p - q) // q\n        ans += flag * sub * x * (x + 1) // 2\n        p -= q * sub\n    y = x * p // q\n    ans += flag * y * (y + 1) // 2\n    x = y - x\n    q = p - q\n    flag *= -1\nprint(ans)", "z = 2050\n(p, q) = (4 * z + 2, 1)\nfor i in range(1, z):\n    j = z - i\n    (p, q) = (q, p)\n    p += 4 * j * q + 2 * q\nq += p\np += p\np += q\nx = int(input())\nans = 0\nflag = 1\nwhile x > 0:\n    if p >= q + q:\n        sub = (p - q) // q\n        ans += flag * sub * x * (x + 1) // 2\n        p -= q * sub\n    y = x * p // q\n    ans += flag * y * (y + 1) // 2\n    x = y - x\n    q = p - q\n    flag *= -1\nprint(ans)", "z = 3050\n(p, q) = (4 * z + 2, 1)\nfor i in range(1, z):\n    j = z - i\n    (p, q) = (q, p)\n    p += 4 * j * q + 2 * q\nq += p\np += p\np += q\nx = int(input())\nans = 0\nflag = 1\nwhile x > 0:\n    if p >= q + q:\n        sub = (p - q) // q\n        ans += flag * sub * x * (x + 1) // 2\n        p -= q * sub\n    y = x * p // q\n    ans += flag * y * (y + 1) // 2\n    x = y - x\n    q = p - q\n    flag *= -1\nprint(ans)", "def S(n, p, q):\n    s = 0\n    z = 1\n    while q > 0 and n > 0:\n        t = p // q\n        s = s + z * t * n * (n + 1) // 2\n        p = p - q * t\n        t = n // q\n        s = s + z * p * t * (n + 1) - z * t * (p * q * t + p + q - 1) // 2\n        n = n - q * t\n        t = n * p // q\n        s = s + z * t * n\n        n = t\n        tem = p\n        p = q\n        q = tem\n        z = -z\n    return s\n(N0, N) = (1, 2)\nLIM = 4000 + 2\nfor i in range(3, LIM):\n    m = 1\n    if (i - 1) % 3 == 0:\n        m = 2 * (i - 1) // 3\n    naya = N0 + N * m\n    (N0, N) = (N, naya)\n(D0, D) = (1, 1)\nfor i in range(3, LIM - 1):\n    m = 1\n    if i % 3 == 0:\n        m = 2 * i // 3\n    naya = D0 + D * m\n    (D0, D) = (D, naya)\nx = input()\nx = int(x)\nans = S(x, N, D)\nprint(ans)", "import math\np = [0 for i in range(4000 + 1)]\nq = [0 for i in range(4000 + 1)]\np[0] = 2\nq[0] = 1\np[1] = 3\nq[1] = 1\np[2] = 8\nq[2] = 3\nfor n in range(3, 4001):\n    a = 0\n    if n % 3 == 1 or n % 3 == 0:\n        a = 1\n    else:\n        a = (n + 1) // 3 * 2\n    p[n] = a * p[n - 1] + p[n - 2]\n    q[n] = a * q[n - 1] + q[n - 2]\nup = p[4000]\ndown = q[4000]\ndic = {}\n\ndef findout(p, q, n):\n    K = p // q\n    temp = n * (n + 1) // 2 * K\n    p = p - q * K\n    M = n * p // q\n    if M == 0:\n        return temp\n    if (p, q, n) in dic:\n        return dic[p, q, n]\n    KK = q * (M + 1) // p\n    LLL = n * M - findout(q, p, M) + temp\n    dic[p, q, n] = LLL\n    return LLL\np = up\nq = down\nn = int(input())\nseq = [(p, q, n)]\nwhile 1:\n    K = p // q\n    p = p - q * K\n    M = n * p // q\n    (p, q) = (q, p)\n    n = M\n    if M != 0:\n        seq += [(p, q, n)]\n    else:\n        break\nseq = seq[::-1]\ntemp = 0\nfor i in range(len(seq)):\n    (p, q, n) = seq[i]\n    temp = findout(p, q, n)\nprint(temp)", "def gen_e_convergents():\n    (h0, h1) = (2, 3)\n    (k0, k1) = (1, 1)\n    yield (h1, k1)\n    n = 2\n    while True:\n        (h0, h1) = (h1, n * h1 + h0)\n        (k0, k1) = (k1, n * k1 + k0)\n        yield (h1, k1)\n        for i in range(2):\n            (h0, h1) = (h1, h1 + h0)\n            (k0, k1) = (k1, k1 + k0)\n            yield (h1, k1)\n        n += 2\n\ndef fsum(n, p, q):\n    s = 0\n    z = 1\n    while q > 0 and n > 0:\n        t = p // q\n        s += z * t * n * (n + 1) // 2\n        p -= q * t\n        t = n // q\n        s += z * p * t * (n + 1) - z * t * (p * q * t + p + q - 1) // 2\n        n -= q * t\n        t = n * p // q\n        s += z * t * n\n        n = t\n        (p, q) = (q, p)\n        z = -z\n    return s\n\ndef sol1(n):\n    if n == 1:\n        return 2\n    for (h, k) in gen_e_convergents():\n        if k >= n:\n            break\n    return fsum(n, h, k)\nn = int(input())\nprint(sol1(n))", "def calc_e(N0):\n    sd = '1'\n    for n in range(0, N0 + 11):\n        sd += '0'\n    d = int(sd)\n    e = 0\n    f = 2\n    n = 3\n    while True:\n        olde = e\n        e += d // f\n        if f > d:\n            break\n        f *= n\n        n += 1\n    return (e, d)\nP = input()\nln = len(P)\nN = int(P)\nR = N * (N + 1)\nif ln <= 101:\n    (p, q) = calc_e(202)\nelse:\n    (p, q) = calc_e(8004)\ns = 0\nn = N\nwhile q > 0 and n > 0:\n    t = p // q\n    if t != 0:\n        s = s + t * n * (n + 1) // 2\n        p = p - q * t\n    t = n // q\n    if t != 0:\n        s = s + p * t * (n + 1) - t * (p * q * t + p + q - 1) // 2\n        n = n - q * t\n    t = n * p // q\n    s = s + t * n\n    n = t\n    (p, q) = (q, p)\n    if q == 0 and n == 0:\n        break\n    t = p // q\n    if t != 0:\n        s = s - t * n * (n + 1) // 2\n        p = p - q * t\n    t = n // q\n    if t != 0:\n        s = s - p * t * (n + 1) + t * (p * q * t + p + q - 1) // 2\n        n = n - q * t\n    t = n * p // q\n    s = s - t * n\n    n = t\n    (p, q) = (q, p)\nprint(R + s)", "def calc_e(N0):\n    sd = '1'\n    for n in range(0, N0 + 11):\n        sd += '0'\n    d = int(sd)\n    e = 0\n    f = 2\n    n = 3\n    while True:\n        olde = e\n        e += d // f\n        if f > d:\n            break\n        f *= n\n        n += 1\n    return (int(e), int(d))\nP = input()\nln = len(P)\nN = int(P)\nR = N * (N + 1)\nif ln <= 101:\n    (p, q) = calc_e(202)\nelse:\n    (p, q) = calc_e(8004)\ns = 0\nn = N\nwhile q > 0 and n > 0:\n    t = p // q\n    if t != 0:\n        s = s + t * n * (n + 1) // 2\n        p = p - q * t\n    t = n // q\n    if t != 0:\n        s = s + p * t * (n + 1) - t * (p * q * t + p + q - 1) // 2\n        n = n - q * t\n    t = n * p // q\n    s = s + t * n\n    n = t\n    (p, q) = (q, p)\n    if q == 0 and n == 0:\n        break\n    t = p // q\n    if t != 0:\n        s = s - t * n * (n + 1) // 2\n        p = p - q * t\n    t = n // q\n    if t != 0:\n        s = s - p * t * (n + 1) + t * (p * q * t + p + q - 1) // 2\n        n = n - q * t\n    t = n * p // q\n    s = s - t * n\n    n = t\n    (p, q) = (q, p)\nprint(R + s)", "import sys\nimport math\nline = lambda : list((int(x) for x in input().split()))\nMOD = int(1000000000.0 + 7)\nMAXN = 4100\na = [0 for i in range(MAXN)]\np = [0 for i in range(MAXN)]\nq = [0 for i in range(MAXN)]\nt = [0 for i in range(MAXN)]\n\ndef build():\n    for i in range(MAXN):\n        if i % 3 < 2:\n            a[i] = 1\n        else:\n            a[i] = i // 3 * 2 + 2\n    a[0] = 2\n    p[MAXN - 1] = a[MAXN - 1]\n    q[MAXN - 1] = 1\n    for k in reversed(range(MAXN - 1)):\n        p[k] = p[k + 1] * a[k] + q[k + 1]\n        q[k] = p[k + 1]\n\ndef solve():\n    build()\n    t[0] = int(input())\n    for i in range(MAXN - 1):\n        t[i + 1] = t[i] * q[i + 1] // p[i + 1]\n    res = 0\n    for i in reversed(range(MAXN - 1)):\n        res *= -1\n        res += t[i] * t[i + 1]\n        res += t[i] * (t[i] + 1) // 2 * a[i]\n    print(res)\nsolve()\nexit(0)", "Umi = 2500\np = 1\nq = 1\nfor i in range(Umi, 0, -2):\n    (p, q) = (q, p + i * q)\n    (p, q) = (q, p + q)\n    (p, q) = (q, p + q)\n(p, q) = (q, p)\np += q\nn = int(input())\nn += 1\nans = 0\na = 0\nb = p\nm = q\nwhile True:\n    if b == 0:\n        ans += n * (a // m)\n        break\n    if a >= m:\n        ans += n * (a // m)\n        a %= m\n    elif b >= m:\n        ans += (n - 1) * n // 2 * (b // m)\n        b %= m\n    else:\n        (n, a, b, m) = ((a + b * n) // m, (a + b * n) % m, m, b)\nprint(ans)", "import sys\n\ndef count_lattice_points(x, numer, denom):\n    if x == 0 or numer == 0:\n        return 0\n    if x >= denom:\n        (q, r) = divmod(x, denom)\n        ret = q * (q * numer * denom - denom + numer + 1) >> 1\n        ret += r * q * numer\n        ret += count_lattice_points(r, numer, denom)\n        return ret\n    elif numer >= denom:\n        (q, r) = divmod(numer, denom)\n        return (x * (x + 1) * q >> 1) + count_lattice_points(x, r, denom)\n    else:\n        q = numer * x // denom\n        return x * q - count_lattice_points(q, denom, numer)\n\ndef solve():\n    sys.setrecursionlimit(20000)\n    nu = 0\n    de = 1\n    K = 4000\n    for k in range(K, 0, -1):\n        v = k // 3 * 2 if k % 3 == 0 else 1\n        (nu, de) = (de, nu + v * de)\n    (de, nu) = (nu, de)\n    nu += de\n    input = sys.stdin.readline\n    N = int(input())\n    print(count_lattice_points(N, nu, de))\nsolve()"]