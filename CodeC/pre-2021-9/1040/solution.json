["def gcd(a, b):\n    if a == 0:\n        return b\n    return gcd(b % a, a)\n\ndef append_count(graph, root, visited, A):\n    s = []\n    ss = []\n    s.append(root)\n    while s:\n        root = s.pop()\n        ss.append(root)\n        visited[root] = True\n        for node in graph[root][0]:\n            if not visited[node[0]]:\n                s.append(node[0])\n    while ss:\n        root = ss.pop()\n        count = 0\n        if root in A:\n            count += 1\n        for node in graph[root][0]:\n            count += graph[node[0]][1]\n        graph[root] = (graph[root][0], count)\n\ndef calculate(graph, root, visited, n, m):\n    s = []\n    ss = []\n    s.append(root)\n    while s:\n        root = s.pop()\n        ss.append(root)\n        visited[root] = True\n        for node in graph[root][0]:\n            if not visited[node[0]]:\n                s.append(node[0])\n    visited = [False for i in range(n + 1)]\n    B = [0 for i in range(n + 1)]\n    while ss:\n        ans = 0\n        root = ss.pop()\n        visited[root] = True\n        for node in graph[root][0]:\n            if visited[node[0]]:\n                ans += node[1] * graph[node[0]][1] * (m - graph[node[0]][1])\n                ans += B[node[0]]\n        B[root] = ans\n    return ans\n\ndef solve(graph, A, n, m):\n    root = next(iter(A))\n    visited = [False for i in range(n + 1)]\n    append_count(graph, root, visited, A)\n    visited = [False for i in range(n + 1)]\n    ans = 2 * calculate(graph, root, visited, n, m)\n    return (ans, m * m)\nt = int(input())\nfor _ in range(t):\n    (n, m) = map(int, input().split())\n    graph = [([], 0) for i in range(n + 1)]\n    for i in range(n - 1):\n        (v, u, l) = map(int, input().split())\n        graph[v][0].append((u, l))\n        graph[u][0].append((v, l))\n    A = set(map(int, input().split()))\n    (x, y) = solve(graph, A, n, m)\n    g = gcd(x, y)\n    print(x // g, y // g)", "import sys\nsys.setrecursionlimit(1 << 17)\nT = int(input())\n\ndef gcd(x, y):\n    while y != 0:\n        (x, y) = (y, x % y)\n    return x\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        g[u - 1].append((v - 1, w))\n        g[v - 1].append((u - 1, w))\n    marked = [False] * n\n    for t in map(int, input().split()):\n        marked[t - 1] = True\n    sub = [0] * n\n\n    def dfs(u, p):\n        if marked[u]:\n            sub[u] = 1\n        res = 0\n        for (v, w) in g[u]:\n            if v == p:\n                continue\n            res += dfs(v, u)\n            sub[u] += sub[v]\n            sub_sup = m - sub[v]\n            res += w * sub_sup * sub[v] * 2\n        return res\n    a = dfs(0, -1)\n    b = m * m\n    c = gcd(a, b)\n    print(a // c, b // c)", "import sys\nsys.setrecursionlimit(1 << 17)\nT = int(input())\n\ndef gcd(x, y):\n    while y != 0:\n        (x, y) = (y, x % y)\n    return x\nfor _ in range(T):\n    (n, m) = map(int, input().split())\n    g = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        (u, v, w) = map(int, input().split())\n        g[u - 1].append((v - 1, w))\n        g[v - 1].append((u - 1, w))\n    marked = [False] * n\n    for t in map(int, input().split()):\n        marked[t - 1] = True\n    sub = [0] * n\n\n    def dfs(u, p):\n        if marked[u]:\n            sub[u] = 1\n        res = 0\n        for (v, w) in g[u]:\n            if v == p:\n                continue\n            res += dfs(v, u)\n            sub[u] += sub[v]\n            sub_sup = m - sub[v]\n            res += w * sub_sup * sub[v] * 2\n        return res\n    a = dfs(0, -1)\n    b = m * m\n    c = gcd(a, b)\n    print(a // c, b // c)", "import sys\nimport queue\nglobal vis, m, adj, nes, num, ina, cost, n\n\ndef dfs(u):\n    global vis, m, adj, nes, num, cost, ina, n\n    vis[u] = True\n    for v in adj[u]:\n        if vis[v] == False:\n            dfs(v)\n            num += cost[v, u] * nes[v] * (m - nes[v])\n            nes[u] += nes[v]\n    if ina[u] == True:\n        nes[u] += 1\n\ndef stackdfs(u):\n    global vis, m, adj, nes, num, cost, ina, n\n    cal = [0] * n\n    s1 = list()\n    s2 = list()\n    s1.append(u)\n    vis[u] = True\n    while len(s1) != 0:\n        v = s1.pop()\n        if len(adj[v]) == 1 and vis[adj[v][0]] == True:\n            cal[v] = 1\n            if ina[v] == True:\n                nes[v] += 1\n        else:\n            s2.append(v)\n        for w in adj[v]:\n            if vis[w] == False:\n                s1.append(w)\n                vis[w] = True\n    while len(s2) != 0:\n        v = s2.pop()\n        for w in adj[v]:\n            if cal[w] == 1:\n                nes[v] += nes[w]\n                num += cost[v, w] * nes[w] * (m - nes[w])\n        if ina[v] == True:\n            nes[v] += 1\n        cal[v] = 1\n\ndef gcd(d, b):\n    if b == 0:\n        return d\n    else:\n        return gcd(b, d % b)\nt = int(sys.stdin.readline())\nfor _ in range(t):\n    (n, m) = map(int, sys.stdin.readline().split())\n    adj = []\n    cost = dict()\n    edg = dict()\n    num = 0\n    p = [-1] * n\n    vis = [False] * n\n    nes = [0] * n\n    ina = [False] * n\n    for i in range(n):\n        adj.append([])\n    for i in range(n - 1):\n        (u, v, c) = map(int, sys.stdin.readline().split())\n        u = u - 1\n        v = v - 1\n        adj[u].append(v)\n        adj[v].append(u)\n        cost[u, v] = c\n        cost[v, u] = c\n    a = []\n    a = map(int, sys.stdin.readline().split())\n    a = list(a)\n    for i in range(m):\n        ina[a[i] - 1] = True\n    if m == 1:\n        num = 0\n    else:\n        stackdfs(0)\n    den = m * m\n    flag = 0\n    if den % 2 == 0:\n        flag = 1\n        den = den // 2\n    if num >= den:\n        z = gcd(num, den)\n    else:\n        z = gcd(den, num)\n    num = num // z\n    den = den // z\n    if num == 0:\n        den = 1\n    if flag == 1:\n        print(num, den)\n    else:\n        print(num * 2, den)"]