["(N, M) = map(int, input().split())\nA = []\nfor i in range(N):\n    A.append(input())\nQ = []\nfor i in range(M):\n    (l, r, v) = input().split()\n    Q.append((int(l), int(r), v))\nimport random\n\ndef genInput(N, M, large=False):\n    if large:\n        A = ['1' + ''.join(['1' if random.randint(0, 10) > 4 else '0' for _ in range(random.randint(1000 if i < 10 else 1, 2000 if i < 10 else 20))]) for i in range(N)]\n        Q = []\n        for i in range(M):\n            l = random.randint(1, N // 2)\n            r = random.randint(l, N)\n            v = '1' + ''.join(['1' if random.randint(0, 10) > 4 else '0' for _ in range(random.randint(1000 if i < 10 else 1, 20000 if i < 10 else 20))])\n            Q.append((l, r, v))\n        return (N, M, A, Q)\n    else:\n        A = ['1' + ''.join(['1' if random.randint(0, 10) > 4 else '0' for _ in range(1, random.randint(1, 20))]) for _ in range(N)]\n        Q = []\n        for i in range(M):\n            l = random.randint(1, N // 2)\n            r = random.randint(l, N)\n            v = '1' + ''.join(['1' if random.randint(0, 10) > 4 else '0' for _ in range(random.randint(1, 20))])\n            Q.append((l, r, v))\n        return (N, M, A, Q)\ntree = {'c': [], 'v': [], 'vl': 0}\n\ndef compressStr(num, maxLen):\n    ans = []\n    ln = len(num)\n    if ln < maxLen:\n        ans.append((maxLen - ln, '0'))\n    elif ln > maxLen:\n        num = num[ln - maxLen:]\n    (i, j) = (0, 0)\n    while j < len(num):\n        if num[j] != num[i]:\n            ans.append((j - i, num[i]))\n            i = j\n        j += 1\n    ans.append((j - i, num[i]))\n    if len(ans) > 1 and ans[0][1] == ans[1][1]:\n        ans[:2] = [(ans[0][0] + ans[1][0], ans[0][1])]\n    return ans\n\ndef diffCompressedStr(u, v):\n    (ui, vi) = (0, 0)\n    same = []\n    while ui < len(u) and vi < len(v):\n        if u[ui][1] == v[vi][1]:\n            if u[ui][0] == v[vi][0]:\n                same.append((u[ui][0], u[ui][1]))\n                ui += 1\n                vi += 1\n            elif u[ui][0] < v[vi][0]:\n                same.append((u[ui][0], u[ui][1]))\n                v[vi] = (v[vi][0] - u[ui][0], v[vi][1])\n                ui += 1\n            else:\n                same.append((v[vi][0], v[vi][1]))\n                u[ui] = (u[ui][0] - v[vi][0], u[ui][1])\n                vi += 1\n        else:\n            break\n    return (same, u[ui:], v[vi:])\n\ndef popLeft(num, count=1):\n    c = 0\n    for i in range(len(num)):\n        if c + num[i][0] > count:\n            return [(num[i][0] - count + c, num[i][1])] + num[i + 1:]\n        else:\n            c += num[i][0]\n    return []\n\ndef rev(val):\n    return '1' if val == '0' else '0'\n\ndef buildTree(num, idx, numLen):\n    t = tree\n    num = compressStr(num, numLen)\n    while num:\n        tv = t['v']\n        (same, vleft, num) = diffCompressedStr(tv, num)\n        if not vleft:\n            if num:\n                u = num[0][1]\n                ru = rev(u)\n                if u in t:\n                    t['c'].append(idx)\n                    t = t[u]\n                    num = popLeft(num, 1)\n                elif ru in t:\n                    t[u] = {'c': [idx], 'v': popLeft(num, 1)}\n                else:\n                    t['c'].append(idx)\n                    t['v'] = num\n                    return\n            else:\n                t['c'].append(idx)\n                return\n        else:\n            c0 = t['0'] if '0' in t else None\n            c1 = t['1'] if '1' in t else None\n            v0 = vleft[0][1]\n            n0 = num[0][1]\n            t[n0] = {'c': [idx], 'v': popLeft(num, 1)}\n            t[v0] = {'c': [x for x in t['c']], 'v': popLeft(vleft, 1)}\n            if c0:\n                t[v0]['0'] = c0\n            if c1:\n                t[v0]['1'] = c1\n            t['v'] = same\n            t['c'].append(idx)\n            return\n    t['c'].append(idx)\n\ndef computeTreeValLen(t):\n    if not t:\n        return\n    if 'v' in t:\n        t['vl'] = sum([x[0] for x in t['v']] or [0])\n    else:\n        t['vl'] = 0\n    if '0' in t:\n        computeTreeValLen(t['0'])\n    if '1' in t:\n        computeTreeValLen(t['1'])\nMXD = max([len(x) for x in A])\nfor (i, v) in enumerate(A):\n    buildTree(v, i + 1, MXD)\ncomputeTreeValLen(tree)\nimport json\n\ndef check(l, r, idx):\n    if not idx:\n        return False\n    if idx[0] > r or idx[-1] < l:\n        return False\n    if l <= idx[0] <= idx[-1] <= r:\n        return True\n    (a, b) = (0, len(idx))\n    while a < b:\n        c = (a + b) // 2\n        v = idx[c]\n        if l <= v <= r:\n            return True\n        if v < l:\n            a = c + 1\n        elif v > r:\n            b = c\n    return False\n\ndef find(l, r, idx):\n    (a, b) = (0, len(idx))\n    while a < b:\n        c = (a + b) // 2\n        v = idx[c]\n        if v < l:\n            a = c + 1\n        elif v > r:\n            b = c\n        else:\n            b = c\n    return idx[a]\n\ndef query(l, r, num):\n    num = compressStr(num, MXD)\n    t = tree\n    while num:\n        if len(tree['c']) <= 1:\n            break\n        if t['v']:\n            num = popLeft(num, t['vl'])\n            if not num:\n                break\n        a = num[0][1]\n        ra = rev(a)\n        if ra in t and check(l, r, t[ra]['c']):\n            t = t[ra]\n            num = popLeft(num, 1)\n        elif a in t and check(l, r, t[a]['c']):\n            t = t[a]\n            num = popLeft(num, 1)\n        else:\n            break\n    return find(l, r, t['c'])\nans = []\nfor (l, r, v) in Q:\n    ans.append(query(l, r, v))\nprint('\\n'.join(map(str, ans)))", "from collections import defaultdict\nfrom bisect import bisect_left, bisect_right\nfrom math import log2, ceil\nmaxpow = 0\n\nclass TrieNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.children = [None] * 2\n        self.data = []\n\nclass Trie:\n\n    def __init__(self):\n        self.root = self.newNode(-1)\n\n    def newNode(self, key):\n        return TrieNode(key)\n\n    def insert(self, key, idx):\n        pCrawl = self.root\n        for i in range(maxpow, -1, -1):\n            f = check(key, i)\n            if not pCrawl.children[f] or pCrawl.children[f] == None:\n                pCrawl.children[f] = self.newNode(key)\n            pCrawl = pCrawl.children[f]\n            pCrawl.data.append(idx)\n\n    def insert_list(self, arr):\n        for i in range(len(arr) - 1):\n            key = arr[i]\n            pCrawl = self.root\n            for j in range(maxpow, -1, -1):\n                f = check(key, j)\n                if not pCrawl.children[f]:\n                    pCrawl.children[f] = self.newNode(key)\n                pCrawl = pCrawl.children[f]\n                pCrawl.data.append(i)\n\n    def find_max_xor(self, x):\n        pCrawl = self.root\n        res = 0\n        for i in range(maxpow - 1, -1, -1):\n            f = check(x, i)\n            if pCrawl.children[f ^ 1]:\n                res += 2 ** i\n                pCrawl = pCrawl.children[f ^ 1]\n            else:\n                pCrawl = pCrawl.children[f]\n        return res\n\n    def query(self, big_nums, l, r, x):\n        res = 0\n        pCrawl = self.root\n        pCrawl2 = None\n        for i in range(maxpow, -1, -1):\n            f = check(x, i)\n            done = False\n            if pCrawl.children[f ^ 1]:\n                pCrawl2 = pCrawl.children[f ^ 1]\n                p = bisect_left(pCrawl2.data, l)\n                if p == len(pCrawl2.data):\n                    p -= 1\n                if pCrawl2.data[p] >= l and pCrawl2.data[p] <= r:\n                    res = 2 * res + 1\n                    pCrawl = pCrawl2\n                    done = True\n            if not done and pCrawl.children[f]:\n                pCrawl = pCrawl.children[f]\n                res *= 2\n        idx = -1\n        for i in big_nums.keys():\n            if l <= i <= r:\n                xo = big_nums[i] ^ x\n                if xo > res:\n                    idx = i\n                    res = xo\n        return (res ^ x, idx)\n\ndef check(b, pos):\n    return 1 if b & 2 ** pos else 0\n\ndef brute(arr, N, Q):\n    results = []\n    for i in range(N):\n        x = int(input(), 2)\n        arr.append(x)\n    for i in range(Q):\n        (l, r, x) = input().split()\n        (l, r, x) = (int(l), int(r), int(x, 2))\n        mx = -1\n        idx = 0\n        for j in range(l, r + 1):\n            if arr[j - 1] ^ x > mx:\n                mx = arr[j - 1] ^ x\n                idx = j\n        results.append(idx)\n    print('\\n'.join((str(k) for k in results)))\n\ndef solve():\n    global maxpow\n    (N, Q) = map(int, input().split())\n    indexes = defaultdict(list)\n    results = []\n    arr = []\n    big_nums = defaultdict(int)\n    max_ = int('1' * (60 - 2 * N // 10000), 2)\n    if Q * N < 300000000:\n        brute(arr, N, Q)\n        return\n    for i in range(N):\n        x = int(input(), 2)\n        if x > max_:\n            big_nums[i] = x\n            x = 0\n        arr.append(x)\n        indexes[x].append(i + 1)\n    maxpow = ceil(log2(max(arr)))\n    arr.append(0)\n    TRIE = Trie()\n    TRIE.insert_list(arr)\n    for _ in range(Q):\n        (L, R, X) = input().split()\n        (L, R, X) = (int(L) - 1, int(R) - 1, int(X, 2))\n        if X > max_:\n            idx = L + 1\n            res = arr[L] ^ X\n            for j in range(L + 1, R + 1):\n                xo = arr[j] ^ X\n                if xo > res:\n                    res = xo\n                    idx = j + 1\n            for i in big_nums.keys():\n                if L <= i <= R:\n                    xo = big_nums[i] ^ X\n                    if xo > res:\n                        idx = i + 1\n                        res = xo\n            results.append(idx)\n        else:\n            (q, idx) = TRIE.query(big_nums, L, R, X)\n            if idx != -1:\n                results.append(idx + 1)\n                continue\n            i = bisect_right(indexes[q], L - 1)\n            if indexes[q][i] < L + 1:\n                i += 1\n            results.append(indexes[q][i])\n    print('\\n'.join((str(k) for k in results)))\nsolve()"]