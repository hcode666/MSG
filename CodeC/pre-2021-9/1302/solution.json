["from functools import reduce\nfrom collections import Counter\nmod = 1000000007\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a):\n    (g, x, y) = egcd(a, mod)\n    return x % mod\n\ndef mul(x, y):\n    return x * y % mod\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, range(n, n - r, -1), 1)\n    denom = reduce(mul, map(modinv, range(1, r + 1)), 1)\n    return numer * denom\nt = int(input())\nfor ti in range(t):\n    (n, m) = map(int, input().split())\n    counts = Counter(map(int, input().split()))\n    res = 1\n    previ = 1\n    prevc = 1\n    free = 0\n    fail = False\n    for i in range(1, len(counts) + 1):\n        if i not in counts:\n            fail = True\n            break\n        for j in range(counts[i]):\n            res *= prevc\n            res %= mod\n        prevc = counts[i]\n        free += prevc * (prevc - 1) // 2\n    extra = m - n + 1\n    if fail or extra > free:\n        print(0)\n        continue\n    res *= ncr(free, extra)\n    print(res % mod)", "from functools import reduce\nfrom collections import Counter\nmod = 1000000007\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a):\n    (g, x, y) = egcd(a, mod)\n    return x % mod\n\ndef mul(x, y):\n    return x * y % mod\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, range(n, n - r, -1), 1)\n    denom = reduce(mul, map(modinv, range(1, r + 1)), 1)\n    return numer * denom\nt = int(input())\nfor ti in range(t):\n    (n, m) = map(int, input().split())\n    counts = Counter(map(int, input().split()))\n    res = 1\n    previ = 1\n    prevc = 1\n    free = 0\n    fail = False\n    for i in range(1, len(counts) + 1):\n        if i not in counts:\n            fail = True\n            break\n        for j in range(counts[i]):\n            res *= prevc\n            res %= mod\n        prevc = counts[i]\n        free += prevc * (prevc - 1) // 2\n    extra = m - n + 1\n    if fail or extra > free:\n        print(0)\n        continue\n    res *= ncr(free, extra)\n    print(res % mod)", "from functools import reduce\nfrom collections import Counter\nmod = 1000000007\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a):\n    (g, x, y) = egcd(a, mod)\n    return x % mod\n\ndef mul(x, y):\n    return x * y % mod\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, range(n, n - r, -1), 1)\n    denom = reduce(mul, map(modinv, range(1, r + 1)), 1)\n    return numer * denom\nt = int(input())\nfor ti in range(t):\n    (n, m) = map(int, input().split())\n    counts = Counter(map(int, input().split()))\n    res = 1\n    previ = 1\n    prevc = 1\n    free = 0\n    fail = False\n    for i in range(1, len(counts) + 1):\n        if i not in counts:\n            fail = True\n            break\n        for j in range(counts[i]):\n            res *= prevc\n            res %= mod\n        prevc = counts[i]\n        free += prevc * (prevc - 1) // 2\n    extra = m - n + 1\n    if fail or extra > free:\n        print(0)\n        continue\n    res *= ncr(free, extra)\n    print(res % mod)", "from functools import reduce\nfrom collections import Counter\nmod = 1000000007\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a):\n    (g, x, y) = egcd(a, mod)\n    return x % mod\n\ndef mul(x, y):\n    return x * y % mod\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, range(n, n - r, -1), 1)\n    denom = reduce(mul, map(modinv, range(1, r + 1)), 1)\n    return numer * denom\nt = int(input())\nfor ti in range(t):\n    (n, m) = map(int, input().split())\n    counts = Counter(map(int, input().split()))\n    res = 1\n    previ = 1\n    prevc = 1\n    free = 0\n    fail = False\n    for i in range(1, len(counts) + 1):\n        if i not in counts:\n            fail = True\n            break\n        for j in range(counts[i]):\n            res *= prevc\n            res %= mod\n        prevc = counts[i]\n        free += prevc * (prevc - 1) // 2\n    extra = m - n + 1\n    if fail or extra > free:\n        print(0)\n        continue\n    res *= ncr(free, extra)\n    print(res % mod)", "MOD = 10 ** 9 + 7\n\ndef ncr(n, r):\n    num = den = 1\n    for i in range(r):\n        num = num * (n - i) % MOD\n        den = den * (i + 1) % MOD\n    return num * pow(den, MOD - 2, MOD) % MOD\nfor _ in range(int(input())):\n    (n, m) = map(int, input().split())\n    a = list(map(int, input().split()))\n    d = {0: 1}\n    for i in a:\n        d[i] = 1 if i not in d else d[i] + 1\n    ans = 1\n    total = 0\n    for (i, j) in d.items():\n        if i == 0:\n            continue\n        ans = ans * pow(d[i - 1] if i - 1 in d else 0, j, MOD) % MOD\n        total = (total + j * (j - 1) // 2 % MOD) % MOD\n    rem = m - n + 1\n    ans = ans * ncr(total, rem) % MOD\n    print(ans)", "import sys\nimport math\nfrom collections import defaultdict, Counter\ninput = sys.stdin.readline\n\ndef print(x):\n    sys.stdout.write(str(x) + '\\n')\n\ndef power(x, y, m):\n    if y == 0:\n        return 1\n    p = power(x, y // 2, m) % m\n    p = p * p % m\n    if y % 2 == 0:\n        return p\n    else:\n        return x * p % m\n\ndef find(n, r):\n    p = 1\n    q = 1\n    for j in range(1, r + 1):\n        p = p * (n - j + 1) % m\n        q = q * j % m\n    return p * power(q, m - 2, m) % m\nm = pow(10, 9) + 7\nt = int(input())\nfor i in range(t):\n    (n, m1) = map(int, input().split())\n    a = list(map(int, input().split()))\n    avail = 0\n    req = m1 - (n - 1)\n    ans = 1\n    c = Counter(a)\n    for j in c:\n        avail += c[j] * (c[j] - 1) // 2\n        if j == 1:\n            continue\n        ans = ans * pow(c.get(j - 1, 0), c[j], m) % m\n    if req > avail:\n        print(0)\n    else:\n        ans = ans * find(avail, req) % m\n        print(ans)", "from functools import reduce\nfrom collections import Counter\nmod = 1000000007\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a):\n    (g, x, y) = egcd(a, mod)\n    return x % mod\n\ndef mul(x, y):\n    return x * y % mod\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, range(n, n - r, -1), 1)\n    denom = reduce(mul, map(modinv, range(1, r + 1)), 1)\n    return numer * denom\nt = int(input())\nfor ti in range(t):\n    (n, m) = map(int, input().split())\n    counts = Counter(map(int, input().split()))\n    res = 1\n    previ = 1\n    prevc = 1\n    free = 0\n    fail = False\n    for i in range(1, len(counts) + 1):\n        if i not in counts:\n            fail = True\n            break\n        for j in range(counts[i]):\n            res *= prevc\n            res %= mod\n        prevc = counts[i]\n        free += prevc * (prevc - 1) // 2\n    extra = m - n + 1\n    if fail or extra > free:\n        print(0)\n        continue\n    res *= ncr(free, extra)\n    print(res % mod)", "mod = 10 ** 9 + 7\nfrom math import factorial\n\ndef create_dic(array):\n    dic = {}\n    for i in array:\n        if i in dic:\n            dic[i] += 1\n        else:\n            dic[i] = 1\n    return dic\n\ndef C(n, r):\n    if r > n:\n        return 0\n    elif r == n:\n        return 1\n    elif r == 0:\n        return 1\n    r = max(r, n - r)\n    num = 1\n    for i in range(r + 1, n + 1):\n        num = num * i % mod\n    den = 1\n    for i in range(1, n - r + 1):\n        den = den * i % mod\n    tbm = pow(den, mod - 2, mod)\n    num = num * tbm % mod\n    return num\nfor _ in range(int(input())):\n    (N, M) = map(int, input().split())\n    array = list(map(int, input().split()))\n    total = 0\n    if M >= N - 1:\n        dic = create_dic(array)\n        if 1 in dic.keys():\n            possible = True\n            cnt = dic[1]\n            search = 2\n            total = 1\n            while cnt < N - 1 and possible:\n                if search in dic.keys():\n                    total = total * pow(dic[search - 1], dic[search], mod) % mod\n                    cnt += dic[search]\n                    search += 1\n                else:\n                    possible = False\n                    total = 0\n        else:\n            total = 0\n    if total > 0:\n        left = M - N + 1\n        pis = 0\n        for value in dic.values():\n            pis += value * (value - 1) // 2\n        total = total * C(pis, left) % mod\n    print(total)", "from functools import reduce\nfrom collections import Counter\nmod = 1000000007\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        (g, y, x) = egcd(b % a, a)\n        return (g, x - b // a * y, y)\n\ndef modinv(a):\n    (g, x, y) = egcd(a, mod)\n    return x % mod\n\ndef mul(x, y):\n    return x * y % mod\n\ndef ncr(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, range(n, n - r, -1), 1)\n    denom = reduce(mul, map(modinv, range(1, r + 1)), 1)\n    return numer * denom\nt = int(input())\nfor ti in range(t):\n    (n, m) = map(int, input().split())\n    counts = Counter(map(int, input().split()))\n    res = 1\n    previ = 1\n    prevc = 1\n    free = 0\n    fail = False\n    for i in range(1, len(counts) + 1):\n        if i not in counts:\n            fail = True\n            break\n        for j in range(counts[i]):\n            res *= prevc\n            res %= mod\n        prevc = counts[i]\n        free += prevc * (prevc - 1) // 2\n    extra = m - n + 1\n    if fail or extra > free:\n        print(0)\n        continue\n    res *= ncr(free, extra)\n    print(res % mod)", "def inv(x):\n    return pow(x, 1000000005, 1000000007)\n\ndef nCr(n, r):\n    z = 1\n    for i in range(r):\n        z = z * (n - i)\n        z %= 1000000007\n    for i in range(r):\n        z = z * inv(i + 1)\n        z %= 1000000007\n    return z\nt = int(input())\nfor you in range(t):\n    l = input().split()\n    n = int(l[0])\n    m = int(l[1])\n    l = input().split()\n    li = [int(i) for i in l]\n    hashi = dict()\n    freq = [0 for i in range(n - 1)]\n    for i in li:\n        freq[i - 1] += 1\n    pro = 1\n    count = 0\n    curr = 1\n    for i in range(n - 1):\n        if freq[i] == 0:\n            break\n        pro = pro * pow(curr, freq[i], 1000000007)\n        pro %= 1000000007\n        count += freq[i]\n        curr = freq[i]\n    if count != n - 1:\n        print(0)\n        continue\n    m -= n - 1\n    tota = 0\n    for i in freq:\n        tota += i * (i - 1) // 2\n    if tota < m:\n        print(0)\n    else:\n        z = nCr(tota, m)\n        pro *= z\n        pro %= 1000000007\n        print(pro)"]