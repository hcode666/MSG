["from collections import namedtuple, defaultdict\nfrom math import isclose, floor, ceil\nline = namedtuple('line', ['m', 'c'])\n\ndef intersection(l1: line, l2: line):\n    if l1.m == l2.m:\n        return None\n    elif l1.m == 'inf':\n        return (l1.c, l2.m * l1.c + l2.c)\n    elif l2.m == 'inf':\n        return (l2.c, l1.m * l2.c + l1.c)\n    x = (l2.c - l1.c) / (l1.m - l2.m)\n    return (x, l1.m * x + l1.c)\n\ndef intgen():\n    return (int(x) for x in input().split())\n\ndef closer(p):\n    if isclose(p, floor(p)):\n        return int(floor(p))\n    elif isclose(p, ceil(p)):\n        return int(ceil(p))\n    return None\ntestcases = int(input())\nfor testcase in range(testcases):\n    (n, xs, ys) = (int(input()), list(intgen()), list(intgen()))\n    points = list(zip(xs, ys))\n    linecount = defaultdict(int)\n    for (x, y) in points:\n        linecount[line(0, y)] += 1\n        linecount[line('inf', x)] += 1\n        linecount[line(1, y - x)] += 1\n        linecount[line(-1, x + y)] += 1\n    (lines, ln, ls) = (list(linecount.keys()), len(linecount), set())\n    for j in range(ln):\n        for k in range(j + 1, ln):\n            if lines[j].m != lines[k].m:\n                (x, y) = intersection(lines[j], lines[k])\n                u = linecount[line(0, closer(y))] + linecount[line('inf', closer(x))] + linecount[line(1, closer(y - x))] + linecount[line(-1, closer(y + x))]\n                if (closer(x), closer(y)) in points:\n                    u -= 4\n                    ls.add(u + 2 * (n - 1 - u))\n                else:\n                    ls.add(u + 2 * (n - u))\n    print(min(ls))", "from collections import namedtuple, defaultdict\nfrom math import isclose, floor, ceil\nline = namedtuple('line', ['m', 'c'])\n\ndef intersection(l1: line, l2: line):\n    if l1.m == l2.m:\n        return None\n    elif l1.m == 'inf':\n        return (l1.c, l2.m * l1.c + l2.c)\n    elif l2.m == 'inf':\n        return (l2.c, l1.m * l2.c + l1.c)\n    x = (l2.c - l1.c) / (l1.m - l2.m)\n    return (x, l1.m * x + l1.c)\n\ndef intgen():\n    return (int(x) for x in input().split())\n\ndef closer(p):\n    if isclose(p, floor(p)):\n        return int(floor(p))\n    elif isclose(p, ceil(p)):\n        return int(ceil(p))\n    return None\ntestcases = int(input())\nfor testcase in range(testcases):\n    (n, xs, ys) = (int(input()), list(intgen()), list(intgen()))\n    points = list(zip(xs, ys))\n    linecount = defaultdict(int)\n    for (x, y) in points:\n        linecount[line(0, y)] += 1\n        linecount[line('inf', x)] += 1\n        linecount[line(1, y - x)] += 1\n        linecount[line(-1, x + y)] += 1\n    (lines, ln, ls) = (list(linecount.keys()), len(linecount), set())\n    for j in range(ln):\n        for k in range(j + 1, ln):\n            if lines[j].m != lines[k].m:\n                (x, y) = intersection(lines[j], lines[k])\n                u = linecount[line(0, closer(y))] + linecount[line('inf', closer(x))] + linecount[line(1, closer(y - x))] + linecount[line(-1, closer(y + x))]\n                if (closer(x), closer(y)) in points:\n                    u -= 4\n                    ls.add(u + 2 * (n - 1 - u))\n                else:\n                    ls.add(u + 2 * (n - u))\n    print(min(ls))", "from collections import namedtuple, defaultdict\nfrom math import isclose, floor, ceil\nline = namedtuple('line', ['m', 'c'])\n\ndef intersection(l1: line, l2: line):\n    if l1.m == l2.m:\n        return None\n    elif l1.m == 'inf':\n        return (l1.c, l2.m * l1.c + l2.c)\n    elif l2.m == 'inf':\n        return (l2.c, l1.m * l2.c + l1.c)\n    x = (l2.c - l1.c) / (l1.m - l2.m)\n    return (x, l1.m * x + l1.c)\n\ndef intgen():\n    return (int(x) for x in input().split())\n\ndef closer(p):\n    if isclose(p, floor(p)):\n        return int(floor(p))\n    elif isclose(p, ceil(p)):\n        return int(ceil(p))\n    return None\ntestcases = int(input())\nfor testcase in range(testcases):\n    (n, xs, ys) = (int(input()), list(intgen()), list(intgen()))\n    points = list(zip(xs, ys))\n    linecount = defaultdict(int)\n    for (x, y) in points:\n        linecount[line(0, y)] += 1\n        linecount[line('inf', x)] += 1\n        linecount[line(1, y - x)] += 1\n        linecount[line(-1, x + y)] += 1\n    (lines, ln, ls) = (list(linecount.keys()), len(linecount), set())\n    for j in range(ln):\n        for k in range(j + 1, ln):\n            if lines[j].m != lines[k].m:\n                (x, y) = intersection(lines[j], lines[k])\n                u = linecount[line(0, closer(y))] + linecount[line('inf', closer(x))] + linecount[line(1, closer(y - x))] + linecount[line(-1, closer(y + x))]\n                if (closer(x), closer(y)) in points:\n                    u -= 4\n                    ls.add(u + 2 * (n - 1 - u))\n                else:\n                    ls.add(u + 2 * (n - u))\n    print(min(ls))", "import math\nt = int(input())\n\ndef find_xy(m1, m2, x1, x2, y1, y2):\n    (a1, b1) = (m1[0], m1[1])\n    (a2, b2) = (m2[0], m2[1])\n    c1 = a1 * x1 + b1 * y1\n    c2 = a2 * x2 + b2 * y2\n    Dx = c1 * b2 - c2 * b1\n    Dy = a1 * c2 - a2 * c1\n    D = a1 * b2 - a2 * b1\n    x = Dx / D\n    y = Dy / D\n    return (x, y)\nfor _ in range(t):\n    n = int(input())\n    X = list(map(float, input().split()))\n    Y = list(map(float, input().split()))\n    m = [[1, 1], [1, -1], [0, 1], [1, 0]]\n    adict = {}\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = abs(X[i] - X[j])\n            y = abs(Y[i] - Y[j])\n            checker = set()\n            for m1 in m:\n                for m2 in m:\n                    if m1 != m2:\n                        temp = find_xy(m1, m2, X[i], X[j], Y[i], Y[j])\n                        checker.add(temp)\n            for temp in checker:\n                try:\n                    adict[temp[0], temp[1]] += 1\n                except:\n                    adict[temp[0], temp[1]] = 1\n    res = []\n    remains = {}\n    for i in range(n):\n        dist = 0\n        for j in range(n):\n            if i != j:\n                x = abs(X[i] - X[j])\n                y = abs(Y[i] - Y[j])\n                if x == 0 or y == 0 or x == y:\n                    dist += 1\n                    remains[X[i], Y[i]] = 0\n                else:\n                    dist += 2\n        res.append(dist)\n    keys = list(adict.keys())\n    key2 = list(remains.keys())\n    for i in range(len(keys)):\n        reserve = {}\n        if adict[keys[i]] == 1:\n            continue\n        for j in range(len(remains)):\n            try:\n                m0 = (key2[j][1] - keys[i][1]) / (key2[j][0] - keys[i][0])\n                if m0 == 0 or m0 == -1 or m0 == 1:\n                    try:\n                        reserve[m0] += 1\n                    except:\n                        reserve[m0] = 1\n            except:\n                m0 = 'inf'\n                try:\n                    reserve[m0] += 1\n                except:\n                    reserve[m0] = 1\n        for t0 in range(len(reserve)):\n            key0 = list(reserve.keys())\n            t1 = reserve[key0[t0]]\n            t1 = t1 * (t1 - 1) / 2\n            adict[keys[i]] += t1\n    for i in range(len(keys)):\n        tem = 1 + math.sqrt(1 + 8 * adict[keys[i]])\n        tem /= 2\n        dist = tem + (n - tem) * 2\n        res.append(dist)\n        if int(dist) == 1:\n            print(adict[keys[i]])\n    print(int(min(res)))", "import sys\nfor t in range(int(input())):\n    N = int(input())\n    x_ = list(map(int, input().split()))\n    y_ = list(map(int, input().split()))\n    ope_max = int(sys.maxsize)\n    x = 0\n    y = 0\n    m = 1\n    if N < 50:\n        m = 4\n    for k in range(m):\n        for p in range(N):\n            for q in range(N):\n                if k == 0:\n                    x = x_[p]\n                    y = y_[q]\n                elif k == 1:\n                    x = y_[p] + x_[q] - y_[q]\n                    y = y_[p]\n                elif k == 2:\n                    x = (x_[q] + y_[q] + x_[p] - y_[p]) / 2.0\n                    y = x + y_[p] - x_[p]\n                elif k == 3:\n                    x = x_[p] + y_[p] - y_[q]\n                    y = y_[q]\n                operations = 0\n                for j in range(N):\n                    if x == x_[j] and y == y_[j]:\n                        operations += 0\n                    elif abs(x - x_[j]) == abs(y - y_[j]) or x == x_[j] or y == y_[j]:\n                        operations += 1\n                    else:\n                        operations += 2\n                if ope_max > operations:\n                    ope_max = operations\n    print(ope_max)", "import sys\nfor t in range(int(input())):\n    N = int(input())\n    x_ = list(map(int, input().split()))\n    y_ = list(map(int, input().split()))\n    ope_max = int(sys.maxsize)\n    x = 0\n    y = 0\n    m = 1\n    if N < 50:\n        m = 4\n    for k in range(m):\n        for p in range(N):\n            for q in range(N):\n                if k == 0:\n                    x = x_[p]\n                    y = y_[q]\n                elif k == 1:\n                    x = y_[p] + x_[q] - y_[q]\n                    y = y_[p]\n                elif k == 2:\n                    x = (x_[q] + y_[q] + x_[p] - y_[p]) / 2.0\n                    y = x + y_[p] - x_[p]\n                elif k == 3:\n                    x = x_[p] + y_[p] - y_[q]\n                    y = y_[q]\n                operations = 0\n                for j in range(N):\n                    if x == x_[j] and y == y_[j]:\n                        operations += 0\n                    elif abs(x - x_[j]) == abs(y - y_[j]) or x == x_[j] or y == y_[j]:\n                        operations += 1\n                    else:\n                        operations += 2\n                if ope_max > operations:\n                    ope_max = operations\n    print(ope_max)", "from collections import namedtuple, defaultdict\nfrom math import isclose, floor, ceil\nline = namedtuple('line', ['m', 'c'])\n\ndef intersection(l1: line, l2: line):\n    if l1.m == l2.m:\n        return None\n    elif l1.m == 'inf':\n        return (l1.c, l2.m * l1.c + l2.c)\n    elif l2.m == 'inf':\n        return (l2.c, l1.m * l2.c + l1.c)\n    x = (l2.c - l1.c) / (l1.m - l2.m)\n    return (x, l1.m * x + l1.c)\n\ndef intgen():\n    return (int(x) for x in input().split())\n\ndef closer(p):\n    if isclose(p, floor(p)):\n        return int(floor(p))\n    elif isclose(p, ceil(p)):\n        return int(ceil(p))\n    return None\ntestcases = int(input())\nfor testcase in range(testcases):\n    (n, xs, ys) = (int(input()), list(intgen()), list(intgen()))\n    points = list(zip(xs, ys))\n    linecount = defaultdict(int)\n    for (x, y) in points:\n        linecount[line(0, y)] += 1\n        linecount[line('inf', x)] += 1\n        linecount[line(1, y - x)] += 1\n        linecount[line(-1, x + y)] += 1\n    (lines, ln, ls) = (list(linecount.keys()), len(linecount), set())\n    for j in range(ln):\n        for k in range(j + 1, ln):\n            if lines[j].m != lines[k].m:\n                (x, y) = intersection(lines[j], lines[k])\n                u = linecount[line(0, closer(y))] + linecount[line('inf', closer(x))] + linecount[line(1, closer(y - x))] + linecount[line(-1, closer(y + x))]\n                if (closer(x), closer(y)) in points:\n                    u -= 4\n                    ls.add(u + 2 * (n - 1 - u))\n                else:\n                    ls.add(u + 2 * (n - u))\n    print(min(ls))", "import sys\nfor t in range(int(input())):\n    N = int(input())\n    x_ = list(map(int, input().split()))\n    y_ = list(map(int, input().split()))\n    ope_max = int(sys.maxsize)\n    x = 0\n    y = 0\n    m = 1\n    if N < 50:\n        m = 4\n    for k in range(m):\n        for p in range(N):\n            for q in range(N):\n                if k == 0:\n                    x = x_[p]\n                    y = y_[q]\n                elif k == 1:\n                    x = y_[p] + x_[q] - y_[q]\n                    y = y_[p]\n                elif k == 2:\n                    x = (x_[q] + y_[q] + x_[p] - y_[p]) / 2.0\n                    y = x + y_[p] - x_[p]\n                elif k == 3:\n                    x = x_[p] + y_[p] - y_[q]\n                    y = y_[q]\n                operations = 0\n                for j in range(N):\n                    if x == x_[j] and y == y_[j]:\n                        operations += 0\n                    elif abs(x - x_[j]) == abs(y - y_[j]) or x == x_[j] or y == y_[j]:\n                        operations += 1\n                    else:\n                        operations += 2\n                if ope_max > operations:\n                    ope_max = operations\n    print(ope_max)", "import sys\nfor t in range(int(input())):\n    N = int(input())\n    x_ = list(map(int, input().split()))\n    y_ = list(map(int, input().split()))\n    ope_max = int(sys.maxsize)\n    x = 0\n    y = 0\n    m = 1\n    if N < 50:\n        m = 4\n    for k in range(m):\n        for p in range(N):\n            for q in range(N):\n                if k == 0:\n                    x = x_[p]\n                    y = y_[q]\n                elif k == 1:\n                    x = y_[p] + x_[q] - y_[q]\n                    y = y_[p]\n                elif k == 2:\n                    x = (x_[q] + y_[q] + x_[p] - y_[p]) / 2.0\n                    y = x + y_[p] - x_[p]\n                elif k == 3:\n                    x = x_[p] + y_[p] - y_[q]\n                    y = y_[q]\n                operations = 0\n                for j in range(N):\n                    if x == x_[j] and y == y_[j]:\n                        operations += 0\n                    elif abs(x - x_[j]) == abs(y - y_[j]) or x == x_[j] or y == y_[j]:\n                        operations += 1\n                    else:\n                        operations += 2\n                if ope_max > operations:\n                    ope_max = operations\n    print(ope_max)", "import sys\nfor t in range(int(input())):\n    N = int(input())\n    x_ = list(map(int, input().split()))\n    y_ = list(map(int, input().split()))\n    ope_max = int(sys.maxsize)\n    x = 0\n    y = 0\n    m = 1\n    if N < 50:\n        m = 4\n    for k in range(m):\n        for p in range(N):\n            for q in range(N):\n                if k == 0:\n                    x = x_[p]\n                    y = y_[q]\n                elif k == 1:\n                    x = y_[p] + x_[q] - y_[q]\n                    y = y_[p]\n                elif k == 2:\n                    x = (x_[q] + y_[q] + x_[p] - y_[p]) / 2.0\n                    y = x + y_[p] - x_[p]\n                elif k == 3:\n                    x = x_[p] + y_[p] - y_[q]\n                    y = y_[q]\n                operations = 0\n                for j in range(N):\n                    if x == x_[j] and y == y_[j]:\n                        operations += 0\n                    elif abs(x - x_[j]) == abs(y - y_[j]) or x == x_[j] or y == y_[j]:\n                        operations += 1\n                    else:\n                        operations += 2\n                if ope_max > operations:\n                    ope_max = operations\n    print(ope_max)", "def check(h, k, x, y, n):\n    count = 0\n    for j in range(n):\n        if h == x[j] and k == y[j]:\n            count += 0\n        elif abs(h - x[j]) == abs(k - y[j]) or h == x[j] or k == y[j]:\n            count += 1\n        else:\n            count += 2\n    return count\nfor i in range(int(input())):\n    n = int(input())\n    x = list(map(int, input().split(' ')))\n    y = list(map(int, input().split(' ')))\n    min_step = 10 ** 100\n    h = 0\n    k = 0\n    m = 1\n    if n < 50:\n        m = 4\n    for l in range(m):\n        for t in range(n):\n            for s in range(n):\n                if l == 0:\n                    h = x[t]\n                    k = y[s]\n                elif l == 1:\n                    h = y[t] + x[s] - y[s]\n                    k = y[t]\n                elif l == 2:\n                    h = (x[s] + y[s] + x[t] - y[t]) / 2\n                    k = h + y[t] - x[t]\n                elif l == 3:\n                    h = x[t] + y[t] - y[s]\n                    k = y[s]\n                mini = check(h, k, x, y, n)\n                min_step = min(min_step, mini)\n    print(min_step)", "def check(h, k, x, y, n):\n    count = 0\n    for j in range(n):\n        if h == x[j] and k == y[j]:\n            count += 0\n        elif abs(h - x[j]) == abs(k - y[j]) or h == x[j] or k == y[j]:\n            count += 1\n        else:\n            count += 2\n    return count\nfor i in range(int(input())):\n    n = int(input())\n    x = list(map(int, input().split(' ')))\n    y = list(map(int, input().split(' ')))\n    min_step = 10 ** 100\n    h = 0\n    k = 0\n    m = 1\n    if n < 50:\n        m = 4\n    for l in range(m):\n        for t in range(n):\n            for s in range(n):\n                if l == 0:\n                    h = x[t]\n                    k = y[s]\n                elif l == 1:\n                    h = y[t] + x[s] - y[s]\n                    k = y[t]\n                elif l == 2:\n                    h = (x[s] + y[s] + x[t] - y[t]) / 2.0\n                    k = h + y[t] - x[t]\n                elif l == 3:\n                    h = x[t] + y[t] - y[s]\n                    k = y[s]\n                mini = check(h, k, x, y, n)\n                min_step = min(min_step, mini)\n    print(min_step)", "def check(h, k, x, y, n):\n    count = 0\n    for j in range(n):\n        if h == x[j] and k == y[j]:\n            count += 0\n        elif abs(h - x[j]) == abs(k - y[j]) or h == x[j] or k == y[j]:\n            count += 1\n        else:\n            count += 2\n    return count\nfor i in range(int(input())):\n    n = int(input())\n    x = list(map(int, input().split(' ')))\n    y = list(map(int, input().split(' ')))\n    min_step = 10 ** 100\n    h = 0\n    k = 0\n    m = 1\n    if n < 50:\n        m = 4\n    for l in range(m):\n        for t in range(n):\n            for s in range(n):\n                if l == 0:\n                    h = x[t]\n                    k = y[s]\n                elif l == 1:\n                    h = y[t] + x[s] - y[s]\n                    k = y[t]\n                elif l == 2:\n                    h = (x[s] + y[s] + x[t] - y[t]) / 2.0\n                    k = h + y[t] - x[t]\n                elif l == 3:\n                    h = x[t] + y[t] - y[s]\n                    k = y[s]\n                mini = check(h, k, x, y, n)\n                min_step = min(min_step, mini)\n    print(min_step)", "def check(h, k, x, y, n):\n    count = 0\n    for j in range(n):\n        if h == x[j] and k == y[j]:\n            count += 0\n        elif abs(h - x[j]) == abs(k - y[j]) or h == x[j] or k == y[j]:\n            count += 1\n        else:\n            count += 2\n    return count\nnum = int(input())\nfor i in range(num):\n    n = int(input())\n    x = list(map(int, input().split(' ')))\n    y = list(map(int, input().split(' ')))\n    min_step = 10 ** 100\n    h = 0\n    k = 0\n    m = 1\n    if n < 50:\n        m = 4\n    for l in range(m):\n        for t in range(n):\n            for s in range(n):\n                if l == 0:\n                    h = x[t]\n                    k = y[s]\n                elif l == 1:\n                    h = y[t] + x[s] - y[s]\n                    k = y[t]\n                elif l == 2:\n                    h = (x[s] + y[s] + x[t] - y[t]) / 2.0\n                    k = h + y[t] - x[t]\n                elif l == 3:\n                    h = x[t] + y[t] - y[s]\n                    k = y[s]\n                mini = check(h, k, x, y, n)\n                if min_step > mini:\n                    min_step = mini\n    print(min_step)", "def calci(Ox, Oy):\n    step = 0\n    for j in range(N):\n        K1 = Ox - X[j]\n        if X[j] == Ox and Y[j] == Oy:\n            continue\n        elif X[j] + K1 == Ox and Y[j] + K1 == Oy:\n            step = step + 1\n        elif X[j] == Ox:\n            step = step + 1\n        elif Y[j] == Oy:\n            step = step + 1\n        elif X[j] + K1 == Ox and Y[j] - K1 == Oy:\n            step = step + 1\n        else:\n            step = step + 2\n    min.append(step)\n    min.sort()\n\ndef calculate(x, y):\n    if (x, y) in d:\n        d[x, y] = d[x, y] + 1\n    else:\n        d[x, y] = 1\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    X = input().split()\n    Y = input().split()\n    d = {}\n    min = []\n    for i in range(N):\n        X[i] = int(X[i])\n        Y[i] = int(Y[i])\n    for i in range(N):\n        Ox = X[i]\n        Oy = Y[i]\n        step = 0\n        for j in range(N):\n            K1 = Ox - X[j]\n            if X[j] == Ox and Y[j] == Oy:\n                continue\n            elif X[j] + K1 == Ox and Y[j] + K1 == Oy:\n                step = step + 1\n            elif X[j] == Ox:\n                step = step + 1\n            elif Y[j] == Oy:\n                step = step + 1\n            elif X[j] + K1 == Ox and Y[j] - K1 == Oy:\n                step = step + 1\n            else:\n                step = step + 2\n        min.append(step)\n    min.sort()\n    for i in range(N):\n        for j in range(i + 1, N):\n            if X[i] + Y[i] == X[j] + Y[j] or X[i] - Y[i] == X[j] - Y[j] or X[i] == X[j] or (Y[i] == Y[j]):\n                calculate(X[i], Y[i])\n                calculate(X[j], Y[j])\n            else:\n                calculate((X[i] + Y[i] + X[j] - Y[j]) / 2, (X[i] + Y[i] - X[j] + Y[j]) / 2)\n                calculate(X[j], X[i] + Y[i] - X[j])\n                calculate(X[i] + Y[i] - Y[j], Y[j])\n                calculate((X[i] - Y[i] + X[j] + Y[j]) / 2, (-X[i] + Y[i] + X[j] + Y[j]) / 2)\n                calculate(X[j], -X[i] + Y[i] + X[j])\n                calculate(X[i] - Y[i] + Y[j], Y[j])\n                calculate(X[i], X[j] + Y[j] - X[i])\n                calculate(X[i], -X[j] + Y[j] + X[i])\n                calculate(X[i], Y[j])\n                calculate(X[j] + Y[j] - Y[i], Y[i])\n                calculate(X[j] - Y[j] + Y[i], Y[i])\n                calculate(X[j], Y[i])\n    max = 0\n    for i in d:\n        if d[i] > max:\n            max = d[i]\n            point = i\n    calci(point[0], point[1])\n    print(min[0])", "def calci(Ox, Oy):\n    step = 0\n    for j in range(N):\n        K1 = Ox - X[j]\n        if X[j] == Ox and Y[j] == Oy:\n            continue\n        elif X[j] + K1 == Ox and Y[j] + K1 == Oy:\n            step = step + 1\n        elif X[j] == Ox:\n            step = step + 1\n        elif Y[j] == Oy:\n            step = step + 1\n        elif X[j] + K1 == Ox and Y[j] - K1 == Oy:\n            step = step + 1\n        else:\n            step = step + 2\n    min.append(step)\n    min.sort()\n\ndef calculate(x, y):\n    if (x, y) in d:\n        d[x, y] = d[x, y] + 1\n    else:\n        d[x, y] = 1\nT = int(input())\nfor i in range(T):\n    N = int(input())\n    X = input().split()\n    Y = input().split()\n    d = {}\n    min = []\n    for i in range(N):\n        X[i] = int(X[i])\n        Y[i] = int(Y[i])\n    for i in range(N):\n        Ox = X[i]\n        Oy = Y[i]\n        step = 0\n        for j in range(N):\n            K1 = Ox - X[j]\n            if X[j] == Ox and Y[j] == Oy:\n                continue\n            elif X[j] + K1 == Ox and Y[j] + K1 == Oy:\n                step = step + 1\n            elif X[j] == Ox:\n                step = step + 1\n            elif Y[j] == Oy:\n                step = step + 1\n            elif X[j] + K1 == Ox and Y[j] - K1 == Oy:\n                step = step + 1\n            else:\n                step = step + 2\n        min.append(step)\n    min.sort()\n    for i in range(N):\n        for j in range(i + 1, N):\n            if X[i] + Y[i] == X[j] + Y[j]:\n                calculate(X[i], Y[i])\n                calculate(X[j], Y[j])\n            elif X[i] - Y[i] == X[j] - Y[j]:\n                calculate(X[i], Y[i])\n                calculate(X[j], Y[j])\n            elif X[i] == X[j]:\n                calculate(X[i], Y[i])\n                calculate(X[j], Y[j])\n            elif Y[i] == Y[j]:\n                calculate(X[i], Y[i])\n                calculate(X[j], Y[j])\n            else:\n                calculate((X[i] + Y[i] + X[j] - Y[j]) / 2, (X[i] + Y[i] - X[j] + Y[j]) / 2)\n                calculate(X[j], X[i] + Y[i] - X[j])\n                calculate(X[i] + Y[i] - Y[j], Y[j])\n                calculate((X[i] - Y[i] + X[j] + Y[j]) / 2, (-X[i] + Y[i] + X[j] + Y[j]) / 2)\n                calculate(X[j], -X[i] + Y[i] + X[j])\n                calculate(X[i] - Y[i] + Y[j], Y[j])\n                calculate(X[i], X[j] + Y[j] - X[i])\n                calculate(X[i], -X[j] + Y[j] + X[i])\n                calculate(X[i], Y[j])\n                calculate(X[j] + Y[j] - Y[i], Y[i])\n                calculate(X[j] - Y[j] + Y[i], Y[i])\n                calculate(X[j], Y[i])\n    max = 0\n    for i in d:\n        if d[i] > max:\n            max = d[i]\n            point = i\n    calci(point[0], point[1])\n    print(min[0])", "from collections import defaultdict\nfrom itertools import product\n\ndef f(l1, l2):\n    (a1, b1, c1) = l1\n    (a2, b2, c2) = l2\n    det = a1 * b2 - a2 * b1\n    det1 = c1 * b2 - c2 * b1\n    det2 = a1 * c2 - a2 * c1\n    return (det1 / det, det2 / det)\n\ndef f1(l, s):\n    if len(l) == 4:\n        l = l[:3]\n    elif len(l) == 7:\n        l = l[:4]\n    return sum(l) - s\nfor t in range(int(input())):\n    n = int(input())\n    (d1, d2, d3, d4) = (defaultdict(set), defaultdict(set), defaultdict(set), defaultdict(set))\n    for (x, y) in zip(map(float, input().split()), map(float, input().split())):\n        d1[1, 0, x].add((x, y))\n        d2[0, 1, y].add((x, y))\n        d3[-1, 1, y - x].add((x, y))\n        d4[1, 1, x + y].add((x, y))\n    d = {}\n    for (dct1, dct2) in ((d1, d2), (d1, d3), (d1, d4), (d2, d3), (d2, d4), (d3, d4)):\n        for (l1, l2) in product(dct1, dct2):\n            intersec = f(l1, l2)\n            if intersec in d:\n                d[intersec][0].append(len(dct2[l2]))\n                if intersec in dct2[l2]:\n                    d[intersec][1] = 2\n            else:\n                d[intersec] = [[len(dct1[l1]), len(dct2[l2])], 2 * (intersec in dct2[l2])]\n    print(2 * n - max((f1(*el) for el in d.values())))", "import sys\n\ndef check(h, k, x, y, n):\n    count = 0\n    for j in range(n):\n        if h == x[j] and k == y[j]:\n            count += 0\n        elif abs(h - x[j]) == abs(k - y[j]) or h == x[j] or k == y[j]:\n            count += 1\n        else:\n            count += 2\n    return count\nnum = int(input())\nfor i in range(num):\n    n = int(input())\n    x = list(map(int, input().split(' ')))\n    y = list(map(int, input().split(' ')))\n    min_step = int(sys.maxsize)\n    h = 0\n    k = 0\n    m = 1\n    if n < 50:\n        m = 4\n    for l in range(m):\n        for t in range(n):\n            for s in range(n):\n                if l == 0:\n                    h = x[t]\n                    k = y[s]\n                elif l == 1:\n                    h = y[t] + x[s] - y[s]\n                    k = y[t]\n                elif l == 2:\n                    h = (x[s] + y[s] + x[t] - y[t]) / 2.0\n                    k = h + y[t] - x[t]\n                elif l == 3:\n                    h = x[t] + y[t] - y[s]\n                    k = y[s]\n                mini = check(h, k, x, y, n)\n                if min_step > mini:\n                    min_step = mini\n    print(min_step)", "import sys\nfor t in range(int(input())):\n    N = int(input())\n    x_ = list(map(int, input().split()))\n    y_ = list(map(int, input().split()))\n    ope_max = int(sys.maxsize)\n    x = 0\n    y = 0\n    m = 1\n    if N < 50:\n        m = 4\n    for k in range(m):\n        for p in range(N):\n            for q in range(N):\n                if k == 0:\n                    x = x_[p]\n                    y = y_[q]\n                elif k == 1:\n                    x = y_[p] + x_[q] - y_[q]\n                    y = y_[p]\n                elif k == 2:\n                    x = (x_[q] + y_[q] + x_[p] - y_[p]) / 2.0\n                    y = x + y_[p] - x_[p]\n                elif k == 3:\n                    x = x_[p] + y_[p] - y_[q]\n                    y = y_[q]\n                operations = 0\n                for j in range(N):\n                    if x == x_[j] and y == y_[j]:\n                        operations += 0\n                    elif abs(x - x_[j]) == abs(y - y_[j]) or x == x_[j] or y == y_[j]:\n                        operations += 1\n                    else:\n                        operations += 2\n                if ope_max > operations:\n                    ope_max = operations\n    print(ope_max)", "import sys\nfor t in range(int(input())):\n    N = int(input())\n    x_ = list(map(int, input().split()))\n    y_ = list(map(int, input().split()))\n    ope_max = int(sys.maxsize)\n    x = 0\n    y = 0\n    m = 1\n    if N < 50:\n        m = 4\n    for k in range(m):\n        for p in range(N):\n            for q in range(N):\n                if k == 0:\n                    x = x_[p]\n                    y = y_[q]\n                elif k == 1:\n                    x = y_[p] + x_[q] - y_[q]\n                    y = y_[p]\n                elif k == 2:\n                    x = (x_[q] + y_[q] + x_[p] - y_[p]) / 2.0\n                    y = x + y_[p] - x_[p]\n                elif k == 3:\n                    x = x_[p] + y_[p] - y_[q]\n                    y = y_[q]\n                operations = 0\n                for j in range(N):\n                    if x == x_[j] and y == y_[j]:\n                        operations += 0\n                    elif abs(x - x_[j]) == abs(y - y_[j]) or x == x_[j] or y == y_[j]:\n                        operations += 1\n                    else:\n                        operations += 2\n                if ope_max > operations:\n                    ope_max = operations\n    print(ope_max)", "for _ in range(int(input())):\n    N = int(input())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n    setP = set()\n    for i in range(N):\n        setP.add((X[i], Y[i]))\n    left = {}\n    right = {}\n    sY = {}\n    sX = {}\n    for i in range(N):\n        l = X[i] + Y[i]\n        left[l] = left.get(l, 0) + 1\n        r = X[i] - Y[i]\n        right[r] = right.get(r, 0) + 1\n        sX[X[i]] = sX.get(X[i], 0) + 1\n        sY[Y[i]] = sY.get(Y[i], 0) + 1\n    minC = 10 ** 5\n    for (x1, y1) in left.items():\n        for (x2, y2) in right.items():\n            x = (x1 + x2) / 2\n            y = (x1 - x2) / 2\n            count = y1 + y2 + sY.get(y, 0) + sX.get(x, 0)\n            if (x, y) in setP:\n                count -= 4\n                count += max(0, 2 * (N - count - 1))\n            else:\n                count += max(0, 2 * (N - count))\n            minC = min(minC, count)\n    for (x, nx) in sX.items():\n        for (y, ny) in sY.items():\n            count = nx + ny + left.get(y + x, 0) + right.get(x - y, 0)\n            if (x, y) in setP:\n                count -= 4\n                count += max(0, 2 * (N - count - 1))\n            else:\n                count += max(0, 2 * (N - count))\n            minC = min(minC, count)\n    for (x, nx) in sX.items():\n        for (s, ns) in left.items():\n            y = s - x\n            count = nx + ns + right.get(x - y, 0) + sY.get(y, 0)\n            if (x, y) in setP:\n                count -= 4\n                count += max(0, 2 * (N - count - 1))\n            else:\n                count += max(0, 2 * (N - count))\n            minC = min(minC, count)\n    for (x, nx) in sX.items():\n        for (d, nd) in right.items():\n            y = x - d\n            count = nx + nd + left.get(x + y, 0) + sY.get(y, 0)\n            if (x, y) in setP:\n                count -= 4\n                count += max(0, 2 * (N - count - 1))\n            else:\n                count += max(0, 2 * (N - count))\n            minC = min(minC, count)\n    for (y, ny) in sY.items():\n        for (s, ns) in left.items():\n            x = s - y\n            count = ny + ns + right.get(x - y, 0) + sX.get(x, 0)\n            if (x, y) in setP:\n                count -= 4\n                count += max(0, 2 * (N - count - 1))\n            else:\n                count += max(0, 2 * (N - count))\n            minC = min(minC, count)\n    for (y, ny) in sY.items():\n        for (d, nd) in right.items():\n            x = d + y\n            count = ny + nd + left.get(x + y, 0) + sX.get(x, 0)\n            if (x, y) in setP:\n                count -= 4\n                count += max(0, 2 * (N - count - 1))\n            else:\n                count += max(0, 2 * (N - count))\n            minC = min(minC, count)\n    print(minC)", "from collections import namedtuple, defaultdict\nfrom math import isclose, floor, ceil\nline = namedtuple('line', ['m', 'c'])\n\ndef intersection(l1: line, l2: line):\n    if l1.m == l2.m:\n        return None\n    elif l1.m == 'inf':\n        return (l1.c, l2.m * l1.c + l2.c)\n    elif l2.m == 'inf':\n        return (l2.c, l1.m * l2.c + l1.c)\n    x = (l2.c - l1.c) / (l1.m - l2.m)\n    return (x, l1.m * x + l1.c)\n\ndef intgen():\n    return (int(x) for x in input().split())\n\ndef closer(p):\n    if isclose(p, floor(p)):\n        return int(floor(p))\n    elif isclose(p, ceil(p)):\n        return int(ceil(p))\n    return None\ntestcases = int(input())\nfor testcase in range(testcases):\n    (n, xs, ys) = (int(input()), list(intgen()), list(intgen()))\n    points = list(zip(xs, ys))\n    linecount = defaultdict(int)\n    for (x, y) in points:\n        linecount[line(0, y)] += 1\n        linecount[line('inf', x)] += 1\n        linecount[line(1, y - x)] += 1\n        linecount[line(-1, x + y)] += 1\n    (lines, ln, ls) = (list(linecount.keys()), len(linecount), set())\n    for j in range(ln):\n        for k in range(j + 1, ln):\n            if lines[j].m != lines[k].m:\n                (x, y) = intersection(lines[j], lines[k])\n                u = linecount[line(0, closer(y))] + linecount[line('inf', closer(x))] + linecount[line(1, closer(y - x))] + linecount[line(-1, closer(y + x))]\n                if (closer(x), closer(y)) in points:\n                    u -= 4\n                    ls.add(u + 2 * (n - 1 - u))\n                else:\n                    ls.add(u + 2 * (n - u))\n    print(min(ls))", "import sys\nfor t in range(int(input())):\n    N = int(input())\n    x_ = list(map(int, input().split()))\n    y_ = list(map(int, input().split()))\n    ope_max = int(sys.maxsize)\n    x = 0\n    y = 0\n    m = 1\n    if N < 50:\n        m = 4\n    for k in range(m):\n        for p in range(N):\n            for q in range(N):\n                if k == 0:\n                    x = x_[p]\n                    y = y_[q]\n                elif k == 1:\n                    x = y_[p] + x_[q] - y_[q]\n                    y = y_[p]\n                elif k == 2:\n                    x = (x_[q] + y_[q] + x_[p] - y_[p]) / 2.0\n                    y = x + y_[p] - x_[p]\n                elif k == 3:\n                    x = x_[p] + y_[p] - y_[q]\n                    y = y_[q]\n                operations = 0\n                for j in range(N):\n                    if x == x_[j] and y == y_[j]:\n                        operations += 0\n                    elif abs(x - x_[j]) == abs(y - y_[j]) or x == x_[j] or y == y_[j]:\n                        operations += 1\n                    else:\n                        operations += 2\n                if ope_max > operations:\n                    ope_max = operations\n    print(ope_max)", "import math\nt = int(input())\n\ndef find_xy(m1, m2, x1, x2, y1, y2):\n    (a1, b1) = (m1[0], m1[1])\n    (a2, b2) = (m2[0], m2[1])\n    c1 = a1 * x1 + b1 * y1\n    c2 = a2 * x2 + b2 * y2\n    Dx = c1 * b2 - c2 * b1\n    Dy = a1 * c2 - a2 * c1\n    D = a1 * b2 - a2 * b1\n    x = Dx / D\n    y = Dy / D\n    return (x, y)\nfor _ in range(t):\n    n = int(input())\n    X = list(map(float, input().split()))\n    Y = list(map(float, input().split()))\n    m = [[1, 1], [1, -1], [0, 1], [1, 0]]\n    adict = {}\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x = abs(X[i] - X[j])\n            y = abs(Y[i] - Y[j])\n            checker = set()\n            for m1 in m:\n                for m2 in m:\n                    if m1 != m2:\n                        temp = find_xy(m1, m2, X[i], X[j], Y[i], Y[j])\n                        checker.add(temp)\n            for temp in checker:\n                try:\n                    adict[temp[0], temp[1]] += 1\n                except:\n                    adict[temp[0], temp[1]] = 1\n    res = []\n    remains = {}\n    for i in range(n):\n        dist = 0\n        for j in range(n):\n            if i != j:\n                x = abs(X[i] - X[j])\n                y = abs(Y[i] - Y[j])\n                if x == 0 or y == 0 or x == y:\n                    dist += 1\n                    remains[X[i], Y[i]] = 0\n                else:\n                    dist += 2\n        res.append(dist)\n    keys = list(adict.keys())\n    key2 = list(remains.keys())\n    for i in range(len(keys)):\n        reserve = {}\n        if adict[keys[i]] == 1:\n            continue\n        for j in range(len(remains)):\n            try:\n                m0 = (key2[j][1] - keys[i][1]) / (key2[j][0] - keys[i][0])\n                if m0 == 0 or m0 == -1 or m0 == 1:\n                    try:\n                        reserve[m0] += 1\n                    except:\n                        reserve[m0] = 1\n            except:\n                m0 = 'inf'\n                try:\n                    reserve[m0] += 1\n                except:\n                    reserve[m0] = 1\n        for t0 in range(len(reserve)):\n            key0 = list(reserve.keys())\n            t1 = reserve[key0[t0]]\n            t1 = t1 * (t1 - 1) / 2\n            adict[keys[i]] += t1\n    for i in range(len(keys)):\n        tem = 1 + math.sqrt(1 + 8 * adict[keys[i]])\n        tem /= 2\n        dist = tem + (n - tem) * 2\n        res.append(dist)\n        if int(dist) == 1:\n            print(adict[keys[i]])\n    print(int(min(res)))", "from collections import namedtuple, defaultdict\nfrom math import isclose, floor, ceil\nline = namedtuple('line', ['m', 'c'])\n\ndef intersection(l1: line, l2: line):\n    if l1.m == l2.m:\n        return None\n    elif l1.m == 'inf':\n        return (l1.c, l2.m * l1.c + l2.c)\n    elif l2.m == 'inf':\n        return (l2.c, l1.m * l2.c + l1.c)\n    x = (l2.c - l1.c) / (l1.m - l2.m)\n    return (x, l1.m * x + l1.c)\n\ndef intgen():\n    return (int(x) for x in input().split())\n\ndef closer(p):\n    if isclose(p, floor(p)):\n        return int(floor(p))\n    elif isclose(p, ceil(p)):\n        return int(ceil(p))\n    return None\ntestcases = int(input())\nfor testcase in range(testcases):\n    (n, xs, ys) = (int(input()), list(intgen()), list(intgen()))\n    points = list(zip(xs, ys))\n    linecount = defaultdict(int)\n    for (x, y) in points:\n        linecount[line(0, y)] += 1\n        linecount[line('inf', x)] += 1\n        linecount[line(1, y - x)] += 1\n        linecount[line(-1, x + y)] += 1\n    (lines, ln, ls) = (list(linecount.keys()), len(linecount), set())\n    for j in range(ln):\n        for k in range(j + 1, ln):\n            if lines[j].m != lines[k].m:\n                (x, y) = intersection(lines[j], lines[k])\n                u = linecount[line(0, closer(y))] + linecount[line('inf', closer(x))] + linecount[line(1, closer(y - x))] + linecount[line(-1, closer(y + x))]\n                if (closer(x), closer(y)) in points:\n                    u -= 4\n                    ls.add(u + 2 * (n - 1 - u))\n                else:\n                    ls.add(u + 2 * (n - u))\n    print(min(ls))", "import sys\nfrom collections import Counter\n\ndef rall():\n    return sys.stdin.readlines()\n\ndef rl():\n    return sys.stdin.readline().strip()\n\ndef rl_types(types):\n    str_list = [x for x in sys.stdin.readline().strip().split(' ')]\n    return [types[i](str_list[i]) for i in range(len(str_list))]\n\ndef pr(something=''):\n    sys.stdout.write(str(something) + '\\n')\n\ndef pra(array):\n    sys.stdout.write(' '.join([str(x) for x in array]) + '\\n')\n\ndef solve(array):\n    return array\nNT = int(rl())\nfor ti in range(NT):\n    _ = rl()\n    xs = [int(x) for x in rl().split(' ')]\n    ys = [int(x) for x in rl().split(' ')]\n    n = len(xs)\n    points = set(zip(xs, ys))\n    freq_x = Counter(xs)\n    freq_y = Counter(ys)\n    freq_xpy = Counter([xs[i] + ys[i] for i in range(n)])\n    freq_xmy = Counter([xs[i] - ys[i] for i in range(n)])\n\n    def tot_move_cost(points, ix, iy):\n        tot_cost = 0\n        for (px, py) in points:\n            if px == ix and py == iy:\n                tot_cost += 0\n            elif px == ix or py == iy or px + py == ix + iy or (px - py == ix - iy):\n                tot_cost += 1\n            else:\n                tot_cost += 2\n        return tot_cost\n\n    def tot_cost_to(ix, iy):\n        (n_samex, n_samey) = (freq_x[ix], freq_y[iy])\n        (n_xpy, n_xmy) = (freq_xpy[ix + iy], freq_xmy[ix - iy])\n        n_rem = n - (n_samex + n_samey + n_xpy + n_xmy)\n        if (ix, iy) in points:\n            n_samex -= 1\n            n_samey -= 1\n            n_xpy -= 1\n            n_xmy -= 1\n            n_rem += 4 - 1\n        return n_samex + n_samey + n_xpy + n_xmy + 2 * n_rem\n    all_cands = {}\n    intersections = set()\n    mn = float('inf')\n    for ix in freq_x:\n        for iy in freq_y:\n            mn = min(mn, tot_cost_to(ix, iy))\n    for ix in freq_x:\n        for xpy in freq_xpy:\n            iy = xpy - ix\n            mn = min(mn, tot_cost_to(ix, iy))\n    for ix in freq_x:\n        for xmy in freq_xmy:\n            iy = ix - xmy\n            mn = min(mn, tot_cost_to(ix, iy))\n    for iy in freq_y:\n        for xpy in freq_xpy:\n            ix = xpy - iy\n            mn = min(mn, tot_cost_to(ix, iy))\n    for iy in freq_y:\n        for xmy in freq_xmy:\n            ix = iy + xmy\n            mn = min(mn, tot_cost_to(ix, iy))\n    for xpy in freq_xpy:\n        for xmy in freq_xmy:\n            ix = (xpy + xmy) / 2\n            iy = xpy - ix\n            mn = min(mn, tot_cost_to(ix, iy))\n    pr(mn)", "class point:\n\n    def __init__(self, x, y):\n        self.x = float(x)\n        self.y = float(y)\n\n    def vertical(self):\n        a = 1\n        b = 0\n        c = -self.x\n        return (a, b, c)\n\n    def horizontal(self):\n        a = 0\n        b = 1\n        c = -self.y\n        return (a, b, c)\n\n    def dig1(self):\n        a = 1\n        b = 1\n        c = -(self.x + self.y)\n        return (a, b, c)\n\n    def dig2(self):\n        a = 1\n        b = -1\n        c = -self.x + self.y\n        return (a, b, c)\n\ndef intersect(p1, p2):\n    a1 = p1[0]\n    b1 = p1[1]\n    a2 = p2[0]\n    b2 = p2[1]\n    if b1 == 0 and b2 == 0:\n        return False\n    if b1 == 0 or b2 == 0:\n        return True\n    if a1 / b1 == a2 / b2:\n        return False\n    else:\n        return True\n\ndef intersectionpoint(l1, l2):\n    a1 = l1[0]\n    b1 = l1[1]\n    c1 = l1[2]\n    a2 = l2[0]\n    b2 = l2[1]\n    c2 = l2[2]\n    a1b2_minus_a2b1 = a1 * b2 - a2 * b1\n    x = (b1 * c2 - b2 * c1) / a1b2_minus_a2b1\n    y = (c1 * a2 - c2 * a1) / a1b2_minus_a2b1\n    if x == 0:\n        x = 0\n    if y == 0:\n        y = 0\n    return (x, y)\n\ndef update(dct, ip, p1, p2):\n    if dct.get(ip, 0) == 0:\n        dct[ip] = {(p1.x, p1.y), (p2.x, p2.y)}\n    else:\n        dct[ip].add((p1.x, p1.y))\n        dct[ip].add((p2.x, p2.y))\nt = int(input())\nfor q in range(t):\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    dct = dict()\n    for i in range(len(x)):\n        x1 = x[i]\n        y1 = y[i]\n        p1 = point(x1, y1)\n        if dct.get((p1.x, p1.y), 0) == 0:\n            dct[p1.x, p1.y] = {(p1.x, p1.y)}\n        for j in range(len(x)):\n            if i == j:\n                continue\n            x2 = x[j]\n            y2 = y[j]\n            p2 = point(x2, y2)\n            if intersect(p1.horizontal(), p2.vertical()):\n                ip = intersectionpoint(p1.horizontal(), p2.vertical())\n                update(dct, ip, p1, p2)\n            if intersect(p1.horizontal(), p2.dig1()):\n                ip = intersectionpoint(p1.horizontal(), p2.dig1())\n                update(dct, ip, p1, p2)\n            if intersect(p1.horizontal(), p2.dig2()):\n                ip = intersectionpoint(p1.horizontal(), p2.dig2())\n                update(dct, ip, p1, p2)\n            if intersect(p1.vertical(), p2.horizontal()):\n                ip = intersectionpoint(p1.vertical(), p2.horizontal())\n                update(dct, ip, p1, p2)\n            if intersect(p1.vertical(), p2.dig1()):\n                ip = intersectionpoint(p1.vertical(), p2.dig1())\n                update(dct, ip, p1, p2)\n            if intersect(p1.vertical(), p2.dig2()):\n                ip = intersectionpoint(p1.vertical(), p2.dig2())\n                update(dct, ip, p1, p2)\n            if intersect(p1.dig1(), p2.horizontal()):\n                ip = intersectionpoint(p1.dig1(), p2.horizontal())\n                update(dct, ip, p1, p2)\n            if intersect(p1.dig1(), p2.vertical()):\n                ip = intersectionpoint(p1.dig1(), p2.vertical())\n                update(dct, ip, p1, p2)\n            if intersect(p1.dig1(), p2.dig2()):\n                ip = intersectionpoint(p1.dig1(), p2.dig2())\n                update(dct, ip, p1, p2)\n            if intersect(p1.dig2(), p2.horizontal()):\n                ip = intersectionpoint(p1.dig2(), p2.horizontal())\n                update(dct, ip, p1, p2)\n            if intersect(p1.dig2(), p2.vertical()):\n                ip = intersectionpoint(p1.dig2(), p2.vertical())\n                update(dct, ip, p1, p2)\n            if intersect(p1.dig2(), p2.dig1()):\n                ip = intersectionpoint(p1.dig2(), p2.dig1())\n                update(dct, ip, p1, p2)\n    maximum = -1\n    maxkey = -1\n    for (k, v) in dct.items():\n        if len(v) == maximum:\n            if k in v:\n                maxkey = k\n        elif len(v) > maximum:\n            maximum = len(v)\n            maxkey = k\n    if maxkey in dct[maxkey]:\n        ans = len(dct[maxkey]) - 1 + (len(x) - len(dct[maxkey])) * 2\n    else:\n        ans = len(dct[maxkey]) + (len(x) - len(dct[maxkey])) * 2\n    print(ans)", "import collections\nfor _ in range(int(input())):\n    n = int(input())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n    res = 1000000000\n    for i in range(n):\n        moves = 0\n        for j in range(n):\n            x = abs(X[i] - X[j])\n            y = abs(Y[i] - Y[j])\n            if x == 0 and y == 0:\n                continue\n            if x == 0 or y == 0:\n                moves += 1\n                continue\n            if x == y:\n                moves += 1\n                continue\n            moves += 2\n        if moves < res:\n            res = moves\n    c1 = collections.Counter()\n    c2 = collections.Counter()\n    c3 = collections.Counter(Y)\n    c4 = collections.Counter(X)\n    P = {}\n    for i in range(n):\n        x = X[i]\n        y = Y[i]\n        c1.update([y - x])\n        c2.update([y + x])\n        P[str(x) + ',' + str(y)] = i\n    for i in c1:\n        for j in c2:\n            px = (j - i) / 2\n            py = (j + i) / 2\n            if P.get(str(int(px)) + ',' + str(int(py))) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n        for j in c3:\n            px = j - i\n            py = j\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n        for j in c4:\n            px = j\n            py = j + i\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n    for i in c2:\n        for j in c3:\n            px = i - j\n            py = j\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n        for j in c4:\n            px = j\n            py = i - j\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n    for i in c3:\n        for j in c4:\n            px = j\n            py = i\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n    print(res)", "import collections\nfor _ in range(int(input())):\n    n = int(input())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n    res = 1000000000\n    for i in range(n):\n        moves = 0\n        for j in range(n):\n            x = abs(X[i] - X[j])\n            y = abs(Y[i] - Y[j])\n            if x == 0 and y == 0:\n                continue\n            if x == 0 or y == 0:\n                moves += 1\n                continue\n            if x == y:\n                moves += 1\n                continue\n            moves += 2\n        if moves < res:\n            res = moves\n    c1 = collections.Counter()\n    c2 = collections.Counter()\n    c3 = collections.Counter(Y)\n    c4 = collections.Counter(X)\n    P = {}\n    for i in range(n):\n        x = X[i]\n        y = Y[i]\n        c1.update([y - x])\n        c2.update([y + x])\n        P[str(x) + ',' + str(y)] = i\n    for i in c1:\n        for j in c2:\n            px = (j - i) / 2\n            py = (j + i) / 2\n            if P.get(str(int(px)) + ',' + str(int(py))) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n        for j in c3:\n            px = j - i\n            py = j\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n        for j in c4:\n            px = j\n            py = j + i\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n    for i in c2:\n        for j in c3:\n            px = i - j\n            py = j\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n        for j in c4:\n            px = j\n            py = i - j\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n    for i in c3:\n        for j in c4:\n            px = j\n            py = i\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n    print(res)", "import collections\n\ndef pcount(px, py):\n    moves = 0\n    for i in range(n):\n        x = abs(px - X[i])\n        y = abs(py - Y[i])\n        if x == 0 and y == 0:\n            continue\n        if x == 0 or y == 0:\n            moves += 1\n            continue\n        if x == y:\n            moves += 1\n            continue\n        moves += 2\n    return moves\nfor _ in range(int(input())):\n    n = int(input())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n    res = 1000000000\n    for i in range(n):\n        moves = 0\n        for j in range(n):\n            x = abs(X[i] - X[j])\n            y = abs(Y[i] - Y[j])\n            if x == 0 and y == 0:\n                continue\n            if x == 0 or y == 0:\n                moves += 1\n                continue\n            if x == y:\n                moves += 1\n                continue\n            moves += 2\n        if moves < res:\n            res = moves\n    c1 = collections.Counter()\n    c2 = collections.Counter()\n    c3 = collections.Counter(Y)\n    c4 = collections.Counter(X)\n    P = {}\n    s = set()\n    for i in range(n):\n        x = X[i]\n        y = Y[i]\n        c1.update([y - x])\n        c2.update([y + x])\n        P[str(x) + ',' + str(y)] = i\n    for i in c1:\n        for j in c2:\n            px = (j - i) / 2\n            py = (j + i) / 2\n            if P.get(str(int(px)) + ',' + str(int(py))) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n        for j in c3:\n            px = j - i\n            py = j\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n        for j in c4:\n            px = j\n            py = j + i\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n    for i in c2:\n        for j in c3:\n            px = i - j\n            py = j\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n        for j in c4:\n            px = j\n            py = i - j\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n    for i in c3:\n        for j in c4:\n            px = j\n            py = i\n            if P.get(str(px) + ',' + str(py)) != None:\n                continue\n            moves = 2 * n\n            moves -= c1[py - px] + c2[py + px] + c3[py] + c4[px]\n            if moves < res:\n                res = moves\n    print(res)", "from collections import defaultdict\nt = int(input())\nwhile t != 0:\n    n = int(input())\n    a = input().split()\n    b = input().split()\n    points = []\n    for i in range(n):\n        a[i] = float(a[i])\n        b[i] = float(b[i])\n        points.append([a[i], b[i]])\n    mapa = defaultdict(int)\n    cross = defaultdict(list)\n    cols = defaultdict(int)\n    rows = defaultdict(int)\n    crosslines = defaultdict(int)\n    for i in range(n):\n        rows[a[i]] += 1\n        cols[b[i]] += 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j] or b[i] == b[j] or a[j] - a[i] == b[j] - b[i] or (a[j] - a[i] == -(b[j] - b[i])):\n                mapa[a[i], b[i]] += 1\n                mapa[a[j], b[j]] += 1\n            crossx1 = (a[i] + a[j] + b[i] - b[j]) / 2\n            crossy1 = (a[i] - a[j] + b[i] + b[j]) / 2\n            if [crossx1, crossy1] not in points:\n                if (a[i], b[i]) not in cross[crossx1, crossy1]:\n                    cross[crossx1, crossy1].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx1, crossy1]:\n                    cross[crossx1, crossy1].append((a[j], b[j]))\n            crossx2 = (a[i] + a[j] - b[i] + b[j]) / 2\n            crossy2 = (a[j] - a[i] + b[i] + b[j]) / 2\n            if [crossx2, crossy2] not in points:\n                if (a[i], b[i]) not in cross[crossx2, crossy2]:\n                    cross[crossx2, crossy2].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx2, crossy2]:\n                    cross[crossx2, crossy2].append((a[j], b[j]))\n            crossx3 = a[i]\n            crossy3 = b[j]\n            if [crossx3, crossy3] not in points:\n                if (a[i], b[i]) not in cross[crossx3, crossy3]:\n                    cross[crossx3, crossy3].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx3, crossy3]:\n                    cross[crossx3, crossy3].append((a[j], b[j]))\n            crossx4 = a[j]\n            crossy4 = b[i]\n            if [crossx4, crossy4] not in points:\n                if (a[i], b[i]) not in cross[crossx4, crossy4]:\n                    cross[crossx4, crossy4].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx4, crossy4]:\n                    cross[crossx4, crossy4].append((a[j], b[j]))\n            crossx5 = a[j]\n            crossy5 = a[j] - a[i] + b[i]\n            if [crossx5, crossy5] not in points:\n                if (a[i], b[i]) not in cross[crossx5, crossy5]:\n                    cross[crossx5, crossy5].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx5, crossy5]:\n                    cross[crossx5, crossy5].append((a[j], b[j]))\n            crossx6 = a[j]\n            crossy6 = a[i] - a[j] + b[i]\n            if [crossx6, crossy6] not in points:\n                if (a[i], b[i]) not in cross[crossx6, crossy6]:\n                    cross[crossx6, crossy6].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx6, crossy6]:\n                    cross[crossx6, crossy6].append((a[j], b[j]))\n            crossx7 = b[j] - b[i] + a[i]\n            crossy7 = b[j]\n            if [crossx7, crossy7] not in points:\n                if (a[i], b[i]) not in cross[crossx7, crossy7]:\n                    cross[crossx7, crossy7].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx7, crossy7]:\n                    cross[crossx7, crossy7].append((a[j], b[j]))\n            crossx8 = a[i] - b[j] + b[i]\n            crossy8 = b[j]\n            if [crossx8, crossy8] not in points:\n                if (a[i], b[i]) not in cross[crossx8, crossy8]:\n                    cross[crossx8, crossy8].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx8, crossy8]:\n                    cross[crossx8, crossy8].append((a[j], b[j]))\n            crossx9 = a[i]\n            crossy9 = a[i] - a[j] + b[j]\n            if [crossx9, crossy9] not in points:\n                if (a[i], b[i]) not in cross[crossx9, crossy9]:\n                    cross[crossx9, crossy9].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx9, crossy9]:\n                    cross[crossx9, crossy9].append((a[j], b[j]))\n            crossx10 = a[i]\n            crossy10 = a[j] - a[i] + b[j]\n            if [crossx10, crossy10] not in points:\n                if (a[i], b[i]) not in cross[crossx10, crossy10]:\n                    cross[crossx10, crossy10].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx10, crossy10]:\n                    cross[crossx10, crossy10].append((a[j], b[j]))\n            crossx11 = b[i] - b[j] + a[j]\n            crossy11 = b[i]\n            if [crossx11, crossy11] not in points:\n                if (a[i], b[i]) not in cross[crossx11, crossy11]:\n                    cross[crossx11, crossy11].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx11, crossy11]:\n                    cross[crossx11, crossy11].append((a[j], b[j]))\n            crossx12 = a[j] - b[i] + b[j]\n            crossy12 = b[i]\n            if [crossx12, crossy12] not in points:\n                if (a[i], b[i]) not in cross[crossx12, crossy12]:\n                    cross[crossx12, crossy12].append((a[i], b[i]))\n                if (a[j], b[j]) not in cross[crossx12, crossy12]:\n                    cross[crossx12, crossy12].append((a[j], b[j]))\n    maxi1 = 0\n    for key in mapa:\n        if mapa[key] > maxi1:\n            maxi1 = mapa[key]\n    result1 = maxi1 + 2 * (n - 1 - maxi1)\n    maxi2 = 0\n    for key in cross:\n        aux = len(cross[key]) + crosslines[key]\n        if aux > maxi2:\n            maxi2 = aux\n    result2 = maxi2 + 2 * (n - maxi2)\n    print(min(result1, result2))\n    t = t - 1", "from collections import defaultdict\ntestcases = int(input())\nfor t in range(testcases):\n    N = int(input())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n    min_opr = int(1000)\n    ONX = []\n    ONY = []\n    for p in range(N):\n        count_opr = int(0)\n        for q in range(N):\n            if q > p:\n                ONX.append((X[p] + X[q] - Y[p] + Y[q]) / 2)\n                ONX.append(X[q])\n                ONX.append(X[p] - Y[p] + Y[q])\n                ONX.append((X[p] + X[q] + Y[p] - Y[q]) / 2)\n                ONX.append(X[q])\n                ONX.append(X[p] + Y[p] - Y[q])\n                ONX.append(X[p])\n                ONX.append(X[p])\n                ONX.append(X[p])\n                ONX.append(X[q] - Y[q] + Y[p])\n                ONX.append(X[q] + Y[q] - Y[p])\n                ONX.append(X[q])\n                ONY.append((X[q] - X[p] + Y[p] + Y[q]) / 2)\n                ONY.append(X[q] - X[p] + Y[p])\n                ONY.append(Y[q])\n                ONY.append((X[p] - X[q] + Y[p] + Y[q]) / 2)\n                ONY.append(X[p] - X[q] + Y[p])\n                ONY.append(Y[q])\n                ONY.append(X[p] - X[q] + Y[q])\n                ONY.append(X[q] - X[p] + Y[q])\n                ONY.append(Y[q])\n                ONY.append(Y[p])\n                ONY.append(Y[p])\n                ONY.append(Y[p])\n            if p != q:\n                if abs(X[p] - X[q]) == abs(Y[p] - Y[q]) or X[p] - X[q] == 0 or Y[p] - Y[q] == 0:\n                    count_opr += 1\n                else:\n                    count_opr += 2\n        if count_opr == N - 1:\n            min_opr = count_opr\n            break\n        elif min_opr > count_opr:\n            min_opr = count_opr\n    frequencyXY = defaultdict(dict)\n    for i in range(0, len(ONX), 12):\n        for j in range(i, i + 12):\n            if ONX[j] in frequencyXY.keys():\n                if ONY[j] in frequencyXY[ONX[j]].keys():\n                    if frequencyXY[ONX[j]][ONY[j]][1] < i:\n                        frequencyXY[ONX[j]][ONY[j]][0] += 1\n                        frequencyXY[ONX[j]][ONY[j]][1] = i\n                else:\n                    frequencyXY[ONX[j]][ONY[j]] = [1, i]\n            else:\n                frequencyXY[ONX[j]][ONY[j]] = [1, i]\n    if min_opr > N:\n        for k1 in frequencyXY.keys():\n            for k2 in frequencyXY[k1].keys():\n                count_opr = int(0)\n                if frequencyXY[k1][k2][0] > 2 * N - min_opr - 1:\n                    for s in range(N):\n                        if abs(k1 - X[s]) == abs(k2 - Y[s]) or k1 - X[s] == 0 or k2 - Y[s] == 0:\n                            count_opr += 1\n                        else:\n                            count_opr += 2\n                    if count_opr == N:\n                        min_opr = count_opr\n                        break\n                    elif min_opr > count_opr:\n                        min_opr = count_opr\n            if min_opr == N:\n                break\n    print(min_opr)", "def getop(x, y, xl, yl, n):\n    o = 0\n    for j in range(n):\n        xd = abs(x - xl[j])\n        yd = abs(y - yl[j])\n        if xd == 0 and yd == 0:\n            continue\n        if xd == 0 or yd == 0:\n            o += 1\n        elif xd == yd:\n            o += 1\n        else:\n            o += 2\n    return o\nt = int(input())\nfor tc in range(t):\n    n = int(input())\n    xl = list(map(int, input().split()))\n    yl = list(map(int, input().split()))\n    mo = 2 * (n - 1)\n    if n > 50:\n        for i in range(n):\n            x = xl[i]\n            y = yl[i]\n            mo = min(mo, getop(x, y, xl, yl, n))\n            x = xl[i]\n            y = xl[i]\n            mo = min(mo, getop(x, y, xl, yl, n))\n            x = yl[i]\n            y = yl[i]\n            mo = min(mo, getop(x, y, xl, yl, n))\n            x = yl[i]\n            y = xl[i]\n            mo = min(mo, getop(x, y, xl, yl, n))\n            for j in range(n):\n                x = xl[i]\n                y = yl[j]\n                mo = min(mo, getop(x, y, xl, yl, n))\n                x = xl[j]\n                y = yl[i]\n                mo = min(mo, getop(x, y, xl, yl, n))\n        print(mo)\n    else:\n        for i in range(n):\n            for j in range(n):\n                x = (xl[i] + xl[j]) // 2\n                y = (yl[i] + yl[j]) // 2\n                mo = min(mo, getop(x, y, xl, yl, n))\n                x = xl[i]\n                y = yl[j]\n                mo = min(mo, getop(x, y, xl, yl, n))\n                c1 = xl[i] + yl[i]\n                c2 = xl[j] - yl[j]\n                x = (c1 + c2) / 2\n                y = (c1 - c2) / 2\n                mo = min(mo, getop(x, y, xl, yl, n))\n                c3 = xl[i] + yl[i]\n                x = xl[j]\n                y = c3 - x\n                mo = min(mo, getop(x, y, xl, yl, n))\n                c4 = xl[i] + yl[i]\n                y = yl[j]\n                x = c4 - y\n                mo = min(mo, getop(x, y, xl, yl, n))\n                c5 = xl[i] - yl[i]\n                x = xl[j]\n                y = x - c5\n                mo = min(mo, getop(x, y, xl, yl, n))\n                c6 = xl[i] - yl[i]\n                y = yl[j]\n                x = c6 + y\n                mo = min(mo, getop(x, y, xl, yl, n))\n        print(mo)", "def this_is_a_new_point(x, y, Ps):\n    return (x, y) not in Ps\n\ndef check_point(x, y, Xs, Ys, Ls, Rs, n):\n    found = Xs.get(x, 0) + Ys.get(y, 0) + Ls.get(x - y, 0) + Rs.get(x + y, 0)\n    total = found + 2 * (n - found)\n    return total\nfor _ in range(int(input())):\n    n = int(input())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n    Xs = {}\n    Ys = {}\n    Ls = {}\n    Rs = {}\n    (L, R) = ([], [])\n    Ps = set()\n    for i in range(n):\n        (x, y) = (X[i], Y[i])\n        Ps.add((x, y))\n        Xs[x] = Xs.get(x, 0) + 1\n        Ys[y] = Ys.get(y, 0) + 1\n        (l, r) = (x - y, x + y)\n        L.append(l)\n        R.append(r)\n        Ls[l] = Ls.get(l, 0) + 1\n        Rs[r] = Rs.get(r, 0) + 1\n    best = None\n    for i in range(n):\n        found = Xs[X[i]] + Ys[Y[i]] + Ls[L[i]] + Rs[R[i]] - 4\n        total = found + 2 * (n - 1 - found)\n        if best is None or total < best:\n            best = total\n    for i in range(n - 1):\n        x1 = X[i]\n        y1 = Y[i]\n        for j in range(i + 1, n):\n            x2 = X[j]\n            y2 = Y[j]\n            sx = x1 + x2\n            sy = y1 + y2\n            dx = x2 - x1\n            dy = y2 - y1\n            new_possible_points = [(x1, y2), (x1, y2 - dx), (x1, y2 + dx), (x2, y1), (x2 - dy, y1), (x2 + dy, y1), (x2, y1 - dx), (x2, y1 + dx), (x1 + dy, y2), (x1 - dy, y2), ((sx - dy) / 2, (sy - dx) / 2), ((sx + dy) / 2, (sy + dx) / 2)]\n            for (x, y) in new_possible_points:\n                if this_is_a_new_point(x, y, Ps):\n                    best = min(best, check_point(x, y, Xs, Ys, Ls, Rs, n))\n                    Ps.add((x, y))\n    print(best)", "import numpy as np\ntry:\n\n    class Solution:\n\n        def Final(self, p1, p2, X, Y, N):\n            ans = 0\n            for i in range(N):\n                x = p1 - X[i]\n                y = p2 - Y[i]\n                if x == 0 and y == 0:\n                    continue\n                if x == 0 or y == 0:\n                    ans += 1\n                elif abs(x) == abs(y):\n                    ans += 1\n                else:\n                    ans += 2\n            return ans\n    for t in range(int(input())):\n        N = int(input())\n        X = list(map(int, input().split()))\n        Y = list(map(int, input().split()))\n        obj = Solution()\n        ANS = float('inf')\n        for i in range(N):\n            for j in range(N):\n                if N > 50:\n                    if i == j:\n                        break\n                if i != j:\n                    p1 = X[i]\n                    p2 = Y[j]\n                    ANS = min(ANS, obj.Final(p1, p2, X, Y, N))\n                    temp1 = X[i] + Y[i]\n                    temp2 = X[j] - Y[j]\n                    temp3 = X[i] - Y[i]\n                    p1 = (temp1 + temp2) / 2\n                    p2 = (temp1 - temp2) / 2\n                    ANS = min(ANS, obj.Final(p1, p2, X, Y, N))\n                    p1 = temp1 - Y[j]\n                    p2 = Y[j]\n                    ANS = min(ANS, obj.Final(p1, p2, X, Y, N))\n                    p1 = temp3 + Y[j]\n                    p2 = Y[j]\n                    ANS = min(ANS, obj.Final(p1, p2, X, Y, N))\n        print(ANS)\nexcept EOFError as e:\n    print(e)", "from collections import Counter\nN = int(input())\nfor _ in range(N):\n    n = int(input())\n    coords = set(zip(map(int, input().split()), map(int, input().split())))\n    xs = Counter()\n    ys = Counter()\n    xy = Counter()\n    yx = Counter()\n    for (x, y) in coords:\n        xs[x] += 1\n        ys[y] += 1\n        xy[x + y] += 1\n        yx[y - x] += 1\n    lines = []\n    for i in xs:\n        lines.append(('xs', i))\n    for i in ys:\n        lines.append(('ys', i))\n    for i in xy:\n        lines.append(('xy', i))\n    for i in yx:\n        lines.append(('yx', i))\n    best_o = float('inf')\n    for (x, y) in coords:\n        singles = xs[x] + ys[y] + xy[x + y] + yx[y - x] - 4\n        doubles = n - singles - 1\n        ops = singles + doubles * 2\n        best_o = min(best_o, ops)\n    for i in range(len(lines)):\n        for j in range(i + 1, len(lines)):\n            (l_a, l_b) = sorted((lines[i], lines[j]))\n            (lt_a, lv_a) = l_a\n            (lt_b, lv_b) = l_b\n            if lt_a == lt_b:\n                continue\n            x = None\n            y = None\n            x_y = None\n            y_x = None\n            if (lt_a, lt_b) == ('xs', 'xy'):\n                x = lv_a\n                x_y = lv_b\n                y = x_y - x\n                y_x = y - x\n            elif (lt_a, lt_b) == ('xs', 'ys'):\n                x = lv_a\n                y = lv_b\n                x_y = x + y\n                y_x = y - x\n            elif (lt_a, lt_b) == ('xs', 'yx'):\n                x = lv_a\n                y_x = lv_b\n                y = x + y_x\n                x_y = x + y\n            elif (lt_a, lt_b) == ('xy', 'ys'):\n                x_y = lv_a\n                y = lv_b\n                x = x_y - y\n                y_x = y - x\n            elif (lt_a, lt_b) == ('xy', 'yx'):\n                x_y = lv_a\n                y_x = lv_b\n                if (x_y + y_x) % 2 == 0:\n                    y = int((x_y + y_x) / 2)\n                if (y_x - x_y) % 2 == 0:\n                    x = int((x_y - y_x) / 2)\n            elif (lt_a, lt_b) == ('ys', 'yx'):\n                y = lv_a\n                y_x = lv_b\n                x = y - y_x\n                x_y = x + y\n            else:\n                raise Exception(lt_a + ',' + lt_b)\n            if (x, y) in coords:\n                continue\n            singles = xs[x] + ys[y] + xy[x_y] + yx[y_x]\n            doubles = n - singles\n            ops = singles + doubles * 2\n            best_o = min(best_o, ops)\n    print(best_o)", "from collections import Counter\nfor _ in range(int(input())):\n    n = int(input())\n    xs = list(map(int, input().split()))\n    ys = list(map(int, input().split()))\n    (ver, hor, dg1, dg2) = (Counter() for _ in range(4))\n    for (x, y) in zip(xs, ys):\n        ver[x] += 1\n        hor[y] += 1\n        dg1[x + y] += 1\n        dg2[x - y] += 1\n    hashed = {(x, y) for (x, y) in zip(xs, ys)}\n    ops = [[ver, hor, lambda u, v: (u, v)], [ver, dg1, lambda u, v: (u, v - u)], [ver, dg2, lambda u, v: (u, u - v)], [hor, dg1, lambda u, v: (v - u, u)], [hor, dg2, lambda u, v: (u + v, u)], [dg1, dg2, lambda u, v: ((u + v) // 2, (u - v) // 2) if (u + v) % 2 == 0 else 0]]\n    (millor, fets) = (2 * (n - 1), {0})\n    for (primer, segon, op) in ops:\n        for u in primer:\n            for v in segon:\n                tp = op(u, v)\n                if tp in fets:\n                    continue\n                fets.add(tp)\n                (x, y) = tp\n                zero = tp in hashed\n                if zero:\n                    uns = ver[x] + hor[y] + dg1[x + y] + dg2[x - y] - 4\n                else:\n                    uns = 0\n                    if x in ver:\n                        uns += ver[x]\n                    if y in hor:\n                        uns += hor[y]\n                    if x + y in dg1:\n                        uns += dg1[x + y]\n                    if x - y in dg2:\n                        uns += dg2[x - y]\n                dos = n - zero - uns\n                value = uns + 2 * dos\n                millor = min(millor, value)\n    for u in dg1:\n        for v in dg2:\n            if (u + v) % 2 == 1:\n                uns = dg1[u] + dg2[v]\n                dos = n - uns\n                value = uns + 2 * dos\n                millor = min(millor, value)\n    print(millor)", "from sys import stdin, stdout\n\ndef check(h, k, x, y, n):\n    s = 0\n    for j in range(0, n):\n        xx = h - x[j]\n        yy = k - y[j]\n        if xx == 0 and yy == 0:\n            m = 0\n        elif xx == 0 and yy != 0 or (xx != 0 and yy == 0):\n            s = s + 1\n        elif xx == yy or xx == -1 * yy:\n            s = s + 1\n        else:\n            s = s + 2\n    return s\nt = int(stdin.readline())\nfor j in range(0, t):\n    n = int(stdin.readline())\n    x = list(map(int, stdin.readline().split()))\n    y = list(map(int, stdin.readline().split()))\n    ms = 1000000000\n    for i in range(0, n):\n        for l in range(i, n):\n            h = (x[i] + x[l]) / 2\n            k = (y[i] + y[l]) / 2\n            ms = min(ms, check(h, k, x, y, n))\n            h = x[i]\n            k = y[l]\n            ms = min(ms, check(h, k, x, y, n))\n            c1 = x[i] + y[i]\n            c2 = x[l] - y[l]\n            h = (c1 + c2) / 2\n            k = (c1 - c2) / 2\n            ms = min(ms, check(h, k, x, y, n))\n            c3 = x[i] + y[i]\n            h = x[l]\n            k = c3 - h\n            ms = min(ms, check(h, k, x, y, n))\n            c4 = x[i] + y[i]\n            k = y[l]\n            h = c4 - k\n            ms = min(ms, check(h, k, x, y, n))\n            c5 = x[i] - y[i]\n            h = x[l]\n            k = h - c5\n            ms = min(ms, check(h, k, x, y, n))\n            c6 = x[i] - y[i]\n            k = y[l]\n            h = c6 + k\n            ms = min(ms, check(h, k, x, y, n))\n    print(ms)", "def point_intersection(i, j, a, c):\n    if i == 0:\n        if j == 1:\n            y = (a + c) / 2\n            x = y - c\n        elif j == 2:\n            x = c\n            y = -x + a\n        elif j == 3:\n            y = c\n            x = -y + a\n    elif i == 1:\n        if j == 2:\n            x = c\n            y = x + a\n        elif j == 3:\n            y = c\n            x = y - a\n    elif i == 2:\n        if j == 3:\n            x = a\n            y = c\n    return (x, y)\nfor _ in range(int(input())):\n    N = int(input())\n    X = list(map(int, input().split()))\n    Y = list(map(int, input().split()))\n    ans = 2 * N - 2\n    point_lookup = {(X[i], Y[i]): i for i in range(N)}\n    (GS, GD, GX, GY) = ({}, {}, {}, {})\n    for i in range(N):\n        (x, y) = (X[i], Y[i])\n        if not x + y in GS:\n            GS[x + y] = set()\n        if not y - x in GD:\n            GD[y - x] = set()\n        if not x in GX:\n            GX[x] = set()\n        if not y in GY:\n            GY[y] = set()\n        GS[x + y].add(i)\n        GD[y - x].add(i)\n        GX[x].add(i)\n        GY[y].add(i)\n    G = [GS, GD, GX, GY]\n    all_intersections = {}\n    for i in range(3):\n        for j in range(i + 1, 4):\n            for (a, b) in G[i].items():\n                for (c, d) in G[j].items():\n                    (px, py) = point_intersection(i, j, a, c)\n                    if not (px, py) in all_intersections:\n                        all_intersections[px, py] = set()\n                    all_intersections[px, py] = set.union(all_intersections[px, py], b, d)\n    for (px, py) in all_intersections:\n        points = all_intersections[px, py]\n        op = 2 * (N - len(points)) + len(points)\n        if (px, py) in point_lookup:\n            op -= 1\n        ans = min(op, ans)\n    print(ans)", "from collections import defaultdict\nfrom itertools import product\n\ndef f(l1, l2):\n    (a1, b1, c1) = l1\n    (a2, b2, c2) = l2\n    det = a1 * b2 - a2 * b1\n    det1 = c1 * b2 - c2 * b1\n    det2 = a1 * c2 - a2 * c1\n    return (det1 / det, det2 / det)\n\ndef f1(l, s):\n    if len(l) == 4:\n        l = l[:3]\n    elif len(l) == 7:\n        l = l[:4]\n    return sum(l) - s\nfor t in range(int(input())):\n    n = int(input())\n    (d1, d2, d3, d4) = (defaultdict(set), defaultdict(set), defaultdict(set), defaultdict(set))\n    for (x, y) in zip(map(float, input().split()), map(float, input().split())):\n        d1[1, 0, x].add((x, y))\n        d2[0, 1, y].add((x, y))\n        d3[-1, 1, y - x].add((x, y))\n        d4[1, 1, x + y].add((x, y))\n    d = {}\n    for (dct1, dct2) in ((d1, d2), (d1, d3), (d1, d4), (d2, d3), (d2, d4), (d3, d4)):\n        for (l1, l2) in product(dct1, dct2):\n            intersec = f(l1, l2)\n            if intersec in d:\n                d[intersec][0].append(len(dct2[l2]))\n                if intersec in dct2[l2]:\n                    d[intersec][1] = 2\n            else:\n                d[intersec] = [[len(dct1[l1]), len(dct2[l2])], 2 * (intersec in dct2[l2])]\n    print(2 * n - max((f1(*el) for el in d.values())))", "def update_cnt(m, key):\n    val = 0\n    if key in m.keys():\n        val = m[key]\n    m[key] = val + 1\n    return m\nt = int(input())\nwhile t > 0:\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    ans = 1000000\n    for i in range(n):\n        st2 = 0\n        st3 = 0\n        hor = 0\n        ver = 0\n        mx = {}\n        my = {}\n        mpos = {}\n        mneg = {}\n        mpos[x[i], y[i]] = 1\n        mneg[x[i], y[i]] = 1\n        mx[x[i], y[i]] = 1\n        my[x[i], y[i]] = 1\n        for j in range(n):\n            if i == j:\n                continue\n            if x[j] + y[i] - x[i] != y[j]:\n                st2 += 1\n                c1 = y[i] - x[i]\n                c2 = y[j] + x[j]\n                inx = (c2 - c1) / 2\n                iny = (c1 + c2) / 2\n                mpos = update_cnt(mpos, (inx, iny))\n                mpos = update_cnt(mpos, (x[j], x[j] + c1))\n                mpos = update_cnt(mpos, (y[j] - c1, y[j]))\n            else:\n                mpos = update_cnt(mpos, (x[j], y[j]))\n            if y[i] + x[i] - x[j] != y[j]:\n                st3 += 1\n                c1_ = y[i] + x[i]\n                c2_ = y[j] - x[j]\n                inx_ = (c1_ - c2_) / 2\n                iny_ = (c1_ + c2_) / 2\n                mneg = update_cnt(mneg, (inx_, iny_))\n                mneg = update_cnt(mneg, (x[j], c1_ - x[j]))\n                mneg = update_cnt(mneg, (c1_ - y[j], y[j]))\n            else:\n                mneg = update_cnt(mneg, (x[j], y[j]))\n            if x[i] != x[j]:\n                ver += 1\n                my = update_cnt(my, (x[i], y[j]))\n            else:\n                my = update_cnt(my, (x[j], y[j]))\n            if y[i] != y[j]:\n                hor += 1\n                mx = update_cnt(mx, (x[j], y[i]))\n            else:\n                mx = update_cnt(mx, (x[j], y[j]))\n        st2 += n - max(mpos.values())\n        st3 += n - max(mneg.values())\n        hor += n - max(mx.values())\n        ver += n - max(my.values())\n        ans = min([ans, st2, st3, hor, ver])\n    print(ans)\n    t = t - 1", "from sys import stdin\ninp = stdin.readline\nt = int(inp())\nfor _ in range(t):\n    n = int(inp())\n    arrx = [int(x) for x in inp().split()]\n    arry = [int(x) for x in inp().split()]\n    (d1, d2, d3, d4) = (dict(), dict(), dict(), dict())\n    for (x, y) in zip(arrx, arry):\n        d1[x] = d1.get(x, 0) + 1\n        d2[y] = d2.get(y, 0) + 1\n        d3[y - x] = d3.get(y - x, 0) + 1\n        d4[y + x] = d4.get(y + x, 0) + 1\n    m = 0\n    for (x, y) in zip(arrx, arry):\n        m = max(m, d1[x] + d2[y] + d3[y - x] + d4[y + x] - 4)\n    (l1, l2, l3, l4) = (max(d1.values()), max(d2.values()), max(d3.values()), max(d4.values()))\n    m2 = max(l1 + l2, l1 + l3, l1 + l4, l2 + l3, l2 + l4, l3 + l4)\n    m3 = 0\n    for x in d1:\n        for y in d2:\n            if d3.get(y - x, 0) and (not (x, y) in zip(arrx, arry)):\n                if d4.get(x + y, 0):\n                    m3 = max(m3, d1[x] + d2[y] + d3[y - x] + d4[x + y])\n                else:\n                    m3 = max(m3, d1[x] + d2[y] + d3[y - x])\n            elif d4.get(x + y, 0) and (not (x, y) in zip(arrx, arry)):\n                m3 = max(m3, d1[x] + d2[y] + d4[x + y])\n        for z in d3:\n            y = z + x\n            if d4.get(x + y, 0) and (not d2.get(y, 0)) and (not (x, y) in zip(arrx, arry)):\n                m3 = max(m3, d1[x] + d3[z] + d4[x + y])\n    for y in d2:\n        for z in d3:\n            x = y - z\n            if d4.get(x + y, 0) and (not d1.get(x, 0)) and (not (x, y) in zip(arrx, arry)):\n                m3 = max(m3, d2[y] + d3[z] + d4[x + y])\n    print(min((n - 1) * 2 - m, n * 2 - m2, n * 2 - m3))", "def inter(x1, y1, x2, y2, x3, y3, x4, y4):\n    a1 = y2 - y1\n    b1 = x1 - x2\n    c1 = a1 * x1 + b1 * y1\n    a2 = y4 - y3\n    b2 = x3 - x4\n    c2 = a2 * x3 + b2 * y3\n    det = a1 * b2 - a2 * b1\n    if det == 0:\n        return ()\n    x = (b2 * c1 - b1 * c2) / det\n    y = (a1 * c2 - a2 * c1) / det\n    return (x, y)\n\ndef onPoint(x, y):\n    return [(x, 0), (0, y), (x + 1, y + 1), (x - 1, y + 1)]\n\ndef maxOfDict(ans):\n    v = 0\n    k = []\n    for i in ans:\n        if ans[i] > v:\n            k = [i]\n            v = ans[i]\n        elif ans[i] == v:\n            k.append(i)\n    return k\n\ndef allPoints(x, y, n):\n    ans = {}\n    for key in range(n - 1):\n        (cx, cy) = (x[key], y[key])\n        diff = cx - cy\n        add = cx + cy\n        cxp = onPoint(cx, cy)\n        for i in range(key + 1, n):\n            if y[i] == cy or x[i] == cx or diff == x[i] - y[i] or (add == x[i] + y[i]):\n                continue\n            else:\n                other = onPoint(x[i], y[i])\n                for p in cxp:\n                    for q in other:\n                        it = inter(cx, cy, p[0], p[1], x[i], y[i], q[0], q[1])\n                        if len(it) == 2:\n                            ans[it] = ans.get(it, 0) + 1\n    return maxOfDict(ans)\nt = int(input())\nwhile t:\n    t -= 1\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    ans = 10000\n    points = allPoints(x, y, n)\n    for j in range(len(points)):\n        if j == n:\n            break\n        it = points[j]\n        (cx, cy) = (it[0], it[1])\n        diff = cx - cy\n        add = cx + cy\n        move = 0\n        for i in range(n):\n            if x[i] == cx and y[i] == cy:\n                continue\n            elif y[i] == cy or x[i] == cx or diff == x[i] - y[i] or (add == x[i] + y[i]):\n                move += 1\n            else:\n                move += 2\n        ans = min(ans, move)\n    for key in range(n):\n        (cx, cy) = (x[key], y[key])\n        move = 0\n        diff = cx - cy\n        add = cx + cy\n        for i in range(n):\n            if x[i] == cx and y[i] == cy:\n                continue\n            elif y[i] == cy or x[i] == cx or diff == x[i] - y[i] or (add == x[i] + y[i]):\n                move += 1\n            else:\n                move += 2\n        ans = min(ans, move)\n    print(ans)", "t = int(input())\n\ndef intersection(L1, L2):\n    D = L1[0] * L2[1] - L1[1] * L2[0]\n    Dx = L1[2] * L2[1] - L1[1] * L2[2]\n    Dy = L1[0] * L2[2] - L1[2] * L2[0]\n    if D != 0:\n        x = Dx / D\n        y = Dy / D\n        return (x, y)\n    else:\n        return None\nfor _ in range(t):\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    points = {(x[i], y[i]) for i in range(n)}\n    lines = {}\n    for i in range(n):\n        lines[1, 0, x[i]] = 0\n        lines[0, 1, y[i]] = 0\n        lines[1, -1, x[i] - y[i]] = 0\n        lines[1, 1, x[i] + y[i]] = 0\n    for i in range(n):\n        for l in lines:\n            if l[0] * x[i] + l[1] * y[i] == l[2]:\n                lines[l] += 1\n    ans = 2 * n\n    lines_list = list(lines.keys())\n    intersection_points = {}\n    for i in range(len(lines_list)):\n        for j in range(i):\n            l1 = lines_list[i]\n            l2 = lines_list[j]\n            intersect = intersection(l1, l2)\n            if intersect is not None:\n                (a, b) = (int(intersect[0]), int(intersect[1]))\n                if l1[0] * a + l1[1] * b == l1[2] and l2[0] * a + l2[1] * b == l2[2]:\n                    intersect = (a, b)\n                if intersect not in intersection_points:\n                    intersection_points[intersect] = {l1, l2}\n                else:\n                    intersection_points[intersect].add(l1)\n                    intersection_points[intersect].add(l2)\n            else:\n                curr = max(lines[l1], lines[l2])\n                curr += (n - curr) * 2 - 1\n                ans = min(curr, ans)\n    for (key, value) in intersection_points.items():\n        curr = 0\n        intersect_in_p = False\n        if key in points:\n            intersect_in_p = True\n        for l in value:\n            curr += lines[l] - intersect_in_p\n        curr += (n - curr - intersect_in_p) * 2\n        ans = min(curr, ans)\n    print(ans)", "from collections import defaultdict\nfor tcase in range(int(input())):\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    linex = defaultdict(list)\n    liney = defaultdict(list)\n    lines = defaultdict(list)\n    lined = defaultdict(list)\n    for i in range(n):\n        (xi, yi) = (x[i], y[i])\n        linex[xi].append(i)\n        liney[yi].append(i)\n        lines[xi + yi].append(i)\n        lined[xi - yi].append(i)\n    points = set(((x[i], y[i]) for i in range(n)))\n    isec = set()\n    for i in range(n):\n        (xi, yi) = (x[i], y[i])\n        (si, di) = (xi + yi, xi - yi)\n        for j in range(n):\n            (xj, yj) = (x[j], y[j])\n            (sj, dj) = (xj + yj, xj - yj)\n            isec.add((xi, yj))\n            if i != j:\n                isec.add((xi, sj - xi))\n                isec.add((xi, xi - dj))\n                isec.add((xj, yi))\n                isec.add((sj - yi, yi))\n                isec.add((dj + yi, yi))\n                isec.add((xj, si - xj))\n                isec.add((si - yj, yj))\n                isec.add(((si + dj) / 2, (si - dj) / 2))\n                isec.add((xj, xj - di))\n                isec.add((di + yj, yj))\n                isec.add(((sj + di) / 2, (sj - di) / 2))\n    result = []\n    for (xi, yi) in isec:\n        r = 2 * n - len(linex[xi]) - len(liney[yi]) - len(lines[xi + yi]) - len(lined[xi - yi])\n        if (xi, yi) in points:\n            r += 2\n        result.append(r)\n    print(min(result))", "from collections import defaultdict\nfor tcase in range(int(input())):\n    n = int(input())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n    linex = defaultdict(list)\n    liney = defaultdict(list)\n    lines = defaultdict(list)\n    lined = defaultdict(list)\n    for i in range(n):\n        (xi, yi) = (x[i], y[i])\n        linex[xi].append(i)\n        liney[yi].append(i)\n        lines[xi + yi].append(i)\n        lined[xi - yi].append(i)\n    points = set(((x[i], y[i]) for i in range(n)))\n    isec = set()\n    for i in range(n):\n        (xi, yi) = (x[i], y[i])\n        (si, di) = (xi + yi, xi - yi)\n        for j in range(n):\n            (xj, yj) = (x[j], y[j])\n            (sj, dj) = (xj + yj, xj - yj)\n            isec.add((xi, yj))\n            if i != j:\n                isec.add((xi, sj - xi))\n                isec.add((xi, xi - dj))\n                isec.add((xj, yi))\n                isec.add((sj - yi, yi))\n                isec.add((dj + yi, yi))\n                isec.add((xj, si - xj))\n                isec.add((si - yj, yj))\n                isec.add(((si + dj) / 2, (si - dj) / 2))\n                isec.add((xj, xj - di))\n                isec.add((di + yj, yj))\n                isec.add(((sj + di) / 2, (sj - di) / 2))\n    result = []\n    for (xi, yi) in isec:\n        if (xi, yi) in points:\n            r = 2 * (n - 1)\n            r -= len(linex[xi]) - 1\n            r -= len(liney[yi]) - 1\n            r -= len(lines[xi + yi]) - 1\n            r -= len(lined[xi - yi]) - 1\n        else:\n            r = 2 * n\n            r -= len(linex[xi])\n            r -= len(liney[yi])\n            r -= len(lines[xi + yi])\n            r -= len(lined[xi - yi])\n        result.append(r)\n    print(min(result))"]