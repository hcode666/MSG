["import heapq\n(n, m) = list(map(int, input().split()))\ngraph = {}\nn = n + 1\nfor i in range(n):\n    graph[i] = []\n\ndef add_edge(u, v):\n    graph[u].append((v, 0))\n    graph[v].append((u, 1))\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    add_edge(u, v)\n\ndef shortestPath(graph, src, n, dest):\n    pq = []\n    heapq.heappush(pq, (0, src))\n    dist = [float('inf')] * n\n    dist[src] = 0\n    while pq:\n        (cost, u) = heapq.heappop(pq)\n        if u == dest:\n            return cost\n        for adj in graph[u]:\n            v = adj[0]\n            weight = adj[1]\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    if dist[dest] == float('inf'):\n        return -1\nprint(shortestPath(graph, 1, n, n - 1))", "import heapq\n(n, m) = list(map(int, input().split()))\ngraph = {}\nn = n + 1\nfor i in range(n):\n    graph[i] = []\n\ndef add_edge(u, v):\n    graph[u].append((v, 0))\n    graph[v].append((u, 1))\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    add_edge(u, v)\n\ndef shortestPath(graph, src, n, dest):\n    pq = []\n    heapq.heappush(pq, (0, src))\n    dist = [float('inf')] * n\n    dist[src] = 0\n    while pq:\n        (cost, u) = heapq.heappop(pq)\n        if u == dest:\n            return cost\n        for adj in graph[u]:\n            v = adj[0]\n            weight = adj[1]\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    if dist[dest] == float('inf'):\n        return -1\nprint(shortestPath(graph, 1, n, n - 1))", "import heapq\n(n, m) = list(map(int, input().split()))\ngraph = {}\nn = n + 1\nfor i in range(n):\n    graph[i] = []\n\ndef add_edge(u, v):\n    graph[u].append((v, 0))\n    graph[v].append((u, 1))\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    add_edge(u, v)\n\ndef shortestPath(graph, src, n, dest):\n    pq = []\n    heapq.heappush(pq, (0, src))\n    dist = [float('inf')] * n\n    dist[src] = 0\n    while pq:\n        (cost, u) = heapq.heappop(pq)\n        if u == dest:\n            return cost\n        for adj in graph[u]:\n            v = adj[0]\n            weight = adj[1]\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    if dist[dest] == float('inf'):\n        return -1\nprint(shortestPath(graph, 1, n, n - 1))", "import heapq\n(n, m) = list(map(int, input().split()))\ngraph = {}\nn = n + 1\nfor i in range(n):\n    graph[i] = []\n\ndef add_edge(u, v):\n    graph[u].append((v, 0))\n    graph[v].append((u, 1))\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    add_edge(u, v)\n\ndef shortestPath(graph, src, n, dest):\n    pq = []\n    heapq.heappush(pq, (0, src))\n    dist = [float('inf')] * n\n    dist[src] = 0\n    while pq:\n        (cost, u) = heapq.heappop(pq)\n        if u == dest:\n            return cost\n        for adj in graph[u]:\n            v = adj[0]\n            weight = adj[1]\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    if dist[dest] == float('inf'):\n        return -1\nprint(shortestPath(graph, 1, n, n - 1))", "import heapq\n(n, m) = list(map(int, input().split()))\ngraph = {}\nn = n + 1\nfor i in range(n):\n    graph[i] = []\n\ndef add_edge(u, v):\n    graph[u].append((v, 0))\n    graph[v].append((u, 1))\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    add_edge(u, v)\n\ndef shortestPath(graph, src, n, dest):\n    pq = []\n    heapq.heappush(pq, (0, src))\n    dist = [float('inf')] * n\n    dist[src] = 0\n    while pq:\n        (cost, u) = heapq.heappop(pq)\n        if u == dest:\n            return cost\n        for adj in graph[u]:\n            v = adj[0]\n            weight = adj[1]\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    if dist[dest] == float('inf'):\n        return -1\nprint(shortestPath(graph, 1, n, n - 1))", "import heapq\n(n, m) = [int(x) for x in input().split()]\na = [[] for i in range(n)]\nfor i in range(m):\n    (p, q) = [int(x) for x in input().split()]\n    if p == q:\n        continue\n    a[p - 1].append((0, q - 1))\n    a[q - 1].append((1, p - 1))\nd = [-1] * n\nd[0] = 0\nq = a[0]\nheapq.heapify(q)\nwhile q:\n    p = heapq.heappop(q)\n    for x in a[p[1]]:\n        if d[x[1]] == -1 or d[x[1]] > p[0] + x[0]:\n            d[x[1]] = p[0] + x[0]\n            heapq.heappush(q, (d[x[1]], x[1]))\nprint(d[n - 1])", "import heapq\n(n, m) = [int(x) for x in input().split()]\na = [[] for i in range(n)]\nfor i in range(m):\n    (p, q) = [int(x) for x in input().split()]\n    if p == q:\n        continue\n    a[p - 1].append((0, q - 1))\n    a[q - 1].append((1, p - 1))\nd = [-1] * n\nd[0] = 0\nq = a[0]\nheapq.heapify(q)\nwhile q:\n    p = heapq.heappop(q)\n    for x in a[p[1]]:\n        if d[x[1]] == -1 or d[x[1]] > p[0] + x[0]:\n            d[x[1]] = p[0] + x[0]\n            heapq.heappush(q, (d[x[1]], x[1]))\nprint(d[n - 1])", "import heapq\n(n, m) = [int(x) for x in input().split()]\na = [[] for i in range(n)]\nfor i in range(m):\n    (p, q) = [int(x) for x in input().split()]\n    if p == q:\n        continue\n    a[p - 1].append((0, q - 1))\n    a[q - 1].append((1, p - 1))\nd = [-1] * n\nd[0] = 0\nq = a[0]\nheapq.heapify(q)\nwhile q:\n    p = heapq.heappop(q)\n    for x in a[p[1]]:\n        if d[x[1]] == -1 or d[x[1]] > p[0] + x[0]:\n            d[x[1]] = p[0] + x[0]\n            heapq.heappush(q, (d[x[1]], x[1]))\nprint(d[n - 1])", "import heapq\n(n, m) = list(map(int, input().split()))\ngraph = {}\nn = n + 1\nfor i in range(n):\n    graph[i] = []\n\ndef add_edge(u, v):\n    graph[u].append((v, 0))\n    graph[v].append((u, 1))\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    add_edge(u, v)\n\ndef shortestPath(graph, src, n, dest):\n    pq = []\n    heapq.heappush(pq, (0, src))\n    dist = [float('inf')] * n\n    vis = set([src])\n    dist[src] = 0\n    while pq:\n        (cost, u) = heapq.heappop(pq)\n        if u == dest:\n            return cost\n        vis.add(u)\n        for adj in graph[u]:\n            v = adj[0]\n            weight = adj[1]\n            if dist[v] > dist[u] + weight and v not in vis:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    if dist[dest] == float('inf'):\n        return -1\nprint(shortestPath(graph, 1, n, n - 1))", "import heapq\n(n, m) = list(map(int, input().split()))\ngraph = {}\nn = n + 1\nfor i in range(n):\n    graph[i] = []\n\ndef add_edge(u, v):\n    graph[u].append((v, 0))\n    graph[v].append((u, 1))\nfor _ in range(m):\n    (u, v) = list(map(int, input().split()))\n    add_edge(u, v)\n\ndef shortestPath(graph, src, n, dest):\n    pq = []\n    heapq.heappush(pq, (0, src))\n    dist = [float('inf')] * n\n    dist[src] = 0\n    while pq:\n        (cost, u) = heapq.heappop(pq)\n        if u == dest:\n            return cost\n        for adj in graph[u]:\n            v = adj[0]\n            weight = adj[1]\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    if dist[dest] == float('inf'):\n        return -1\nprint(shortestPath(graph, 1, n, n - 1))", "import sys\n(n, m) = map(int, input().split())\nlevel = [10000000000.0 for i in range(n + 100)]\ngraph = [[] for i in range(n + 100)]\n\ndef create_graph():\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        if x == y:\n            continue\n        graph[x].append([y, 0])\n        graph[y].append([x, 1])\n\ndef bfs(v=1):\n    q = []\n    q.append(v)\n    level[1] = 0\n    while len(q) != 0:\n        cur_v = q[0]\n        q.pop(0)\n        for child in graph[cur_v]:\n            c_v = child[0]\n            wt = child[1]\n            if level[cur_v] + wt < level[c_v]:\n                if wt == 0:\n                    q.insert(0, c_v)\n                else:\n                    q.append(c_v)\n                level[c_v] = level[cur_v] + wt\n    if level[n] == 10000000000.0:\n        return -1\n    return level[n]\ncreate_graph()\nprint(bfs())", "import sys\n(n, m) = map(int, input().split())\nlevel = [10000000000.0 for i in range(n + 100)]\ngraph = [[] for i in range(n + 100)]\n\ndef create_graph():\n    for i in range(m):\n        (x, y) = map(int, input().split())\n        if x == y:\n            continue\n        graph[x].append([y, 0])\n        graph[y].append([x, 1])\n\ndef bfs(v=1):\n    q = []\n    q.append(v)\n    level[1] = 0\n    while len(q) != 0:\n        cur_v = q[0]\n        q.pop(0)\n        for child in graph[cur_v]:\n            c_v = child[0]\n            wt = child[1]\n            if level[cur_v] + wt < level[c_v]:\n                if wt == 0:\n                    q.insert(0, c_v)\n                else:\n                    q.append(c_v)\n                level[c_v] = level[cur_v] + wt\n    if level[n] == 10000000000.0:\n        return -1\n    return level[n]\ncreate_graph()\nprint(bfs())", "(n, m) = list(map(int, input().split()))\ngraph = {i: [] for i in range(1, n + 1)}\nfor i in range(m):\n    (x, y) = list(map(int, input().split()))\n    graph[x].append([y, 0])\n    graph[y].append([x, 1])\nfrom collections import deque\nqueue = deque()\ndist = [float('inf') for i in range(n + 1)]\nqueue.append(1)\ndist[1] = 0\nwhile queue:\n    u = queue.popleft()\n    if u == n:\n        break\n    for (nei, wt) in graph[u]:\n        if dist[u] + wt < dist[nei]:\n            dist[nei] = dist[u] + wt\n            if wt == 1:\n                queue.append(nei)\n            else:\n                queue.appendleft(nei)\nif dist[n] != float('inf'):\n    print(dist[n])\nelse:\n    print(-1)", "from collections import defaultdict as dd, deque\nread = lambda : list(map(int, input().split()))\n(m, n) = read()\nadj = dd(set)\nfor _ in range(n):\n    (a, b) = read()\n    if a == b:\n        continue\n    adj[a].add((b, 0))\n    adj[b].add((a, 1))\nq = deque()\nq.append(1)\ndis = [float('inf')] * (m + 1)\ndis[1] = 0\nwhile q:\n    u = q.popleft()\n    for (v, w) in adj[u]:\n        if dis[v] > dis[u] + w:\n            dis[v] = dis[u] + w\n            if w == 1:\n                q.append(v)\n            else:\n                q.appendleft(v)\nif dis[m] == float('inf'):\n    print(-1)\nelse:\n    print(dis[m])", "from collections import defaultdict, deque\n\ndef main():\n    (n, m) = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        if u == v:\n            continue\n        graph[u].append((v, 0))\n        graph[v].append((u, 1))\n    dist = [float('inf') for i in range(n + 1)]\n    queue = deque()\n    queue.append(1)\n    dist[1] = 0\n    while len(queue):\n        node = queue.popleft()\n        for (neighbour, weight) in graph[node]:\n            if dist[node] + weight < dist[neighbour]:\n                dist[neighbour] = dist[node] + weight\n                if weight == 1:\n                    queue.append(neighbour)\n                else:\n                    queue.appendleft(neighbour)\n    if dist[n] == float('inf'):\n        print(-1)\n    else:\n        print(dist[n])\nmain()", "import heapq, sys\n\ndef solution(points, vertices, edges):\n    adj = {i: [] for i in range(1, vertices + 1)}\n    for i in range(edges):\n        (x, y) = points[i]\n        adj[x].append([0, y])\n        adj[y].append([1, x])\n    (pq, dist) = ([], [sys.maxsize] * (vertices + 1))\n    heapq.heapify(pq)\n    heapq.heappush(pq, [0, 1])\n    dist[0] = 0\n    dist[1] = 0\n    while pq:\n        (dista, u) = heapq.heappop(pq)\n        for val in adj[u]:\n            (weight, v) = val\n            if dist[v] > dist[u] + weight:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, [-weight, v])\n    if dist[vertices] >= sys.maxsize:\n        print('-1')\n    else:\n        print(dist[vertices])\n(vertices, edges) = input().split()\n(vertices, edges) = (int(vertices), int(edges))\npoints = [[]] * edges\nfor i in range(edges):\n    (x, y) = input().split()\n    points[i] = [int(x), int(y)]\nsolution(points, vertices, edges)", "from collections import defaultdict, deque\n\ndef main():\n    (n, m) = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        if u == v:\n            continue\n        graph[u].append((v, 0))\n        graph[v].append((u, 1))\n    dist = [float('inf') for i in range(n + 1)]\n    queue = deque()\n    queue.append(1)\n    dist[1] = 0\n    while len(queue):\n        node = queue.popleft()\n        for (neighbour, weight) in graph[node]:\n            if dist[node] + weight < dist[neighbour]:\n                dist[neighbour] = dist[node] + weight\n                if weight == 1:\n                    queue.append(neighbour)\n                else:\n                    queue.appendleft(neighbour)\n    if dist[n] == float('inf'):\n        print(-1)\n    else:\n        print(dist[n])\nmain()", "from collections import defaultdict\nfrom heapq import heappush, heappop, heapify\n\ndef main():\n    (n, m) = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        (u, v) = map(int, input().split())\n        if u == v:\n            continue\n        graph[u].append((v, 0))\n        graph[v].append((u, 1))\n    dist = [float('inf') for i in range(n + 1)]\n    queue = []\n    queue.append((0, 1))\n    heapify(queue)\n    dist[1] = 0\n    while len(queue):\n        (dis, node) = heappop(queue)\n        for (neighbour, weight) in graph[node]:\n            if dist[node] != float('inf'):\n                if dis + weight < dist[neighbour]:\n                    dist[neighbour] = dis + weight\n                    heappush(queue, (dist[neighbour], neighbour))\n    if dist[n] == float('inf'):\n        print(-1)\n    else:\n        print(dist[n])\nmain()", "from heapq import heapify, heappush, heappop\n\ndef dij(ed, hp, d):\n    while len(hp) != 0:\n        val = heappop(hp)\n        for (key, dis) in ed[val[1]]:\n            if val[0] + dis < d[key]:\n                d[key] = val[0] + dis\n                heappush(hp, (val[0] + dis, key))\n(n, m) = [int(a) for a in input().split()]\ned = []\nfor l in range(n + 1):\n    ed.append([])\nfor _ in range(m):\n    (u, v) = [int(a) for a in input().split()]\n    if len(ed[u]) == 0:\n        ed[u] = []\n    ed[u].append([v, 0])\n    if len(ed[v]) == 0:\n        ed[v] = []\n    ed[v].append([u, 1])\nd = []\nfor l in range(n + 1):\n    d.append(float('inf'))\nd[1] = 0\nhp = []\nheapify(hp)\nheappush(hp, (0, 1))\ndij(ed, hp, d)\nif d[n] == float('inf'):\n    print(-1)\nelse:\n    print(d[n])", "import sys\nfrom collections import defaultdict\nfrom collections import deque\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append((v, 0))\n        self.graph[v].append((u, 1))\n\n    def ZeroOne(self, source):\n        dq = deque()\n        dist = [sys.maxsize for i in range(self.V + 1)]\n        dist[1] = 0\n        dq.append((source, 0))\n        while dq:\n            (node, d) = dq.popleft()\n            for (v, w) in self.graph[node]:\n                if dist[v] > w + d:\n                    dist[v] = w + d\n                    if w == 1:\n                        dq.append((v, dist[v]))\n                    else:\n                        dq.appendleft((v, dist[v]))\n        return dist[self.V]\n(n, m) = map(int, input().split())\ng = Graph(n)\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    g.addEdge(u, v)\nans = g.ZeroOne(1)\nif ans == sys.maxsize:\n    print(-1)\nelse:\n    print(ans)", "import sys\nfrom collections import defaultdict\nfrom collections import deque\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append((v, 0))\n        self.graph[v].append((u, 1))\n\n    def ZeroOne(self, source):\n        dq = deque()\n        dist = [sys.maxsize for i in range(self.V + 1)]\n        dist[1] = 0\n        dq.append((source, 0))\n        while dq:\n            (node, d) = dq.popleft()\n            for (v, w) in self.graph[node]:\n                if dist[v] > w + d:\n                    dist[v] = w + d\n                    if w == 1:\n                        dq.append((v, dist[v]))\n                    else:\n                        dq.appendleft((v, dist[v]))\n        return dist[self.V]\n(n, m) = map(int, input().split())\ng = Graph(n)\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    g.addEdge(u, v)\nans = g.ZeroOne(1)\nif ans == sys.maxsize:\n    print(-1)\nelse:\n    print(ans)", "import sys\nfrom collections import defaultdict\nfrom collections import deque\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append((v, 0))\n        self.graph[v].append((u, 1))\n\n    def ZeroOne(self, source):\n        dq = deque()\n        dist = [sys.maxsize for i in range(self.V + 1)]\n        dist[1] = 0\n        dq.append((source, 0))\n        while dq:\n            node = dq[0][0]\n            d = dq[0][1]\n            dq.popleft()\n            for (v, w) in self.graph[node]:\n                if dist[v] > w + d:\n                    dist[v] = w + d\n                    if w == 1:\n                        dq.append((v, dist[v]))\n                    else:\n                        dq.appendleft((v, dist[v]))\n        return dist[self.V]\n(n, m) = map(int, input().split())\ng = Graph(n)\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    g.addEdge(u, v)\nans = g.ZeroOne(1)\nif ans == sys.maxsize:\n    print(-1)\nelse:\n    print(ans)", "from collections import *\nINF = float('inf')\n(n, m) = map(int, input().split())\nsusjedi = {i: [] for i in range(1, n + 1)}\nudaljenost = [INF for i in range(n + 1)]\nudaljenost[1] = 0\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    susjedi[x].append([y, 0])\n    susjedi[y].append([x, 1])\nq = deque()\nq.append([1, 0])\nwhile q:\n    (x, y) = q.popleft()\n    for i in susjedi[x]:\n        (a, b) = i\n        if y + b < udaljenost[a]:\n            if b == 0:\n                q.appendleft([a, y])\n                udaljenost[a] = y\n            else:\n                q.append([a, y + 1])\n                udaljenost[a] = y + 1\nif udaljenost[n] != INF:\n    print(udaljenost[n])\nelse:\n    print(-1)", "from heapq import *\n(N, M) = map(int, input().split())\ngraph = {pos: [] for pos in range(1, N + 1)}\nvis_arr = [False for _ in range(N)]\nshor_dis = [-1 for _ in range(N)]\nfor _ in range(M):\n    (u, v) = map(int, input().split())\n    graph[u].append([v, 0])\n    graph[v].append([u, 1])\nqueue = [[0, 1]]\nheapify(queue)\nshor_dis[0] = 0\nib = False\nwhile queue:\n    (dis, node) = heappop(queue)\n    vis_arr[node - 1] = True\n    if node == N:\n        print(shor_dis[N - 1])\n        ib = True\n        break\n    else:\n        for i in range(len(graph[node])):\n            (child, weight) = (graph[node][i][0], graph[node][i][1])\n            if not vis_arr[child - 1] and (shor_dis[child - 1] == -1 or shor_dis[child - 1] > shor_dis[node - 1] + weight):\n                shor_dis[child - 1] = shor_dis[node - 1] + weight\n                heappush(queue, [shor_dis[child - 1], child])\nif not ib:\n    print(-1)", "import sys\nfrom collections import defaultdict\nfrom collections import deque\n\nclass Graph:\n\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = defaultdict(list)\n\n    def addEdge(self, u, v):\n        self.graph[u].append((v, 0))\n        self.graph[v].append((u, 1))\n\n    def ZeroOne(self, source):\n        dq = deque()\n        dist = [sys.maxsize for i in range(self.V + 1)]\n        dist[1] = 0\n        dq.append((source, 0))\n        while dq:\n            node = dq[0][0]\n            d = dq[0][1]\n            dq.popleft()\n            for (v, w) in self.graph[node]:\n                if dist[v] > w + d:\n                    dist[v] = w + d\n                    if w == 1:\n                        dq.append((v, dist[v]))\n                    else:\n                        dq.appendleft((v, dist[v]))\n        return dist[self.V]\n(n, m) = map(int, input().split())\ng = Graph(n)\nfor _ in range(m):\n    (u, v) = map(int, input().split())\n    g.addEdge(u, v)\nans = g.ZeroOne(1)\nif ans == sys.maxsize:\n    print(-1)\nelse:\n    print(ans)", "(N, M) = map(int, input().split())\nadj = [0]\nvis = [0]\nfor i in range(N):\n    adj.append([])\n    vis.append(0)\nfor i in range(M):\n    (x, y) = map(int, input().split())\n    adj[x].append([y, 0])\n    adj[y].append([x, 1])\nspt = []\ndist = [0]\nfor i in range(N):\n    if i == 0:\n        dist.append(0)\n    else:\n        dist.append(10 ** 5)\nq = [1]\nmindist = 10 ** 5\n(L1, L2) = (0, 1)\nans = -1\nwhile L1 < N:\n    mindist = 10 ** 5\n    index = -1\n    for i in range(L2):\n        if dist[q[i]] < mindist:\n            mindist = dist[q[i]]\n            index = i\n    if len(q) == 0:\n        break\n    node = q.pop(index)\n    if node == N:\n        ans = dist[N]\n        break\n    spt.append(node)\n    vis[node] = 2\n    L1 += 1\n    L2 -= 1\n    for i in adj[node]:\n        if dist[node] + i[1] < dist[i[0]]:\n            dist[i[0]] = dist[node] + i[1]\n        if vis[i[0]] == 0:\n            vis[i[0]] = 1\n            q.append(i[0])\n            L2 += 1\nprint(ans)", "import queue\nimport sys\n\ndef fun(d, v, e):\n    LOQ = [queue.Queue() for i in range(2)]\n    visited = set()\n    LOQ[0].put([1, 0])\n    while LOQ[0].qsize() > 0 or LOQ[1].qsize() > 0:\n        while LOQ[0].qsize() > 0:\n            rem = LOQ[0].get()\n            if rem[0] in visited:\n                continue\n            visited.add(rem[0])\n            if rem[0] == v:\n                return rem[1]\n            for nbr in d[rem[0]]:\n                dest = nbr[0]\n                cost = nbr[1]\n                if dest not in visited:\n                    if cost == 0:\n                        LOQ[0].put([dest, rem[1]])\n                    else:\n                        LOQ[1].put([dest, rem[1] + 1])\n        LOQ = LOQ[::-1]\n    return -1\n(v, e) = map(int, input().split())\nd = {}\nfor i in range(e):\n    (frm, to) = map(int, input().split())\n    if frm in d:\n        d[frm].append([to, 0])\n    else:\n        d[frm] = [[to, 0]]\n    if to in d:\n        d[to].append([frm, 1])\n    else:\n        d[to] = [[frm, 1]]\nprint(fun(d, v, e))", "from heapq import *\n(N, M) = map(int, input().split())\ngraph = {pos: [] for pos in range(1, N + 1)}\nvis_arr = [False for _ in range(N)]\nshor_dis = [-1 for _ in range(N)]\nfor _ in range(M):\n    (u, v) = map(int, input().split())\n    graph[u].append([v, 0])\n    graph[v].append([u, 1])\nqueue = [[0, 1]]\nheapify(queue)\nshor_dis[0] = 0\nib = False\nwhile queue:\n    (dis, node) = heappop(queue)\n    vis_arr[node - 1] = True\n    if node == N:\n        print(shor_dis[N - 1])\n        ib = True\n        break\n    else:\n        for i in range(len(graph[node])):\n            (child, weight) = (graph[node][i][0], graph[node][i][1])\n            if not vis_arr[child - 1] and (shor_dis[child - 1] == -1 or shor_dis[child - 1] > shor_dis[node - 1] + weight):\n                shor_dis[child - 1] = shor_dis[node - 1] + weight\n                heappush(queue, [shor_dis[child - 1], child])\nif not ib:\n    print(-1)", "from heapq import *\n(N, M) = map(int, input().split())\ngraph = dict({op: [] for op in range(1, N + 1)})\nfor _ in range(M):\n    (u, v) = map(int, input().split())\n    graph[u].append([v, 0])\n    graph[v].append([u, 1])\nqueue = [[0, 1]]\nheapify(queue)\nshor_dis = [-1 for _ in range(N)]\nvis_arr = [False for _ in range(N)]\nshor_dis[0] = 0\nif_break = False\nwhile queue:\n    (dis, node) = heappop(queue)\n    vis_arr[node - 1] = True\n    if node == N:\n        print(shor_dis[N - 1])\n        if_break = True\n        break\n    else:\n        for i in range(len(graph[node])):\n            (child, weight) = (graph[node][i][0], graph[node][i][1])\n            if not vis_arr[child - 1] and (shor_dis[child - 1] == -1 or shor_dis[child - 1] > shor_dis[node - 1] + weight):\n                shor_dis[child - 1] = shor_dis[node - 1] + weight\n                heappush(queue, [shor_dis[child - 1], child])\nif not if_break:\n    print(-1)", "import io, os, time\nfrom sys import stdin, stdout\nfrom collections import defaultdict\nfrom heapq import heappush as push, heappop as pop\n\ndef take_input():\n    s = stdin.readline()\n    return s\n\ndef display_arr(arr):\n    stdout.write(' '.join(map(str, arr)) + '\\n')\n\ndef display_num(num):\n    stdout.write(str(num) + '\\n')\n\ndef solve():\n    dis = [float('inf')] * (n + 1)\n    vis = [0] * (n + 1)\n    dis[1] = 0\n    heap = [(0, 1)]\n    while heap:\n        (distance, node) = pop(heap)\n        if node == n:\n            return distance\n        vis[node] = 1\n        for (adj, wt) in graph[node]:\n            if vis[adj] == 0 and dis[adj] > distance + wt:\n                dis[adj] = distance + wt\n                push(heap, (distance + wt, adj))\n    return dis[-1] if dis[-1] != float('inf') else -1\n(n, m) = map(int, take_input().split())\ngraph = defaultdict(list)\nfor i in range(m):\n    (u, v) = map(int, take_input().split())\n    graph[u].append((v, 0))\n    graph[v].append((u, 1))\nprint(solve())", "from collections import defaultdict, deque\nfrom heapq import *\n(n, m) = map(int, input().split())\ngraph = defaultdict(list)\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    graph[a].append([b, 0])\n    graph[b].append([a, 1])\ns = 1\ne = n\nweights = [[0, 1]]\nheapify(weights)\nfound = False\nvis = set()\nwhile weights:\n    (curWt, newNode) = heappop(weights)\n    if newNode in vis:\n        continue\n    if newNode == e:\n        found = True\n        print(curWt)\n        break\n    vis.add(newNode)\n    for node in graph[newNode]:\n        (nbr, w) = node\n        if nbr not in vis:\n            heappush(weights, [curWt + w, nbr])\nif not found:\n    print(-1)", "from heapq import heappush, heappop\n\ndef reverseEdges(n, start, end, edgeList):\n    graph = {}\n    for i in edgeList:\n        if i[0] not in graph:\n            graph[i[0]] = []\n        if i[1] not in graph:\n            graph[i[1]] = []\n        graph[i[0]].append([i[1], 0])\n        graph[i[1]].append([i[0], 1])\n    visited = [0] * (n + 1)\n    heap = [[0, start]]\n    ans = float('inf')\n    while heap:\n        x = heappop(heap)\n        if visited[x[1]]:\n            continue\n        if x[1] == end:\n            return x[0]\n        visited[x[1]] = 1\n        for i in graph[x[1]]:\n            heappush(heap, [x[0] + i[1], i[0]])\n    return -1\n(n, m) = list(map(int, input().split()))\nedges = []\nfor i in range(m):\n    edge = list(map(int, input().split()))\n    edges.append(edge)\nprint(reverseEdges(n, 1, n, edges))", "import heapq\n(n, m) = map(int, input().split())\ndict = {}\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    try:\n        dict[x].append((y, 0))\n    except:\n        dict[x] = [(y, 0)]\n    try:\n        dict[y].append((x, 1))\n    except:\n        dict[y] = [(x, 1)]\nvisited = [0 for i in range(n + 1)]\ndist = [100000000 for i in range(n + 1)]\nqu = []\nheapq.heappush(qu, (0, 1))\ndist[1] = 0\nflag = False\nwhile len(qu) > 0:\n    node = heapq.heappop(qu)\n    if visited[node[1]] == 1:\n        continue\n    visited[node[1]] = 1\n    if node[1] == n:\n        flag = True\n        print(node[0])\n        break\n    for curr in dict[node[1]]:\n        if curr[1] + node[0] < dist[curr[0]]:\n            dist[curr[0]] = curr[1] + node[0]\n            heapq.heappush(qu, (dist[curr[0]], curr[0]))\nif flag == False:\n    print(-1)", "from heapq import heappush, heappop\n\ndef reverseEdges(n, start, end, edgeList):\n    graph = {}\n    for i in edgeList:\n        if i[0] not in graph:\n            graph[i[0]] = []\n        if i[1] not in graph:\n            graph[i[1]] = []\n        graph[i[0]].append([i[1], 0])\n        graph[i[1]].append([i[0], 1])\n    visited = [0] * (n + 1)\n    heap = [[0, start]]\n    ans = float('inf')\n    while heap:\n        x = heappop(heap)\n        if visited[x[1]]:\n            continue\n        if x[1] == end:\n            return x[0]\n        visited[x[1]] = 1\n        for i in graph[x[1]]:\n            heappush(heap, [x[0] + i[1], i[0]])\n    return -1\n(n, m) = list(map(int, input().split()))\nedges = []\nfor i in range(m):\n    edge = list(map(int, input().split()))\n    edges.append(edge)\nprint(reverseEdges(n, 1, n, edges))", "from heapq import heappush, heappop\n\ndef reverseEdges(n, start, end, edgeList):\n    graph = {}\n    for i in edgeList:\n        if i[0] not in graph:\n            graph[i[0]] = []\n        if i[1] not in graph:\n            graph[i[1]] = []\n        graph[i[0]].append([i[1], 0])\n        graph[i[1]].append([i[0], 1])\n    visited = [0] * (n + 1)\n    heap = [[0, start]]\n    ans = float('inf')\n    while heap:\n        x = heappop(heap)\n        if visited[x[1]]:\n            continue\n        if x[1] == end:\n            return x[0]\n        visited[x[1]] = 1\n        for i in graph[x[1]]:\n            heappush(heap, [x[0] + i[1], i[0]])\n    return -1\n(n, m) = list(map(int, input().split()))\nedges = []\nfor i in range(m):\n    edge = list(map(int, input().split()))\n    edges.append(edge)\nprint(reverseEdges(n, 1, n, edges))", "import heapq\n(n, m) = input().split()\n(n, m) = (int(n), int(m))\n(s, d) = (1, n)\ngraph = {}\nfor i in range(m):\n    (a, b) = input().split()\n    (a, b) = (int(a), int(b))\n    if a not in graph:\n        graph[a] = []\n    if b not in graph:\n        graph[b] = []\n    graph[a].append((b, 0))\n    graph[b].append((a, 1))\nheap = [(0, s)]\nvisited = set()\nflag = True\nwhile heap:\n    (cur_price, cur_node) = heapq.heappop(heap)\n    if cur_node in visited:\n        continue\n    if cur_node == d:\n        flag = False\n        print(cur_price)\n        break\n    visited.add(cur_node)\n    for (padosi, padosi_price) in graph[cur_node]:\n        if padosi not in visited:\n            heapq.heappush(heap, (cur_price + padosi_price, padosi))\nif flag:\n    print(-1)", "class GraphNode:\n\n    def __init__(self, nodeB, weight):\n        self.node = nodeB\n        self.weight = weight\n\ndef bfs01(graph, numOfNodes):\n    distance = [sys.maxsize for i in range(numOfNodes + 1)]\n    distance[1] = 0\n    visited = [False for i in range(numOfNodes + 1)]\n    visited[1] = True\n    heap = deque()\n    heap.appendleft((0, 1))\n    while len(heap) != 0:\n        (dist, node) = heap.popleft()\n        visited[node] = True\n        for child in graph[node]:\n            if not visited[child.node]:\n                if distance[child.node] > dist + child.weight:\n                    distance[child.node] = dist + child.weight\n                    if child.weight == 0:\n                        heap.appendleft((distance[child.node], child.node))\n                    else:\n                        heap.append((distance[child.node], child.node))\n    return distance[-1] if distance[-1] != sys.maxsize else -1\n\ndef code():\n    (n, m) = [int(i) for i in input().split()]\n    graph = {}\n    for _ in range(m):\n        (nodeA, nodeB) = [int(i) for i in input().split()]\n        if nodeA not in graph:\n            graph[nodeA] = []\n        nodeAObj = GraphNode(nodeB, 0)\n        graph[nodeA].append(nodeAObj)\n        if nodeB not in graph:\n            graph[nodeB] = []\n        nodeBObj = GraphNode(nodeA, 1)\n        graph[nodeB].append(nodeBObj)\n    print(bfs01(graph, n))\nfrom collections import deque\nimport sys\nimport heapq\nsys.setrecursionlimit(10 ** 6)\ncode()", "class GraphNode:\n\n    def __init__(self, nodeB, weight):\n        self.node = nodeB\n        self.weight = weight\n\ndef bfs01(graph, numOfNodes):\n    distance = [sys.maxsize for i in range(numOfNodes + 1)]\n    distance[1] = 0\n    visited = [False for i in range(numOfNodes + 1)]\n    visited[1] = True\n    heap = deque()\n    heap.appendleft((0, 1))\n    while len(heap) != 0:\n        (dist, node) = heap.popleft()\n        visited[node] = True\n        for child in graph[node]:\n            if not visited[child.node]:\n                if distance[child.node] > dist + child.weight:\n                    distance[child.node] = dist + child.weight\n                    if child.weight == 0:\n                        heap.appendleft((distance[child.node], child.node))\n                    else:\n                        heap.append((distance[child.node], child.node))\n    return distance[-1] if distance[-1] != sys.maxsize else -1\n\ndef code():\n    (n, m) = [int(i) for i in input().split()]\n    graph = {}\n    for _ in range(m):\n        (nodeA, nodeB) = [int(i) for i in input().split()]\n        if nodeA not in graph:\n            graph[nodeA] = []\n        nodeAObj = GraphNode(nodeB, 0)\n        graph[nodeA].append(nodeAObj)\n        if nodeB not in graph:\n            graph[nodeB] = []\n        nodeBObj = GraphNode(nodeA, 1)\n        graph[nodeB].append(nodeBObj)\n    print(bfs01(graph, n))\nfrom collections import deque\nimport sys\nimport heapq\nsys.setrecursionlimit(10 ** 6)\ncode()", "from collections import defaultdict, deque\nimport math\n(n, m) = map(int, input().split())\ng = defaultdict(list)\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    if u != v:\n        g[u].append([v, 0])\nfor i in range(1, n + 1):\n    for k in g[i]:\n        if k[1] == 0:\n            g[k[0]].append([i, 1])\nq = deque([(1, 0)])\ndist = [math.inf] * (n + 1)\ndist[1] = 0\nvisited = set()\nwhile q:\n    (a, w) = q.popleft()\n    if a not in visited:\n        visited.add(a)\n        for i in g[a]:\n            dist[i[0]] = min(dist[i[0]], dist[a] + i[1])\n            if i[1] == 1:\n                q.append(i)\n            else:\n                q.appendleft(i)\nif n in visited:\n    print(dist[n])\nelse:\n    print(-1)", "import os.path\nfrom math import gcd, floor, ceil\nfrom collections import *\nimport sys\nmod = 1000000007\nINF = float('inf')\n\ndef st():\n    return list(sys.stdin.readline().strip())\n\ndef li():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef mp():\n    return map(int, sys.stdin.readline().split())\n\ndef inp():\n    return int(sys.stdin.readline())\n\ndef pr(n):\n    return sys.stdout.write(str(n) + '\\n')\n\ndef prl(n):\n    return sys.stdout.write(str(n) + ' ')\nif os.path.exists('input.txt'):\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\n(n, m) = mp()\nd = {i: [] for i in range(1, n + 1)}\nfor i in range(m):\n    (a, b) = mp()\n    d[a].append([b, 0])\n    d[b].append([a, 1])\nq = deque()\nq.append([1, 0])\ndist = [INF for i in range(n + 1)]\ndist[1] = 0\nwhile q:\n    (x, y) = q.popleft()\n    for i in d[x]:\n        (node, distance) = i\n        if y + distance < dist[node]:\n            if distance == 0:\n                q.appendleft([node, y])\n                dist[node] = y\n            else:\n                q.append([node, y + 1])\n                dist[node] = y + 1\npr(dist[n] if dist[n] != INF else -1)", "import sys\ninput = lambda : sys.stdin.readline().rstrip('\\r\\n')\ninp = lambda : list(map(int, sys.stdin.readline().rstrip('\\r\\n').split()))\nmod = 10 ** 9 + 7\nMod = 998244353\nINF = float('inf')\nfrom collections import deque\ntc = 1\nfor _ in range(tc):\n    (n, m) = inp()\n    g = [set() for i in range(n + 1)]\n    for ind in range(m):\n        (i, j) = inp()\n        g[i].add((j, 0))\n        g[i].discard((j, 1))\n        if (i, 0) not in g[j]:\n            g[j].add((i, 1))\n    ans = INF\n    weight = [INF] * (n + 1)\n    weight[1] = 0\n    q = deque([1])\n    vis = [False] * (n + 1)\n    while q:\n        node = q.popleft()\n        if vis[node] == True:\n            continue\n        vis[node] = True\n        for (edge, wt) in g[node]:\n            new_dist = weight[node] + wt\n            if new_dist < weight[edge]:\n                if wt == 1:\n                    q.append(edge)\n                else:\n                    q.appendleft(edge)\n                weight[edge] = new_dist\n    print(-1 if weight[n] == INF else weight[n])", "import queue\nimport sys\n\ndef fun(d, v, e):\n    ListOfQueues = [queue.Queue() for i in range(2)]\n    visited = set()\n    ListOfQueues[0].put([1, 0])\n    while ListOfQueues[0].qsize() > 0 or ListOfQueues[1].qsize() > 0:\n        while ListOfQueues[0].qsize() > 0:\n            rem = ListOfQueues[0].get()\n            if rem[0] in visited:\n                continue\n            visited.add(rem[0])\n            if rem[0] == v:\n                return rem[1]\n            for nbr in d[rem[0]]:\n                dest = nbr[0]\n                cost = nbr[1]\n                if dest not in visited:\n                    if cost == 0:\n                        ListOfQueues[0].put([dest, rem[1]])\n                    else:\n                        ListOfQueues[1].put([dest, rem[1] + 1])\n        ListOfQueues = ListOfQueues[::-1]\n    return -1\n(v, e) = map(int, input().split())\nd = {}\nfor i in range(e):\n    (frm, to) = map(int, input().split())\n    if frm in d:\n        d[frm].append([to, 0])\n    else:\n        d[frm] = [[to, 0]]\n    if to in d:\n        d[to].append([frm, 1])\n    else:\n        d[to] = [[frm, 1]]\nprint(fun(d, v, e))", "import queue\nimport sys\n\ndef fun(d, v, e):\n    ListOfQueues = [queue.Queue() for i in range(2)]\n    ListOfQueues[0].put([1, 0])\n    visited = set()\n    x = 0\n    while ListOfQueues[0].qsize() > 0 or ListOfQueues[1].qsize() > 0:\n        while ListOfQueues[0].qsize() > 0:\n            rem = ListOfQueues[0].get()\n            if rem[0] in visited:\n                continue\n            visited.add(rem[0])\n            if rem[0] == v:\n                return rem[1]\n            for nbr in d[rem[0]]:\n                dest = nbr[0]\n                cost = nbr[1]\n                if dest not in visited:\n                    if cost == 0:\n                        ListOfQueues[0].put([dest, rem[1]])\n                    else:\n                        ListOfQueues[1].put([dest, rem[1] + 1])\n        ListOfQueues = ListOfQueues[::-1]\n        x += 1\n    return -1\n(v, e) = map(int, input().split())\nd = {}\nfor i in range(e):\n    (frm, to) = map(int, input().split())\n    if frm in d:\n        d[frm].append([to, 0])\n    else:\n        d[frm] = [[to, 0]]\n    if to in d:\n        d[to].append([frm, 1])\n    else:\n        d[to] = [[frm, 1]]\nprint(fun(d, v, e))", "from collections import defaultdict, deque\nimport math\n(n, m) = map(int, input().split())\ng = defaultdict(list)\nfor i in range(m):\n    (u, v) = map(int, input().split())\n    if u != v:\n        g[u].append([v, 0])\nfor i in range(1, n + 1):\n    for k in g[i]:\n        if k[1] == 0:\n            g[k[0]].append([i, 1])\nq = deque([(1, 0)])\ndist = [math.inf] * (n + 1)\ndist[1] = 0\nvisited = set()\nwhile q:\n    (a, w) = q.popleft()\n    if a not in visited:\n        visited.add(a)\n        for i in g[a]:\n            dist[i[0]] = min(dist[i[0]], dist[a] + i[1])\n            if i[1] == 1:\n                q.append(i)\n            else:\n                q.appendleft(i)\nif n in visited:\n    print(dist[n])\nelse:\n    print(-1)", "from heapq import *\nimport math\n(n, m) = map(int, input().split())\ng = {}\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    if a not in g:\n        g[a] = []\n        g[a].append([0, b])\n    else:\n        g[a].append([0, b])\n    if b not in g:\n        g[b] = []\n        g[b].append([1, a])\n    else:\n        g[b].append([1, a])\nvis = [0] * (n + 1)\ndis = [math.inf] * (n + 1)\nh = []\ndis[1] = 0\nheappush(h, [0, 1])\nf_1 = 0\nwhile len(h) > 0:\n    t_1 = heappop(h)\n    if vis[t_1[1]] == 1:\n        continue\n    vis[t_1[1]] = 1\n    if t_1[1] == n:\n        f_1 = 1\n        print(t_1[0])\n        break\n    for i in g[t_1[1]]:\n        if vis[i[1]] == 0:\n            if i[0] + t_1[0] < dis[i[1]]:\n                dis[i[1]] = i[0] + t_1[0]\n                heappush(h, [dis[i[1]], i[1]])\nif f_1 == 0:\n    print(-1)", "from heapq import *\nimport math\n(n, m) = map(int, input().split())\ng = {}\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    if a not in g:\n        g[a] = []\n        g[a].append([0, b])\n    else:\n        g[a].append([0, b])\n    if b not in g:\n        g[b] = []\n        g[b].append([1, a])\n    else:\n        g[b].append([1, a])\nvis = [0] * (n + 1)\ndis = [math.inf] * (n + 1)\nh = []\ndis[1] = 0\nheappush(h, [0, 1])\nf_1 = 0\nwhile len(h) > 0:\n    t_1 = heappop(h)\n    if vis[t_1[1]] == 1:\n        continue\n    vis[t_1[1]] = 1\n    if t_1[1] == n:\n        f_1 = 1\n        print(t_1[0])\n        break\n    for i in g[t_1[1]]:\n        if i[0] + t_1[0] < dis[i[1]]:\n            dis[i[1]] = i[0] + t_1[0]\n            heappush(h, [dis[i[1]], i[1]])\nif f_1 == 0:\n    print(-1)", "from collections import deque\nfrom sys import stdin\nimport numpy as np\n(n, m) = map(int, input().split())\nAdj = [[] for i in range(n + 1)]\nfor _ in range(m):\n    (a, b) = map(int, stdin.readline().split())\n    Adj[a].append([b, 0])\n    Adj[b].append([a, 1])\nq = deque([1])\nd = np.ones(n + 1, dtype=np.uint32) * 10 ** 6\nd[1] = 0\nwhile q:\n    q1 = q.popleft()\n    for (v, w) in Adj[q1]:\n        if d[v] > d[q1] + w:\n            if w == 1:\n                q.append(v)\n            else:\n                q.appendleft(v)\n            d[v] = d[q1] + w\ndist = d[-1]\nif dist == 1000000:\n    print(-1)\nelse:\n    print(dist)", "from collections import deque\nfrom sys import stdin\nimport numpy as np\n(n, m) = map(int, input().split())\nAdj = [[] for i in range(n + 1)]\nfor _ in range(m):\n    (a, b) = map(int, stdin.readline().split())\n    Adj[a].append([b, 0])\n    Adj[b].append([a, 1])\nq = deque([1])\nd = np.ones(n + 1, dtype=np.uint32) * 10 ** 6\nd[1] = 0\nwhile q:\n    q1 = q.popleft()\n    for (v, w) in Adj[q1]:\n        if d[v] > d[q1] + w:\n            if w == 1:\n                q.append(v)\n            else:\n                q.appendleft(v)\n            d[v] = d[q1] + w\ndist = d[-1]\nif dist == 1000000:\n    print(-1)\nelse:\n    print(dist)", "from collections import deque\nfrom sys import stdin\nimport numpy as np\n(n, m) = map(int, input().split())\nAdj = [[] for i in range(n + 1)]\nfor _ in range(m):\n    (a, b) = map(int, stdin.readline().split())\n    Adj[a].append([b, 0])\n    Adj[b].append([a, 1])\nq = deque([1])\nd = np.ones(n + 1, dtype=np.uint32) * 10 ** 6\nd[1] = 0\nwhile q:\n    q1 = q.popleft()\n    for (v, w) in Adj[q1]:\n        if d[v] > d[q1] + w:\n            if w == 1:\n                q.append(v)\n            else:\n                q.appendleft(v)\n            d[v] = d[q1] + w\ndist = d[-1]\nif dist == 1000000:\n    print(-1)\nelse:\n    print(dist)", "from collections import deque\nfrom sys import stdin\nimport numpy as np\n(n, m) = map(int, input().split())\nAdj = [[] for i in range(n + 1)]\nfor _ in range(m):\n    (a, b) = map(int, stdin.readline().split())\n    Adj[a].append([b, 0])\n    Adj[b].append([a, 1])\nq = deque([1])\nd = np.ones(n + 1, dtype=np.uint32) * 10 ** 6\nd[1] = 0\nwhile q:\n    q1 = q.popleft()\n    for (v, w) in Adj[q1]:\n        if d[v] > d[q1] + w:\n            if w == 1:\n                q.append(v)\n            else:\n                q.appendleft(v)\n            d[v] = d[q1] + w\ndist = d[-1]\nif dist == 1000000:\n    print(-1)\nelse:\n    print(dist)", "from collections import deque\nfrom sys import stdin\nimport numpy as np\n(n, m) = map(int, input().split())\nAdj = [[] for i in range(n + 1)]\nfor i in range(m):\n    (a, b) = map(int, stdin.readline().split())\n    Adj[a].append([b, 0])\n    Adj[b].append([a, 1])\nq = deque([1])\nd = np.ones(n + 1, dtype=np.uint32) * 10 ** 6\nd[1] = 0\nwhile q:\n    q1 = q.popleft()\n    for (v, w) in Adj[q1]:\n        if d[v] > d[q1] + w:\n            if w == 1:\n                q.append(v)\n            else:\n                q.appendleft(v)\n            d[v] = d[q1] + w\ndist = d[-1]\nif dist == 1000000:\n    print(-1)\nelse:\n    print(dist)", "try:\n    from collections import deque\n    from sys import stdin\n    import numpy as np\n    (n, m) = map(int, input().split())\n    Adj = [[] for i in range(n + 1)]\n    for i in range(m):\n        (a, b) = map(int, stdin.readline().split())\n        Adj[a].append([b, 0])\n        Adj[b].append([a, 1])\n    q = deque([1])\n    d = np.ones(n + 1, dtype=np.uint32) * 10 ** 6\n    d[1] = 0\n    while q:\n        q1 = q.popleft()\n        for (v, w) in Adj[q1]:\n            if d[v] > d[q1] + w:\n                if w == 1:\n                    q.append(v)\n                else:\n                    q.appendleft(v)\n                d[v] = d[q1] + w\n    dist = d[-1]\n    if dist == 1000000:\n        print(-1)\n    else:\n        print(dist)\nexcept:\n    pass", "try:\n    from collections import deque\n    from sys import stdin\n    import numpy as np\n    (n, m) = map(int, input().split())\n    Adj = [[] for i in range(n + 1)]\n    for i in range(m):\n        (a, b) = map(int, stdin.readline().split())\n        Adj[a].append([b, 0])\n        Adj[b].append([a, 1])\n    q = deque([1])\n    d = np.ones(n + 1, dtype=np.uint32) * 10 ** 6\n    d[1] = 0\n    while q:\n        q1 = q.popleft()\n        for (v, w) in Adj[q1]:\n            if d[v] > d[q1] + w:\n                if w == 1:\n                    q.append(v)\n                else:\n                    q.appendleft(v)\n                d[v] = d[q1] + w\n    dist = d[-1]\n    if dist == 1000000:\n        print(-1)\n    else:\n        print(dist)\nexcept:\n    pass", "from collections import deque\nfrom sys import stdin\nimport numpy as np\n(n, m) = map(int, input().split())\nAdj = [[] for i in range(n + 1)]\nfor i in range(m):\n    (a, b) = map(int, stdin.readline().split())\n    Adj[a].append([b, 0])\n    Adj[b].append([a, 1])\nq = deque([1])\nd = np.ones(n + 1, dtype=np.uint32) * 10 ** 6\nd[1] = 0\nwhile q:\n    q1 = q.popleft()\n    for (v, w) in Adj[q1]:\n        if d[v] > d[q1] + w:\n            if w == 1:\n                q.append(v)\n            else:\n                q.appendleft(v)\n            d[v] = d[q1] + w\ndist = d[-1]\nif dist == 1000000:\n    print(-1)\nelse:\n    print(dist)", "from collections import deque\nfrom sys import stdin\nimport numpy as np\n(n, m) = map(int, input().split())\nAdj = [[] for i in range(n + 1)]\nfor i in range(m):\n    (a, b) = map(int, stdin.readline().split())\n    Adj[a].append([b, 0])\n    Adj[b].append([a, 1])\nq = deque([1])\nd = np.ones(n + 1, dtype=np.uint32) * 10 ** 6\nd[1] = 0\nwhile q:\n    q1 = q.popleft()\n    for (v, w) in Adj[q1]:\n        if d[v] > d[q1] + w:\n            if w == 1:\n                q.append(v)\n            else:\n                q.appendleft(v)\n            d[v] = d[q1] + w\ndist = d[-1]\nif dist == 1000000:\n    print(-1)\nelse:\n    print(dist)", "from heapq import *\n(n, m) = map(int, input().split())\nadj = [[] for i in range(n)]\nheap = []\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    if x != y:\n        adj[x - 1].append((y - 1, 0))\n        adj[y - 1].append((x - 1, 1))\ncost = [10 ** 9] * n\ncost[0] = 0\nfor i in adj[0]:\n    heap.append((i[1], i[0]))\n    cost[i[0]] = i[1]\nvis = [0] * n\nvis[0] = 1\nheapify(heap)\ndone = set()\nwhile heap:\n    node = heappop(heap)\n    if node in done:\n        continue\n    done.add(node)\n    if node[1] == n - 1:\n        break\n    for (i, co) in adj[node[1]]:\n        vis[i] = 1\n        if cost[i] > node[0] + co:\n            cost[i] = node[0] + co\n            heappush(heap, (cost[i], i))\nif cost[n - 1] == 10 ** 9:\n    print(-1)\nelse:\n    print(cost[n - 1])", "import heapq\n(n, m) = map(int, input().split())\ndict = {}\nfor i in range(m):\n    (x, y) = map(int, input().split())\n    try:\n        dict[x].append((y, 0))\n    except:\n        dict[x] = [(y, 0)]\n    try:\n        dict[y].append((x, 1))\n    except:\n        dict[y] = [(x, 1)]\nvisited = [0 for i in range(n + 1)]\ndist = [100000000 for i in range(n + 1)]\nqu = []\nheapq.heappush(qu, (0, 1))\ndist[1] = 0\nflag = False\nwhile len(qu) > 0:\n    node = heapq.heappop(qu)\n    if visited[node[1]] == 1:\n        continue\n    visited[node[1]] = 1\n    if node[1] == n:\n        flag = True\n        print(node[0])\n        break\n    for curr in dict[node[1]]:\n        if curr[1] + node[0] < dist[curr[0]]:\n            dist[curr[0]] = curr[1] + node[0]\n            heapq.heappush(qu, (dist[curr[0]], curr[0]))\nif flag == False:\n    print(-1)", "import heapq\n(n, m) = map(int, input().split())\nhash = {}\nfor i in range(n):\n    hash[i + 1] = []\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    try:\n        hash[b]\n    except:\n        hash[b] = [[1, a]]\n    else:\n        hash[b].append([1, a])\n    try:\n        hash[a]\n    except:\n        hash[a] = [[0, b]]\n    else:\n        hash[a].append([0, b])\nhash_ha = {}\nfor i in range(n):\n    hash_ha[i + 1] = 10 ** 18\nhash_ha[1] = 0\nhash_bool = {}\nfor i in range(n):\n    hash_bool[i + 1] = False\n\ndef bfs():\n    queue = [1]\n    hash_bool[1] = True\n    while queue != []:\n        z = queue.pop(0)\n        for i in hash[z]:\n            if hash_bool[i[1]] == False:\n                hash_bool[i[1]] = True\n                queue.append(i[1])\n    return hash_bool\nhash_bool = bfs()\n\ndef dijskstras():\n    l = [[0, 1]]\n    heapq.heapify(l)\n    while l != []:\n        z = heapq.heappop(l)\n        for i in hash[z[1]]:\n            if z[0] + i[0] < hash_ha[i[1]]:\n                hash_ha[i[1]] = z[0] + i[0]\n                heapq.heappush(l, [hash_ha[i[1]], i[1]])\n    return hash_ha\nif hash_bool[n] == False:\n    print(-1)\nelse:\n    z = dijskstras()\n    print(z[n])", "from collections import defaultdict\nd = defaultdict(list)\n(n, m) = map(int, input().split())\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    a = a - 1\n    b = b - 1\n    d[a].append([b, 0])\n    d[b].append([a, 1])\nimport heapq\nl = []\ndist = [10 ** 9] * n\ndist[0] = 0\nfor i in d[0]:\n    l.append([i[0], i[1]])\n    dist[i[0]] = i[1]\nheapq.heapify(l)\nvis = [0] * n\nwhile l:\n    t = heapq.heappop(l)\n    weight = t[1]\n    elem = t[0]\n    for x in d[elem]:\n        vis[x[0]] = 1\n        if x[1] + weight < dist[x[0]]:\n            dist[x[0]] = x[1] + weight\n            heapq.heappush(l, [x[0], dist[x[0]]])\nprint(dist[n - 1] if dist[n - 1] != 10 ** 9 else -1)", "from collections import defaultdict\nimport heapq\n(v, e) = map(int, input().split())\ng = defaultdict(list)\nno_cost = defaultdict(int)\nfor _ in range(e):\n    (x, y) = map(int, input().split())\n    g[x - 1].append(y - 1)\n    g[y - 1].append(x - 1)\n    no_cost[x - 1, y - 1] = 1\nq = [[0, 0]]\nvisited = [False] * v\nwhile q:\n    (cost, t) = heapq.heappop(q)\n    if t == v - 1:\n        print(cost)\n        break\n    if not visited[t]:\n        visited[t] = True\n        for i in g[t]:\n            heapq.heappush(q, [cost + (0 if no_cost[t, i] else 1), i])\nelse:\n    print(-1)", "import math\nimport os\nimport queue\nfrom collections import namedtuple\nEdge = namedtuple('Edge', ['vertex', 'weight'])\n\nclass Graph(object):\n\n    def __init__(self, vertex_count):\n        self.vertex_count = vertex_count\n        self.adjacency_list = [[] for _ in range(vertex_count)]\n\n    def add_edge(self, source, dest, weight):\n        assert source < self.vertex_count\n        assert dest < self.vertex_count\n        self.adjacency_list[source].append(Edge(dest, weight))\n        self.adjacency_list[dest].append(Edge(source, 1))\n\n    def get_edge(self, vertex):\n        for e in self.adjacency_list[vertex]:\n            yield e\n\n    def get_vertex(self):\n        for v in range(self.vertex_count):\n            yield v\n\ndef dijkstra(graph, source, dest):\n    q = queue.PriorityQueue()\n    parents = []\n    distances = []\n    start_weight = float('inf')\n    for i in graph.get_vertex():\n        weight = start_weight\n        if source == i:\n            weight = 0\n        distances.append(weight)\n        parents.append(None)\n    q.put([0, source])\n    while not q.empty():\n        v_tuple = q.get()\n        v = v_tuple[1]\n        for e in graph.get_edge(v):\n            candidate_distance = distances[v] + e.weight\n            if distances[e.vertex] > candidate_distance:\n                distances[e.vertex] = candidate_distance\n                parents[e.vertex] = v\n                if candidate_distance < -1000:\n                    raise Exception('Negative cycle detected')\n                q.put([distances[e.vertex], e.vertex])\n    if distances[N - 1] == float('inf'):\n        return -1\n    return distances[N - 1]\n(N, M) = map(int, input().split())\ng = Graph(N)\nfor i in range(M):\n    (x, y) = map(int, input().split())\n    g.add_edge(x - 1, y - 1, 0)\nprint(dijkstra(g, 0, N - 1))", "from heapq import heapify, heappop, heappush\n\ndef bsf(source, dic, dist, n):\n    dist[source] = 0\n    vis = [False] * (n + 1)\n    Q = [(dist[source], source)]\n    while Q:\n        (lent, ver) = heappop(Q)\n        if ver == n:\n            break\n        if vis[ver]:\n            continue\n        else:\n            vis[ver] = True\n        for i in dic[ver]:\n            if not vis[i]:\n                dist[i] = min(dist[i], dic[ver][i] + dist[ver])\n                heappush(Q, (dist[i], i))\n    return dist[n]\nfrom collections import defaultdict\n(n, m) = map(int, input().split())\ndist = [float('inf')] * (n + 1)\ndic = defaultdict(lambda : defaultdict(lambda : float('inf')))\nfor i in range(m):\n    (a, b) = map(int, input().split())\n    dic[a][b] = min(dic[a][b], 0)\n    dic[b][a] = min(dic[b][a], 1)\ntot = bsf(1, dic, dist, n)\nif tot == float('inf'):\n    print(-1)\nelse:\n    print(tot)", "from queue import PriorityQueue\n\ndef dijkstra(G, src, des):\n    dist = [1 << 28] * len(G)\n    Q = PriorityQueue()\n    dist[src] = 0\n    Q.put((0, src))\n    while Q.empty() == False:\n        (cost, u) = Q.get()\n        if u == des:\n            return dist[des]\n        l = len(G[u])\n        for i in range(0, l):\n            (v, Cost) = G[u][i]\n            if dist[v] > cost + Cost:\n                dist[v] = cost + Cost\n                Q.put((dist[v], v))\n    return -1\n(N, M) = map(int, input().split())\nGraph = [[] for i in range(N + 1)]\nfor i in range(0, M):\n    (u, v) = map(int, input().split())\n    Graph[u].append((v, 0))\n    Graph[v].append((u, 1))\nprint(dijkstra(Graph, 1, N))", "from queue import PriorityQueue\n\ndef dijkstra(G, src, des, N):\n    dist = [1 << 28] * (N + 1)\n    Q = PriorityQueue()\n    dist[src] = 0\n    Q.put((0, src))\n    while Q.empty() == False:\n        (cost, u) = Q.get()\n        if u == des:\n            return dist[des]\n        l = len(G[u])\n        for i in range(0, l):\n            (v, Cost) = G[u][i]\n            if dist[v] > cost + Cost:\n                dist[v] = cost + Cost\n                Q.put((dist[v], v))\n    return -1\n(N, M) = map(int, input().split())\nGraph = [[] for i in range(N + 1)]\nfor i in range(0, M):\n    (u, v) = map(int, input().split())\n    Graph[u].append((v, 0))\n    Graph[v].append((u, 1))\nprint(dijkstra(Graph, 1, N, N))", "(n, m) = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(m):\n    (v, u) = map(int, input().split())\n    v -= 1\n    u -= 1\n    g[v].append((0, u))\n    g[u].append((1, v))\nfor i in range(n):\n    g[i].sort()\nused = set()\nd = [0] * n\n(l, r) = (n, n)\nq = [0] * 2 * (n + 1)\nused.add(0)\nwhile l <= r:\n    v = q[l]\n    l += 1\n    for (cost, u) in g[v]:\n        if cost:\n            if u not in used:\n                r += 1\n                q[r] = u\n                d[u] = d[v] + 1\n        elif u not in used or d[u] > d[v]:\n            l -= 1\n            q[l] = u\n            d[u] = d[v]\n        used.add(u)\nprint(d[n - 1] if n - 1 in used else -1)", "from collections import deque\n(n, m) = map(int, input().split())\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    (v1, v2) = [int(x) - 1 for x in input().split()]\n    g[v1].append((v2, 0))\n    g[v2].append((v1, 1))\nd = [n] * n\nq = deque([0])\nd[0] = 0\nwhile q:\n    v = q.popleft()\n    if v == n - 1:\n        break\n    for (to, cost) in g[v]:\n        if d[to] > d[v] + cost:\n            d[to] = d[v] + cost\n            if cost == 0:\n                q.appendleft(to)\n            else:\n                q.append(to)\nprint(-1 if d[n - 1] == n else d[n - 1])"]