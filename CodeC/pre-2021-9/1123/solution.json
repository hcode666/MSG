["import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(parent, n, depth, depth_ct, adj):\n    if depth == len(depth_ct):\n        depth_ct.append(0)\n    depth_ct[depth] += 1\n    for c in adj[n]:\n        if c != parent:\n            dfs(n, c, depth + 1, depth_ct, adj)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = []\n    for __ in range(n):\n        adj.append([])\n    for __ in range(n - 1):\n        (u, v) = [int(x) - 1 for x in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    depth_ct = []\n    dfs(-1, 0, 0, depth_ct, adj)\n    max_time = 0\n    cum_tot = 0\n    for i in range(len(depth_ct) - 1, -1, -1):\n        cum_tot += depth_ct[i]\n        this_time = min(2 * i + 1, 2 * cum_tot)\n        max_time = max(this_time, max_time)\n    print(max_time)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(parent, n, depth, depth_ct, adj):\n    if depth == len(depth_ct):\n        depth_ct.append(0)\n    depth_ct[depth] += 1\n    for c in adj[n]:\n        if c != parent:\n            dfs(n, c, depth + 1, depth_ct, adj)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = []\n    for __ in range(n):\n        adj.append([])\n    for __ in range(n - 1):\n        (u, v) = [int(x) - 1 for x in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    depth_ct = []\n    dfs(-1, 0, 0, depth_ct, adj)\n    max_time = 0\n    cum_tot = 0\n    for i in range(len(depth_ct) - 1, -1, -1):\n        cum_tot += depth_ct[i]\n        this_time = min(2 * i + 1, 2 * cum_tot)\n        max_time = max(this_time, max_time)\n    print(max_time)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(parent, n, depth, depth_ct, adj):\n    if depth == len(depth_ct):\n        depth_ct.append(0)\n    depth_ct[depth] += 1\n    for c in adj[n]:\n        if c != parent:\n            dfs(n, c, depth + 1, depth_ct, adj)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = []\n    for __ in range(n):\n        adj.append([])\n    for __ in range(n - 1):\n        (u, v) = [int(x) - 1 for x in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    depth_ct = []\n    dfs(-1, 0, 0, depth_ct, adj)\n    max_time = 0\n    cum_tot = 0\n    for i in range(len(depth_ct) - 1, -1, -1):\n        cum_tot += depth_ct[i]\n        this_time = min(2 * i + 1, 2 * cum_tot)\n        max_time = max(this_time, max_time)\n    print(max_time)", "import sys\nsys.setrecursionlimit(10 ** 6)\n\ndef dfs(parent, n, depth, depth_ct, depths, adj):\n    depths[n] = depth\n    if depth == len(depth_ct):\n        depth_ct.append(0)\n    depth_ct[depth] += 1\n    for c in adj[n]:\n        if c != parent:\n            dfs(n, c, depth + 1, depth_ct, depths, adj)\nfor _ in range(int(input())):\n    n = int(input())\n    adj = []\n    for __ in range(n):\n        adj.append([])\n    for __ in range(n - 1):\n        (u, v) = [int(x) - 1 for x in input().split()]\n        adj[u].append(v)\n        adj[v].append(u)\n    depths = n * [None]\n    depth_ct = []\n    dfs(-1, 0, 0, depth_ct, depths, adj)\n    max_time = 0\n    cum_tot = 0\n    for i in range(len(depth_ct) - 1, -1, -1):\n        cum_tot += depth_ct[i]\n        this_time = min(2 * i, 2 * cum_tot - 1)\n        max_time = max(this_time, max_time)\n    print(max_time + 1)", "from typing import List\n\nclass Node:\n    value: int\n    children: 'List[Node]'\n\n    def __init__(self, value: int):\n        self.value = value\n        self.children = []\n\n    def __repr__(self):\n        return f'({self.value}: {[n.value for n in self.children]})'\n\ndef bfs(tree: Node, n: int) -> List[List[Node]]:\n    already_considered = [False for i in range(n + 1)]\n    layers = [[tree]]\n    layer_idx = 0\n    while len(layers[layer_idx]) > 0:\n        layers.append([])\n        for node in layers[layer_idx]:\n            already_considered[node.value] = True\n            layers[layer_idx + 1].extend([c for c in node.children if not already_considered[c.value]])\n        layer_idx += 1\n    layers.pop()\n    return layers\n\ndef number_of_turns(tree: Node, n: int) -> int:\n    layers = bfs(tree, n)\n    turns = 0\n    top_index = 0\n    bottom_index = len(layers) - 1\n    top_turn = True\n    while top_index <= bottom_index:\n        if top_turn:\n            top_index += 1\n        else:\n            layers[bottom_index].pop()\n            if len(layers[bottom_index]) == 0:\n                bottom_index -= 1\n        turns += 1\n        top_turn = not top_turn\n    return turns\n\ndef main():\n    tests = int(input())\n    for _ in range(tests):\n        n = int(input())\n        if n > 0:\n            nodes = [Node(i) for i in range(n + 1)]\n            for _ in range(n - 1):\n                edge = [int(node) for node in input().split()]\n                nodes[edge[0]].children.append(nodes[edge[1]])\n                nodes[edge[1]].children.append(nodes[edge[0]])\n            turns = number_of_turns(nodes[1], n)\n            print(turns)\n        else:\n            print(0)\nmain()", "from typing import List\n\nclass Node:\n    value: int\n    children: 'List[Node]'\n\n    def __init__(self, value: int):\n        self.value = value\n        self.children = []\n\n    def __repr__(self):\n        return f'({self.value}: {[n.value for n in self.children]})'\n\ndef bfs(tree: Node, n: int) -> List[List[Node]]:\n    already_considered = [False for i in range(n + 1)]\n    layers = [[tree]]\n    layer_idx = 0\n    while len(layers[layer_idx]) > 0:\n        layers.append([])\n        for node in layers[layer_idx]:\n            already_considered[node.value] = True\n            layers[layer_idx + 1].extend([c for c in node.children if not already_considered[c.value]])\n        layer_idx += 1\n    layers.pop()\n    return layers\n\ndef number_of_turns(tree: Node, n: int) -> int:\n    layers = bfs(tree, n)\n    turns = 0\n    top_index = 0\n    bottom_index = len(layers) - 1\n    top_turn = True\n    while top_index <= bottom_index:\n        if top_turn:\n            top_index += 1\n        else:\n            layers[bottom_index].pop()\n            if len(layers[bottom_index]) == 0:\n                bottom_index -= 1\n        turns += 1\n        top_turn = not top_turn\n    return turns\n\ndef main():\n    tests = int(input())\n    for _ in range(tests):\n        n = int(input())\n        if n > 0:\n            nodes = [Node(i) for i in range(n + 1)]\n            for _ in range(n - 1):\n                edge = [int(node) for node in input().split()]\n                nodes[edge[0]].children.append(nodes[edge[1]])\n                nodes[edge[1]].children.append(nodes[edge[0]])\n            turns = number_of_turns(nodes[1], n)\n            print(turns)\n        else:\n            print(0)\nmain()", "from typing import List\n\nclass Node:\n    value: int\n    children: 'List[Node]'\n\n    def __init__(self, value: int):\n        self.value = value\n        self.children = []\n\n    def __repr__(self):\n        return f'({self.value}: {[n.value for n in self.children]})'\n\ndef bfs(tree: Node, n: int) -> List[List[Node]]:\n    already_considered = [False for i in range(n + 1)]\n    layers = [[tree]]\n    layer_idx = 0\n    while len(layers[layer_idx]) > 0:\n        layers.append([])\n        for node in layers[layer_idx]:\n            already_considered[node.value] = True\n            layers[layer_idx + 1].extend([c for c in node.children if not already_considered[c.value]])\n        layer_idx += 1\n    layers.pop()\n    return layers\n\ndef number_of_turns(tree: Node, n: int) -> int:\n    layers = bfs(tree, n)\n    turns = 0\n    top_index = 0\n    bottom_index = len(layers) - 1\n    top_turn = True\n    while top_index <= bottom_index:\n        if top_turn:\n            top_index += 1\n        else:\n            layers[bottom_index].pop()\n            if len(layers[bottom_index]) == 0:\n                bottom_index -= 1\n        turns += 1\n        top_turn = not top_turn\n    return turns\n\ndef main():\n    tests = int(input())\n    for _ in range(tests):\n        n = int(input())\n        if n > 0:\n            nodes = [Node(i) for i in range(n + 1)]\n            for _ in range(n - 1):\n                edge = [int(node) for node in input().split()]\n                nodes[edge[0]].children.append(nodes[edge[1]])\n                nodes[edge[1]].children.append(nodes[edge[0]])\n            turns = number_of_turns(nodes[1], n)\n            print(turns)\n        else:\n            print(0)\nmain()", "from typing import List\n\nclass Node:\n    value: int\n    children: 'List[Node]'\n\n    def __init__(self, value: int):\n        self.value = value\n        self.children = []\n\n    def __repr__(self):\n        return f'({self.value}: {[n.value for n in self.children]})'\n\ndef bfs(tree: Node, n: int) -> List[List[Node]]:\n    already_considered = [False for i in range(n + 1)]\n    layers = [[tree]]\n    layer_idx = 0\n    while len(layers[layer_idx]) > 0:\n        layers.append([])\n        for node in layers[layer_idx]:\n            already_considered[node.value] = True\n            layers[layer_idx + 1].extend([c for c in node.children if not already_considered[c.value]])\n        layer_idx += 1\n    layers.pop()\n    return layers\n\ndef number_of_turns(tree: Node, n: int) -> int:\n    layers = bfs(tree, n)\n    turns = 0\n    top_index = 0\n    bottom_index = len(layers) - 1\n    top_turn = True\n    while top_index <= bottom_index:\n        if top_turn:\n            top_index += 1\n        else:\n            layers[bottom_index].pop()\n            if len(layers[bottom_index]) == 0:\n                bottom_index -= 1\n        turns += 1\n        top_turn = not top_turn\n    return turns\n\ndef main():\n    tests = int(input())\n    for _ in range(tests):\n        n = int(input())\n        if n > 0:\n            nodes = [Node(i) for i in range(n + 1)]\n            for _ in range(n - 1):\n                edge = [int(node) for node in input().split()]\n                nodes[edge[0]].children.append(nodes[edge[1]])\n                nodes[edge[1]].children.append(nodes[edge[0]])\n            turns = number_of_turns(nodes[1], n)\n            print(turns)\n        else:\n            print(0)\nmain()", "import sys\nimport queue\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n > 1:\n        a = [list() for i in range(n)]\n        for i in range(n - 1):\n            line = input().split()\n            u = int(line[0]) - 1\n            v = int(line[1]) - 1\n            a[u].append(v)\n            a[v].append(u)\n        q = queue.Queue(n)\n        q.put(0)\n        V = [False for i in range(n)]\n        H = [0 for i in range(n)]\n        while not q.empty():\n            cur = q.get()\n            V[cur] = True\n            for x in a[cur]:\n                if V[x] == False:\n                    q.put(x)\n                    H[x] = H[cur] + 1\n        H.sort()\n        first = 0\n        last = n - 1\n        count = 0\n        turn = 0\n        while 1:\n            if turn == 0:\n                if first > last:\n                    break\n                cur = H[first]\n                while H[first] == cur and first <= last:\n                    first += 1\n                turn = 1\n                count = count + 1\n            else:\n                if first > last:\n                    break\n                last = last - 1\n                count = count + 1\n                turn = 0\n        print(count)\n    elif n == 1:\n        print(1)\n    else:\n        print(0)"]